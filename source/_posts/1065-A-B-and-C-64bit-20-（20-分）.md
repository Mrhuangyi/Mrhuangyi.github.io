---
title: 1065 A+B and C (64bit) (20)（20 分）
date: 2018-07-19 21:18:41
tags: PAT
categories: 题解集
---

1065 A+B and C (64bit) (20)（20 分）
Given three integers A, B and C in [-2^63^, 2^63^], you are supposed to tell whether A+B > C.

Input Specification:

The first line of the input gives the positive number of test cases, T (<=10). Then T test cases follow, each consists of a single line containing three integers A, B and C, separated by single spaces.

Output Specification:

For each test case, output in one line "Case #X: true" if A+B&gtC, or "Case #X: false" otherwise, where X is the case number (starting from 1).

Sample Input:
```
3
1 2 3
2 3 4
9223372036854775807 -9223372036854775808 0
```
Sample Output:
```
Case #1: false
Case #2: true
Case #3: false
```
题目大意：给出三个整数a, b, c,如果a + b > c，则输出true，否则输出false。

分析，由于给出的整数范围是[-2^63, 2^63],属于long long长整型，因此两数相加可能会发生溢出，这也是这道题的考点。由于不能直接进行大小判断，需要分析溢出后的具体范围。
***如果两个正数之和等于负数或两个负数之和等于正数，那么就属于发生了溢出***

- 当a+b>2^63时，会超过long long的正向最大值发生正溢出，正溢出后的值区间为[-2^64, -2]，右边界由(2^64-2)%(2^64)得
- 当a+b<-2^63时，会超过long long的负向最小值发生负溢出，负溢出后的值区间为[0, 2^63]，左边界由(-2^64)%(2^64)得
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int main() {
    int t, tcase = 1;
    scanf("%d", &t);
    while(t--) {
        long long a, b, c;
        scanf("%lld%lld%lld", &a, &b, &c);
        long long res = a + b;
        bool flag;
        if(a > 0 && b > 0 && res < 0) { //正溢出
            flag = true;
        } else if(a < 0 && b < 0 && res >= 0) { //负溢出
            flag = false;
        } else if(res > c) {
            flag = true;
        } else {
            flag = false;
        }
        if(flag) {
            printf("Case #%d: true\n", tcase++);
        } else {
            printf("Case #%d: false\n", tcase++);
        }
    }
    return 0;
}

```