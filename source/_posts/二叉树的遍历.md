---
title: 二叉树的遍历
date: 2018-04-29 22:13:41
categories: 算法和数据结构
tags:
---
# 二叉树的遍历
二叉树的遍历是指通过一定的顺序访问二叉树的所有结点。
一般包括：先序遍历、中序遍历、后序遍历、层次遍历
先序、中序、后序的遍历一般通过深度优先搜索实现，层次遍历一般通过广度优先搜索实现。
## 1. 先序遍历
遍历顺序：根结点->左子树->右子树
```cpp
void preorder(node* root){
    if(root==NULL){
        return;
    }
    printf("%d\n",root->data);
    preorder(root->lchild);
    preorder(root->rchild);
}
```
## 2. 中序遍历
遍历顺序：左子树->根结点->右子树
```cpp
void inorder(node* root){
    if(root==NULL){
        return;
    }
    inorder(root->lchild);
    printf("%d\n",root->data);
    inorder(root->rchild);
}
```
## 3. 后序遍历
遍历顺序：左子树->右子树->根结点
```cpp
void postorder(node* root){
    if(root==NULL){
        return;
    }
    postorder(root->lchild);
    postorder(root->rchild);
    printf("%d\n",root->data);
}
```
## 4. 层序遍历
层序遍历指按层次的顺序从根结点向下逐层进行遍历，且对同一层的节点为从左到右遍历。
基本思路：从根结点开始广度优先搜索
* 将根结点root加入队列
* 取出队首结点，访问它
* 如果该结点有左孩子，将左孩子入队。
* 如果该结点有右孩子，将右孩子入队
* 返回第二步，直到队列为空
```cpp
void LayerOrder(node* root){
    queue<node*> q;
    q.push(root);
    while(!q.empty()){
        node* now = q.front();
        q.pop();
        printf("%d",noe->data);
        if(now->lchild!=NULL) q.push(now->lchild);
        if(now->rchild!=NULL) q.push(now->rchild);
    }
}
```
* 如果题目要求计算每个结点所处层次，可以在二叉树结点的定义中添加一个记录层次的layer变量。
```cpp
struct node{
    int data;
    int layer;
    node* lchild;
    node* rchild;
};

void LayerOrder(node* root){
    queue<node*> q;
    root->layer=1;
    q.push(root);
    while(!q.empty()){
        node* now = q.front();
        q.pop();
        printf("%d",noe->data);
        if(now->lchild!=NULL){
                now->lchild->layer=now->layer+1;
                q.push(now->lchild);
                
        }
        if(now->rchild!=NULL) {
            now->rchild->layer=now->layer+1;
                q.push(now->rchild);
        }
    }
}
```
* 问题：给定一棵二叉树的先序遍历序列和中序遍历序列（或者给定后序序列和中序序列），要求重建这棵二叉树。
### 中序序列(确定左右子树)可以与先序序列、后序序列、层序序列（确定根结点）中的任意一个来构建唯一地二叉树，后三者任意搭配都不能构建唯一的二叉树
假设已知先序序列为pre1,pre2……中序序列为in1,in2……
则先序序列中的第一个元素pre1是当前二叉树的根结点
当前二叉树的根结点又将中序序列划分为左子树和右子树，在中序序列中找到某个结点ink，使得ink=pre1。
左子树结点个数numLeft=k-1，同时可得出左右子树的先序和中序序列区间。
递归边界：先序序列的长度小于等于0
```cpp
node* create(int prel ,int prer,int inl,int inr){
    if(prel<prer){
        return NULL;
    }
    node* root=new node;
    root->data=pre[prel];
    int k;
    for(k=inl;k<=inr;k++){
        if(in[k]==pre[prel]){
            break;
        }
    }
    int numLeft=k-inl;
    root->lchild=create(prel+1,prel+numLeft,inl,k-1);
    root->rchild=create(prel+numLeft+1,prer,k+1,inr);
    return root;
}
```
### 二叉树的静态实现
不用指针，只用数组实现二叉树基本操作
* 静态二叉链表
```cpp
struct node{
    typename data;
    int lchild;
    int rchild;
}Node[maxn];
int index=0;
int newNode(int v){
    Node[index].data=v;
    Node[index].lchild=-1;
    Node[index].rchild=-1;
    return index++;
}
```
### 二叉树的查找、插入、建立
root为根结点在数组中的下标
```cpp
void search(int root,int x,int newdata){
    if(root==-1){
        return;
    }
    if(Node[root].data==x){
        Node[root].data=newdata;
    }
    search(Node[root].lchild,x,newdata);
    search(Node[root].rchil,x,newdata);
}
void insert(int &root,int x){
    if(root==-1){
        root==newNode(x);
        return;
    }
    if(x插在左子树){
        insert(Node[root].lchild,x);
    }else{
    insert(Node[root].rchild,x);
    }
}
void create(int data[],int n){
    int root=-1;
    for(int i=0;i<n;i++){
        insert(root,data[i]);
    }
    return root;
}
```
### 二叉树的遍历
```cpp
//先序遍历
void preorder(int root){
    if(root==-1){
        return;
    }
    printf("%d\n",Node[root].data);
    preorder(Node[root].lchild);
    preorder(Node[root].rchild);
}
//中序遍历
void inorder(int root){
    if(root==-1){
        return;
    }
    inorder(Node[root].lchild);
    printf("%d\n",Node[root].data);
    inorder(Node[root].rchild);
}
//后序遍历
void postorder(int root){
    if(root==-1){
        return ;
    }
    postorder(Node[root].lchild);
    postorder(Node[root].rchild);
    printf("%d\n",Node[root].data);
}
//层序遍历
void LayerOrder(int root){
    queue<int> q;
    q.push(root);
    while(!q.empty()){
        int now=q.front();
        q.pop();
        printf("%d ",Node[now].data);
        if(Node[now].lchild!=-1) q.push(Node[now].lchild);
        if(Node[now].rchild!=-1) q.push(Node[now].rchild);
    }
}
```
