---
title: 树的遍历
date: 2018-04-30 20:12:22
categories: 算法和数据结构
---
# 树的遍历
### 树的静态写法
```cpp
struct node{
  typename data;//数据域
  int child[maxn];//指针域，存放所有子结点的下标
}Node[maxn];
struct node{
    typename data;
    vector child;
}Node[maxn];
int index=0;
int newNode(int v){
    Node[index].data=v;
    Node[index].child.clear();
    return index++;
}
```
### 树的先根遍历
先访问根结点，在访问子树
```cpp
void preorder(int root){
    printf("%d ",Node[root].data);
    for(int i=0;i<Node[root].child/size();i++){
        preorder(Node[root].child[i]);
    }
}
```
### 树的层序遍历
与二叉树的层序遍历类似，一般使用一个队列来存放结点在数组中的下标，每次取出队首元素来访问，并将
其所有子结点加入队列，直到队列为空。
```cpp
void LayerOrder(int root){
    queue<int> q;
    q.push(root);
    while(!q.empty()){
        int front=q.front();
        printf("%d ",Node[front].data);
        q.pop();
        for(int i=0;i<Node[front].child.size();i++){
            q.push(Node[front].child[i]);
        }
    }
}
//如果要对结点的层次进行记录
struct node{
    int layer;
    int data;
    vector<int> child;
};
void LayerOrder(int root){
    queue<int> q;
    q.push(root);
    Node[root].layer=0;
    while(!q.empty()){
        int front=q.front();
        printf("%d ",Node[front].data);
        q.pop();
        for(int i=0;i<Node[front].child.size();i++){
            int child = Node[front].child[i];
            q.push(Node[front].child[i]);
            q.push(child);
        }
    }
}
```
