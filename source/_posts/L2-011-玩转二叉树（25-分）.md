---
title: L2-011 玩转二叉树（25 分）
date: 2018-06-05 15:31:15
tags: PAT
categories: 题解集
---

L2-011 玩转二叉树（25 分）
给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。

输入格式：

输入第一行给出一个正整数N（<=30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。

输出格式：

在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。

输入样例：

7
1 2 3 4 5 6 7
4 1 3 2 6 5 7
输出样例：

4 6 1 7 5 3 2

普通的思路就是重建二叉树，然后广搜输出结点

```cpp
#include <iostream>  
#include <cstdio>  
#include <queue>  
using namespace std;  
const int maxn = 35;  
const int INF = 0x3f3f3f3f;  
struct node{  
    int l=-1,r=-1;  
}a[1000];
int n;
int mid[maxn],first[maxn];  
int rebuild(int la, int ra, int lb, int rb){///la是中序遍历  
    if(la > ra) return -1;    
    int rt = first[lb];  
    int i = 0;  
    while(mid[la+i] != rt) i++;  
    a[rt].r = rebuild(la+i+1,ra,lb+i+1,rb);  
    a[rt].l = rebuild(la,la+i-1,lb+1,lb+i);  
    return rt;  
}  
void bfs(int s){  
    queue<int> q;  
    q.push(s);  
    while(!q.empty()){  
        int now = q.front();  
        q.pop();  
        if(a[now].r != -1) q.push(a[now].r);  
        if(a[now].l != -1) q.push(a[now].l);  
        printf("%d",now);  
        if(!q.empty()) printf(" ");  
    }  
}  
  
int main()  
{  
    scanf("%d",&n);  
    for(int i = 0; i < n; ++i) scanf("%d",&mid[i]);  
    for(int i = 0; i < n; ++i) scanf("%d",&first[i]);  
    rebuild(0,n-1,0,n-1);  
    bfs(first[0]);  
    return 0;  
}  

```