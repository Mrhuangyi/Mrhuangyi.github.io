---
title: 345. 反转字符串中的元音字母
date: 2018-06-11 14:11:13
tags: LeetCode
categories: 题解集
---

编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

示例 1：
给定 s = "hello", 返回 "holle".

示例 2：
给定 s = "leetcode", 返回 "leotcede".

注意:
元音字母不包括 "y".

思路分析：
如果考虑一个更简单的问题：如何反转一个字符串，相信大家都能马上想到算法，因为我们知道每个位置的字符在反转后会出现在什么位置。
方法一：翻转ID
本题中只需要反转元音字母，同样的，我们希望知道每个元音字母在反转后应该出现在什么位置。因此我们用一个position数组记录元音字母的位置，然后进行反转即可。算法复杂度为O(N)，N是字符串长度。

```cpp
class Solution {
public:
    string reverseVowels(string s) {
        vector<int> pos(s.size());
        set<char> vowel;
        int cnt = 0;
        vowel.insert('a');
        vowel.insert('e');
        vowel.insert('i');
        vowel.insert('o');
        vowel.insert('u');
        vowel.insert('A');
        vowel.insert('E');
        vowel.insert('I');
        vowel.insert('O');
        vowel.insert('U');
        string ans = "";
        for(int i=0;i<s.size();i++){
            if(vowel.count(s[i])){
                pos[cnt] = i;
                cnt++;
            }
            ans += s[i];
        }
        
        for(int i=0;i<cnt;i++){
            ans[pos[i]] = s[pos[cnt-i-1]];
        }
        return  ans;
    }
};
```

方法二： 双指针法

本题还有另外一种思路，那就是two pointer。一个指针从前往后扫描，一个指针从后往前扫描，遇到元音字母是进行交换，直到两个指针相遇，算法终止。算法复杂度同样是O(N)。

```cpp
class Solution {
public:
    string reverseVowels(string s) {
      int left = 0, right= s.size() - 1;
        while (left < right)
        {
            if (isVowel(s[left]) && isVowel(s[right]))
            {
                swap(s[left++], s[right--]);
            }
            else if (isVowel(s[left]))
            {
                --right;
            }
            else
            {
                ++left;
            }
        }
        return s;
    }
    bool isVowel(char c)
    {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';
    }
};
```