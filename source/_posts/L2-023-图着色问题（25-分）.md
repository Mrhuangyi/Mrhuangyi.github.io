---
title: L2-023 图着色问题（25 分）
date: 2018-07-19 12:05:04
tags: PAT
categories: 题解集
---

L2-023 图着色问题（25 分）
图着色问题是一个著名的NP完全问题。给定无向图 G = (V, E)，问可否用K种颜色为V中的每一个顶点分配一种颜色，使得不会有两个相邻顶点具有同一种颜色？

但本题并不是要你解决这个着色问题，而是对给定的一种颜色分配，请你判断这是否是图着色问题的一个解。

输入格式：

输入在第一行给出3个整数V（0 < V <= 500）、E（>= 0）和K（0 < K <= V），分别是无向图的顶点数、边数、以及颜色数。顶点和颜色都从1到V编号。随后E行，每行给出一条边的两个端点的编号。在图的信息给出之后，给出了一个正整数N（<= 20），是待检查的颜色分配方案的个数。随后N行，每行顺次给出V个顶点的颜色（第i个数字表示第i个顶点的颜色），数字间以空格分隔。题目保证给定的无向图是合法的（即不存在自回路和重边）。

输出格式：

对每种颜色分配方案，如果是图着色问题的一个解则输出“Yes”，否则输出“No”，每句占一行。

输入样例：
```
6 8 3
2 1
1 3
4 6
2 5
2 4
5 4
5 6
3 6
4
1 2 3 3 1 2
4 5 6 6 4 5
1 2 3 4 5 6
2 3 4 2 3 4
```
输出样例：
```
Yes
Yes
No
No
```
分析：这题主要考察对图的遍历，题目要求你判断給定的颜色分配是不是图着色问题的一个解，而图着色问题的要求是用k种颜色为图G中的每个顶点分配一种颜色，并且不会有相邻两个顶点具有同一种颜色。可以枚举所有相连的点，看颜色是否相同。
```cpp
#include<cstdio>
#include<iostream>
#include<vector>
#include<map>
using namespace std;
const int N = 1e5+11;
const int M = 1e6+11;
vector<int> vet[N];
int n;
int color[N];
int flag;
void solve(){
    for(int i = 1; i <= n; i++) {
        for(int j = 0; j < vet[i].size(); j++){
            int v = vet[i][j];
            if(color[i] == color[v]) {
                flag = 0;
            }
        }
    }
}
int main()
{
    int m,k;
    scanf("%d %d %d",&n,&m,&k);
    while(m--) {
        int a,b;
        scanf("%d %d",&a,&b);
        vet[a].push_back(b);
        vet[b].push_back(a);
    }
    int t;
    scanf("%d",&t);
    while(t--) {
        map<int,int> mp;
    int f = 1;
    for(int i = 1; i <= n; i++) {
        scanf("%d", &color[i]);
        mp[color[i]] = 1;
    }
    if(mp.size() != k){
        printf("No\n");
    } else {
        flag = 1;
        solve();
        if(flag) {
            printf("Yes\n");
        } else {
            printf("No\n");
        }
    }
    }
    return 0;
}

```