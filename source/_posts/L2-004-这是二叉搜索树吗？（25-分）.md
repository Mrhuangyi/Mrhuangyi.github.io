---
title: L2-004 这是二叉搜索树吗？（25 分）
date: 2018-05-30 10:37:10
tags: PAT
categories: 题解集
---

L2-004 这是二叉搜索树吗？（25 分）
一棵二叉搜索树可被递归地定义为具有下列性质的二叉树：对于任一结点，

其左子树中所有结点的键值小于该结点的键值；
其右子树中所有结点的键值大于等于该结点的键值；
其左右子树都是二叉搜索树。
所谓二叉搜索树的“镜像”，即将所有结点的左右子树对换位置后所得到的树。

给定一个整数键值序列，现请你编写程序，判断这是否是对一棵二叉搜索树或其镜像进行前序遍历的结果。

输入格式：

输入的第一行给出正整数N（<=1000）。随后一行给出N个整数键值，其间以空格分隔。

输出格式：

如果输入序列是对一棵二叉搜索树或其镜像进行前序遍历的结果，则首先在一行中输出“YES”，然后在下一行输出该树后序遍历的结果。数字间有1个空格，一行的首尾不得有多余空格。若答案是否，则输出“NO”。

输入样例1：

7
8 6 5 7 10 8 11
输出样例1：

YES
5 7 6 8 11 10 8
输入样例2：

7
8 10 11 8 6 7 5
输出样例2：

YES
11 8 10 7 5 6 8
输入样例3：

7
8 6 8 5 10 9 11
输出样例3：

NO

```cpp
#include<cstdio>
#include<vector>
using namespace std;
struct node{
    int data;
    node *left,*right;
};
void insert(node* &root,int data){
    if(root==NULL){
        root=new node;
        root->data=data;
        root->left=root->right=NULL;
        return ;
    }
    if(data<root->data) insert(root->left,data);
    else insert(root->right,data);
}
void preOrder(node* root,vector<int>&vi){
    if(root==NULL) return;
    vi.push_back(root->data);
    preOrder(root->left,vi);
    preOrder(root->right,vi);
}
void preOrderMirror(node* root,vector<int>&vi){
    if(root==NULL) return;
    vi.push_back(root->data);
    preOrderMirror(root->right,vi);
    preOrderMirror(root->left,vi);

}
void postOrder(node* root,vector<int>& vi){
    if(root==NULL) return;
    postOrder(root->left,vi);
    postOrder(root->right,vi);
    vi.push_back(root->data);
}
void postOrderMirror(node* root,vector<int>&vi){
    if(root==NULL) return;
    postOrderMirror(root->right,vi);
    postOrderMirror(root->left,vi);
    vi.push_back(root->data);
}
vector<int> origin,pre,preN,postN,post;
int main()
{
    int n,data;
    node* root=NULL;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%d",&data);
        origin.push_back(data);
        insert(root,data);

    }
    preOrder(root,pre);
    preOrderMirror(root,preN);
    postOrder(root,post);
    postOrderMirror(root,postN);
    if(origin==pre){
        printf("YES\n");
        for(int i=0;i<post.size();i++){
            printf("%d",post[i]);
            if(i<post.size()-1) printf(" ");
        }
    }else if(origin==preN){
    printf("YES\n");
    for(int i=0;i<postN.size();i++){
        printf("%d",postN[i]);
        if(i<postN.size()-1) printf(" ");
    }
    }else{
    printf("NO\n");
    }
    return 0;
}

```