---
title: 1010 Radix (25)（25 分）
date: 2018-07-29 16:50:07
tags: PAT
categories: 题解集
---

Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is "yes", if 6 is a decimal number and 110 is a binary number.

Now for any pair of positive integers N1 and N2, your task is to find the radix of one number while that of the other is given.

Input Specification:

Each input file contains one test case. Each case occupies a line which contains 4 positive integers:\ N1 N2 tag radix\ Here N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set {0-9, a-z} where 0-9 represent the decimal numbers 0-9, and a-z represent the decimal numbers 10-35. The last number "radix" is the radix of N1 if "tag" is 1, or of N2 if "tag" is 2.

Output Specification:

For each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print "Impossible". If the solution is not unique, output the smallest possible radix.

Sample Input 1:
```
6 110 1 10
```
Sample Output 1:
```
2
```
Sample Input 2:
```
1 ab 1 2
```
Sample Output 2:
```
Impossible
```
题目大意：输入4个整数n1，n2，tag，radix，tag为1表示n1为radix进制数，tag为2表示n2为radix进制数。求n1和n2中未知进制的那个数是否存在，并满足某个进制时和另一个数在10进制下相等。若存在，输出满足条件的最小进制；否则，输出Impossible

分析
1：将已确定进制的数放在n1，未确定进制的数放在n2

2：二分查找，二分n2的进制，将n2从该进制转化为10进制，令其与n1的10进制比较：如果大于n1的十进制，则往左子区间二分；如果小于n2的十进制，则往右子区间二分。

```cpp

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long LL;
LL inf = (1LL << 63) - 1;
LL m[256];
void init() {
    for(char c = '0'; c <= '9'; c++) {
        m[c] = c - '0';
    }
    for(char c = 'a'; c <= 'z'; c++) {
        m[c] = c - 'a' + 10;
    }
}
LL convertTo10(char a[], LL radix, LL t) {
    LL ans = 0;
    int len = strlen(a);
    for(int i = 0; i < len; i++) {
        ans = ans * radix + m[a[i]];
        if(ans < 0 || ans > t) {
            return -1;
        }
    }
    return ans;
}
int cmp(char n2[], LL radix, LL t) {
    int len = strlen(n2);
    LL num = convertTo10(n2, radix, t);
    if(num < 0) {
        return 1;
    }
    if(t > num) {
        return -1;
    } else if(t == num) {
        return 0;
    } else {
        return 1;
    }
}
LL binarySearch(char n2[], LL left, LL right, LL t) {
    LL mid;
    while(left <= right) {
        mid = (left + right) / 2;
        int flag = cmp(n2, mid, t);
        if(flag == 0) {
            return mid;
        } else if(flag == -1) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
int findLargest(char n2[]) {
    int ans = -1;
    int len = strlen(n2);
    for(int i = 0; i < len; i++) {
        if(m[n2[i]] > ans) {
            ans = m[n2[i]];
        }
    }
    return ans + 1;
}
int main() {
    char n1[20], n2[20], temp[20];
    int tag, radix;
    init();
    scanf("%s %s %d %d", n1, n2, &tag, &radix);
    if(tag == 2) {
        swap(n1, n2);
    }
    LL t = convertTo10(n1, radix, inf);
    LL low = findLargest(n2);
    LL high = max(low, t) + 1;
    LL ans = binarySearch(n2, low, high, t);
    if(ans == -1) {
        printf("Impossible\n");
    } else {
        printf("%lld\n", ans);
    }
    return 0;
}

```