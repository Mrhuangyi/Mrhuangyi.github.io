---
title: 153. 寻找旋转排序数组中的最小值
date: 2018-07-06 20:06:50
tags: LeetCode
categories: 题解集
---


假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

示例 1:
```
输入: [3,4,5,1,2]
输出: 1
```
示例 2:
```
输入: [4,5,6,7,0,1,2]
输出: 0
```

这道题乍一看很纳闷，求最小元素不是一个sort就能搞定的吗？

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        return nums[0];
    }
};
```
后来看下标签，考点是二分查找
我们需要知道，对于一个区间A，如果A[start]	<	A[stop]，那么该区间一定是有 序的了。
另外，由于不含重复元素，需要分两种情况。
对于一个轮转了的排序了的数组，
如果nums[mid]>nums[left]，最小值一定在右半区间
如果nums[mid]<nums[left]，最小值一定在左半区间

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int size = nums.size();
        if(size==0){
            return 0;
        }else if(size==1){
            return nums[0];
        }else if(size==2){
            return min(nums[0],nums[1]);
        }
        int left = 0,right = size-1;
        while(left<right-1){
            if(nums[left]<nums[right]){
                return nums[left];
            }
            int mid = left+(right-left)/2;
            if(nums[mid]<nums[left]){
                right = mid;
            }
            if(nums[mid]>nums[left]){
                left = mid;
            }
        }
        return min(nums[left],nums[right]);
        
    }
};
```