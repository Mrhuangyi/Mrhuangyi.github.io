---
title: 4. 两个排序数组的中位数
date: 2018-10-01 20:25:52
tags: LeetCode
categories: 题解集
---

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。

请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。

你可以假设 nums1 和 nums2 不同时为空。

示例 1:
```
nums1 = [1, 3]
nums2 = [2]

中位数是 2.0
```
示例 2:
```
nums1 = [1, 2]
nums2 = [3, 4]

中位数是 (2 + 3)/2 = 2.5
```
分析：题目要求求出两个有序数组的中位数，其实这个问题属于TOPKth问题的一个特例，就是让你求两个有序数组的第k大数。
思路：比较直观简单的想法就是合并两个有序数组然后再求中位数，但这种做法时间复杂度为O(m + n).可是题目里面要求时间复杂度控制为O(log(m + n)).换一种双指针想法，首先用一个计数器记录当前已找到的第m大的元素，同时让两个指针pA和pB分别指向两个数组的第一个元素，使用类似于归并排序的思想，如果数组nums1当前元素较小，那么pA++，同时m++；反之，pB++，同时m++。当m == k 遍历结束。时间复杂度O(k),空间复杂度O(1).但是如果k很接近m + n ,那么时间复杂度还是O(m + n)的。
在换一种想法，要求O(log(m + n))复杂度，我们想到二分查找，但是直接用二分，时间复杂度在O(log(m*n))，只能说用类似二分的做法。
我们假设nums1和nums2的元素个数都大于k / 2.我们比较nums1[k/2-1]和nums2[k/2-1]，有以下三种情况：
- nums1[k/2-1] == nums2[k/2-1]
- nums1[k/2-1] > nums2[k/2-1]
- nums1[k/2-1] < nums2[k/2-1]
- 如果nums1[k/2-1] < nums2[k/2-1]，则nums1[0]~nums1[k/2-1]之间肯定在topK元素范围内，同理，如果nums1[k/2-1] > nums2[k/2-1],则nums2[0] -- nums2[k/2-1]肯定在topK元素范围内；如果nums1[k/2-1] == nums2[k/2-1] ，说明已找到第k大元素。
采用递归写法的话，终止条件为：
- 当nums1或nums2为空时，直接返回nums1[k-1]或nums2[k-1]
- 当k == 1时，返回min(nums1[0],nums2[0]);
- 当nums1[k/2-1]  == nums2[k/2-1],返回nums1[k/2-1]或nums2[k/2-1]

关于具体的数学证明可以参考下官网给出的提解，蛮详细的。
https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/
```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int lenA = nums1.size();
        int lenB = nums2.size();
        if((lenA + lenB) % 2 == 0) {
            double r1 = (double) findKth(nums1, 0, lenA, nums2, 0, lenB, (lenA + lenB) / 2);
            double r2 = (double) findKth(nums1, 0, lenA, nums2, 0, lenB, (lenA + lenB) / 2 + 1);
            return (r1 + r2) / 2.0;
        } else {
            return findKth(nums1, 0, lenA, nums2, 0, lenB, (lenA + lenB + 1) / 2);
        }
    }
    int findKth(vector<int>& A, int startA, int endA, vector<int>& B,int startB, int endB, int k) {
        int n = endA - startA;
        int m = endB - startB;
        if(n <= 0) {
            return B[startB + k - 1];
        }
        if(m <= 0) {
            return A[startA + k - 1];
        }
        if(k == 1) {
            return A[startA] < B[startB] ? A[startA] : B[startB];
        }
        int midA = (startA + endA) / 2;
        int midB = (startB + endB) / 2;
        if(A[midA] <= B[midB]) {
            if(n / 2 + m / 2 + 1 >= k) {
                return findKth(A, startA, endA, B, startB, midB, k);
            } else {
                return findKth(A, midA + 1, endA, B, startB, endB, k - n / 2 - 1);
            }
        } else {
            if(n / 2 + m / 2 + 1 >= k) {
                return findKth(A, startA, midA, B, startB, endB, k);
            } else {
                return findKth(A, startA, endA, B, midB + 1, endB, k - m / 2 - 1);
            }
        }
    }
};
```