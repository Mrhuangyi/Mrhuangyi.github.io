---
title: L2-025 分而治之（25 分）
date: 2018-07-08 19:22:55
tags: PAT
categories: 题解集
---

L2-025 分而治之（25 分）
分而治之，各个击破是兵家常用的策略之一。在战争中，我们希望首先攻下敌方的部分城市，使其剩余的城市变成孤立无援，然后再分头各个击破。为此参谋部提供了若干打击方案。本题就请你编写程序，判断每个方案的可行性。

输入格式：

输入在第一行给出两个正整数 N 和 M（均不超过10 000），分别为敌方城市个数（于是默认城市从 1 到 N 编号）和连接两城市的通路条数。随后 M 行，每行给出一条通路所连接的两个城市的编号，其间以一个空格分隔。在城市信息之后给出参谋部的系列方案，即一个正整数 K （<= 100）和随后的 K 行方案，每行按以下格式给出：

Np v[1] v[2] ... v[Np]
其中 Np 是该方案中计划攻下的城市数量，后面的系列 v[i] 是计划攻下的城市编号。

输出格式：

对每一套方案，如果可行就输出“YES”，否则输出“NO”。

分析：题目给出n个城市m条通路，然后决定攻击np个相应城市，让你判断剩余城市是否都孤立无援，也就是剩余的城市之间不存在通路。
首先城市间通路表示可以用邻接矩阵进行初始化，然后用map映射来标记已被攻击的城市，最后循环遍历判断是否还有连通的两个城市

输入样例：
```
10 11
8 7
6 8
4 5
8 4
8 1
1 2
1 4
9 8
9 1
1 10
2 4
5
4 10 3 8 4
6 6 1 7 5 4 9
3 1 8 4
2 2 8
7 9 8 7 6 5 4 2
```
输出样例：
```
NO
YES
YES
NO
NO
```

```cpp
#include<iostream>
#include<map>
#include<algorithm>
using namespace std;
const int maxm = 10010;
struct node{
    int x;
    int y;
}edge[maxm];
int v[maxm];
int main()
{
    int n,m,k,t,x,y,city,l,p,flag;
    scanf("%d %d",&n,&m);
    for(int i=0;i<m;i++){
        scanf("%d %d",&edge[i].x,&edge[i].y);
    }
    scanf("%d",&k);
    for(int i=0;i<k;i++){
        map<int,int> m2;
        scanf("%d",&t);
        for(int j=0;j<t;j++){
            scanf("%d",&city);
            m2[city] = 1;
        }
        int j = 0;
        for(j=0;j<m;j++){
            if(m2[edge[j].x]!=1&&m2[edge[j].y]!=1){
                printf("NO\n");
                break;
            }
        }
        if(j>=m){
            printf("YES\n");
        }
    }
    return 0;
}

```