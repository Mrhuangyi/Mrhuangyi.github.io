---
title: L2-013 红色警报（25 分）
date: 2018-06-23 12:06:52
tags: PAT
categories: 题解集
---

L2-013 红色警报（25 分）
战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。

输入格式：

输入在第一行给出两个整数N（0 < N <=500）和M（<=5000），分别为城市个数（于是默认城市从0到N-1编号）和连接两城市的通路条数。随后M行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数K和随后的K个被攻占的城市的编号。

注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。

输出格式：

对每个被攻占的城市，如果它会改变整个国家的连通性，则输出“Red Alert: City k is lost!”，其中k是该城市的编号；否则只输出“City k is lost.”即可。如果该国失去了最后一个城市，则增加一行输出“Game Over.”。

输入样例：

5 4
0 1
1 3
3 0
0 4
5
1 2 0 4 3
输出样例：

City 1 is lost.
City 2 is lost.
Red Alert: City 0 is lost!
City 4 is lost.
City 3 is lost.
Game Over.

方法一：用dfs判断是否连通并且计算连通数

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxm = 550;
int edge[maxm][maxm];
int visit[maxm],n;
void dfs(int x){
    visit[x] = 1;
    for(int i=0;i<n;i++){
        if(!visit[i]&&edge[x][i]){
            dfs(i);
        }
    }
}
int Calcnt(){
    int cnt = 0;
    for(int i=0;i<n;i++){
        if(!visit[i]){
            dfs(i);
            cnt++;
        }
    }
    return cnt;
}
int main()
{
    int m;
    scanf("%d%d",&n,&m);
    memset(edge,0,sizeof(edge));
    memset(visit,0,sizeof(visit));
    for(int i=0;i<m;i++){
        int a,b;
        scanf("%d%d",&a,&b);
        edge[a][b] = 1;
        edge[b][a] = 1;
    }
    int cntt = Calcnt();
    int k,city;
    scanf("%d",&k);
    for(int i=0;i<k;i++){
        scanf("%d",&city);
        for(int j=0;j<n;j++){
            if(edge[city][j]){
                edge[city][j] = 0;
                edge[j][city] = 0;
            }
        }
        memset(visit,0,sizeof(visit));
        int temp = Calcnt();
        if(temp>cntt+1){
            printf("Red Alert: City %d is lost!\n",city);
        }else{
            printf("City %d is lost.\n",city);
        }
        cntt = temp;
    }
    if(k==n){
        printf("Game Over.\n");
    }
    return 0;
}

```

方法二：并查集

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxm = 550;
int n,m;
struct node{
    int u,v;
}edge[5005];
int visit[maxm],fa[maxm];
int Find(int x){
    if(x==fa[x]){
        return fa[x];
    }else{
        return Find(fa[x]);
    }
}
void Union(int x,int y){
    int xc = Find(x);
    int yc = Find(y);
    if(xc!=yc){
        fa[xc] = yc;
    }
}
int main()
{
    int k,u,v;
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++){
        fa[i] = i;
    }
    for(int i=0;i<m;i++){
        scanf("%d%d",&u,&v);
        edge[i].u = u;
        edge[i].v = v;
        Union(u,v);
    }
    int num1 = 0,num2;
    for(int i=0;i<n;i++){
        if(fa[i]==i){
            num1++;
        }
    }
    memset(visit,0,sizeof(visit));
    scanf("%d",&k);
    for(int j=0;j<k;j++){
        num2 = 0;
        for(int i=0;i<n;i++){
            fa[i] = i;
        }
        int city;
        scanf("%d",&city);
        visit[city] = 1;
        for(int i=0;i<m;i++){
            if(visit[edge[i].u]==1||visit[edge[i].v]==1){
                continue;
            }else{
                Union(edge[i].u,edge[i].v);
            }
        }
        for(int i=0;i<n;i++){
            if(fa[i]==i){
                num2++;
            }
        }
        if(num1==num2||num1+1==num2){
            printf("City %d is lost.\n",city);
        }else{
            printf("Red Alert: City %d is lost!\n",city);
        }
        num1 = num2;
    }
    num1 = 0;
    for(int i=0;i<n;i++){
        if(visit[i]==1){
            num1++;
        }
    }
    if(num1==n){
        printf("Game Over.\n");
    }
    return 0;
}

```