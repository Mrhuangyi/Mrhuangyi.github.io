---
title: 完全背包
date: 2018-05-16 19:45:25
categories: 算法和数据结构
tags:
---

# 完全背包问题

有n种物品，每种物品的单件重量为w[i],价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，
使得背包内物品的总价值最大。其中每种物品都有无穷件。

完全背包与01背包的唯一区别：完全背包的物品数量每种有无穷件，而01背包的物品数量每种只有1件。

令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值

对每种物品有两种策略：

1. 不放第i件物品，那么dp[i][v] = dp[i-1][v]
2. 放第i件物品。dp[i][v] = dp[i][v-w[i]]+c[i]
由此得出状态转移方程：
        **dp[i][v] = max(dp[i-1][v],dp[i][v-w[i]]+c[i]) (1<=i<=n,w[i]<=v<=V)**
        边界：dp[0][v] = 0(0<=v<=V)
改写成一维形式：
        **dp[v] = max(dp[v],dp[v-w[i]]+c[i]) (1<=i<=n,w[i]<=v<=V)**
        边界：dp[v] = 0(0<=v<=V)
```cpp
for(int i=1;i<=n;i++){
    for(int v=w[i];v<=V;v++){
    dp[v] = max(dp[v],dp[v-w[i]]+c[i]);
    }
}
```

# 常见dp问题的模型总结

1. 最大连续子列和
令dp[i]表示以A[i]作为末尾的连续序列的最大和。

2. 最长不下降子序列（LIS）
令dp[i]表示以A[i]结尾的最长不下降子序列长度

3. 最长公共子序列（LCS）
令dp[i][j]表示字符串A的i号位和字符串B的j号位之前的LCS长度

4. 最长回文子串
令dp[i][j]表示S[i]至S[j]所表示的子串是否是回文子串

5. 数塔dp
令dp[i][j]表示从第i行第j个数字出发的到达最底层的所有路径上所能得到的最大和

6. DAG最长路
令dp[i]表示从i号顶点出发能获得的最长路径长度

7. 01背包
令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值

8. 完全背包
令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值

