---
title: L2-022 重排链表（25 分）
date: 2018-07-04 17:33:08
tags: PAT
categories: 题解集
---
L2-022 重排链表（25 分）
给定一个单链表 L~1~→L~2~→...→L~n-1~→L~n~，请编写程序将链表重新排列为 L~n~→L~1~→L~n-1~→L~2~→...。例如：给定L为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。

输入格式：

每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数N (<= 10^5^)。结点的地址是5位非负整数，NULL地址用-1表示。

接下来有N行，每行格式为：

Address Data Next

其中Address是结点地址；Data是该结点保存的数据，为不超过10^5^的正整数；Next是下一结点的地址。题目保证给出的链表上至少有两个结点。

输出格式：

对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。

输入样例：
```
00100 6
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
```
输出样例：
```
68237 6 00100
00100 1 99999
99999 5 12309
12309 2 00000
00000 4 33218
33218 3 -1
```

按照要求重置链表，新建一个链表模拟赋值就可以了。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
using namespace std;
struct ListNode{
    int val;
    int next;
}a[100001];
int main()
{
    int s,n;
    scanf("%d%d",&s,&n);
    int address,data,nex;
    for(int i=0;i<n;i++){
        scanf("%d%d%d",&address,&data,&nex);
        a[address].val = data;
        a[address].next = nex;
    }
    int cnt = 0;
    int res1[100005],res2[100005];
    while(s!=-1){//链表的值赋给res1
        res1[cnt++] = s;
        s = a[s].next;
    }
    int left = 0,right = cnt-1;
    int cnt2 = 0;
    while(left<=right){//模拟求出res2
        if(left==right){
            res2[cnt2++] = res1[right--];
        }else{
            res2[cnt2++] = res1[right--];
            res2[cnt2++] = res1[left++];
        }
    }
    for(int i=0;i<cnt-1;i++){
        printf("%05d %d %05d\n",res2[i],a[res2[i]].val,res2[i+1]);
    }
    printf("%05d %d -1\n",res2[cnt-1],a[res2[cnt-1]].val);
    return 0;
}

```