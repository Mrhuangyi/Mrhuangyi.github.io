---
title: 二叉查找树
date: 2018-05-01 21:38:15
categories: 算法和数据结构
tags: 
---
# 二叉查找树
## 二叉查找树的定义
二叉查找树是一种特殊的二叉树，又称二叉排序树、二叉搜索树。
二叉查找树的递归定义：
1. 二叉查找树要么为一棵空树。
2. 二叉查找树要么为由根结点、左子树、右子树组成，其中左子树和右子树都是二叉查找树，
且左子树上所有结点的数据域均小于或等于根结点的数据域，右子树上所有结点的数据域均大于等于根节点的数据域。

二叉查找树其实是一棵数据有序的树。即对树上的每个结点，都满足其左子树上所有结点的数据域均小于或等于根结点的数据域，
右子树上所有结点的数据域均大于根结点的数据域。
# 二叉查找树的基本操作
1. 查找操作
由二叉查找树的性质得：可以只选择一棵子树进行遍历，因此查找将会是从树根到查找结点的一条路径，
故最坏时间复杂度为O(h),h为二叉查找树高度
基本思路：
1. 如果当前根结点为空，则查找失败，返回
2. 如果需要查找的值x等于当前根结点的数据域root->data，说明查找成功，访问
3. 如果需要查找的值x小于当前根结点的数据域root->data,则向左子树root->lchild递归查找
4. 如果需要查找的值x大于当前根结点的数据域root->data,则向右子树root->rchild递归查找
```cpp
void search(node* root,int x){
    if(root==NULL){
        printf("search failed\n");
        return ;
    }
    if(x==root->data){
        printf("%d\n",root->data);
    }else if(x<root->data){
        search(root->lchild,x);
    }else{
        search(root->rchild,x);
    }
}
```
2. 插入操作
对一棵二叉查找树来说，查找某个数据域的结点一定是沿着确定的路径进行的。
当某个需要查找的值在二叉查找树中查找成功，说明结点已经存在；
反之，查找失败的地方一定是结点需要插入的位置。
插入操作的时间复杂对也是O(h)
```cpp
void insert(node* &root,int x){
        if(root==NULL){
            root=newNode(x);
            return;
        }
        if(x==root->data){
            return;
        }else if(x<root->data){
        insert(root->lchild,x);
        }else{
        insert(root->rchild,x);
        }
}
```
3. 二叉查找树的建立
建立一棵二叉查找树就是先后插入n个结点的过程。
```cpp
node* Create(int data[],int n){
    node* root=NULL;
    for(int i=0;i<n;i++){
        insert(root,data[i]);
    }
    return root;
}
```
4. 二叉查找树的删除（确保删除后仍是一棵二叉查找树）
一般有两种做法，时间复杂度都为O(h)
删除操作的基本思路：
1. 如果当前结点root为空，说明不存在权值为x的结点，返回
2. 如果当前结点root的权值恰为给定的权值x，说明找到了想要删除的结点，进入删除处理
  a. 如果当前结点root不存在左右孩子，说明是叶子结点，直接删除
  b. 如果当前结点root存在左孩子，那么在左子树中寻找结点前驱pre，然后让pre的数据覆盖root，接着在右子树中删除节点next
  c. 如果当前结点root存在右孩子，那么在右子树中寻找结点后继next，然后让next的数据覆盖root，接着在右子树中删除节点next
3. 如果当前结点root的权值大于给定的权值x，则在左子树中递归删除权值为x的结点
4. 如果当前结点root的权值大于給定的权值x，则在右子树中递归删除权值为x的结点
```cpp
//寻找以root为根结点的树中的最大权值结点
node* findMax(node* root){
    while(root->rchild!=NULL){
        root=root->rchild;
    }
    return root;
}
//寻找以root为根结点的树中权值最小的结点
node* findMin(node* root){
    while(root->lchild!=NULL){
        root=root->lchild;
    }
    return root;
}
void deleteNode(node* &root,int x){
    if(root==NULL) return;
    if(root->data==x){
        if(root->lchild==NULL&&root->rchild==NULL){
            root=NULL;
        }else if(root->lchild!=NULL){
        node* pre=findMax(root->lchild);
        root->data=pre->data;
        deleteNode(root->lchild,pre->data);
        }else{
        node* next=findMin(root->rchild);
        root->data=next->data;
        deleteNode(root->rchild,next->data);
        }
    }else if(root->data>x){
    deleteNode(root->lchild,x);
    }else{
    deleteNode(root->rchild,x);
    }
}
```
## 二叉查找树的性质
对二叉查找树进行中序遍历，遍历的结果是有序的
