---
title: 最大连续子列和
date: 2018-05-13 11:57:35
categories: 算法和数据结构
tags:
---

# 最大连续子列和问题
给定一个数字序列A1，A2，......An,求i，j(1<=i<=j<=n),使得Ai+....Aj最大，输出这个最大和。

### 方法一：暴力枚举
枚举左端点和右端点（即枚举i和j），需要O(n^2)的复杂度，求和有需要O(n)的复杂度，因此总复杂度为O(n^3)

### 方法二：预处理记录前缀和
记S[i] = A[0]+A[1]....+A[i],这样A[i]+...+A[j] = S[j]-S[i-1];该计算的复杂度为O(1),但总的时间复杂度为O(n^2)

### 方法三：动态规划
动态规划问题的核心与难点其实就在于确定状态和状态转移方程，以及边界分析。
步骤一：确定状态
令状态dp[i]表示以A[i]作为末尾的连续序列的最大和，
因此所求最大和便是dp[0],dp[1],dp[2]...dp[n-1]中的最大值。
步骤二：确定状态转移方程，求dp数组
以A[i]结尾的连续序列只有两种情况
1. 这个最大和的连续序列只有一个元素，即以A[i]开始，以A[i]结尾
2. 这个最大和的连续序列有多个元素，即以A[p]开始，A[i]结尾
第一种情况，最大和就是A[i]
第二种情况，最大和是dp[i-1]+A[i]
所以可以得到状态转移方程
dp[i] = max{A[i],dp[i-1]+A[i]}
边界为dp[0] = A[0]
时间复杂度为O(n)
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn = 10010;
int a[maxn],dp[maxn];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%d",&a[i]);
    }
    dp[0] = a[0];
    for(int i=1;i<n;i++){
        dp[i] = max(a[i],dp[i-1]+a[i]);
    }
    int k = 0;
    for(int i=1;i<n;i++){
        if(dp[i]>dp[k]){
            k = i;
        }
    }
    printf("%d\n",dp[k]);
    return 0;
}

```
# 状态的无后效性
状态的无后效性是指：当前状态记录了信息，一旦当前状态确定，就不会再改变，且未来的决策只能在已有的一个或若干个状态的
基础上进行，历史信息只能通过已有的状态去影响未来的决策。
