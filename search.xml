<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>LeetCode 35. 搜索插入位置</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><p>输入: [1,3,5,6], 5<br>输出: 2<br>示例 2:</p><p>输入: [1,3,5,6], 2<br>输出: 1<br>示例 3:</p><p>输入: [1,3,5,6], 7<br>输出: 4<br>示例 4:</p><p>输入: [1,3,5,6], 0<br>输出: 0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(nums[x<span class="number">-1</span>]&lt;target)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;=target)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 27. 移除元素</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      <content type="html"><![CDATA[<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><p><strong>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</strong></p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:</p><p>给定 nums = [3,2,2,3], val = 3,</p><p>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p><p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p><p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,</p><p>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p>注意这五个元素可为任意顺序。</p><p>你不需要考虑数组中超出新长度后面的元素。<br>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><p>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>int len = removeElement(nums, val);</p><p>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=val)&#123;</span><br><span class="line">                nums[index++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance(nums.begin(),remove(nums.begin(),nums.end(),val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 26. 删除排序数组中的重复项</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      <content type="html"><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p><strong>不要使用额外的数组空间</strong>，你必须在原地修改输入数组并在使用<strong> O(1) 额外</strong>空间的条件下完成。</p><p>示例 1:</p><p>给定数组 nums = [1,1,2], </p><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p><p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p><p>你不需要考虑数组中超出新长度后面的元素。<br>解法一：标记下标，然后遍历数组元素依次进行比较，出现不等元素就赋值给标记的下一个位置<br>解法二：利用STL里的unique函数（由于给的是有序数组，所以可以直接用）</p><ul><li>unique()是C++标准库函数里面的函数，其功能是去除相邻的重复元素（只保留一个），所以使用前需要对数组进行排序</li><li>distance主要是用来求两个迭代器之间的元素个数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                nums[++pos] = nums[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance(nums.begin(),unique(nums.begin(),nums.end()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 21. 合并两个有序链表</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p>逐个比较大小，到后面较长的链表的多余元素直接补上<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* p = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> val1 = l1-&gt;val;</span><br><span class="line">            <span class="keyword">int</span> val2 = l2-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(val1&lt;val2)&#123;</span><br><span class="line">                p-&gt;next = l1;</span><br><span class="line">                p = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">                p = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 204. 计数质数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>统计所有小于非负数整数 n 的质数的数量。</p><p>示例:</p><p>输入: 10<br>输出: 4<br>解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p><p>先预处理，不是素数的就标记出来<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; isPrime(n,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i;j&lt;n;j+=i)&#123;</span><br><span class="line">                    isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 167. 两数之和 II - 输入有序数组</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><p>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>示例:</p><p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.size();i++)&#123;</span><br><span class="line">            m[numbers[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.size();i++)&#123;</span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> gap = target-numbers[i];</span><br><span class="line">            <span class="keyword">if</span>(m.find(gap)!=m.end()&amp;&amp;m[gap]&gt;i)&#123;</span><br><span class="line">                result.push_back(i+<span class="number">1</span>);</span><br><span class="line">                result.push_back(m[gap]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 136.只出现一次的数字</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      <content type="html"><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有<strong>线性时间复杂度</strong>。 你可以<strong>不使用额外空间</strong>来实现吗？</p><p>示例 1:</p><p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p><p>输入: [4,1,2,1,2]<br>输出: 4</p><p>分析，只有一个元素出现一次，其余均出现两次，可以想到异或运算符，<br>遍历整个数组，出现两次的异或以后为0，最后自然只剩下了出现一次的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            x^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 1.两数之和</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      <content type="html"><![CDATA[<p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p><p>法一：直接双重循环 暴力解，但会超时，O(n^2)</p><p>法二：哈希，用一个哈希表，存储每个数的对应下标，复杂度O(n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            m[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> gap = target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(m.find(gap)!=m.end()&amp;&amp;m[gap]&gt;i)&#123;</span><br><span class="line">                result.push_back(i);</span><br><span class="line">                result.push_back(m[gap]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>技术书单系列2</title>
      <link href="/%E9%9A%8F%E7%AC%94/%E6%8A%80%E6%9C%AF%E4%B9%A6%E5%8D%95%E7%B3%BB%E5%88%972/"/>
      <url>/%E9%9A%8F%E7%AC%94/%E6%8A%80%E6%9C%AF%E4%B9%A6%E5%8D%95%E7%B3%BB%E5%88%972/</url>
      <content type="html"><![CDATA[<h1 id="C语言相关"><a href="#C语言相关" class="headerlink" title="C语言相关"></a>C语言相关</h1><ul><li><p>《C和指针》</p></li><li><p>《C缺陷与陷阱》</p></li><li><p>《C专家编程》</p></li><li><p>《C语言深度剖析》</p></li></ul><h1 id="C-相关"><a href="#C-相关" class="headerlink" title="C++相关"></a>C++相关</h1><ul><li><p>《C++ Primer 5th》</p></li><li><p>《Effective C++》</p></li><li><p>《深度探索C++对象模型》</p></li><li><p>《STL源码剖析》</p></li></ul><h1 id="计算机底层相关"><a href="#计算机底层相关" class="headerlink" title="计算机底层相关"></a>计算机底层相关</h1><ul><li><p>《编码》</p></li><li><p>《编译原理》</p></li><li><p>《汇编语言》</p></li><li><p>《C++反汇编与逆向分析》</p></li></ul><h1 id="算法、数据结构相关"><a href="#算法、数据结构相关" class="headerlink" title="算法、数据结构相关"></a>算法、数据结构相关</h1><ul><li><p>《算法导论》</p></li><li><p>《编程珠玑》</p></li><li><p>《编程之美》</p></li><li><p>《算法艺术与信息学竞赛》</p></li></ul><h1 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h1><ul><li><p>《深入理解操作系统》</p></li><li><p>《Linux内核完全注释》</p></li><li><p>《自己动手写操作系统》</p></li><li><p>《Windows内核原理与实现》</p></li></ul><h1 id="软件开发相关"><a href="#软件开发相关" class="headerlink" title="软件开发相关"></a>软件开发相关</h1><ul><li><p>《Head First 设计模式》</p></li><li><p>《设计模式-可复用面向对象软件的基础》</p></li><li><p>《重构与模式》</p></li><li><p>《代码大全》</p></li><li><p>《设计模式》</p></li></ul><h1 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h1><ul><li><p>《数据库系统概念》</p></li><li><p>《数据库系统实现》</p></li><li><p>《MySQL技术内幕：sql编程》</p></li><li><p>《MySQL技术内幕：innodb存储引擎》</p></li></ul>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向Google的学习手册</title>
      <link href="/%E8%AF%91%E6%96%87%E9%9B%86/%E9%9D%A2%E5%90%91Google%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
      <url>/%E8%AF%91%E6%96%87%E9%9B%86/%E9%9D%A2%E5%90%91Google%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<p>在GitHub上无意中发现一位为了入职Google而准备的学习手册，粗略一看，深感佩服，获益颇多，故转发一波，希望与大家共勉。</p><h1 id="译-Google-Interview-University-一套完整的学习手册帮助自己准备-Google-的面试"><a href="#译-Google-Interview-University-一套完整的学习手册帮助自己准备-Google-的面试" class="headerlink" title="[译] Google Interview University 一套完整的学习手册帮助自己准备 Google 的面试"></a>[译] Google Interview University 一套完整的学习手册帮助自己准备 Google 的面试</h1><blockquote><ul><li>原文地址：<a href="https://github.com/jwasham/google-interview-university" target="_blank" rel="noopener">Google Interview University</a></li><li>原文作者：<a href="https://github.com/jwasham" target="_blank" rel="noopener">John Washam</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>译者：<a href="https://github.com/aleen42" target="_blank" rel="noopener">aleen42</a>，<a href="https://github.com/Newt0n" target="_blank" rel="noopener">Newton</a>，<a href="https://github.com/bobmayuze" target="_blank" rel="noopener">bobmayuze</a>，<a href="https://github.com/laobie" target="_blank" rel="noopener">Jaeger</a>，<a href="https://github.com/sqrthree" target="_blank" rel="noopener">sqrthree</a></li></ul></blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/c9c9db0a39b56738a62332f0791d58b1522fdf82/68747470733a2f2f7261776769742e636f6d2f616c65656e34322f6261646765732f6d61737465722f7372632f786974752e737667" alt="xitu"></a></p><h2 id="这是？"><a href="#这是？" class="headerlink" title="这是？"></a>这是？</h2><p>这是我为了从 web 开发者（自学、非计算机科学学位）蜕变至 Google 软件工程师所制定的计划，其内容历时数月。</p><p><img src="https://dng5l3qzreal6.cloudfront.net/2016/Aug/coding_board_small-1470866369118.jpg" alt="白板上编程 ———— 来自 HBO 频道的剧集，“硅谷”"></p><p>这一长列表是从 <strong>Google 的指导笔记</strong> 中萃取出来并进行扩展。因此，有些事情你必须去了解一下。我在列表的底部添加了一些额外项，用于解决面试中可能会出现的问题。这些额外项大部分是来自于 Steve Yegge 的“<a href="http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html" target="_blank" rel="noopener">得到在 Google 工作的机会</a>”。而在 Google 指导笔记的逐字间，它们有时也会被反映出来。</p><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#这是">这是？</a></li><li><a href="#为何要用到它">为何要用到它？</a></li><li><a href="#如何使用它">如何使用它</a></li><li><a href="#拥有一名-googler-的心态">拥有一名 Googler 的心态</a></li><li><a href="#我得到了工作吗">我得到了工作吗？</a></li><li><a href="#跟着我的脚步">跟着我的脚步</a></li><li><a href="#不要妄自菲薄">不要妄自菲薄</a></li><li><a href="#关于-google">关于 Google</a></li><li><a href="#相关视频资源">相关视频资源</a></li><li><a href="#面试过程--通用的面试准备">面试过程 &amp; 通用的面试准备</a></li><li><a href="#为你的面试选择一种语言">为你的面试选择一种语言</a></li><li><a href="#在你开始之前">在你开始之前</a></li><li><a href="#你所看不到的">你所看不到的</a></li><li><a href="#日常计划">日常计划</a></li><li><a href="#必备知识">必备知识</a></li><li><a href="#算法复杂度--big-o--渐进分析法">算法复杂度 / Big-O / 渐进分析法</a></li><li><a href="#数据结构">数据结构</a><ul><li><a href="#数组arrays">数组（Arrays）</a></li><li><a href="#链表linked-lists">链表（Linked Lists）</a></li><li><a href="#堆栈stack">堆栈（Stack）</a></li><li><a href="#队列queue">队列（Queue）</a></li><li><a href="#哈希表hash-table">哈希表（Hash table）</a></li></ul></li><li><a href="#更多的知识">更多的知识</a><ul><li><a href="#二分查找binary-search">二分查找（Binary search）</a></li><li><a href="#按位运算bitwise-operations">按位运算（Bitwise operations）</a></li></ul></li><li><a href="#树trees">树（Trees）</a><ul><li><a href="#树--笔记--背景">树 —— 笔记 &amp; 背景</a></li><li><a href="#二叉查找树binary-search-treesbsts">二叉查找树（Binary search trees）：BSTs</a></li><li><a href="#堆heap--优先级队列priority-queue--二叉堆binary-heap">堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）</a></li><li><a href="#字典树tries">字典树（Tries）</a></li><li><a href="#平衡查找树balanced-search-trees">平衡查找树（Balanced search trees）</a></li><li><a href="#n-叉树k-叉树m-叉树">N 叉树（K 叉树、M 叉树）</a></li></ul></li><li><a href="#排序sorting">排序</a></li><li><a href="#图graphs">图（Graphs）</a></li><li><a href="#更多知识">更多知识</a><ul><li><a href="#递归recursion">递归</a></li><li><a href="#动态规划dynamic-programming">动态规划</a></li><li><a href="#组合combinatorics-n-中选-k-个--概率probability">组合 &amp; 概率</a></li><li><a href="#np-np-完全和近似算法">NP, NP-完全和近似算法</a></li><li><a href="#缓存cache">缓存</a></li><li><a href="#进程processe和线程thread">进程和线程</a></li><li><a href="#系统设计可伸缩性数据处理">系统设计、可伸缩性、数据处理</a></li><li><a href="#论文">论文</a></li><li><a href="#测试">测试</a></li><li><a href="#调度">调度</a></li><li><a href="#实现系统例程">实现系统例程</a></li><li><a href="#字符串搜索和操作">字符串搜索和操作</a></li></ul></li><li><a href="#终面">终面</a></li><li><a href="#书籍">书籍</a></li><li><a href="#编码练习和挑战">编码练习和挑战</a></li><li><a href="#当你临近面试时">当你临近面试时</a></li><li><a href="#你的简历">你的简历</a></li><li><a href="#当面试来临的时候">当面试来临的时候</a></li><li><a href="#问面试官的问题">问面试官的问题</a></li><li><a href="#当你获得了梦想的职位">当你获得了梦想的职位</a></li></ul><p>—————- 下面的内容是可选的 —————-</p><ul><li><a href="#附加的学习">附加的学习</a><ul><li><a href="#unicode">Unicode</a></li><li><a href="#字节顺序">字节顺序</a></li><li><a href="#emacs-and-vim">Emacs and vi(m)</a></li><li><a href="#unix-命令行工具">Unix 命令行工具</a></li><li><a href="#信息资源-视频">信息资源 (视频)</a></li><li><a href="#奇偶校验位--汉明码-视频">奇偶校验位 &amp; 汉明码 (视频)</a></li><li><a href="#系统熵值系统复杂度">系统熵值（系统复杂度）</a></li><li><a href="#密码学">密码学</a></li><li><a href="#压缩">压缩</a></li><li><a href="#网络-视频">网络 (视频)</a></li><li><a href="#计算机安全">计算机安全</a></li><li><a href="#释放缓存">释放缓存</a></li><li><a href="#并行并发编程">并行/并发编程</a></li><li><a href="#设计模式">设计模式</a></li><li><a href="#信息传输-序列化和队列化的系统">信息传输, 序列化, 和队列化的系统</a></li><li><a href="#快速傅里叶变换">快速傅里叶变换</a></li><li><a href="#布隆过滤器">布隆过滤器</a></li><li><a href="#van-emde-boas-树">van Emde Boas 树</a></li><li><a href="#更深入的数据结构">更深入的数据结构</a></li><li><a href="#跳表">跳表</a></li><li><a href="#网络流">网络流</a></li><li><a href="#不相交集--联合查找">不相交集 &amp; 联合查找</a></li><li><a href="#math-for-fast-processing">快速处理数学</a></li><li><a href="#树堆-treap">树堆 (Treap)</a></li><li><a href="#线性规划linear-programming视频">线性规划</a></li><li><a href="#几何凸包geometry-convex-hull视频">几何：凸包（Geometry, Convex hull）</a></li><li><a href="#离散数学">离散数学</a></li><li><a href="#机器学习machine-learning">机器学习</a></li><li><a href="#go-语言">Go 语言</a></li></ul></li><li><a href="#一些主题的额外内容">一些主题的额外内容</a></li><li><a href="#视频系列">视频系列</a></li><li><a href="#计算机科学课程">计算机科学课程</a></li></ul><hr><h2 id="为何要用到它？"><a href="#为何要用到它？" class="headerlink" title="为何要用到它？"></a>为何要用到它？</h2><p>我一直都是遵循该计划去准备 Google 的面试。自 1997 年以来，我一直从事于 web 程序的构建、服务器的构建及创业型公司的创办。对于只有着一个经济学学位，而不是计算机科学学位（CS degree）的我来说，在职业生涯中所取得的都非常成功。然而，我想在 Google 工作，并进入大型系统中，真正地去理解计算机系统、算法效率、数据结构性能、低级别编程语言及其工作原理。可一项都不了解的我，怎么会被 Google 所应聘呢？</p><p>当我创建该项目时，我从一个堆栈到一个堆都不了解。那时的我，完全不了解 Big-O 、树，或如何去遍历一个图。如果非要我去编写一个排序算法的话，我只能说我所写的肯定是很糟糕。一直以来，我所用的任何数据结构都是内建于编程语言当中。至于它们在背后是如何运作，对此我一概不清楚。此外，以前的我并不需要对内存进行管理，最多就只是在一个正在执行的进程抛出了“内存不足”的错误后，采取一些权变措施。而在我的编程生活中，也甚少使用到多维数组，可关联数组却成千上万。而且，从一开始到现在，我都还未曾自己实现过数据结构。</p><p>就是这样的我，在经过该学习计划后，已然对被 Google 所雇佣充满信心。这是一个漫长的计划，以至于花费了我数月的时间。若您早已熟悉大部分的知识，那么也许能节省大量的时间。</p><h2 id="如何使用它"><a href="#如何使用它" class="headerlink" title="如何使用它"></a>如何使用它</h2><p>下面所有的东西都只是一个概述。因此，你需要由上而下逐一地去处理它。</p><p>在学习过程中，我是使用 GitHub 特殊的语法特性 markdown flavor 去检查计划的进展，包括使用任务列表。</p><ul><li style="list-style: none"><input type="checkbox" checked> 创建一个新的分支，以使得你可以像这样去检查计划的进展。直接往方括号中填写一个字符 x 即可：[x]</li></ul><p><a href="https://guides.github.com/features/mastering-markdown/#GitHub-flavored-markdown" target="_blank" rel="noopener">更多关于 Github-flavored markdown 的详情</a></p><h2 id="拥有一名-Googler-的心态"><a href="#拥有一名-Googler-的心态" class="headerlink" title="拥有一名 Googler 的心态"></a>拥有一名 Googler 的心态</h2><p>把一个（或两个）印有“<a href="https://github.com/jwasham/google-interview-university/blob/master/extras/future-googler.pdf" target="_blank" rel="noopener">future Googler</a>”的图案打印出来，并用你誓要成功的眼神盯着它。</p><p><a href="https://github.com/jwasham/google-interview-university/blob/master/extras/future-googler.pdf" target="_blank" rel="noopener"><img src="https://dng5l3qzreal6.cloudfront.net/2016/Oct/Screen_Shot_2016_10_04_at_10_13_24_AM-1475601104364.png" alt="future Googler sign"></a></p><h2 id="我得到了工作吗？"><a href="#我得到了工作吗？" class="headerlink" title="我得到了工作吗？"></a>我得到了工作吗？</h2><p>我还没去应聘。</p><p>因为我离完成学习（完成该疯狂的计划列表）还需要数天的时间，并打算在下周开始用一整天的时间，以编程的方式去解决问题。当然，这将会持续数周的时间。然后，我才通过使用在二月份所得到的一个介绍资格，去正式应聘 Google（没错，是二月份时就得到的）。</p><pre><code>感谢 JP 的这次介绍。</code></pre><h2 id="跟着我的脚步"><a href="#跟着我的脚步" class="headerlink" title="跟着我的脚步"></a>跟着我的脚步</h2><p>目前我仍在该计划的执行过程中，如果你想跟随我脚步去学习的话，可以登进我在 <a href="https://googleyasheck.com/" target="_blank" rel="noopener">GoogleyAsHeck.com</a> 上所写的博客。</p><p>下面是我的联系方式：</p><ul><li>Twitter: <a href="https://twitter.com/googleyasheck" target="_blank" rel="noopener">@googleyasheck</a></li><li>Twitter: <a href="https://twitter.com/StartupNextDoor" target="_blank" rel="noopener">@StartupNextDoor</a></li><li>Google+: <a href="https://plus.google.com/+Googleyasheck" target="_blank" rel="noopener">+Googleyasheck</a></li><li>LinkedIn: <a href="https://www.linkedin.com/in/johnawasham" target="_blank" rel="noopener">johnawasham</a></li></ul><p><img src="https://dng5l3qzreal6.cloudfront.net/2016/Aug/book_stack_photo_resized_18_1469302751157-1472661280368.png" alt="John Washam - Google Interview University"></p><h2 id="不要妄自菲薄"><a href="#不要妄自菲薄" class="headerlink" title="不要妄自菲薄"></a>不要妄自菲薄</h2><ul><li>Google 的工程师都是才智过人的。但是，就算是工作在 Google 的他们，仍然会因为觉得自己不够聪明而感到一种不安。</li><li><a href="https://www.youtube.com/watch?v=0SARbwvhupQ" target="_blank" rel="noopener">天才程序员的神话</a></li></ul><h2 id="关于-Google"><a href="#关于-Google" class="headerlink" title="关于 Google"></a>关于 Google</h2><ul><li style="list-style: none"><input type="checkbox"> 面向学生 —— <a href="https://www.google.com/about/careers/students/guide-to-technical-development.html" target="_blank" rel="noopener">Google 的职业生涯：技术开发指导</a></li><li style="list-style: none"><input type="checkbox"> Google 检索的原理：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=mTBShTwCnD4" target="_blank" rel="noopener">Google 检索的发展史（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.google.com/insidesearch/howsearchworks/thestory/" target="_blank" rel="noopener">Google 检索的原理 —— 故事篇</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.google.com/insidesearch/howsearchworks/" target="_blank" rel="noopener">Google 检索的原理</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=BNHR6IQJGZs" target="_blank" rel="noopener">Google 检索的原理 —— Matt Cutts（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=J5RZOU6vK4Q" target="_blank" rel="noopener">Google 是如何改善其检索算法（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 系列文章：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://backchannel.com/how-google-search-dealt-with-mobile-33bc09852dc9" target="_blank" rel="noopener">Google 检索是如何处理移动设备</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://backchannel.com/googles-secret-study-to-find-out-our-needs-eba8700263bf" target="_blank" rel="noopener">Google 为了寻找大众需求的秘密研究</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://backchannel.com/google-search-will-be-your-next-brain-5207c26e4523" target="_blank" rel="noopener">Google 检索将成为你的下一个大脑</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://backchannel.com/the-deep-mind-of-demis-hassabis-156112890d8a" target="_blank" rel="noopener">Demis Hassabis 的心灵直白</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.amazon.com/How-Google-Works-Eric-Schmidt/dp/1455582344" target="_blank" rel="noopener">书籍：Google 公司是如何运作的</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=q4y0KOeXViI" target="_blank" rel="noopener">由 Google 通告所制作 —— 2016年10月（视频）</a></li></ul><h2 id="相关视频资源"><a href="#相关视频资源" class="headerlink" title="相关视频资源"></a>相关视频资源</h2><p>部分视频只能通过在 Coursera、Edx 或 Lynda.com class 上注册登录才能观看。这些视频被称为网络公开课程（MOOC）。即便是免费观看，部分课程可能会由于不在时间段内而无法获取。因此，你需要多等待几个月。</p><pre><code>很感谢您能帮我把网络公开课程的视频链接转换成公开的视频源，以代替那些在线课程的视频。此外，一些大学的讲座视频也是我所青睐的。</code></pre><h2 id="面试过程-amp-通用的面试准备"><a href="#面试过程-amp-通用的面试准备" class="headerlink" title="面试过程 &amp; 通用的面试准备"></a>面试过程 &amp; 通用的面试准备</h2><ul><li><p>[ ] 视频：</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=oWbUtlUhwa8&amp;feature=youtu.be" target="_blank" rel="noopener">如何在 Google 工作 —— 考生指导课程（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=qc1owf2-220&amp;feature=youtu.be" target="_blank" rel="noopener">Google 招聘者所分享的技术面试小窍门（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=8npJLXkcmu8" target="_blank" rel="noopener">如何在 Google 工作：技术型简历的准备（视频）</a></li></ul></li><li><p>[ ] 文章：</p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.google.com/about/careers/lifeatgoogle/hiringprocess/" target="_blank" rel="noopener">三步成为 Googler</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html" target="_blank" rel="noopener">得到在 Google 的工作机会</a><ul><li>所有他所提及的事情都列在了下面</li></ul></li><li style="list-style: none"><input type="checkbox"> <em>（早已过期）</em> <a href="http://dondodge.typepad.com/the_next_big_thing/2010/09/how-to-get-a-job-at-google-interview-questions-hiring-process.html" target="_blank" rel="noopener">如何得到 Google 的一份工作，面试题，应聘过程</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://sites.google.com/site/steveyegge2/five-essential-phone-screen-questions" target="_blank" rel="noopener">电话面试的问题</a></li></ul></li><li><p>[ ] 附加的（虽然 Google 不建议，但我还是添加在此）：</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://medium.com/always-be-coding/abc-always-be-coding-d5f8051afce2#.4heg8zvm4" target="_blank" rel="noopener">ABC：永远都要去编程（Always Be Coding）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://medium.com/always-be-coding/four-steps-to-google-without-a-degree-8f381aa6bd5e#.asalo1vfx" target="_blank" rel="noopener">四步成为 Google 里一名没有学位的员工</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://medium.com/@dpup/whiteboarding-4df873dbba2e#.hf6jn45g1" target="_blank" rel="noopener">共享白板（Whiteboarding）</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.kpcb.com/blog/lessons-learned-how-google-thinks-about-hiring-management-and-culture" target="_blank" rel="noopener">Google 是如何看待应聘、管理和公司文化</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.coderust.com/blog/2014/04/10/effective-whiteboarding-during-programming-interviews/" target="_blank" rel="noopener">程序开发面试中有效的白板（Whiteboarding）</a></li><li style="list-style: none"><input type="checkbox"> 震撼开发类面试 第一集：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=rEJzOhC5ZtQ" target="_blank" rel="noopener">Gayle L McDowell —— 震撼开发类面试（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=aClxtDcdpsQ" target="_blank" rel="noopener">震撼开发类面试 —— 作者 Gayle Laakmann McDowell（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 如何在世界四强企业中获得一份工作：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=YJZCUhxNCv8" target="_blank" rel="noopener">“如何在世界四强企业中获得一份工作 —— Amazon、Facebook、Google 和 Microsoft”（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://alexbowe.com/failing-at-google-interviews/" target="_blank" rel="noopener">面试 Google 失败</a></li></ul></li></ul><h2 id="为你的面试选择一种语言"><a href="#为你的面试选择一种语言" class="headerlink" title="为你的面试选择一种语言"></a>为你的面试选择一种语言</h2><p>在这，我就以下话题写一篇短文 —— <a href="https://googleyasheck.com/important-pick-one-language-for-the-google-interview/" target="_blank" rel="noopener">重点：为在 Google 的面试选择一种语言</a></p><p>在大多数公司的面试当中，你可以在编程这一环节，使用一种自己用起来较为舒适的语言去完成编程。但在 Google，你只有三种固定的选择：</p><ul><li>C++</li><li>Java</li><li>Python</li></ul><p>有时你也可以使用下面两种，但需要事先查阅说明。因为，说明中会有警告：</p><ul><li>JavaScript</li><li>Ruby</li></ul><p>你需要对你所选择的语言感到非常舒适且足够了解。</p><p>更多关于语言选择的阅读：</p><ul><li><a href="http://www.byte-by-byte.com/choose-the-right-language-for-your-coding-interview/" target="_blank" rel="noopener">http://www.byte-by-byte.com/choose-the-right-language-for-your-coding-interview/</a></li><li><a href="http://blog.codingforinterviews.com/best-programming-language-jobs/" target="_blank" rel="noopener">http://blog.codingforinterviews.com/best-programming-language-jobs/</a></li><li><a href="https://www.quora.com/What-is-the-best-language-to-program-in-for-an-in-person-Google-interview" target="_blank" rel="noopener">https://www.quora.com/What-is-the-best-language-to-program-in-for-an-in-person-Google-interview</a></li></ul><p><a href="../programming-language-resources.md">在此查看相关语言的资源</a></p><p>由于，我正在学习C、C++ 和 Python。因此，在下面你会看到部分关于它们的学习资料。相关书籍请看文章的底部。</p><h2 id="在你开始之前"><a href="#在你开始之前" class="headerlink" title="在你开始之前"></a>在你开始之前</h2><p>该列表已经持续更新了很长的一段时间，所以，我们的确很容易会对其失去控制。</p><p>这里列出了一些我所犯过的错误，希望您不要重滔覆辙。</p><h3 id="1-你不可能把所有的东西都记住"><a href="#1-你不可能把所有的东西都记住" class="headerlink" title="1. 你不可能把所有的东西都记住"></a>1. 你不可能把所有的东西都记住</h3><p>就算我查看了数小时的视频，并记录了大量的笔记。几个月后的我，仍然会忘却其中大部分的东西。所以，我翻阅了我的笔记，并将可回顾的东西制作成抽认卡（flashcard）（请往下看）</p><h3 id="2-使用抽认卡"><a href="#2-使用抽认卡" class="headerlink" title="2. 使用抽认卡"></a>2. 使用抽认卡</h3><p>为了解决善忘的问题，我制作了一些关于抽认卡的页面，用于添加两种抽认卡：正常的及带有代码的。每种卡都会有不同的格式设计。</p><p>而且，我还以移动设备为先去设计这些网页，以使得在任何地方的我，都能通过我的手机及平板去回顾知识。</p><p>你也可以免费制作属于你自己的抽认卡网站：</p><ul><li><a href="https://github.com/jwasham/computer-science-flash-cards" target="_blank" rel="noopener">抽认卡页面的代码仓库</a></li><li><a href="https://github.com/jwasham/computer-science-flash-cards/blob/master/cards-jwasham.db" target="_blank" rel="noopener">我的抽认卡数据库</a>：有一点需要记住的是，我做事有点过头，以至于把卡片都覆盖到所有的东西上。从汇编语言和 Python 的细枝末节，乃至到机器学习和统计都被覆盖到卡片上。而这种做法，对于 Google 的要求来说，却是多余。</li></ul><p><strong>在抽认卡上做笔记：</strong> 若你第一次发现你知道问题的答案时，先不要急着把其标注成“已懂”。你需要做的，是去查看一下是否有同样的抽认卡，并在你真正懂得如何解决问题之前，多问自己几次。重复地问答可帮助您深刻记住该知识点。</p><h3 id="3-回顾，回顾，回顾"><a href="#3-回顾，回顾，回顾" class="headerlink" title="3. 回顾，回顾，回顾"></a>3. 回顾，回顾，回顾</h3><p>我留有一组 ASCII 码表、OSI 堆栈、Big-O 记号及更多的小抄纸，以便在空余的时候可以学习。</p><p>每编程半个小时就要休息一下，并去回顾你的抽认卡。</p><h3 id="4-专注"><a href="#4-专注" class="headerlink" title="4. 专注"></a>4. 专注</h3><p>在学习的过程中，往往会有许多令人分心的事占据着我们宝贵的时间。因此，专注和集中注意力是非常困难的。</p><h2 id="你所看不到的"><a href="#你所看不到的" class="headerlink" title="你所看不到的"></a>你所看不到的</h2><p>由于，这个巨大的列表一开始是作为我个人从 Google 面试指导笔记所形成的一个事件处理列表。因此，有一些我熟悉且普遍的技术在此都未被谈及到：</p><ul><li>SQL</li><li>Javascript</li><li>HTML、CSS 和其他前端技术</li></ul><h2 id="日常计划"><a href="#日常计划" class="headerlink" title="日常计划"></a>日常计划</h2><p>部分问题可能会花费一天的时间去学习，而部分则会花费多天。当然，有些学习并不需要我们懂得如何实现。</p><p>因此，每一天我都会在下面所列出的列表中选择一项，并查看相关的视频。然后，使用以下的一种语言去实现：</p><pre><code>C —— 使用结构体和函数，该函数会接受一个结构体指针 * 及其他数据作为参数。C++ —— 不使用内建的数据类型。C++ —— 使用内建的数据类型，如使用 STL 的 std::list 来作为链表。Python ——  使用内建的数据类型（为了持续练习 Python），并编写一些测试去保证自己代码的正确性。有时，只需要使用断言函数 assert() 即可。此外，你也可以使用 Java 或其他语言。以上只是我的个人偏好而已。</code></pre><p>为何要在这些语言上分别实现一次？</p><pre><code>因为可以练习，练习，练习，直至我厌倦它，并完美地实现出来。（若有部分边缘条件没想到时，我会用书写的形式记录下来并去记忆）因为可以在纯原生的条件下工作（不需垃圾回收机制的帮助下，分配/释放内存（除了 Python））因为可以利用上内建的数据类型，以使得我拥有在现实中使用内建工具的经验（在生产环境中，我不会去实现自己的链表）</code></pre><p>就算我没有时间去每一项都这么做，但我也会尽我所能的。</p><p>在这里，你可以查看到我的代码：</p><ul><li><a href="https://github.com/jwasham/practice-c" target="_blank" rel="noopener">C</a></li><li><a href="https://github.com/jwasham/practice-cpp" target="_blank" rel="noopener">C++</a></li><li><a href="https://github.com/jwasham/practice-python" target="_blank" rel="noopener">Python</a></li></ul><p>你不需要记住每一个算法的内部原理。</p><p>在一个白板上写代码，而不要直接在计算机上编写。在测试完部分简单的输入后，到计算机上再测试一遍。</p><h2 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h2><ul><li><p>[ ] <strong>计算机是如何处理一段程序：</strong></p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=42KTvGYQYnA" target="_blank" rel="noopener">CPU 是如何执行代码（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Mv2XQgpbTNE" target="_blank" rel="noopener">机器码指令（视频）</a></li></ul></li><li><p>[ ] <strong>编译器</strong></p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=IhC7sdYe-Jg" target="_blank" rel="noopener">编译器是如何在 ~1 分钟内工作（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=CSZLNYF4Klo" target="_blank" rel="noopener">Hardvard CS50 —— 编译器（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=twodd1KFfGk" target="_blank" rel="noopener">C++（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=FnGCDLhaxKU" target="_blank" rel="noopener">掌握编译器的优化（C++）（视频）</a></li></ul></li><li><p>[ ] <strong>浮点数是如何存储的：</strong></p><ul><li style="list-style: none"><input type="checkbox"> 简单的 8-bit：<a href="https://www.youtube.com/watch?v=ji3SfClm8TU" target="_blank" rel="noopener">浮点数的表达形式　—— 1（视频 —— 在计算上有一个错误 —— 详情请查看视频的介绍）</a></li><li style="list-style: none"><input type="checkbox"> 32 bit：<a href="https://www.youtube.com/watch?v=50ZYcZebIec" target="_blank" rel="noopener">IEEE754 32-bit 浮点二进制（视频）</a></li></ul></li></ul><h2 id="算法复杂度-Big-O-渐进分析法"><a href="#算法复杂度-Big-O-渐进分析法" class="headerlink" title="算法复杂度 / Big-O / 渐进分析法"></a>算法复杂度 / Big-O / 渐进分析法</h2><ul><li>并不需要实现</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=iOq5kSKqeR4" target="_blank" rel="noopener">Harvard CS50 —— 渐进表示（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=V6mKVRU1evU" target="_blank" rel="noopener">Big O 记号（通用快速教程）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ei-A_wy5Yxw&amp;index=2&amp;list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN" target="_blank" rel="noopener">Big O 记号（以及 Omega 和 Theta）——  最佳数学解释（视频）</a></li><li style="list-style: none"><input type="checkbox"> Skiena 算法：<ul><li><a href="https://www.youtube.com/watch?v=gSyDMtdPNpU&amp;index=2&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">视频</a></li><li><a href="http://www3.cs.stonybrook.edu/~algorith/video-lectures/2007/lecture2.pdf" target="_blank" rel="noopener">幻灯片</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://discrete.gr/complexity/" target="_blank" rel="noopener">对于算法复杂度分析的一次详细介绍</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://class.coursera.org/algorithmicthink1-004/lecture/59" target="_blank" rel="noopener">增长阶数（Orders of Growth）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://class.coursera.org/algorithmicthink1-004/lecture/61" target="_blank" rel="noopener">渐进性（Asymptotics）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/VIS4YDpuP98" target="_blank" rel="noopener">UC Berkeley Big O（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/ca3e7UVmeUc" target="_blank" rel="noopener">UC Berkeley Big Omega（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=B3SpQZaAZP4&amp;index=10&amp;list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN" target="_blank" rel="noopener">平摊分析法（Amortized Analysis）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://class.coursera.org/algorithmicthink1-004/lecture/63" target="_blank" rel="noopener">举证“Big O”（视频）</a></li><li style="list-style: none"><input type="checkbox"> 高级编程（包括递归关系和主定理）：<ul><li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-1/" target="_blank" rel="noopener">计算性复杂度：第一部</a></li><li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-2/" target="_blank" rel="noopener">计算性复杂度：第二部</a></li></ul></li><li><p>[ ] <a href="http://bigocheatsheet.com/" target="_blank" rel="noopener">速查表（Cheat sheet）</a></p><p>  如果部分课程过于学术性，你可直接跳到文章底部，去查看离散数学的视频以获取相关背景知识。</p></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li><h3 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h3><ul><li>实现一个可自动调整大小的动态数组。</li><li style="list-style: none"><input type="checkbox"> 介绍：<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/OsBSF/arrays" target="_blank" rel="noopener">数组（视频）</a></li><li><a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Basic-arrays/149042/177104-4.html" target="_blank" rel="noopener">数组的基础知识（视频）</a></li><li><a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Multidimensional-arrays/149042/177105-4.html" target="_blank" rel="noopener">多维数组（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/EwbnV/dynamic-arrays" target="_blank" rel="noopener">动态数组（视频）</a></li><li><a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Jagged-arrays/149042/177106-4.html" target="_blank" rel="noopener">不规则数组（视频）</a></li><li><a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Resizable-arrays/149042/177108-4.html" target="_blank" rel="noopener">调整数组的大小（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 实现一个动态数组（可自动调整大小的可变数组）：<ul><li style="list-style: none"><input type="checkbox"> 练习使用数组和指针去编码，并且指针是通过计算去跳转而不是使用索引</li><li style="list-style: none"><input type="checkbox"> 通过分配内存来新建一个原生数据型数组<ul><li>可以使用 int 类型的数组，但不能使用其语法特性</li><li>从大小为16或更大的数（使用2的倍数 —— 16、32、64、128）开始编写</li></ul></li><li style="list-style: none"><input type="checkbox"> size() —— 数组元素的个数</li><li style="list-style: none"><input type="checkbox"> capacity() —— 可容纳元素的个数</li><li style="list-style: none"><input type="checkbox"> is_empty()</li><li style="list-style: none"><input type="checkbox"> at(index) —— 返回对应索引的元素，且若索引越界则愤然报错</li><li style="list-style: none"><input type="checkbox"> push(item)</li><li style="list-style: none"><input type="checkbox"> insert(index, item) —— 在指定索引中插入元素，并把后面的元素依次后移</li><li style="list-style: none"><input type="checkbox"> prepend(item) —— 可以使用上面的 insert 函数，传参 index 为 0</li><li style="list-style: none"><input type="checkbox"> pop() —— 删除在数组末端的元素，并返回其值</li><li style="list-style: none"><input type="checkbox"> delete(index) —— 删除指定索引的元素，并把后面的元素依次前移</li><li style="list-style: none"><input type="checkbox"> remove(item) —— 删除指定值的元素，并返回其索引（即使有多个元素）</li><li style="list-style: none"><input type="checkbox"> find(item) —— 寻找指定值的元素并返回其中第一个出现的元素其索引，若未找到则返回 -1</li><li style="list-style: none"><input type="checkbox"> resize(new_capacity) // 私有函数<ul><li>若数组的大小到达其容积，则变大一倍</li><li>获取元素后，若数组大小为其容积的1/4，则缩小一半</li></ul></li></ul></li><li style="list-style: none"><input type="checkbox"> 时间复杂度<ul><li>在数组末端增加/删除、定位、更新元素，只允许占 O(1) 的时间复杂度（平摊（amortized）去分配内存以获取更多空间）</li><li>在数组任何地方插入/移除元素，只允许 O(n) 的时间复杂度</li></ul></li><li style="list-style: none"><input type="checkbox"> 空间复杂度<ul><li>因为在内存中分配的空间邻近，所以有助于提高性能</li><li>空间需求 = （大于或等于 n 的数组容积）* 元素的大小。即便空间需求为 2n，其空间复杂度仍然是 O(n)</li></ul></li></ul></li><li><h3 id="链表（Linked-Lists）"><a href="#链表（Linked-Lists）" class="headerlink" title="链表（Linked Lists）"></a>链表（Linked Lists）</h3><ul><li style="list-style: none"><input type="checkbox"> 介绍：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/kHhgK/singly-linked-lists" target="_blank" rel="noopener">单向链表（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=sJtJOtXCW_M&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=5" target="_blank" rel="noopener">CS 61B —— 链表（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=QN6FPiD0Gzo" target="_blank" rel="noopener">C 代码（视频）</a><ul><li>并非看完整个视频，只需要看关于节点结果和内存分配那一部分即可</li></ul></li><li style="list-style: none"><input type="checkbox"> 链表 vs 数组：<ul><li><a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/rjBs9/core-linked-lists-vs-arrays" target="_blank" rel="noopener">基本链表 Vs 数组（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/QUaUd/in-the-real-world-lists-vs-arrays" target="_blank" rel="noopener">在现实中，链表 Vs 数组（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=YQs6IC-vgmo" target="_blank" rel="noopener">为什么你需要避免使用链表（视频）</a></li><li style="list-style: none"><input type="checkbox"> 的确：你需要关于“指向指针的指针”的相关知识：（因为当你传递一个指针到一个函数时，该函数可能会改变指针所指向的地址）该页只是为了让你了解“指向指针的指针”这一概念。但我并不推荐这种链式遍历的风格。因为，这种风格的代码，其可读性和可维护性太低。<ul><li><a href="https://www.eskimo.com/~scs/cclass/int/sx8.html" target="_blank" rel="noopener">指向指针的指针</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 实现（我实现了使用尾指针以及没有使用尾指针这两种情况）：<ul><li style="list-style: none"><input type="checkbox"> size() —— 返回链表中数据元素的个数</li><li style="list-style: none"><input type="checkbox"> empty() —— 若链表为空则返回一个布尔值 true</li><li style="list-style: none"><input type="checkbox"> value_at(index) —— 返回第 n 个元素的值（从0开始计算）</li><li style="list-style: none"><input type="checkbox"> push_front(value) —— 添加元素到链表的首部</li><li style="list-style: none"><input type="checkbox"> pop_front() —— 删除首部元素并返回其值</li><li style="list-style: none"><input type="checkbox"> push_back(value) —— 添加元素到链表的尾部</li><li style="list-style: none"><input type="checkbox"> pop_back() —— 删除尾部元素并返回其值</li><li style="list-style: none"><input type="checkbox"> front() —— 返回首部元素的值</li><li style="list-style: none"><input type="checkbox"> back() —— 返回尾部元素的值</li><li style="list-style: none"><input type="checkbox"> insert(index, value) —— 插入值到指定的索引，并把当前索引的元素指向到新的元素</li><li style="list-style: none"><input type="checkbox"> erase(index) —— 删除指定索引的节点</li><li style="list-style: none"><input type="checkbox"> value_n_from_end(n) —— 返回倒数第 n 个节点的值</li><li style="list-style: none"><input type="checkbox"> reverse() —— 逆序链表</li><li style="list-style: none"><input type="checkbox"> remove_value(value) —— 删除链表中指定值的第一个元素</li></ul></li><li style="list-style: none"><input type="checkbox"> 双向链表<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/jpGKD/doubly-linked-lists" target="_blank" rel="noopener">介绍（视频）</a></li><li>并不需要实现</li></ul></li></ul></li><li><h3 id="堆栈（Stack）"><a href="#堆栈（Stack）" class="headerlink" title="堆栈（Stack）"></a>堆栈（Stack）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/UdKzQ/stacks" target="_blank" rel="noopener">堆栈（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Using-stacks-last-first-out/149042/177120-4.html" target="_blank" rel="noopener">使用堆栈 —— 后进先出（视频）</a></li><li style="list-style: none"><input type="checkbox"> 可以不实现，因为使用数组来实现并不重要</li></ul></li><li><h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Using-queues-first-first-out/149042/177122-4.html" target="_blank" rel="noopener">使用队列 —— 先进先出（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/EShpq/queue" target="_blank" rel="noopener">队列（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Circular_buffer" target="_blank" rel="noopener">原型队列/先进先出（FIFO）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Priority-queues-deques/149042/177123-4.html" target="_blank" rel="noopener">优先级队列（视频）</a></li><li style="list-style: none"><input type="checkbox"> 使用含有尾部指针的链表来实现:<ul><li>enqueue(value) —— 在尾部添加值</li><li>dequeue() —— 删除最早添加的元素并返回其值（首部元素）</li><li>empty()</li></ul></li><li style="list-style: none"><input type="checkbox"> 使用固定大小的数组实现：<ul><li>enqueue(value) —— 在可容的情况下添加元素到尾部</li><li>dequeue() —— 删除最早添加的元素并返回其值</li><li>empty()</li><li>full()</li></ul></li><li style="list-style: none"><input type="checkbox"> 花销：<ul><li>在糟糕的实现情况下，使用链表所实现的队列，其入列和出列的时间复杂度将会是 O(n)。因为，你需要找到下一个元素，以致循环整个队列</li><li>enqueue：O(1)（平摊（amortized）、链表和数组 [探测（probing）]）</li><li>dequeue：O(1)（链表和数组）</li><li>empty：O(1)（链表和数组）</li></ul></li></ul></li><li><h3 id="哈希表（Hash-table）"><a href="#哈希表（Hash-table）" class="headerlink" title="哈希表（Hash table）"></a>哈希表（Hash table）</h3><ul><li><p>[ ] 视频：</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=0M_kIqhwbFo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=8" target="_blank" rel="noopener">链式哈希表（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=BRO7mVIFt08&amp;index=9&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">Table Doubling 和 Karp-Rabin（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=rvdJDijO2Ro&amp;index=10&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">Open Addressing 和密码型哈希（Cryptographic Hashing）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=C4Kc8xzcA68" target="_blank" rel="noopener">PyCon 2010：The Mighty Dictionary（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=z0lJ2k0sl1g&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=11" target="_blank" rel="noopener">（进阶）随机取样（Randomization）：全域哈希（Universal Hashing）&amp; 完美哈希（Perfect Hashing）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=N0COwN14gt0&amp;list=PL2B4EEwhKD-NbwZ4ezj7gyc_3yNrojKM9&amp;index=4" target="_blank" rel="noopener">（进阶）完美哈希（Perfect hashing）（视频）</a></li></ul></li><li><p>[ ] 在线课程：</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Understanding-hash-functions/149042/177126-4.html" target="_blank" rel="noopener">哈希函数的掌握（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Using-hash-tables/149042/177127-4.html" target="_blank" rel="noopener">使用哈希表（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Supporting-hashing/149042/177128-4.html" target="_blank" rel="noopener">哈希表的支持（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Language-support-hash-tables/149042/177129-4.html" target="_blank" rel="noopener">哈希表的语言支持（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/m7UuP/core-hash-tables" target="_blank" rel="noopener">基本哈希表（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/home/week/3" target="_blank" rel="noopener">数据结构（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/NYZZP/phone-book-problem" target="_blank" rel="noopener">电话薄问题（Phone Book Problem）（视频）</a></li><li style="list-style: none"><input type="checkbox"> 分布式哈希表：<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/DvaIb/instant-uploads-and-storage-optimization-in-dropbox" target="_blank" rel="noopener">Dropbox 中的瞬时上传及存储优化（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/tvH8H/distributed-hash-tables" target="_blank" rel="noopener">分布式哈希表（视频）</a></li></ul></li></ul></li><li><p>[ ] 使用线性探测的数组去实现</p><ul><li>hash(k, m) —— m 是哈希表的大小</li><li>add(key, value) —— 如果 key 已存在则更新值</li><li>exists(key)</li><li>get(key)</li><li>remove(key)</li></ul></li></ul></li></ul><h2 id="更多的知识"><a href="#更多的知识" class="headerlink" title="更多的知识"></a>更多的知识</h2><ul><li><h3 id="二分查找（Binary-search）"><a href="#二分查找（Binary-search）" class="headerlink" title="二分查找（Binary search）"></a>二分查找（Binary search）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=D5SrAga1pno" target="_blank" rel="noopener">二分查找（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search" target="_blank" rel="noopener">二分查找（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/binary-search/" target="_blank" rel="noopener">详情</a></li><li style="list-style: none"><input type="checkbox"> 实现：<ul><li>二分查找（在一个已排序好的整型数组中查找）</li><li>迭代式二分查找</li></ul></li></ul></li><li><h3 id="按位运算（Bitwise-operations）"><a href="#按位运算（Bitwise-operations）" class="headerlink" title="按位运算（Bitwise operations）"></a>按位运算（Bitwise operations）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://github.com/jwasham/google-interview-university/blob/master/extras/cheat%20sheets/bits-cheat-cheet.pdf" target="_blank" rel="noopener">Bits 速查表</a><ul><li>你需要知道大量2的幂数值（从2^1 到 2^16 及 2^32）</li></ul></li><li style="list-style: none"><input type="checkbox"> 好好理解位操作符的含义：&amp;、|、^、~、&gt;&gt;、&lt;&lt;<ul><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Word_(computer_architecture" target="_blank" rel="noopener">字码（words）</a>)</li><li style="list-style: none"><input type="checkbox"> 好的介绍：<br>  <a href="https://www.youtube.com/watch?v=7jkIUgLC29I" target="_blank" rel="noopener">位操作（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=d0AwjSpNXR0" target="_blank" rel="noopener">C 语言编程教程 2-10：按位运算（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Bit_manipulation" target="_blank" rel="noopener">位操作</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Bitwise_operation" target="_blank" rel="noopener">按位运算</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://graphics.stanford.edu/~seander/bithacks.html" target="_blank" rel="noopener">Bithacks</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://bits.stephan-brumme.com/" target="_blank" rel="noopener">位元抚弄者（The Bit Twiddler）</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://bits.stephan-brumme.com/interactive.html" target="_blank" rel="noopener">交互式位元抚弄者（The Bit Twiddler Interactive）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 一补数和补码<ul><li><a href="https://www.youtube.com/watch?v=lKTsv6iVxV4" target="_blank" rel="noopener">二进制：利 &amp; 弊（为什么我们要使用补码）（视频）</a></li><li><a href="https://en.wikipedia.org/wiki/Ones%27_complement" target="_blank" rel="noopener">一补数（1s Complement）</a></li><li><a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank" rel="noopener">补码（2s Complement）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 计算置位（Set Bits）<ul><li><a href="https://youtu.be/Hzuzo9NJrlc" target="_blank" rel="noopener">计算一个字节中置位（Set Bits）的四种方式（视频）</a></li><li><a href="https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan" target="_blank" rel="noopener">计算比特位</a></li><li><a href="http://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer" target="_blank" rel="noopener">如何在一个 32 位的整型中计算置位（Set Bits）的数量</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 四舍五入2的幂数：<ul><li><a href="http://bits.stephan-brumme.com/roundUpToNextPowerOfTwo.html" target="_blank" rel="noopener">四舍五入到2的下一幂数</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 交换值：<ul><li><a href="http://bits.stephan-brumme.com/swap.html" target="_blank" rel="noopener">交换（Swap）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 绝对值：<ul><li><a href="http://bits.stephan-brumme.com/absInteger.html" target="_blank" rel="noopener">绝对整型（Absolute Integer）</a></li></ul></li></ul></li></ul><h2 id="树（Trees）"><a href="#树（Trees）" class="headerlink" title="树（Trees）"></a>树（Trees）</h2><ul><li><h3 id="树-——-笔记-amp-背景"><a href="#树-——-笔记-amp-背景" class="headerlink" title="树 —— 笔记 &amp; 背景"></a>树 —— 笔记 &amp; 背景</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/ovovP/core-trees" target="_blank" rel="noopener">系列：基本树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/95qda/trees" target="_blank" rel="noopener">系列：树（视频）</a></li><li>基本的树形结构</li><li>遍历</li><li>操作算法</li><li>BFS（广度优先检索，breadth-first search）<ul><li><a href="https://www.youtube.com/watch?v=s-CYnVz-uh4&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=13" target="_blank" rel="noopener">MIT（视频）</a></li><li>层序遍历（使用队列的 BFS 算法）<ul><li>时间复杂度： O(n)</li><li>空间复杂度：<ul><li>最好情况： O(1)</li><li>最坏情况：O(n/2)=O(n)</li></ul></li></ul></li></ul></li><li>DFS（深度优先检索，depth-first search）<ul><li><a href="https://www.youtube.com/watch?v=AfSk24UTFS8&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=14" target="_blank" rel="noopener">MIT（视频）</a></li><li>笔记：<ul><li>时间复杂度：O(n)</li><li>空间复杂度：<ul><li>最好情况：O(log n) - 树的平均高度</li><li>最坏情况：O(n)</li></ul></li></ul></li><li>中序遍历（DFS：左、节点本身、右）</li><li>后序遍历（DFS：左、右、节点本身）</li><li>先序遍历（DFS：节点本身、左、右）</li></ul></li></ul></li><li><h3 id="二叉查找树（Binary-search-trees）：BSTs"><a href="#二叉查找树（Binary-search-trees）：BSTs" class="headerlink" title="二叉查找树（Binary search trees）：BSTs"></a>二叉查找树（Binary search trees）：BSTs</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=x6At0nzX92o&amp;index=1&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="noopener">二叉查找树概览（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/p82sw/core-introduction-to-binary-search-trees" target="_blank" rel="noopener">系列（视频）</a><ul><li>从符号表开始到 BST 程序</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/E7cXP/introduction" target="_blank" rel="noopener">介绍（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=9Jry5-82I68" target="_blank" rel="noopener">MIT（视频）</a></li><li>C/C++:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=COZK7NATh4k&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=28" target="_blank" rel="noopener">二叉查找树 —— 在 C/C++ 中实现（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=hWokyBoo0aI&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=29" target="_blank" rel="noopener">BST 的实现 —— 在堆栈和堆中的内存分配（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Ut90klNN264&amp;index=30&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="noopener">在二叉查找树中找到最小和最大的元素（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=_pnqMz5nrRs&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=31" target="_blank" rel="noopener">寻找二叉树的高度（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=9RHO6jU--GU&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=32" target="_blank" rel="noopener">二叉树的遍历 —— 广度优先和深度优先策略（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=86g8jAQug04&amp;index=33&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="noopener">二叉树：层序遍历（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=gm8DUJJhmY4&amp;index=34&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="noopener">二叉树的遍历：先序、中序、后序（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=yEwSGhSsT0U&amp;index=35&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="noopener">判断一棵二叉树是否为二叉查找树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=gcULXE7ViZw&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=36" target="_blank" rel="noopener">从二叉查找树中删除一个节点（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=5cPbNCrdotA&amp;index=37&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="noopener">二叉查找树中序遍历的后继者（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 实现：<ul><li style="list-style: none"><input type="checkbox"> insert    // 往树上插值</li><li style="list-style: none"><input type="checkbox"> get_node_count // 查找树上的节点数</li><li style="list-style: none"><input type="checkbox"> print_values // 从小到大打印树中节点的值</li><li style="list-style: none"><input type="checkbox"> delete_tree</li><li style="list-style: none"><input type="checkbox"> is_in_tree // 如果值存在于树中则返回 true</li><li style="list-style: none"><input type="checkbox"> get_height // 返回节点所在的高度（如果只有一个节点，那么高度则为1）</li><li style="list-style: none"><input type="checkbox"> get_min   // 返回树上的最小值</li><li style="list-style: none"><input type="checkbox"> get_max   // 返回树上的最大值</li><li style="list-style: none"><input type="checkbox"> is_binary_search_tree</li><li style="list-style: none"><input type="checkbox"> delete_value</li><li style="list-style: none"><input type="checkbox"> get_successor // 返回给定值的后继者，若没有则返回-1</li></ul></li></ul></li><li><h3 id="堆（Heap）-优先级队列（Priority-Queue）-二叉堆（Binary-Heap）"><a href="#堆（Heap）-优先级队列（Priority-Queue）-二叉堆（Binary-Heap）" class="headerlink" title="堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）"></a>堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）</h3><ul><li>可视化是一棵树，但通常是以线性的形式存储（数组、链表）</li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Heap_(data_structure" target="_blank" rel="noopener">堆</a>)</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/2OpTs/introduction" target="_blank" rel="noopener">介绍（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/z3l9N/naive-implementations" target="_blank" rel="noopener">无知的实现（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/GRV2q/binary-trees" target="_blank" rel="noopener">二叉树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/supplement/S5xxz/tree-height-remark" target="_blank" rel="noopener">关于树高的讨论（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/0g1dl/basic-operations" target="_blank" rel="noopener">基本操作（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/gl5Ni/complete-binary-trees" target="_blank" rel="noopener">完全二叉树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/HxQo9/pseudocode" target="_blank" rel="noopener">伪代码（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/odNJmw5TOEE?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3291" target="_blank" rel="noopener">堆排序 —— 跳到起点（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/hSzMO/heap-sort" target="_blank" rel="noopener">堆排序（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/dwrOS/building-a-heap" target="_blank" rel="noopener">构建一个堆（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=B7hVxCmfPtM&amp;index=4&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">MIT：堆与堆排序（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=yIUFT6AKBGE&amp;index=24&amp;list=PL4BBB74C7D2A1049C" target="_blank" rel="noopener">CS 61B Lecture 24：优先级队列（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=MiyLo8adrWw" target="_blank" rel="noopener">构建线性时间复杂度的堆（大顶堆）</a></li><li style="list-style: none"><input type="checkbox"> 实现一个大顶堆：<ul><li style="list-style: none"><input type="checkbox"> insert</li><li style="list-style: none"><input type="checkbox"> sift_up —— 用于插入元素</li><li style="list-style: none"><input type="checkbox"> get_max —— 返回最大值但不移除元素</li><li style="list-style: none"><input type="checkbox"> get_size() —— 返回存储的元素数量</li><li style="list-style: none"><input type="checkbox"> is_empty() —— 若堆为空则返回 true</li><li style="list-style: none"><input type="checkbox"> extract_max —— 返回最大值并移除</li><li style="list-style: none"><input type="checkbox"> sift_down —— 用于获取最大值元素</li><li style="list-style: none"><input type="checkbox"> remove(i) —— 删除指定索引的元素</li><li style="list-style: none"><input type="checkbox"> heapify —— 构建堆，用于堆排序</li><li style="list-style: none"><input type="checkbox"> heap_sort() —— 拿到一个未排序的数组，然后使用大顶堆进行就地排序<ul><li>注意：若用小顶堆可节省操作，但导致空间复杂度加倍。（无法做到就地）</li></ul></li></ul></li></ul></li><li><h3 id="字典树（Tries）"><a href="#字典树（Tries）" class="headerlink" title="字典树（Tries）"></a>字典树（Tries）</h3><ul><li>需要注意的是，字典树各式各样。有些有前缀，而有些则没有。有些使用字符串而不使用比特位来追踪路径。</li><li>阅读代码，但不实现。</li><li style="list-style: none"><input type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Tries" target="_blank" rel="noopener">数据结构笔记及编程技术</a></li><li style="list-style: none"><input type="checkbox"> 短课程视频：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/08Xyf/core-introduction-to-tries" target="_blank" rel="noopener">对字典树的介绍（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/PvlZW/core-performance-of-tries" target="_blank" rel="noopener">字典树的性能（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/DFvd3/core-implementing-a-trie" target="_blank" rel="noopener">实现一棵字典树（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.toptal.com/java/the-trie-a-neglected-data-structure" target="_blank" rel="noopener">字典树：一个被忽略的数据结构</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/using-tries/" target="_blank" rel="noopener">高级编程 —— 使用字典树</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=TJ8SkcUSdbU" target="_blank" rel="noopener">标准教程（现实中的用例）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=NinWEPPrkDQ&amp;index=16&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf" target="_blank" rel="noopener">MIT，高阶数据结构，使用字符串追踪路径（可事半功倍）</a></li></ul></li><li><h3 id="平衡查找树（Balanced-search-trees）"><a href="#平衡查找树（Balanced-search-trees）" class="headerlink" title="平衡查找树（Balanced search trees）"></a>平衡查找树（Balanced search trees）</h3><ul><li>掌握至少一种平衡查找树（并懂得如何实现）：</li><li>“在各种平衡查找树当中，AVL 树和2-3树已经成为了过去，而红黑树（red-black trees）看似变得越来越受人青睐。这种令人特别感兴趣的数据结构，亦称伸展树（splay tree）。它可以自我管理，且会使用轮换来移除任何访问过根节点的 key。” —— Skiena</li><li>因此，在各种各样的平衡查找树当中，我选择了伸展树来实现。虽然，通过我的阅读，我发现在 Google 的面试中并不会被要求实现一棵平衡查找树。但是，为了胜人一筹，我们还是应该看看如何去实现。在阅读了大量关于红黑树的代码后，我才发现伸展树的实现确实会使得各方面更为高效。<ul><li>伸展树：插入、查找、删除函数的实现，而如果你最终实现了红黑树，那么请尝试一下：</li><li>跳过删除函数，直接实现搜索和插入功能</li></ul></li><li>我希望能阅读到更多关于 B 树的资料，因为它也被广泛地应用到大型的数据库当中。</li><li><p>[ ] <a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" target="_blank" rel="noopener">自平衡二叉查找树</a></p></li><li><p>[ ] <strong>AVL 树</strong></p><ul><li>实际中：我能告诉你的是，该种树并无太多的用途，但我能看到有用的地方在哪里：AVL 树是另一种平衡查找树结构。其可支持时间复杂度为 O(log n) 的查询、插入及删除。它比红黑树严格意义上更为平衡，从而导致插入和删除更慢，但遍历却更快。正因如此，才彰显其结构的魅力。只需要构建一次，就可以在不重新构造的情况下读取，适合于实现诸如语言字典（或程序字典，如一个汇编程序或解释程序的操作码）。</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=FNeL18KsWPc&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=6" target="_blank" rel="noopener">MIT AVL 树 / AVL 树的排序（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/Qq5E0/avl-trees" target="_blank" rel="noopener">AVL 树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/PKEBC/avl-tree-implementation" target="_blank" rel="noopener">AVL 树的实现（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/22BgE/split-and-merge" target="_blank" rel="noopener">分离与合并</a></li></ul></li><li><p>[ ] <strong>伸展树</strong></p><ul><li>实际中：伸展树一般用于缓存、内存分配者、路由器、垃圾回收者、数据压缩、ropes（字符串的一种替代品，用于存储长串的文本字符）、Windows NT（虚拟内存、网络及文件系统）等的实现。</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Najzh1rYQTo&amp;index=23&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd" target="_blank" rel="noopener">CS 61B：伸展树（Splay trees）（视频）</a></li><li style="list-style: none"><input type="checkbox"> MIT 教程：伸展树（Splay trees）：<ul><li>该教程会过于学术，但请观看到最后的10分钟以确保掌握。</li><li><a href="https://www.youtube.com/watch?v=QnPl_Y6EqMo" target="_blank" rel="noopener">视频</a></li></ul></li></ul></li><li><p>[ ] <strong>2-3查找树</strong></p><ul><li>实际中：2-3树的元素插入非常快速，但却有着查询慢的代价（因为相比较 AVL 树来说，其高度更高）。</li><li>你会很少用到2-3树。这是因为，其实现过程中涉及到不同类型的节点。因此，人们更多地会选择红黑树。</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=C3SsdUqasD4&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&amp;index=2" target="_blank" rel="noopener">2-3树的直感与定义（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=iYvBtGKsqSg&amp;index=3&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="noopener">2-3树的二元观点</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=TOb1tuEZ2X4&amp;index=5&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">2-3树（学生叙述）（视频）</a></li></ul></li><li><p>[ ] <strong>2-3-4树 (亦称2-4树)</strong></p><ul><li>实际中：对于每一棵2-4树，都有着对应的红黑树来存储同样顺序的数据元素。在2-4树上进行插入及删除操作等同于在红黑树上进行颜色翻转及轮换。这使得2-4树成为一种用于掌握红黑树背后逻辑的重要工具。这就是为什么许多算法引导文章都会在介绍红黑树之前，先介绍2-4树，尽管<strong>2-4树在实际中并不经常使用</strong>。</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=zqrqYXkth6Q&amp;index=26&amp;list=PL4BBB74C7D2A1049C" target="_blank" rel="noopener">CS 61B Lecture 26：平衡查找树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=DQdMYevEyE4&amp;index=4&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="noopener">自底向上的2-4树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2679VQ26Fp4&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&amp;index=5" target="_blank" rel="noopener">自顶向下的2-4树（视频）</a></li></ul></li><li><p>[ ] <strong>B 树</strong></p><ul><li>有趣的是：为啥叫 B 仍然是一个神秘。因为 B 可代表波音（Boeing）、平衡（Balanced）或 Bayer（联合创造者）</li><li>实际中：B 树会被广泛适用于数据库中，而现代大多数的文件系统都会使用到这种树（或变种)。除了运用在数据库中，B 树也会被用于文件系统以快速访问一个文件的任意块。但存在着一个基本的问题，那就是如何将文件块 i 转换成一个硬盘块（或一个柱面-磁头-扇区）上的地址。</li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener">B 树</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=I22wEC1tTGo&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&amp;index=6" target="_blank" rel="noopener">B 树的介绍（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=s3bCdZGrgpA&amp;index=7&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="noopener">B 树的定义及其插入操作（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=svfnVhJOfMc&amp;index=8&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="noopener">B 树的删除操作（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=V3omVLzI0WE&amp;index=7&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf" target="_blank" rel="noopener">MIT 6.851 —— 内存层次模块（Memory Hierarchy Models）（视频）</a><ul><li>覆盖有高速缓存参数无关型（cache-oblivious）B 树和非常有趣的数据结构</li><li>头37分钟讲述的很专业，或许可以跳过（B 指块的大小、即缓存行的大小）</li></ul></li></ul></li><li><p>[ ] <strong>红黑树</strong></p><ul><li>实际中：红黑树提供了在最坏情况下插入操作、删除操作和查找操作的时间保证。这些时间值的保障不仅对时间敏感型应用有用，例如实时应用，还对在其他数据结构中块的构建非常有用，而这些数据结构都提供了最坏情况下的保障；例如，许多用于计算几何学的数据结构都可以基于红黑树，而目前 Linux 系统所采用的完全公平调度器（the Completely Fair Scheduler）也使用到了该种树。在 Java 8中，红黑树也被用于存储哈希列表集合中相同的数据，而不是使用链表及哈希码。</li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/1W3x0f_RmUo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3871" target="_blank" rel="noopener">Aduni —— 算法 —— 课程4（该链接直接跳到开始部分）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=hm2GHwyKF1o&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=5" target="_blank" rel="noopener">Aduni —— 算法 —— 课程5（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree" target="_blank" rel="noopener">黑树（Black Tree）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/" target="_blank" rel="noopener">二分查找及红黑树的介绍</a></li></ul></li></ul></li><li><h3 id="N-叉树（K-叉树、M-叉树）"><a href="#N-叉树（K-叉树、M-叉树）" class="headerlink" title="N 叉树（K 叉树、M 叉树）"></a>N 叉树（K 叉树、M 叉树）</h3><ul><li>注意：N 或 K 指的是分支系数（即树的最大分支数）：<ul><li>二叉树是一种分支系数为2的树</li><li>2-3树是一种分支系数为3的树</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/K-ary_tree" target="_blank" rel="noopener">K 叉树</a></li></ul></li></ul><h2 id="排序（Sorting）"><a href="#排序（Sorting）" class="headerlink" title="排序（Sorting）"></a>排序（Sorting）</h2><ul><li><p>[ ] 笔记:</p><ul><li>实现各种排序 &amp; 知道每种排序的最坏、最好和平均的复杂度分别是什么场景:<ul><li>不要用冒泡排序 - 大多数情况下效率感人 - 时间复杂度 O(n^2), 除非 n &lt;= 16</li></ul></li><li style="list-style: none"><input type="checkbox"> 排序算法的稳定性 (“快排是稳定的么?”)<ul><li><a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability" target="_blank" rel="noopener">排序算法的稳定性</a></li><li><a href="http://stackoverflow.com/questions/1517793/stability-in-sorting-algorithms" target="_blank" rel="noopener">排序算法的稳定性</a></li><li><a href="http://stackoverflow.com/questions/1517793/stability-in-sorting-algorithms" target="_blank" rel="noopener">排序算法的稳定性</a></li><li><a href="http://www.geeksforgeeks.org/stability-in-sorting-algorithms/" target="_blank" rel="noopener">排序算法的稳定性</a></li><li><a href="http://homepages.math.uic.edu/~leon/cs-mcs401-s08/handouts/stability.pdf" target="_blank" rel="noopener">排序算法 - 稳定性</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 哪种排序算法可以用链表？哪种用数组？哪种两者都可？<ul><li>并不推荐对一个链表排序，但归并排序是可行的.</li><li><a href="http://www.geeksforgeeks.org/merge-sort-for-linked-list/" target="_blank" rel="noopener">链表的归并排序</a></li></ul></li></ul></li><li><p>关于堆排序，请查看前文堆的数据结构部分。堆排序很强大，不过是非稳定排序。</p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=P00xJgWzz2c&amp;index=1&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">冒泡排序 (video)</a></p></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ni_zk257Nqo&amp;index=7&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">冒泡排序分析 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Kg4bqzAqRBM&amp;index=3&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">插入排序 &amp; 归并排序 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=c4BRHC7kTaQ&amp;index=2&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">插入排序 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=GCae1WNvnZM&amp;index=3&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">归并排序 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=y_G9BkAm6B8&amp;index=4&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">快排 (video)</a></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=6nDMgr0-Yyo&amp;index=8&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">选择排序 (video)</a></p></li><li><p>[ ] 斯坦福大学关于排序算法的视频:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ENp00xylP7c&amp;index=15&amp;list=PLFE6E58F856038C69" target="_blank" rel="noopener">课程 15 | 编程抽象 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=y4M9IVgrVKo&amp;index=16&amp;list=PLFE6E58F856038C69" target="_blank" rel="noopener">课程 16 | 编程抽象 (video)</a></li></ul></li><li><p>[ ] Shai Simonson 视频, <a href="http://www.aduni.org/" target="_blank" rel="noopener">Aduni.org</a>:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=odNJmw5TOEE&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=2" target="_blank" rel="noopener">算法 - 排序 - 第二讲 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=hj8YKFTFKEE&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=3" target="_blank" rel="noopener">算法 - 排序2 - 第三讲 (video)</a></li></ul></li><li><p>[ ] Steven Skiena 关于排序的视频:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/ute-pmMkyuk?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=1600" target="_blank" rel="noopener">课程从 26:46 开始 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=yLvp-pB8mak&amp;index=8&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">课程从 27:40 开始 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=q7K9otnzlfE&amp;index=9&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">课程从 35:00 开始 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=TvqIGu9Iupw&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=10" target="_blank" rel="noopener">课程从 23:50 开始 (video)</a></li></ul></li><li><p>[ ] 加州大学伯克利分校（UC Berkeley） 大学课程:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=EiUvYS2DT6I&amp;list=PL4BBB74C7D2A1049C&amp;index=29" target="_blank" rel="noopener">CS 61B 课程 29: 排序 I (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2hTY3t80Qsk&amp;list=PL4BBB74C7D2A1049C&amp;index=30" target="_blank" rel="noopener">CS 61B 课程 30: 排序 II (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Y6LOLpxg6Dc&amp;index=32&amp;list=PL4BBB74C7D2A1049C" target="_blank" rel="noopener">CS 61B 课程 32: 排序 III (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=qNMQ4ly43p4&amp;index=33&amp;list=PL4BBB74C7D2A1049C" target="_blank" rel="noopener">CS 61B 课程 33: 排序 V (video)</a></li></ul></li><li><p>[ ] - 归并排序:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/examples/sorting/mergesort.c" target="_blank" rel="noopener">使用外部数组</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://github.com/jwasham/practice-cpp/blob/master/merge_sort/merge_sort.cc" target="_blank" rel="noopener">对原数组直接排序</a></li></ul></li><li><p>[ ] - 快速排序:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/examples/randomization/quick.c" target="_blank" rel="noopener">实现</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://github.com/jwasham/practice-c/blob/master/quick_sort/quick_sort.c" target="_blank" rel="noopener">实现</a></li></ul></li><li><p>[ ] 实现:</p><ul><li style="list-style: none"><input type="checkbox"> 归并：平均和最差情况的时间复杂度为 O(n log n)。</li><li style="list-style: none"><input type="checkbox"> 快排：平均时间复杂度为 O(n log n)。</li><li>选择排序和插入排序的最坏、平均时间复杂度都是 O(n^2)。</li><li>关于堆排序，请查看前文堆的数据结构部分。</li></ul></li><li><p>[ ] 有兴趣的话，还有一些补充 - 但并不是必须的:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#radixSort" target="_blank" rel="noopener">基数排序</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=xhr26ia4k38" target="_blank" rel="noopener">基数排序 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Nz1KZXbghj8&amp;index=7&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">基数排序, 计数排序 (线性时间内) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=cNB2lADK3_s&amp;index=8&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">随机算法: 矩阵相乘, 快排, Freivalds’ 算法 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=pOKy3RZbSws&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&amp;index=14" target="_blank" rel="noopener">线性时间内的排序 (video)</a></li></ul></li></ul><h2 id="图（Graphs）"><a href="#图（Graphs）" class="headerlink" title="图（Graphs）"></a>图（Graphs）</h2><p>图论能解决计算机科学里的很多问题，所以这一节会比较长，像树和排序的部分一样。</p><ul><li><p>Yegge 的笔记:</p><ul><li>有 3 种基本方式在内存里表示一个图:<ul><li>对象和指针</li><li>矩阵</li><li>邻接表</li></ul></li><li>熟悉以上每一种图的表示法，并了解各自的优缺点</li><li>宽度优先搜索和深度优先搜索 - 知道它们的计算复杂度和设计上的权衡以及如何用代码实现它们</li><li>遇到一个问题时，首先尝试基于图的解决方案，如果没有再去尝试其他的。</li></ul></li><li><p>[ ] Skiena 教授的课程 - 很不错的介绍:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=OiXxhDrFruw&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=11" target="_blank" rel="noopener">CSE373 2012 - 课程 11 - 图的数据结构 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=g5vF8jscteo&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=12" target="_blank" rel="noopener">CSE373 2012 - 课程 12 - 广度优先搜索 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=S23W6eTcqdY&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=13" target="_blank" rel="noopener">CSE373 2012 - 课程 13 - 图的算法 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=WitPBKGV0HY&amp;index=14&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">CSE373 2012 - 课程 14 - 图的算法 (1) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ia1L30l7OIg&amp;index=15&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">CSE373 2012 - 课程 15 - 图的算法 (2) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=jgDOQq6iWy8&amp;index=16&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">CSE373 2012 - 课程 16 - 图的算法 (3) (video)</a></li></ul></li><li><p>[ ] 图 (复习和其他):</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Aa2sqUhIn-E&amp;index=15&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">6.006 单源最短路径问题 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2E7MmKv0Y24&amp;index=16&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">6.006 Dijkstra 算法 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ozsuci5pIso&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=17" target="_blank" rel="noopener">6.006 Bellman-Ford 算法(video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=CHvQ3q_gJ7E&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=18" target="_blank" rel="noopener">6.006 Dijkstra 效率优化 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=i_AQT_XfvD8&amp;index=6&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="noopener">Aduni: 图的算法 I - 拓扑排序, 最小生成树, Prim 算法 -  第六课 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ufj5_bppBsA&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=7" target="_blank" rel="noopener">Aduni: 图的算法 II - 深度优先搜索, 广度优先搜索, Kruskal 算法, 并查集数据结构 - 第七课 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=DiedsPsMKXc&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=8" target="_blank" rel="noopener">Aduni: 图的算法 III: 最短路径 - 第八课 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=XIAQRlNkJAw&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=9" target="_blank" rel="noopener">Aduni: 图的算法. IV: 几何算法介绍 - 第九课 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/dgjX4HdMI-Q?list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;t=3489" target="_blank" rel="noopener">CS 61B 2014 (从 58:09 开始) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=aJjlQCFwylA&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=19" target="_blank" rel="noopener">CS 61B 2014: 加权图 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=tKwnms5iRBU&amp;index=16&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">贪心算法: 最小生成树 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=RpgcYiky7uw" target="_blank" rel="noopener">图的算法之强连通分量 Kosaraju 算法 (video)</a></li></ul></li><li><p>完整的 Coursera 课程:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-on-graphs/home/welcome" target="_blank" rel="noopener">图的算法 (video)</a></li></ul></li><li><p>Yegge: 如果有机会，可以试试研究更酷炫的算法:</p><ul><li style="list-style: none"><input type="checkbox"> Dijkstra 算法 - 上文 - 6.006</li><li style="list-style: none"><input type="checkbox"> A* 算法<ul><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/A*_search_algorithm" target="_blank" rel="noopener">A* 算法</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=KNXfSOx4eEE" target="_blank" rel="noopener">A* 寻路教程 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=-L-WgKMFuhE" target="_blank" rel="noopener">A* 寻路 (E01: 算法解释) (video)</a></li></ul></li></ul></li><li><p>我会实现:</p><ul><li style="list-style: none"><input type="checkbox"> DFS 邻接表 (递归)</li><li style="list-style: none"><input type="checkbox"> DFS 邻接表 (栈迭代)</li><li style="list-style: none"><input type="checkbox"> DFS 邻接矩阵 (递归)</li><li style="list-style: none"><input type="checkbox"> DFS 邻接矩阵 (栈迭代)</li><li style="list-style: none"><input type="checkbox"> BFS 邻接表</li><li style="list-style: none"><input type="checkbox"> BFS 邻接矩阵</li><li style="list-style: none"><input type="checkbox"> 单源最短路径问题 (Dijkstra)</li><li style="list-style: none"><input type="checkbox"> 最小生成树</li><li>基于 DFS 的算法 (根据上文 Aduni 的视频):<ul><li style="list-style: none"><input type="checkbox"> 检查环 (我们会先检查是否有环存在以便做拓扑排序)</li><li style="list-style: none"><input type="checkbox"> 拓扑排序</li><li style="list-style: none"><input type="checkbox"> 计算图中的连通分支</li><li style="list-style: none"><input type="checkbox"> 列出强连通分量</li><li style="list-style: none"><input type="checkbox"> 检查双向图</li></ul></li></ul></li></ul><p>可以从 Skiena 的书（参考下面的书推荐小节）和面试书籍中学习更多关于图的实践。</p><h2 id="更多知识"><a href="#更多知识" class="headerlink" title="更多知识"></a>更多知识</h2><ul><li><h3 id="递归（Recursion）"><a href="#递归（Recursion）" class="headerlink" title="递归（Recursion）"></a>递归（Recursion）</h3><ul><li style="list-style: none"><input type="checkbox"> Stanford 大学关于递归 &amp; 回溯的课程:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=gl3emqCuueQ&amp;list=PLFE6E58F856038C69&amp;index=8" target="_blank" rel="noopener">课程 8 | 抽象编程 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=uFJhEPrbycQ&amp;list=PLFE6E58F856038C69&amp;index=9" target="_blank" rel="noopener">课程 9 | 抽象编程 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=NdF1QDTRkck&amp;index=10&amp;list=PLFE6E58F856038C69" target="_blank" rel="noopener">课程 10 | 抽象编程 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=p-gpaIGRCQI&amp;list=PLFE6E58F856038C69&amp;index=11" target="_blank" rel="noopener">课程 11 | 抽象编程 (video)</a></li></ul></li><li>什么时候适合使用</li><li>尾递归会更好么?<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.quora.com/What-is-tail-recursion-Why-is-it-so-bad" target="_blank" rel="noopener">什么是尾递归以及为什么它如此糟糕?</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=L1jjXGfxozc" target="_blank" rel="noopener">尾递归 (video)</a></li></ul></li></ul></li><li><h3 id="动态规划（Dynamic-Programming）"><a href="#动态规划（Dynamic-Programming）" class="headerlink" title="动态规划（Dynamic Programming）"></a>动态规划（Dynamic Programming）</h3><ul><li><strong>注意</strong> ：动态规划是门极为重要的技术，尽管其并未被 Google 提供的准备手册提及，但你可能会对寻求最佳解的方式有点疑问，所以我将其列入这份表单。</li><li>这一部分会有点困难，每个可以用动态规划解决的问题都必须先定义出递推关系，要推导出来可能会有点棘手。</li><li><p>我建议先阅读和学习足够多的动态规划的例子，以便对解决 DP 问题的一般模式有个扎实的理解。</p></li><li><p>[ ] 视频:</p><ul><li>Skiena 的视频可能会有点难跟上，有时候他用白板写的字会比较小，难看清楚。</li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/Qc2ieXRgR0k?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=1718" target="_blank" rel="noopener">Skiena: CSE373 2012 - 课程 19 - 动态规划介绍 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/IsmMhMdyeGY?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=2749" target="_blank" rel="noopener">Skiena: CSE373 2012 - 课程 20 - 编辑距离 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/o0V9eYF4UI8?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=406" target="_blank" rel="noopener">Skiena: CSE373 2012 - 课程 21 - 动态规划举例 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=dRbMC1Ltl3A&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=22" target="_blank" rel="noopener">Skiena: CSE373 2012 - 课程 22 - 动态规划应用 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/J5aJEcOr6Eo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3558" target="_blank" rel="noopener">Simonson: 动态规划 0 (starts at 59:18) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=0EzHjQ_SOeU&amp;index=11&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="noopener">Simonson: 动态规划 I - 课程 11 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=v1qiRwuJU7g&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=12" target="_blank" rel="noopener">Simonson: 动态规划 II - 课程 12 (video)</a></li><li style="list-style: none"><input type="checkbox"> 单独的 DP 问题 (每一个视频都很短):<br>  <a href="https://www.youtube.com/playlist?list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr" target="_blank" rel="noopener">动态规划 (video)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> Yale 课程笔记:<ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#dynamicProgramming" target="_blank" rel="noopener">动态规划</a></li></ul></li><li style="list-style: none"><input type="checkbox"> Coursera 课程:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/80RrW/the-rna-secondary-structure-problem" target="_blank" rel="noopener">RNA 二级结构问题 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/PSonq/a-dynamic-programming-algorithm" target="_blank" rel="noopener">动态规划算法 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/oUEK2/illustrating-the-dp-algorithm" target="_blank" rel="noopener">DP 算法描述 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/nfK2r/running-time-of-the-dp-algorithm" target="_blank" rel="noopener">DP 算法的运行时间 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/M999a/dp-vs-recursive-implementation" target="_blank" rel="noopener">DP vs 递归实现 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/UZ7o6/global-pairwise-sequence-alignment" target="_blank" rel="noopener">全局成对序列排列 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/WnNau/local-pairwise-sequence-alignment" target="_blank" rel="noopener">本地成对序列排列 (video)</a></li></ul></li></ul></li><li><h3 id="组合（Combinatorics）-n-中选-k-个-amp-概率（Probability）"><a href="#组合（Combinatorics）-n-中选-k-个-amp-概率（Probability）" class="headerlink" title="组合（Combinatorics） (n 中选 k 个) &amp; 概率（Probability）"></a>组合（Combinatorics） (n 中选 k 个) &amp; 概率（Probability）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=8RRo6Ti9d0U" target="_blank" rel="noopener">数据技巧: 如何找出阶乘、排列和组合(选择) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=sZkAAk9Wwa4" target="_blank" rel="noopener">来点学校的东西: 概率 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=dNaJg-mLobQ" target="_blank" rel="noopener">来点学校的东西: 概率和马尔可夫链 (video)</a></li><li style="list-style: none"><input type="checkbox"> 可汗学院:<ul><li>课程设置:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.khanacademy.org/math/probability/probability-and-combinatorics-topic" target="_blank" rel="noopener">概率理论基础</a></li></ul></li><li>视频 - 41 (每一个都短小精悍):<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=uzkc-qNVoOk&amp;list=PLC58778F28211FA19" target="_blank" rel="noopener">概率解释 (video)</a></li></ul></li></ul></li></ul></li><li><h3 id="NP-NP-完全和近似算法"><a href="#NP-NP-完全和近似算法" class="headerlink" title="NP, NP-完全和近似算法"></a>NP, NP-完全和近似算法</h3><ul><li>知道最经典的一些 NP 完全问题，比如旅行商问题和背包问题,<br>  而且能在面试官试图忽悠你的时候识别出他们。</li><li>知道 NP 完全是什么意思.</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=moPtwq_cVH8&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=23" target="_blank" rel="noopener">计算复杂度 (video)</a></li><li style="list-style: none"><input type="checkbox"> Simonson:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/qcGnJ47Smlo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=2939" target="_blank" rel="noopener">贪心算法. II &amp; 介绍 NP-完全性 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=e0tGC6ZQdQE&amp;index=16&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="noopener">NP-完全性 II &amp; 归约 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=fCX1BGT3wjE&amp;index=17&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="noopener">NP-完全性 III (Video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=NKLDp3Rch3M&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=18" target="_blank" rel="noopener">NP-完全性 IV (video)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> Skiena:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/KiK5TVgXbFg?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=1508" target="_blank" rel="noopener">CSE373 2012 - 课程 23 - 介绍 NP-完全性 IV (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=27Al52X3hd4&amp;index=24&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">CSE373 2012 - 课程 24 - NP-完全性证明 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=xCPH4gwIIXM&amp;index=25&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">CSE373 2012 - 课程 25 - NP-完全性挑战 (video)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=eHZifpgyH_4&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=22" target="_blank" rel="noopener">复杂度: P, NP, NP-完全性, 规约 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=MEz1J9wY2iM&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=24" target="_blank" rel="noopener">复杂度: 近视算法 Algorithms (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=4q-jmGrmxKs&amp;index=25&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">复杂度: 固定参数算法 (video)</a></li><li>Peter Norvik 讨论旅行商问题的近似最优解:<ul><li><a href="http://nbviewer.jupyter.org/url/norvig.com/ipython/TSP.ipynb" target="_blank" rel="noopener">Jupyter 笔记本</a></li></ul></li><li>《算法导论》的第 1048 - 1140 页。</li></ul></li><li><h3 id="缓存（Cache）"><a href="#缓存（Cache）" class="headerlink" title="缓存（Cache）"></a>缓存（Cache）</h3><ul><li style="list-style: none"><input type="checkbox"> LRU 缓存:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=R5ON3iwx78M" target="_blank" rel="noopener">LRU 的魔力 (100 Days of Google Dev) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=bq6N7Ym81iI" target="_blank" rel="noopener">实现 LRU (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=8-FZRAjR7qU" target="_blank" rel="noopener">LeetCode - 146 LRU Cache (C++) (video)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> CPU 缓存:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=vjYF_fAZI5E&amp;list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-&amp;index=24" target="_blank" rel="noopener">MIT 6.004 L15: 存储体系 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ajgC3-pyGlk&amp;index=25&amp;list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-" target="_blank" rel="noopener">MIT 6.004 L16: 缓存的问题 (video)</a></li></ul></li></ul></li><li><h3 id="进程（Processe）和线程（Thread）"><a href="#进程（Processe）和线程（Thread）" class="headerlink" title="进程（Processe）和线程（Thread）"></a>进程（Processe）和线程（Thread）</h3><ul><li style="list-style: none"><input type="checkbox"> 计算机科学 162 - 操作系统 (25 个视频):<ul><li>视频 1-11 是关于进程和线程</li><li><a href="https://www.youtube.com/playlist?list=PL-XXv-cvA_iBDyz-ba4yDskqMDY6A1w_c" target="_blank" rel="noopener">操作系统和系统编程 (video)</a></li></ul></li><li><a href="https://www.quora.com/What-is-the-difference-between-a-process-and-a-thread" target="_blank" rel="noopener">进程和线程的区别是什么?</a></li><li>涵盖了:<ul><li>进程、线程、协程<ul><li>进程和线程的区别</li><li>进程</li><li>线程</li><li>锁</li><li>互斥</li><li>信号量</li><li>监控</li><li>他们是如何工作的</li><li>死锁</li><li>活锁</li></ul></li><li>CPU 活动, 中断, 上下文切换</li><li>现代多核处理器的并发式结构</li><li>进程资源需要（内存：代码、静态存储器、栈、堆、文件描述符、I/O）</li><li>线程资源需要（在同一个进程内和其他线程共享以上的资源，但是每个线程都有独立的程序计数器、栈计数器、寄存器和栈）</li><li>Fork 操作是真正的写时复制（只读），直到新的进程写到内存中，才会生成一份新的拷贝。</li><li>上下文切换<ul><li>操作系统和底层硬件是如何初始化上下文切换的。</li></ul></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M" target="_blank" rel="noopener">C++ 的线程 (系列 - 10 个视频)</a></li><li style="list-style: none"><input type="checkbox"> Python 的协程 (视频):<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PL1H1sBF1VAKVMONJWJkmUh6_p8g4F2oy1" target="_blank" rel="noopener">线程系列</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Bs7vPNbB9JM" target="_blank" rel="noopener">Python 线程</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Obt-vMVdM8s" target="_blank" rel="noopener">理解 Python 的 GIL (2010)</a><ul><li><a href="http://www.dabeaz.com/GIL" target="_blank" rel="noopener">参考</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=MCs5OvhV9S4" target="_blank" rel="noopener">David Beazley - Python 协程 - PyCon 2015</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ZzfHjytDceU" target="_blank" rel="noopener">Keynote David Beazley - 兴趣主题 (Python 异步 I/O)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=0zaPs8OtyKY" target="_blank" rel="noopener">Python 中的互斥</a></li></ul></li></ul></li></ul><pre><code>系统设计以及可伸缩性，要把软硬件的伸缩性设计的足够好有很多的东西要考虑，所以这是个包含非常多内容和资源的大主题。需要花费相当多的时间在这个主题上。</code></pre><ul><li><h3 id="系统设计、可伸缩性、数据处理"><a href="#系统设计、可伸缩性、数据处理" class="headerlink" title="系统设计、可伸缩性、数据处理"></a>系统设计、可伸缩性、数据处理</h3><ul><li>Yegge 的注意事项:<ul><li>伸缩性<ul><li>把大数据集提取为单一值</li><li>大数据集转换</li><li>处理大量的数据集</li></ul></li><li>系统<ul><li>特征集</li><li>接口</li><li>类层次结构</li><li>在特定的约束下设计系统</li><li>轻量和健壮性</li><li>权衡和折衷</li><li>性能分析和优化</li></ul></li></ul></li><li style="list-style: none"><input type="checkbox"> <strong>从这里开始</strong>: <a href="http://www.hiredintech.com/system-design/" target="_blank" rel="noopener">HiredInTech：系统设计</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.quora.com/How-do-I-prepare-to-answer-design-questions-in-a-technical-interview?redirected_qid=1500023" target="_blank" rel="noopener">该如何为技术面试里设计方面的问题做准备?</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://blog.gainlo.co/index.php/2015/10/22/8-things-you-need-to-know-before-system-design-interviews/" target="_blank" rel="noopener">在系统设计面试前必须知道的 8 件事</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.hiredintech.com/algorithm-design/" target="_blank" rel="noopener">算法设计</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=UrYLYV7WSHM" target="_blank" rel="noopener">数据库范式 - 1NF, 2NF, 3NF and 4NF (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://github.com/checkcheckzz/system-design-interview" target="_blank" rel="noopener">系统设计面试</a> - 这一部分有很多的资源，浏览一下我放在下面的文章和例子。</li><li style="list-style: none"><input type="checkbox"> <a href="http://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/" target="_blank" rel="noopener">如何在系统设计面试中脱颖而出</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://everythingisdata.wordpress.com/2009/10/17/numbers-everyone-should-know/" target="_blank" rel="noopener">每个人都该知道的一些数字</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html" target="_blank" rel="noopener">上下文切换操作会耗费多少时间?</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=srOgpXECblk" target="_blank" rel="noopener">跨数据中心的事务 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem/" target="_blank" rel="noopener">简明 CAP 理论介绍</a></li><li style="list-style: none"><input type="checkbox"> Paxos 一致性算法:<ul><li><a href="https://www.youtube.com/watch?v=s8JqcZtvnsM" target="_blank" rel="noopener">时间很短</a></li><li><a href="https://www.youtube.com/watch?v=JEpsBg0AO6o" target="_blank" rel="noopener">用例 和 multi-paxos</a></li><li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="noopener">论文</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.tom-e-white.com/2007/11/consistent-hashing.html" target="_blank" rel="noopener">一致性哈希</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://horicky.blogspot.com/2009/11/nosql-patterns.html" target="_blank" rel="noopener">NoSQL 模式</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=OkC7HKtiZC0&amp;list=PLGLfVvz_LVvQ5G-LdJ8RLqe-ndo7QITYc" target="_blank" rel="noopener">OOSE: UML 2.0 系列 (video)</a></li><li style="list-style: none"><input type="checkbox"> OOSE: 使用 UML 和 Java 开发软件 (21 videos):<ul><li>如果你对 OO 都深刻的理解和实践，可以跳过这部分。</li><li><a href="https://www.youtube.com/playlist?list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO" target="_blank" rel="noopener">OOSE: 使用 UML 和 Java 开发软件</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 面向对象编程的 SOLID 原则:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=TMuno5RZNeE" target="_blank" rel="noopener">Bob Martin 面向对象的 SOLID 原则和敏捷设计 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PL8m4NUhTQU48oiGCSgCP1FiJEcg_xJzyQ" target="_blank" rel="noopener">C# SOLID 设计模式 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PL4CE9F710017EA77A" target="_blank" rel="noopener">SOLID 原则 (video)</a></li><li style="list-style: none"><input type="checkbox"> S - <a href="http://www.oodesign.com/single-responsibility-principle.html" target="_blank" rel="noopener">单一职责原则</a> | <a href="http://www.javacodegeeks.com/2011/11/solid-single-responsibility-principle.html" target="_blank" rel="noopener">每个对象的单一职责</a><ul><li><a href="https://docs.google.com/open?id=0ByOwmqah_nuGNHEtcU5OekdDMkk" target="_blank" rel="noopener">更多</a></li></ul></li><li style="list-style: none"><input type="checkbox"> O - <a href="http://www.oodesign.com/open-close-principle.html" target="_blank" rel="noopener">开闭原则</a>  | <a href="https://en.wikipedia.org/wiki/Open/closed_principle" target="_blank" rel="noopener">生产环境里的对象应该为扩展做准备而不是为更改</a><ul><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgN2M5MTkwM2EtNWFkZC00ZTI3LWFjZTUtNTFhZGZiYmUzODc1&amp;hl=en" target="_blank" rel="noopener">更多</a></li></ul></li><li style="list-style: none"><input type="checkbox"> L - <a href="http://www.oodesign.com/liskov-s-substitution-principle.html" target="_blank" rel="noopener">里氏代换原则</a> | <a href="http://stackoverflow.com/questions/56860/what-is-the-liskov-substitution-principle" target="_blank" rel="noopener">基类和继承类遵循 ‘IS A’ 原则</a><ul><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgNzAzZjA5ZmItNjU3NS00MzQ5LTkwYjMtMDJhNDU5ZTM0MTlh&amp;hl=en" target="_blank" rel="noopener">更多</a></li></ul></li><li style="list-style: none"><input type="checkbox"> I - <a href="http://www.oodesign.com/interface-segregation-principle.html" target="_blank" rel="noopener">接口隔离原则</a> | 客户端被迫实现用不到的接口<ul><li><a href="https://www.youtube.com/watch?v=3CtAfl7aXAQ" target="_blank" rel="noopener">5 分钟讲解接口隔离原则 (video)</a></li><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgOTViYjJhYzMtMzYxMC00MzFjLWJjMzYtOGJiMDc5N2JkYmJi&amp;hl=en" target="_blank" rel="noopener">更多</a></li></ul></li><li style="list-style: none"><input type="checkbox"> D -<a href="http://www.oodesign.com/dependency-inversion-principle.html" target="_blank" rel="noopener">依赖反转原则</a> | 减少对象里的依赖。<ul><li><a href="http://stackoverflow.com/questions/62539/what-is-the-dependency-inversion-principle-and-why-is-it-important" target="_blank" rel="noopener">什么是依赖倒置以及它为什么重要</a></li><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgMjdlMWIzNGUtZTQ0NC00ZjQ5LTkwYzQtZjRhMDRlNTQ3ZGMz&amp;hl=en" target="_blank" rel="noopener">更多</a></li></ul></li></ul></li><li style="list-style: none"><input type="checkbox"> 可伸缩性:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=-W9F__D3oY4" target="_blank" rel="noopener">很棒的概述 (video)</a></li><li style="list-style: none"><input type="checkbox"> 简短系列:<ul><li><a href="http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones" target="_blank" rel="noopener">克隆</a></li><li><a href="http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database" target="_blank" rel="noopener">数据库</a></li><li><a href="http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache" target="_blank" rel="noopener">缓存</a></li><li><a href="http://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism" target="_blank" rel="noopener">异步</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.aosabook.org/en/distsys.html" target="_blank" rel="noopener">可伸缩的 Web 架构和分布式系统</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://pages.cs.wisc.edu/~zuyu/files/fallacies.pdf" target="_blank" rel="noopener">错误的分布式系统解释</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html" target="_blank" rel="noopener">实用编程技术</a><ul><li><a href="http://horicky.blogspot.com/2010/07/google-pregel-graph-processing.html" target="_blank" rel="noopener">extra: Google Pregel 图形处理</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=modXC5IWTJI" target="_blank" rel="noopener">Jeff Dean - 在 Goolge 构建软件系统 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://lethain.com/introduction-to-architecting-systems-for-scale/" target="_blank" rel="noopener">可伸缩系统架构设计介绍</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=9nWyWwY2Onc" target="_blank" rel="noopener">使用 App Engine 和云存储扩展面向全球用户的手机游戏架构实践(video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=H4vMcD7zKM0" target="_blank" rel="noopener">How Google Does Planet-Scale Engineering for Planet-Scale Infra (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/the-importance-of-algorithms/" target="_blank" rel="noopener">算法的重要性</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html" target="_blank" rel="noopener">分片</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.infoq.com/presentations/Scale-at-Facebook" target="_blank" rel="noopener">Facebook 系统规模扩展实践 (2009)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=oodS71YtkGU" target="_blank" rel="noopener">Facebook 系统规模扩展实践 (2012), “为 10 亿用户构建” (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=p0jGmgIrf_M&amp;list=PLRXxvay_m8gqVlExPC5DG3TGWJTaBgqSA&amp;index=4" target="_blank" rel="noopener">Long Game 工程实践 - Astrid Atkinson Keynote(video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2012/3/26/7-years-of-youtube-scalability-lessons-in-30-minutes.html" target="_blank" rel="noopener">30 分钟看完 YouTuBe 7 年系统扩展经验</a><ul><li><a href="https://www.youtube.com/watch?v=G-lGCC4KKok" target="_blank" rel="noopener">video</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/8/15/how-paypal-scaled-to-billions-of-transactions-daily-using-ju.html" target="_blank" rel="noopener">PayPal 如何用 8 台虚拟机扛住 10 亿日交易量系统</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://blog.clevertap.com/how-to-remove-duplicates-in-large-datasets/" target="_blank" rel="noopener">如何对大数据集去重</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=3vV4YiqKm1o" target="_blank" rel="noopener">Etsy 的扩展和工程文化探究 Jon Cowie (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://thenewstack.io/led-amazon-microservices-architecture/" target="_blank" rel="noopener">是什么造就了 Amazon 自己的微服务架构</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://eng.uber.com/trip-data-squeeze/" target="_blank" rel="noopener">压缩还是不压缩，是 Uber 面临的问题</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/3/3/asyncio-tarantool-queue-get-in-the-queue.html" target="_blank" rel="noopener">异步 I/O Tarantool 队列</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/2/25/when-should-approximate-query-processing-be-used.html" target="_blank" rel="noopener">什么时候应该用近视查询处理?</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/2/23/googles-transition-from-single-datacenter-to-failover-to-a-n.html" target="_blank" rel="noopener">Google 从单数据中心到故障转移, 到本地多宿主架构的演变</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2012/9/24/google-spanners-most-surprising-revelation-nosql-is-out-and.html" target="_blank" rel="noopener">Spanner</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/2/15/egnyte-architecture-lessons-learned-in-building-and-scaling.html" target="_blank" rel="noopener">Egnyte: 构建和扩展 PB 级分布式系统架构的经验教训</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/7/6/machine-learning-driven-programming-a-new-programming-for-a.html" target="_blank" rel="noopener">机器学习驱动的编程: 新世界的新编程方式</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/6/15/the-image-optimization-technology-that-serves-millions-of-re.html" target="_blank" rel="noopener">日服务数百万请求的图像优化技术</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/2/1/a-patreon-architecture-short.html" target="_blank" rel="noopener">Patreon 架构</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/1/27/tinder-how-does-one-of-the-largest-recommendation-engines-de.html" target="_blank" rel="noopener">Tinder: 推荐引擎是如何决定下一个你将会看到谁的?</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html" target="_blank" rel="noopener">现代缓存设计</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/1/13/live-video-streaming-at-facebook-scale.html" target="_blank" rel="noopener">Facebook 实时视频流扩展</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/1/11/a-beginners-guide-to-scaling-to-11-million-users-on-amazons.html" target="_blank" rel="noopener">在 Amazon AWS 上把服务扩展到 1100 万量级的新手教程</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2015/12/16/how-does-the-use-of-docker-effect-latency.html" target="_blank" rel="noopener">对延时敏感的应用是否应该使用 Docker?</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2015/12/14/does-amp-counter-an-existential-threat-to-google.html" target="_blank" rel="noopener">AMP（Accelerated Mobile Pages）的存在是对 Google 的威胁么?</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html" target="_blank" rel="noopener">360 度解读 Netflix 技术栈</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/latency-everywhere-and-it-costs-you-sales-how-crush-it" target="_blank" rel="noopener">延迟无处不在 - 如何搞定它？</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://martinfowler.com/articles/serverless.html" target="_blank" rel="noopener">无服务器架构</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances" target="_blank" rel="noopener">是什么驱动着 Instagram: 上百个实例、几十种技术</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html" target="_blank" rel="noopener">Cinchcast 架构 - 每天处理 1500 小时的音频</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html" target="_blank" rel="noopener">Justin.Tv 实时视频播放架构</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html" target="_blank" rel="noopener">Playfish’s 社交游戏架构 - 每月五千万用户增长</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html" target="_blank" rel="noopener">猫途鹰架构 - 40 万访客, 200 万动态页面访问, 30TB 数据</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/plentyoffish-architecture" target="_blank" rel="noopener">PlentyOfFish 架构</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html" target="_blank" rel="noopener">Salesforce 架构 - 如何扛住 13 亿日交易量</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html" target="_blank" rel="noopener">ESPN’s 架构扩展</a></li><li style="list-style: none"><input type="checkbox"> 下面 『消息、序列化和消息系统』部分的内容会提到什么样的技术能把各种服务整合到一起</li><li style="list-style: none"><input type="checkbox"> Twitter:<ul><li><a href="https://www.youtube.com/watch?v=5cKTP36HVgI" target="_blank" rel="noopener">O’Reilly MySQL CE 2011: Jeremy Cole, “Big and Small Data at @Twitter” (video)</a></li><li><a href="https://www.infoq.com/presentations/Twitter-Timeline-Scalability" target="_blank" rel="noopener">时间线的扩展</a></li></ul></li><li>更多内容可以查看视频部分的『大规模数据挖掘』视频系列。</li></ul></li><li style="list-style: none"><input type="checkbox"> 系统设计问题练习：下面有一些指导原则，每一个都有相关文档以及在现实中该如何处理。<ul><li>复习: <a href="http://www.hiredintech.com/system-design/" target="_blank" rel="noopener">HiredInTech 的系统设计</a></li><li><a href="https://github.com/jwasham/google-interview-university/blob/master/extras/cheat%20sheets/system-design.pdf" target="_blank" rel="noopener">cheat sheet</a></li><li>流程:<ol><li>理解问题和范围:<ul><li>在面试官的帮助下定义用例</li><li>提出附加功能的建议</li><li>去掉面试官认定范围以外的内容</li><li>假定高可用是必须的，而且要作为一个用例</li></ul></li><li>考虑约束:<ul><li>问一下每月请求量</li><li>问一下每秒请求量 (他们可能会主动提到或者让你算一下)</li><li>评估读写所占的百分比</li><li>评估的时候牢记 2/8 原则</li><li>每秒写多少数据</li><li>总的数据存储量要考虑超过 5 年的情况</li><li>每秒读多少数据</li></ul></li><li>抽象设计:<ul><li>分层 (服务, 数据, 缓存)</li><li>基础设施: 负载均衡, 消息</li><li>粗略的概括任何驱动整个服务的关键算法</li><li>考虑瓶颈并指出解决方案</li></ul></li></ol></li><li>练习:<ul><li><a href="http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&amp;context=compsci" target="_blank" rel="noopener">设计一个 CDN 网络</a></li><li><a href="https://blog.twitter.com/2010/announcing-snowflake" target="_blank" rel="noopener">设计一个随机唯一 ID 生成系统</a></li><li><a href="http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html" target="_blank" rel="noopener">设计一个在线多人卡牌游戏</a></li><li><a href="http://www.slideshare.net/dvirsky/introduction-to-redis" target="_blank" rel="noopener">设计一个 key-value 数据库</a></li><li><a href="https://icmi.cs.ucsb.edu/research/tech_reports/reports/2005-23.pdf" target="_blank" rel="noopener">设计一个函数获取过去某个时间段内前 K 个最高频访问的请求</a></li><li><a href="http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html" target="_blank" rel="noopener">设计一个图片分享系统</a></li><li><a href="http://ijcai13.org/files/tutorial_slides/td3.pdf" target="_blank" rel="noopener">设计一个推荐系统</a></li><li><a href="http://www.hiredintech.com/system-design/the-system-design-process/" target="_blank" rel="noopener">设计一个短域名生成系统</a></li><li><a href="https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/" target="_blank" rel="noopener">设计一个缓存系统</a></li></ul></li></ul></li></ul></li><li><h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><ul><li>有 Google 的论文和一些知名的论文.</li><li>你很可能实在没时间一篇篇完整的读完他们。我建议可以有选择的读其中一些论文里的核心部分。</li><li style="list-style: none"><input type="checkbox"> <a href="http://spinroot.com/courses/summer/Papers/hoare_1978.pdf" target="_blank" rel="noopener">1978: 通信顺序处理</a><ul><li><a href="https://godoc.org/github.com/thomas11/csp" target="_blank" rel="noopener">Go 实现</a></li><li><a href="https://www.cs.cmu.edu/~crary/819-f09/" target="_blank" rel="noopener">喜欢经典的论文?</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf" target="_blank" rel="noopener">2003: The Google 文件系统</a><ul><li>2012 年被 Colossus 取代了</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">2004: MapReduce: Simplified Data Processing on Large Clusters</a><ul><li>大多被云数据流取代了?</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.akkadia.org/drepper/cpumemory.pdf" target="_blank" rel="noopener">2007: 每个程序员都应该知道的内存知识 (非常长，作者建议跳过某些章节来阅读)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.wired.com/2012/07/google-colossus/" target="_blank" rel="noopener">2012: Google 的 Colossus</a><ul><li>没有论文</li></ul></li><li style="list-style: none"><input type="checkbox"> 2012: AddressSanitizer: 快速的内存访问检查器:<ul><li><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/37752.pdf" target="_blank" rel="noopener">论文</a></li><li><a href="https://www.usenix.org/conference/atc12/technical-sessions/presentation/serebryany" target="_blank" rel="noopener">视频</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 2013: Spanner: Google 的分布式数据库:<ul><li><a href="http://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf" target="_blank" rel="noopener">论文</a></li><li><a href="https://www.usenix.org/node/170855" target="_blank" rel="noopener">视频</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43146.pdf" target="_blank" rel="noopener">2014: Machine Learning: The High-Interest Credit Card of Technical Debt</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43790.pdf" target="_blank" rel="noopener">2015: Continuous Pipelines at Google</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44686.pdf" target="_blank" rel="noopener">2015: 大规模高可用: 构建 Google Ads 的数据基础设施</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://download.tensorflow.org/paper/whitepaper2015.pdf" target="_blank" rel="noopener">2015: TensorFlow: 异构分布式系统上的大规模机器学习</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43835.pdf" target="_blank" rel="noopener">2015: 开发者应该如何搜索代码：用例学习</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44843.pdf" target="_blank" rel="noopener">2016: Borg, Omega, and Kubernetes</a></li></ul></li><li><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>涵盖了:<ul><li>单元测试是如何工作的</li><li>什么是模拟对象</li><li>什么是集成测试</li><li>什么是依赖注入</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=SAhJf36_u5U" target="_blank" rel="noopener">James Bach 讲敏捷软件测试 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ILkT_HV9DVU" target="_blank" rel="noopener">James Bach 软件测试公开课 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://vimeo.com/83960706" target="_blank" rel="noopener">Steve Freeman - 测试驱动的开发 (video)</a><ul><li><a href="http://gotocon.com/dl/goto-berlin-2013/slides/SteveFreeman_TestDrivenDevelopmentThatsNotWhatWeMeant.pdf" target="_blank" rel="noopener">slides</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html" target="_blank" rel="noopener">测试驱动的开发已死。测试不朽。</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=z9quxZsLcfo" target="_blank" rel="noopener">测试驱动的开发已死? (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=nzJapzxH_rE&amp;list=PLAwxTw4SYaPkWVHeC_8aSIbSxE_NXI76g" target="_blank" rel="noopener">视频系列 (152 个) - 并不都是必须 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.obeythetestinggoat.com/pages/book.html#toc" target="_blank" rel="noopener">Python：测试驱动的 Web 开发</a></li><li style="list-style: none"><input type="checkbox"> 依赖注入:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=IKD2-MAkXyQ" target="_blank" rel="noopener">视频</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://jasonpolites.github.io/tao-of-testing/ch3-1.1.html" target="_blank" rel="noopener">测试之道</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://jasonpolites.github.io/tao-of-testing/ch4-1.1.html" target="_blank" rel="noopener">如何编写测试</a></li></ul></li><li><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><ul><li>在操作系统中是如何运作的</li><li>在操作系统部分的视频里有很多资料</li></ul></li><li><h3 id="实现系统例程"><a href="#实现系统例程" class="headerlink" title="实现系统例程"></a>实现系统例程</h3><ul><li>理解你使用的系统 API 底层有什么</li><li>你能自己实现它们么?</li></ul></li><li><h3 id="字符串搜索和操作"><a href="#字符串搜索和操作" class="headerlink" title="字符串搜索和操作"></a>字符串搜索和操作</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/tAfHI/search-pattern-in-text" target="_blank" rel="noopener">文本的搜索模式 (video)</a></li><li style="list-style: none"><input type="checkbox"> Rabin-Karp (videos):<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/c0Qkw/rabin-karps-algorithm" target="_blank" rel="noopener">Rabin Karps 算法</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/nYrc8/optimization-precomputation" target="_blank" rel="noopener">预先计算的优化</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/h4ZLc/optimization-implementation-and-analysis" target="_blank" rel="noopener">优化: 实现和分析</a></li><li><a href="https://www.youtube.com/watch?v=BRO7mVIFt08&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=9" target="_blank" rel="noopener">Table Doubling, Karp-Rabin</a></li><li><a href="https://www.youtube.com/watch?v=w6nuXg0BISo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=32" target="_blank" rel="noopener">滚动哈希</a></li></ul></li><li style="list-style: none"><input type="checkbox"> Knuth-Morris-Pratt (KMP) 算法:<ul><li><a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="noopener">Pratt 算法</a></li><li><a href="https://www.youtube.com/watch?v=2ogqPWJSftE" target="_blank" rel="noopener">教程: Knuth-Morris-Pratt (KMP) 字符串匹配算法</a></li></ul></li><li style="list-style: none"><input type="checkbox"> Boyer–Moore 字符串搜索算法<ul><li><a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm" target="_blank" rel="noopener">Boyer-Moore字符串搜索算法</a></li><li><a href="https://www.youtube.com/watch?v=QDZpzctPf10" target="_blank" rel="noopener">Boyer-Moore-Horspool 高级字符串搜索算法 (video)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-on-strings/home/week/1" target="_blank" rel="noopener">Coursera: 字符串的算法</a></li></ul></li></ul><hr><h2 id="终面"><a href="#终面" class="headerlink" title="终面"></a>终面</h2><pre><code>这一部分有一些短视频，你可以快速的观看和复习大多数重要概念。这对经常性的巩固很有帮助。</code></pre><h4 id="综述"><a href="#综述" class="headerlink" title="综述:"></a>综述:</h4><ul><li style="list-style: none"><input type="checkbox"> 2-3 分钟的短视频系列 (23 个)<ul><li><a href="https://www.youtube.com/watch?v=r4r1DZcx1cM&amp;list=PLmVb1OknmNJuC5POdcDv5oCS7_OUkDgpj&amp;index=22" target="_blank" rel="noopener">Videos</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 2-5 分钟的短视频系列 - Michael Sambol (18 个):<ul><li><a href="https://www.youtube.com/channel/UCzDJwLWoYCUQowF_nG3m5OQ" target="_blank" rel="noopener">Videos</a></li></ul></li></ul><h4 id="排序"><a href="#排序" class="headerlink" title="排序:"></a>排序:</h4><ul><li style="list-style: none"><input type="checkbox"> 归并排序: <a href="https://www.youtube.com/watch?v=GCae1WNvnZM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=GCae1WNvnZM</a></li></ul><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><h3 id="Google-Coaching-里提到的"><a href="#Google-Coaching-里提到的" class="headerlink" title="Google Coaching 里提到的"></a>Google Coaching 里提到的</h3><p><strong>阅读并做练习:</strong></p><ul><li><p>[ ] 算法设计手册 (Skiena)</p><ul><li>书 (Kindle 上可以租到):<ul><li><a href="http://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1849967202" target="_blank" rel="noopener">Algorithm Design Manual</a></li></ul></li><li>Half.com 是一个资源丰富且性价比很高的在线书店.</li><li>答案:<ul><li><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/The_Algorithms_Design_Manual_(Second_Edition" target="_blank" rel="noopener">解答</a>)</li><li><a href="http://blog.panictank.net/category/algorithmndesignmanualsolutions/page/2/" target="_blank" rel="noopener">解答</a></li></ul></li><li><p><a href="http://www3.cs.stonybrook.edu/~skiena/algorist/book/errata" target="_blank" rel="noopener">勘误表</a></p><p>read and do exercises from the books below. Then move to coding challenges (further down below)<br>一旦你理解了每日计划里的所有内容，就去读上面所列的书并完成练习，然后开始读下面所列的书并做练习，之后就可以开始实战写代码了（本文再往后的部分）</p></li></ul></li></ul><p><strong>首先阅读:</strong></p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-047012167X.html" target="_blank" rel="noopener">Programming Interviews Exposed: Secrets to Landing Your Next Job, 2nd Edition</a></li></ul><p><strong>然后阅读 (这本获得了很多推荐， 但是不在 Google coaching 的文档里):</strong></p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.amazon.com/Cracking-Coding-Interview-6th-Programming/dp/0984782850/" target="_blank" rel="noopener">Cracking the Coding Interview, 6th Edition</a><ul><li>如果你看到有人在看 “The Google Resume”, 实际上它和 “Cracking the Coding Interview” 是同一个作者写的，而且后者是升级版。</li></ul></li></ul><h3 id="附加书单"><a href="#附加书单" class="headerlink" title="附加书单"></a>附加书单</h3><p>这些没有被 Google 推荐阅读，不过我因为需要这些背景知识所以也把它们列在了这里。</p><ul><li><p>[ ] C Programming Language, Vol 2</p><ul><li><a href="https://github.com/lekkas/c-algorithms" target="_blank" rel="noopener">练习的答案</a></li></ul></li><li><p>[ ] C++ Primer Plus, 6th Edition</p></li><li><p>[ ] <a href="http://product.half.ebay.com/The-UNIX-Programming-Environment-by-Brian-W-Kernighan-and-Rob-Pike-1983-Other/54385&amp;tg=info" target="_blank" rel="noopener">《Unix 环境高级编程》 The Unix Programming Environment</a></p></li><li><p>[ ] <a href="http://www.amazon.com/Programming-Pearls-2nd-Jon-Bentley/dp/0201657880" target="_blank" rel="noopener">《编程珠玑》 Programming Pearls</a></p></li><li><p>[ ] <a href="http://www.amazon.com/Algorithms-Programming-Solutions-Alexander-Shen/dp/0817638474" target="_blank" rel="noopener">Algorithms and Programming: Problems and Solutions</a></p></li></ul><h3 id="如果你有时间"><a href="#如果你有时间" class="headerlink" title="如果你有时间"></a>如果你有时间</h3><ul><li><p>[ ] <a href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844" target="_blank" rel="noopener">Introduction to Algorithms</a></p></li><li><p>[ ] <a href="https://www.amazon.com/Elements-Programming-Interviews-Insiders-Guide/dp/1479274836" target="_blank" rel="noopener">Elements of Programming Interviews</a></p><ul><li>如果你希望在面试里用 C++ 写代码，这本书的代码全都是 C++ 写的</li><li>通常情况下能找到解决方案的好书.</li></ul></li></ul><h2 id="编码练习和挑战"><a href="#编码练习和挑战" class="headerlink" title="编码练习和挑战"></a>编码练习和挑战</h2><p>一旦你学会了理论基础，就应该把它们拿出来练练。<br>尽量坚持每天做编码练习，越多越好。</p><p>编程问题预备:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.hiredintech.com/algorithm-design/" target="_blank" rel="noopener">不错的介绍 (摘自 System Design 章节): 算法设计:</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/how-to-find-a-solution/" target="_blank" rel="noopener">如何找到解决方案</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/how-to-dissect-a-topcoder-problem-statement/" target="_blank" rel="noopener">如何剖析 Topcoder 题目描述</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/mathematics-for-topcoders/" target="_blank" rel="noopener">Topcoders 里用到的数学</a></li><li><p>[ ] <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/dynamic-programming-from-novice-to-advanced/" target="_blank" rel="noopener">动态规划 – 从入门到精通</a></p></li><li><p><a href="https://courses.csail.mit.edu/iap/interview/materials.php" target="_blank" rel="noopener">MIT 面试材料</a></p></li><li><p><a href="http://exercism.io/languages" target="_blank" rel="noopener">针对编程语言本身的练习</a></p></li></ul><p>编码练习平台:</p><ul><li><a href="https://leetcode.com/" target="_blank" rel="noopener">LeetCode</a></li><li><a href="https://www.topcoder.com/" target="_blank" rel="noopener">TopCoder</a></li><li><a href="https://projecteuler.net/index.php?section=problems" target="_blank" rel="noopener">Project Euler (数学方向为主)</a></li><li><a href="http://www.codewars.com" target="_blank" rel="noopener">Codewars</a></li><li><a href="https://www.hackerrank.com/" target="_blank" rel="noopener">HackerRank</a></li><li><a href="https://codility.com/programmers/" target="_blank" rel="noopener">Codility</a></li><li><a href="https://www.interviewcake.com/" target="_blank" rel="noopener">InterviewCake</a></li><li><p><a href="https://www.interviewbit.com/invite/icjf" target="_blank" rel="noopener">InterviewBit</a></p></li><li><p><a href="http://www.gainlo.co/" target="_blank" rel="noopener">模拟大公司的面试</a></p></li></ul><h2 id="当你临近面试时"><a href="#当你临近面试时" class="headerlink" title="当你临近面试时"></a>当你临近面试时</h2><ul><li style="list-style: none"><input type="checkbox"> 搞定代码面试 (videos):<ul><li><a href="https://www.youtube.com/watch?v=4NIb9l3imAo" target="_blank" rel="noopener">Cracking The Code Interview</a></li><li><a href="https://www.youtube.com/watch?v=Eg5-tdAwclo" target="_blank" rel="noopener">Cracking the Coding Interview - 全栈系列</a></li><li><a href="https://www.youtube.com/watch?v=1fqxMuPmGak" target="_blank" rel="noopener">Ask Me Anything: Gayle Laakmann McDowell (Cracking the Coding Interview 的作者)</a></li></ul></li></ul><h2 id="你的简历"><a href="#你的简历" class="headerlink" title="你的简历"></a>你的简历</h2><ul><li><a href="http://steve-yegge.blogspot.co.uk/2007_09_01_archive.html" target="_blank" rel="noopener">10 条小贴士让你写出一份还算不错的简历</a></li><li>这是搞定面试的第一个关键步骤</li></ul><h2 id="当面试来临的时候"><a href="#当面试来临的时候" class="headerlink" title="当面试来临的时候"></a>当面试来临的时候</h2><pre><code>随着下面列举的问题思考下你可能会遇到的 20 个面试问题每个问题准备 2-3 种回答准备点故事，不要只是摆一些你完成的事情的数据，相信我，人人都喜欢听故事</code></pre><ul><li>你为什么想得到这份工作？</li><li>你解决过的最有难度的问题是什么？</li><li>面对过的最大挑战是什么?</li><li>见过的最好或者最坏的设计是怎么样的?</li><li>对某项 Google 产品提出改进建议。</li><li>你作为一个个体同时也是团队的一员，如何达到最好的工作状态?</li><li>你的什么技能或者经验是你的角色中不可或缺的?为什么？</li><li>你在某份工作或某个项目中最享受的是什么?</li><li>你在某份工作或某个项目中面临过的最大挑战是什么?</li><li>你在某份工作或某个项目中遇到过的最蛋疼的 Bug 是什么样的？</li><li>你在某份工作或某个项目中学到了什么？</li><li>你在某份工作或某个项目中哪些地方还可以做的更好？</li></ul><h2 id="问面试官的问题"><a href="#问面试官的问题" class="headerlink" title="问面试官的问题"></a>问面试官的问题</h2><pre><code>我会问的一些：(可能我已经知道了答案但我想听听面试官的看法或者了解团队的前景):</code></pre><ul><li>团队多大规模?</li><li>开发周期是怎样的? 会使用瀑布流/极限编程/敏捷开发么?</li><li>经常会为 deadline 加班么? 或者是有弹性的?</li><li>团队里怎么做技术选型?</li><li>每周平均开多少次会?</li><li>你觉得工作环境有助于员工集中精力吗?</li><li>目前正在做什么工作?</li><li>喜欢这些事情吗?</li><li>工作期限是怎么样的?</li></ul><h2 id="当你获得了梦想的职位"><a href="#当你获得了梦想的职位" class="headerlink" title="当你获得了梦想的职位"></a>当你获得了梦想的职位</h2><p>我还能说些什么呢，恭喜你！</p><ul><li><a href="https://medium.com/@moonstorming/10-things-i-wish-i-knew-on-my-first-day-at-google-107581d87286#.livxn7clw" target="_blank" rel="noopener">我希望在 Google 的第一天就知道的 10 件事</a></li></ul><p>坚持继续学习。</p><p>得到这份工作只是一个开始。</p><hr><pre><code>**********************************************************************************************************************************************************************************************************下面的内容都是可选的。这些是我的推荐，不是 Google 的。通过学习这些内容，你将会得到更多的有关 CS 的概念，并将为所有的软件工程工作做更好的准备。**********************************************************************************************************************************************************************************************************</code></pre><hr><h2 id="附加的学习"><a href="#附加的学习" class="headerlink" title="附加的学习"></a>附加的学习</h2><ul><li><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.joelonsoftware.com/articles/Unicode.html" target="_blank" rel="noopener">每一个软件开发者的绝对最低限度，必须要知道的关于 Unicode 和字符集知识</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://kunststube.net/encoding/" target="_blank" rel="noopener">关于处理文本需要的编码和字符集, 每个程序员绝对需要知道的知识</a></li></ul></li><li><h3 id="字节顺序"><a href="#字节顺序" class="headerlink" title="字节顺序"></a>字节顺序</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html" target="_blank" rel="noopener">大、小端字节序</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=JrNF0KRAlyo" target="_blank" rel="noopener">大端字节 Vs 小端字节(视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=oBSuXP-1Tc0" target="_blank" rel="noopener">大、小端字节序的里里外外(Big And Little Endian Inside/Out) (视频)</a><ul><li>内核开发者的讨论非常技术性，如果大多数都超出了你的理解范围，不要太担心。</li><li>前半段已经足够了。</li></ul></li></ul></li><li><h3 id="Emacs-and-vi-m"><a href="#Emacs-and-vi-m" class="headerlink" title="Emacs and vi(m)"></a>Emacs and vi(m)</h3><ul><li>Yegge 的建议，从一个很早以前的亚马逊招聘信息中而来：熟悉基于 unix 的代码编辑器</li><li>vi(m):<ul><li><a href="https://www.youtube.com/watch?v=5givLEMcINQ&amp;index=1&amp;list=PL13bz4SHGmRxlZVmWQ9DvXo1fEg4UdGkr" target="_blank" rel="noopener">使用 vim 进行编辑 01 - 安装, 设置和模式 (视频)</a></li><li><a href="http://vim-adventures.com/" target="_blank" rel="noopener">VIM 的冒险之旅</a></li><li>4 个视频集:<ul><li><a href="https://www.youtube.com/watch?v=SI8TeVMX8pk" target="_blank" rel="noopener">vi/vim 编辑器 - 课程 1</a></li><li><a href="https://www.youtube.com/watch?v=F3OO7ZIOaJE" target="_blank" rel="noopener">vi/vim 编辑器 - 课程 2</a></li><li><a href="https://www.youtube.com/watch?v=1lYD5gwgZIA" target="_blank" rel="noopener">vi/vim 编辑器 - 课程 4</a></li><li><a href="https://www.youtube.com/watch?v=ZYEccA_nMaI" target="_blank" rel="noopener">vi/vim 编辑器 - 课程 3</a></li></ul></li><li><a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Using_Vi_instead_of_Emacs" target="_blank" rel="noopener">使用 Vi 而不是 Emacs</a></li></ul></li><li>emacs:<ul><li><a href="https://www.youtube.com/watch?v=hbmV1bnQ-i0" target="_blank" rel="noopener">基础 Emacs 教程 (视频)</a></li><li>3 个视频集:<ul><li><a href="https://www.youtube.com/watch?v=ujODL7MD04Q" target="_blank" rel="noopener">Emacs 教程 (初学者) -第 1 部分- 文件命令, 剪切/复制/粘贴,  自定义命令</a></li><li><a href="https://www.youtube.com/watch?v=XWpsRupJ4II" target="_blank" rel="noopener">Emacs 教程 (初学者 -第 2 部分- Buffer 管理, 搜索, M-x grep 和 rgrep 模式</a></li><li><a href="https://www.youtube.com/watch?v=paSgzPso-yc" target="_blank" rel="noopener">Emacs 教程 (初学者 -第 3 部分- 表达式, 声明, ~/.emacs 文件和包机制</a></li></ul></li><li><a href="https://www.youtube.com/watch?v=JWD1Fpdd4Pc" target="_blank" rel="noopener">Evil 模式: 或许, 我是怎样对 Emacs 路人转粉的 (视频)</a></li><li><a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Writing_C_programs_with_Emacs" target="_blank" rel="noopener">使用 Emacs 开发 C 程序</a></li><li><a href="https://www.youtube.com/watch?v=nsGYet02bEk" target="_blank" rel="noopener">(或许) 深度组织模式:管理结构 (视频)</a></li></ul></li></ul></li><li><h3 id="Unix-命令行工具"><a href="#Unix-命令行工具" class="headerlink" title="Unix 命令行工具"></a>Unix 命令行工具</h3><ul><li>下列内容中的优秀工具由的 Yegge 推荐，Yegge 目前致力于 Amazon 人事招聘处。</li><li style="list-style: none"><input type="checkbox"> bash</li><li style="list-style: none"><input type="checkbox"> cat</li><li style="list-style: none"><input type="checkbox"> grep</li><li style="list-style: none"><input type="checkbox"> sed</li><li style="list-style: none"><input type="checkbox"> awk</li><li style="list-style: none"><input type="checkbox"> curl or wget</li><li style="list-style: none"><input type="checkbox"> sort</li><li style="list-style: none"><input type="checkbox"> tr</li><li style="list-style: none"><input type="checkbox"> uniq</li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Strace" target="_blank" rel="noopener">strace</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://danielmiessler.com/study/tcpdump/" target="_blank" rel="noopener">tcpdump</a></li></ul></li><li><h3 id="信息资源-视频"><a href="#信息资源-视频" class="headerlink" title="信息资源 (视频)"></a>信息资源 (视频)</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.khanacademy.org/computing/computer-science/informationtheory" target="_blank" rel="noopener">Khan Academy 可汗学院</a></li><li style="list-style: none"><input type="checkbox"> 更多有关马尔可夫的内容:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/waxgx/core-markov-text-generation" target="_blank" rel="noopener">Core Markov Text Generation马尔可夫内容生成</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/gZhiC/core-implementing-markov-text-generation" target="_blank" rel="noopener">Core Implementing Markov Text Generation马尔可夫内容生成补充</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/EUjrq/project-markov-text-generation-walk-through" target="_blank" rel="noopener">Project = Markov Text Generation Walk Through一个马尔可夫内容生成器的项目</a></li></ul></li><li>关于更多信息，请参照下方 MIT 6.050J 信息和系统复杂度的内容.</li></ul></li><li><h3 id="奇偶校验位-amp-汉明码-视频"><a href="#奇偶校验位-amp-汉明码-视频" class="headerlink" title="奇偶校验位 &amp; 汉明码 (视频)"></a>奇偶校验位 &amp; 汉明码 (视频)</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=q-3BctoUpHE" target="_blank" rel="noopener">入门</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=DdMcAUlxh1M" target="_blank" rel="noopener">奇偶校验位</a></li><li style="list-style: none"><input type="checkbox"> 汉明码(Hamming Code):<ul><li><a href="https://www.youtube.com/watch?v=1A_NcXxdoCc" target="_blank" rel="noopener">发现错误</a></li><li><a href="https://www.youtube.com/watch?v=JAMLuxdHH8o" target="_blank" rel="noopener">修正错误</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=wbH2VxzmoZk" target="_blank" rel="noopener">检查错误</a></li></ul></li><li><h3 id="系统熵值（系统复杂度）"><a href="#系统熵值（系统复杂度）" class="headerlink" title="系统熵值（系统复杂度）"></a>系统熵值（系统复杂度）</h3><ul><li>请参考下方视频</li><li>观看之前，请先确定观看了信息论的视频</li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/JnJq3Py0dyM?t=176" target="_blank" rel="noopener">信息理论, 克劳德·香农, 熵值, 系统冗余, 数据比特压缩 (视频)</a></li></ul></li><li><h3 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h3><ul><li>请参考下方视频</li><li>观看之前，请先确定观看了信息论的视频</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.khanacademy.org/computing/computer-science/密码学" target="_blank" rel="noopener">可汗学院</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=KqqOXndnvic&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=30" target="_blank" rel="noopener">密码学: 哈希函数</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=9TNI2wHmaeI&amp;index=31&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">密码学: 加密</a></li></ul></li><li><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul><li>观看之前，请先确定观看了信息论的视频</li><li style="list-style: none"><input type="checkbox"> 压缩 (视频):<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Lto-ajuqW3w" target="_blank" rel="noopener">压缩</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=M5c_RFKVkko" target="_blank" rel="noopener">压缩熵值</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=umTbivyJoiI" target="_blank" rel="noopener">由上而下的树 (霍夫曼编码树)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=DV8efuB3h2g" target="_blank" rel="noopener">额外比特 - 霍夫曼编码树</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=goOa3DGezUA" target="_blank" rel="noopener">优雅的压缩数据 (无损数据压缩方法)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=cCDCfoHTsaU" target="_blank" rel="noopener">Text Compression Meets Probabilities</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIJGErt5rrCqaSGTMyyqNt2H" target="_blank" rel="noopener">数据压缩的艺术</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=whGwm0Lky2s" target="_blank" rel="noopener">(可选) 谷歌开发者: GZIP 还差远了呢!</a></li></ul></li><li><h3 id="网络-视频"><a href="#网络-视频" class="headerlink" title="网络 (视频)"></a>网络 (视频)</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.khanacademy.org/computing/computer-science/internet-intro" target="_blank" rel="noopener">可汗学院</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Vdc8TCESIg8" target="_blank" rel="noopener">网络传输协议中的数据压缩</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=e5DEVa9eSN0" target="_blank" rel="noopener">TCP/IP 和 OSI 模型解析!</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=nomyRJehhnM" target="_blank" rel="noopener">TCP/IP 教程：传输数据包.</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=WGJrLqtX7As" target="_blank" rel="noopener">HTTP</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=S2iBR2ZlZf0" target="_blank" rel="noopener">SSL 和 HTTPS</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Rp3iZUvXWlM" target="_blank" rel="noopener">SSL/TLS</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=E9FxNzv1Tr8" target="_blank" rel="noopener">HTTP 2.0</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLEbnTDJUr_IegfoqO4iPnPYQui46QqT0j" target="_blank" rel="noopener">视频</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=t5xYI0jzOf4" target="_blank" rel="noopener">子网络解密 - 第五部分 经典内部域名指向 CIDR 标记</a></li></ul></li><li><h3 id="计算机安全"><a href="#计算机安全" class="headerlink" title="计算机安全"></a>计算机安全</h3><ul><li><a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">MIT</a><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=GqmQg-cszw4&amp;index=1&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">威胁模型：入门</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=6bwzNg5qQ0o&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&amp;index=2" target="_blank" rel="noopener">控制攻击</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=drQyrzRoRiA&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&amp;index=3" target="_blank" rel="noopener">缓冲数据注入和防御</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=6SIJmoE9L9g&amp;index=4&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">优先权区分</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=8VqTSY-11F4&amp;index=5&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">能力</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=VEV74hwASeU&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&amp;index=6" target="_blank" rel="noopener">在沙盒中运行原生代码</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=chkFBigodIw&amp;index=7&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">网络安全模型</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=EBQIGy1ROLY&amp;index=8&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">网络安全应用</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=yRVZPvHYHzw&amp;index=9&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">标志化执行</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=SIEVvk3NVuk&amp;index=11&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">网络安全</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=QOtA76ga_fY&amp;index=12&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">网络协议</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=PuVMkSEcPiI&amp;index=15&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">旁路攻击</a></li></ul></li></ul></li><li><h3 id="释放缓存"><a href="#释放缓存" class="headerlink" title="释放缓存"></a>释放缓存</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=StdfeXaKGEc&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=25" target="_blank" rel="noopener">Java 释放缓存; 片段化数据 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLO9y7hOkmmSGTy5z6HZ-W4k2y8WXF7Bff" target="_blank" rel="noopener">编译器 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=iHVs_HkjdmI" target="_blank" rel="noopener">Python 释放缓存 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.infoq.com/presentations/garbage-collection-benefits" target="_blank" rel="noopener">深度解析：论释放缓存在 JAVA 中的重要性</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=P-8Z0-MhdQs&amp;list=PLdzf4Clw0VbOEWOS_sLhT_9zaiQDrS5AR&amp;index=3" target="_blank" rel="noopener">深度解析：论释放缓存在 Python 中的重要性(视频)</a></li></ul></li><li><h3 id="并行-并发编程"><a href="#并行-并发编程" class="headerlink" title="并行/并发编程"></a>并行/并发编程</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/parprog1/home/week/1" target="_blank" rel="noopener">Coursera (Scala)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=uY85GkaYzBk" target="_blank" rel="noopener">论并行/并发编程如何提高 Python 执行效率 (视频)</a></li></ul></li><li><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=3cmzqZzwNDM&amp;list=PLGLfVvz_LVvQ5G-LdJ8RLqe-ndo7QITYc&amp;index=3" target="_blank" rel="noopener">UML统一建模语言概览 (视频)</a></li><li style="list-style: none"><input type="checkbox"> 主要有如下的设计模式:<ul><li style="list-style: none"><input type="checkbox"> s(strategy)</li><li style="list-style: none"><input type="checkbox"> singleton</li><li style="list-style: none"><input type="checkbox"> adapter</li><li style="list-style: none"><input type="checkbox"> prototype</li><li style="list-style: none"><input type="checkbox"> decorator</li><li style="list-style: none"><input type="checkbox"> visitor</li><li style="list-style: none"><input type="checkbox"> factory, abstract factory</li><li style="list-style: none"><input type="checkbox"> facade</li><li style="list-style: none"><input type="checkbox"> observer</li><li style="list-style: none"><input type="checkbox"> proxy</li><li style="list-style: none"><input type="checkbox"> delegate</li><li style="list-style: none"><input type="checkbox"> command</li><li style="list-style: none"><input type="checkbox"> state</li><li style="list-style: none"><input type="checkbox"> memento</li><li style="list-style: none"><input type="checkbox"> iterator</li><li style="list-style: none"><input type="checkbox"> composite</li><li style="list-style: none"><input type="checkbox"> flyweight</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/LAP2A80Ajrg?list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO&amp;t=3344" target="_blank" rel="noopener">第六章 (第 1 部分 ) - 设计模式 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=U8-PGsjvZc4&amp;index=12&amp;list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO" target="_blank" rel="noopener">第六章 (第 2 部分 ) - Abstraction-Occurrence, General Hierarchy, Player-Role, Singleton, Observer, Delegation (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=7sduBHuex4c&amp;index=13&amp;list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO" target="_blank" rel="noopener">第六章 (第 3 部分 ) - Adapter, Facade, Immutable, Read-Only Interface, Proxy (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLF206E906175C7E07" target="_blank" rel="noopener">视频</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.amazon.com/Head-First-Design-Patterns-Freeman/dp/0596007124" target="_blank" rel="noopener">Head First 设计模型</a><ul><li>尽管这本书叫做设计模式：重复使用模块，但是我还是认为Head First是对于新手来说很不错的书。</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://sourcemaking.com/design-patterns-and-tips" target="_blank" rel="noopener">基于实际操作对于入门开发者的建议</a></li></ul></li><li><h3 id="信息传输-序列化-和队列化的系统"><a href="#信息传输-序列化-和队列化的系统" class="headerlink" title="信息传输, 序列化,和队列化的系统"></a>信息传输, 序列化,和队列化的系统</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://thrift.apache.org/" target="_blank" rel="noopener">Thrift</a><ul><li><a href="http://thrift-tutorial.readthedocs.io/en/latest/intro.html" target="_blank" rel="noopener">教程</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">协议缓冲</a><ul><li><a href="https://developers.google.com/protocol-buffers/docs/tutorials" target="_blank" rel="noopener">教程</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.grpc.io/" target="_blank" rel="noopener">gRPC</a><ul><li><a href="https://www.youtube.com/watch?v=5tmPvSe7xXQ&amp;list=PLcTqM9n_dieN0k1nSeN36Z_ppKnvMJoly&amp;index=1" target="_blank" rel="noopener">gRPC 对于JAVA开发者的入门教程（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://redis.io/" target="_blank" rel="noopener">Redis</a><ul><li><a href="http://try.redis.io/" target="_blank" rel="noopener">教程</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://aws.amazon.com/sqs/" target="_blank" rel="noopener">Amazon的 SQS 系统 (队列)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://aws.amazon.com/sns/" target="_blank" rel="noopener">Amazon的 SNS 系统 (pub-sub)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a><ul><li><a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">入门教程</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.celeryproject.org/" target="_blank" rel="noopener">Celery</a><ul><li><a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html" target="_blank" rel="noopener">Celery入门</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://zeromq.org/" target="_blank" rel="noopener">ZeroMQ</a><ul><li><a href="http://zeromq.org/intro:read-the-manual" target="_blank" rel="noopener">入门教程</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://activemq.apache.org/" target="_blank" rel="noopener">ActiveMQ</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://kafka.apache.org/documentation.html#introduction" target="_blank" rel="noopener">Kafka</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://msgpack.org/index.html" target="_blank" rel="noopener">MessagePack</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://avro.apache.org/" target="_blank" rel="noopener">Avro</a></li></ul></li><li><h3 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.askamathematician.com/2012/09/q-what-is-a-fourier-transform-what-is-it-used-for/" target="_blank" rel="noopener">什么是傅立叶变换？论傅立叶变换的用途</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Xxut2PN-V8Q" target="_blank" rel="noopener">什么是傅立叶变换？ (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=iTMn0Kt18tg&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=4" target="_blank" rel="noopener">关于 FFT 的不同观点 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://jakevdp.github.io/blog/2013/08/28/understanding-the-fft/" target="_blank" rel="noopener">FTT 是什么</a></li></ul></li><li><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><ul><li>给一个布隆过滤器m比特和k个哈希函数，所有的注入和相关测试都会是通过。</li><li><a href="https://www.youtube.com/watch?v=-SuTGoFYjZs" target="_blank" rel="noopener">布隆过滤器</a></li><li><a href="https://www.youtube.com/watch?v=qBTdukbzc78" target="_blank" rel="noopener">布隆过滤器 | 数据挖掘 | Stanford University</a></li><li><a href="http://billmill.org/bloomfilter-tutorial/" target="_blank" rel="noopener">教程</a></li><li><a href="http://blog.michaelschmatz.com/2016/04/11/how-to-write-a-bloom-filter-cpp/" target="_blank" rel="noopener">如何写一个布隆过滤器应用</a></li></ul></li><li><h3 id="van-Emde-Boas-树"><a href="#van-Emde-Boas-树" class="headerlink" title="van Emde Boas 树"></a>van Emde Boas 树</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=hmReJCupbNU&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=6" target="_blank" rel="noopener">争论: van Emde Boas 树 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2012/lecture-notes/MIT6_046JS12_lec15.pdf" target="_blank" rel="noopener">MIT课堂笔记</a></li></ul></li><li><h3 id="更深入的数据结构"><a href="#更深入的数据结构" class="headerlink" title="更深入的数据结构"></a>更深入的数据结构</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/zksIj9O8_jc?list=PL4BBB74C7D2A1049C&amp;t=950" target="_blank" rel="noopener">CS 61B 第 39 课: 更深入的数据结构</a></li></ul></li><li><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><ul><li>“有一种非常迷幻的数据类型” - Skiena</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2g9OSRKJuzM&amp;index=10&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">随机化: 跳表 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Skip_list" target="_blank" rel="noopener">更生动详细的解释</a></li></ul></li><li><h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=v1VgJmkEJW0" target="_blank" rel="noopener">5分钟简析Ford-Fulkerson (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=v1VgJmkEJW0" target="_blank" rel="noopener">Ford-Fulkerson 算法 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2vhN4Ice5jI" target="_blank" rel="noopener">网络流 (视频)</a></li></ul></li><li><h3 id="不相交集-amp-联合查找"><a href="#不相交集-amp-联合查找" class="headerlink" title="不相交集 &amp; 联合查找"></a>不相交集 &amp; 联合查找</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank" rel="noopener">不相交集</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=MAEGXTwmUsI&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=21" target="_blank" rel="noopener">UCB 61B - 不相交集; 排序 &amp; 选择(视频)</a></li><li style="list-style: none"><input type="checkbox"> Coursera (not needed since the above video explains it great):<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/JssSY/overview" target="_blank" rel="noopener">概览</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/EM5D0/naive-implementations" target="_blank" rel="noopener">初级实践</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/Mxu0w/trees" target="_blank" rel="noopener">树状结构</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/qb4c2/union-by-rank" target="_blank" rel="noopener">合并树状结构</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/Q9CVI/path-compression" target="_blank" rel="noopener">路径压缩</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/GQQLN/analysis-optional" target="_blank" rel="noopener">分析选项</a></li></ul></li></ul></li><li><h3 id="快速处理数学"><a href="#快速处理数学" class="headerlink" title="快速处理数学"></a>快速处理数学</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=eCaXlAaN2uE&amp;index=11&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">整数运算, Karatsuba 乘法 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ru7mWZJlRQg" target="_blank" rel="noopener">中国剩余定理 (在密码学中的使用) (视频)</a></li></ul></li><li><h3 id="树堆-Treap"><a href="#树堆-Treap" class="headerlink" title="树堆 (Treap)"></a>树堆 (Treap)</h3><ul><li>一个二叉搜索树和一个堆的组合</li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Treap" target="_blank" rel="noopener">树堆</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=6podLUYinH8" target="_blank" rel="noopener">数据结构：树堆的讲解(video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.cs.cmu.edu/~scandal/papers/treaps-spaa98.pdf" target="_blank" rel="noopener">集合操作的应用(Applications in set operations)</a></li></ul></li><li><h3 id="线性规划（Linear-Programming）（视频）"><a href="#线性规划（Linear-Programming）（视频）" class="headerlink" title="线性规划（Linear Programming）（视频）"></a>线性规划（Linear Programming）（视频）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=M4K6HYLHREQ" target="_blank" rel="noopener">线性规划</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2ACJ9ewUC6U" target="_blank" rel="noopener">寻找最小成本</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=8AA_81xI3ik" target="_blank" rel="noopener">寻找最大值</a></li></ul></li><li><h3 id="几何：凸包（Geometry-Convex-hull）（视频）"><a href="#几何：凸包（Geometry-Convex-hull）（视频）" class="headerlink" title="几何：凸包（Geometry, Convex hull）（视频）"></a>几何：凸包（Geometry, Convex hull）（视频）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/XIAQRlNkJAw?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3164" target="_blank" rel="noopener">Graph Alg. IV: 几何算法介绍 - 第 9 课</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=J5aJEcOr6Eo&amp;index=10&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="noopener">Graham &amp; Jarvis: 几何算法 - 第 10 课</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=EzeYI7p9MjU&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=2" target="_blank" rel="noopener">Divide &amp; Conquer: 凸包, 中值查找</a></li></ul></li><li><h3 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h3><ul><li>查看下面的视频：(这里没看到视频= =）</li></ul></li><li><h3 id="机器学习（Machine-Learning）"><a href="#机器学习（Machine-Learning）" class="headerlink" title="机器学习（Machine Learning）"></a>机器学习（Machine Learning）</h3><ul><li style="list-style: none"><input type="checkbox"> 为什么学习机器学习？<ul><li style="list-style: none"><input type="checkbox"> <a href="https://backchannel.com/how-google-is-remaking-itself-as-a-machine-learning-first-company-ada63defcb70" target="_blank" rel="noopener">谷歌如何将自己改造成一家「机器学习优先」公司？</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=QSaZGT4-6EY" target="_blank" rel="noopener">智能计算机系统的大规模深度学习 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=X769cyzBNVw" target="_blank" rel="noopener">Peter Norvig：深度学习和理解与软件工程和验证的对比</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Ja2hxBAwG_0" target="_blank" rel="noopener">谷歌云机器学习工具（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIIuiBfYad6rFYQU_jL2ryal" target="_blank" rel="noopener">谷歌开发者机器学习清单 (Scikit Learn 和 Tensorflow) (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=oZikw5k_2FM" target="_blank" rel="noopener">Tensorflow (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.tensorflow.org/versions/r0.11/tutorials/index.html" target="_blank" rel="noopener">Tensorflow 教程</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.analyticsvidhya.com/blog/2016/04/neural-networks-python-theano/" target="_blank" rel="noopener">Python 实现神经网络实例教程（使用 Theano）</a></li><li>课程:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">很棒的初级课程：机器学习</a><pre><code>- [视频教程](https://www.youtube.com/playlist?list=PLZ9qNFMHZ-A4rycgrgOYma6zxF4BZGGPW)- 看第 12-18 集复习线性代数（第 14 集和第 15 集是重复的）</code></pre></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/neural-networks" target="_blank" rel="noopener">机器学习中的神经网络</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.udacity.com/course/deep-learning--ud730" target="_blank" rel="noopener">Google 深度学习微学位</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.udacity.com/course/machine-learning-engineer-nanodegree-by-google--nd009" target="_blank" rel="noopener">Google/Kaggle 机器学习工程师微学位</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.udacity.com/drive" target="_blank" rel="noopener">无人驾驶工程师微学位</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.thisismetis.com/explore-data-science" target="_blank" rel="noopener">Metis 在线课程 (两个月 99 美元)</a></li></ul></li><li>资源:<ul><li>书籍: Data Science from Scratch: First Principles with Python: <a href="https://www.amazon.com/Data-Science-Scratch-Principles-Python/dp/149190142X" target="_blank" rel="noopener">https://www.amazon.com/Data-Science-Scratch-Principles-Python/dp/149190142X</a></li><li>网站: Data School: <a href="http://www.dataschool.io/" target="_blank" rel="noopener">http://www.dataschool.io/</a></li></ul></li></ul></li><li><h3 id="Go-语言"><a href="#Go-语言" class="headerlink" title="Go 语言"></a>Go 语言</h3><ul><li style="list-style: none"><input type="checkbox"> 视频:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=FTl0tl9BGdc" target="_blank" rel="noopener">为什么学习 Go 语言？</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=CF9S4QZuV30" target="_blank" rel="noopener">Go 语言编程</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ytEkHepK08c" target="_blank" rel="noopener">Go 语言之旅</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 书籍:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.golang-book.com/books/intro" target="_blank" rel="noopener">Go 语言编程入门 (免费在线阅读)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440" target="_blank" rel="noopener">Go 语言圣经 (Donovan &amp; Kernighan)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.golang-book.com/guides/bootcamp" target="_blank" rel="noopener">Go 语言新手训练营</a></li></ul></li></ul><p>–</p><h2 id="一些主题的额外内容"><a href="#一些主题的额外内容" class="headerlink" title="一些主题的额外内容"></a>一些主题的额外内容</h2><pre><code>我为前面提到的某些主题增加了一些额外的内容，之所以没有直接添加到前面，是因为这样很容易导致某个主题内容过多。毕竟你想在本世纪找到一份工作，对吧？</code></pre><ul><li><p>[ ] <strong>动态规划的更多内容</strong> (视频)</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=OQ5jsbhAv_M&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=19" target="_blank" rel="noopener">6.006: 动态规划 I: 斐波那契数列, 最短路径</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ENyox7kNKeY&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=20" target="_blank" rel="noopener">6.006: 动态规划 II: 文本匹配, 二十一点/黑杰克</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ocZMDMZwhCY&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=21" target="_blank" rel="noopener">6.006: 动态规划 III: 最优加括号方式, 最小编辑距离, 背包问题</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=tp4_UXaVyx8&amp;index=22&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">6.006: 动态规划 IV: 吉他指法，拓扑，超级马里奥.</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Tw1k46ywN6E&amp;index=14&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">6.046: 动态规划: 动态规划进阶</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=NzgFUwOaoIw&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=15" target="_blank" rel="noopener">6.046: 动态规划: 所有点对最短路径</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=krZI60lKPek&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=12" target="_blank" rel="noopener">6.046: 动态规划: 更多示例</a></li></ul></li><li><p>[ ] <strong>图形处理进阶</strong> (视频)</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=mUBmcbbJNf4&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=27" target="_blank" rel="noopener">异步分布式算法: 对称性破缺，最小生成树</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=kQ-UQAzcnzA&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=28" target="_blank" rel="noopener">异步分布式算法: 最小生成树</a></li></ul></li><li><p>[ ] MIT <strong>概率论</strong> (mathy, and go slowly, which is good for mathy things) (视频):</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=SmFwFdESMHI&amp;index=18&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 概率论概述</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=E6FbvM-FGZ8&amp;index=19&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 条件概率 Probability</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=l1BCv3qqW4A&amp;index=20&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 独立</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=MOfhhFaQdjw&amp;list=PLB7540DEDD482705B&amp;index=21" target="_blank" rel="noopener">MIT 6.042J - 随机变量</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=gGlMSe7uEkA&amp;index=22&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 期望 I</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=oI9fMUqgfxY&amp;index=23&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 期望 II</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=q4mwO2qS2z4&amp;index=24&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 大偏差</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=56iFMY8QW2k&amp;list=PLB7540DEDD482705B&amp;index=25" target="_blank" rel="noopener">MIT 6.042J - 随机游走</a></li></ul></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=oDniZCmNmNw&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=19" target="_blank" rel="noopener">Simonson: 近似算法 (视频)</a></p></li></ul><h2 id="视频系列"><a href="#视频系列" class="headerlink" title="视频系列"></a>视频系列</h2><p> 坐下来享受一下吧。”netflix and skill” :P</p><ul><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr" target="_blank" rel="noopener">个人的动态规划问题列表 (都是短视频哟)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL038BE01D3BAEFDB0" target="_blank" rel="noopener">x86 架构，汇编，应用程序 (11 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLE7DDD91010BC51F8" target="_blank" rel="noopener">MIT 18.06 线性代数，2005 年春季 (35 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL3B08AE665AB9002A" target="_blank" rel="noopener">绝妙的 MIT 微积分：单变量微积分</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL-XXv-cvA_iD8wQm8U0gG_Z1uHjImKXFy" target="_blank" rel="noopener">计算机科学 70, 001 - 2015 年春季 - 离散数学和概率理论</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL3o9D4Dl2FJ9q0_gtFXPh_H4POI5dK0yG" target="_blank" rel="noopener">离散数学 (19 个视频)</a></p></li><li><p>[ ] CSE373 - 算法分析 (25 个视频)</p><ul><li><a href="https://www.youtube.com/watch?v=ZFjhkohHdAA&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=1" target="_blank" rel="noopener">Skiena 的算法设计手册讲座</a></li></ul></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=mFPmKGIrQs4&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd" target="_blank" rel="noopener">UC Berkeley 61B (2014 年春季): 数据结构 (25 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL4BBB74C7D2A1049C" target="_blank" rel="noopener">UC Berkeley 61B (2006 年秋季): 数据结构 (39 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=gJJeUFyuvvg&amp;list=PL-XXv-cvA_iCl2-D-FS5mk0jFF6cYSJs_" target="_blank" rel="noopener">UC Berkeley 61C: 计算机结构 (26 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO" target="_blank" rel="noopener">OOSE: 使用 UML 和 Java 进行软件开发 (21 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=UH0QYvtP7Rk&amp;index=20&amp;list=PLkFD6_40KJIwEiwQx1dACXwh-2Fuo32qr" target="_blank" rel="noopener">UC Berkeley CS 152: 计算机结构和工程 (20 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-" target="_blank" rel="noopener">MIT 6.004: 计算结构 (49 视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL5PHm2jkkXmi5CxxI7b3JCL1TWybTDtKq" target="_blank" rel="noopener">卡內基梅隆大学 - 计算机架构讲座 (39 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=HtSuA80QTyo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;nohtml5=False" target="_blank" rel="noopener">MIT 6.006: 算法介绍 (47 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=zm2VP0kHl1M&amp;list=PL6535748F59DCA484" target="_blank" rel="noopener">MIT 6.033: 计算机系统工程 (22 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP63gFHB6xb-kVBiQHYe_4hSi" target="_blank" rel="noopener">MIT 6.034 人工智能, 2010 年秋季 (30 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=L3LMbpZIKhQ&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J: 计算机科学数学, 2010 年秋季 (25 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=2P-yW7LQr08&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">MIT 6.046: 算法设计与分析 (34 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=phxsQrZQupo&amp;list=PL_2Bwul6T-A7OldmhGODImZL8KEVE38X7" target="_blank" rel="noopener">MIT 6.050J: 信息和熵, 2008 年春季 (19 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=T0yzrZL1py0&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&amp;index=1" target="_blank" rel="noopener">MIT 6.851: 高等数据结构 (22 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL6ogFv-ieghdoGKGg2Bik3Gl1glBTEu8c" target="_blank" rel="noopener">MIT 6.854: 高等算法, 2016 年春季 (24 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=GqmQg-cszw4&amp;index=1&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">MIT 6.858计算机系统安全, 2014 年秋季</a></p></li><li><p>[ ] 斯坦福: 编程范例 (17 个视频)</p><ul><li><a href="https://www.youtube.com/watch?v=jTSvthW34GU&amp;list=PLC0B8B318B7394B6F&amp;nohtml5=False" target="_blank" rel="noopener">C 和 C++ 课程</a></li></ul></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=2aHkqB2-46k&amp;feature=youtu.be" target="_blank" rel="noopener">密码学导论</a></p><ul><li><a href="https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg" target="_blank" rel="noopener">本系列更多内容 (不分先后顺序)</a></li></ul></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLLssT5z_DsK9JDLcT8T62VtzwyW9LNepV" target="_blank" rel="noopener">大数据 - 斯坦福大学 (94 个视频)</a></p></li></ul><h2 id="计算机科学课程"><a href="#计算机科学课程" class="headerlink" title="计算机科学课程"></a>计算机科学课程</h2><ul><li><a href="https://github.com/open-source-society/computer-science" target="_blank" rel="noopener"> 在线 CS 课程目录 </a></li><li><a href="https://github.com/prakhar1989/awesome-courses" target="_blank" rel="noopener">CS 课程目录 (一些是在线讲座)</a></li></ul>]]></content>
      
      <categories>
          
          <category> 译文集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>技术书单系列1</title>
      <link href="/%E9%9A%8F%E7%AC%94/%E6%8A%80%E6%9C%AF%E4%B9%A6%E5%8D%95%E7%B3%BB%E5%88%971/"/>
      <url>/%E9%9A%8F%E7%AC%94/%E6%8A%80%E6%9C%AF%E4%B9%A6%E5%8D%95%E7%B3%BB%E5%88%971/</url>
      <content type="html"><![CDATA[<h1 id="我眼中的阅读"><a href="#我眼中的阅读" class="headerlink" title="我眼中的阅读"></a>我眼中的阅读</h1><p>有这么一句话：看一个人，只需看他读什么书，与什么交往。</p><p>但不知为什么，估计是我的社交圈太小的原因吧，大学里面认识的同学，目前没有几个是真正热爱阅读的，不论是带有功利性质的技能书还是休闲性质的杂书。注意，我没有过分强调读书的功利作用，我从不认为不读书的人就怎么怎么没素养，不读书就不能有大的作为。很多时候这也不过是一种爱好，一种消磨时间的途径而已。所以爱读书的也不必故作清高，但不爱读书的，也请将你的读书无用论收一收，不读书的一个巨大遗憾就是让你们产生了这样的眼界。</p><p>对我来说，书的魅力是巨大的，起初和很多人一样，一看到书就头疼，会有种读不下去的感觉，尤其是面对一些字典般大小的恐龙书。因此很多时候，读书也得讲策略，不是任何一本书都得一字一句的啃下去，有选择有针对性的扩展广度，当发现一本内容精致的好书在一遍遍精读也不迟。这里又提到了选书的问题，其实人这一生，你再怎么努力，能读的书终究是有限的，因此选择成了至关重要的一环，门外汉建议还是根据口碑选择较为靠谱，数年积累的业内口碑一般都不是没有理由的，经典之所以能成为经典，必然是经过一代代人的筛选与淘汰留下的宝藏。</p><p>说起自己，倒也误区多多，一方面，关于买书，我明显对技术书籍有了歧视，至今我买的纸质书里面，大多以古今中外文学名著小说诗歌居多，然而技术书却是能用指头就点的过来的寥寥几本。其中，我可能嫌一些技术书价格过高，网上的pdf版本一搜一大把，何苦花这冤枉钱。但后面意识到，很多技术书却是值这个价，内容对一些原理和思维剖析深刻到位，总之纸质书的阅读感很多时候还是电子书无法取代的。我目前两种媒介都不拒绝，大多时候不方便的话，kindle带在身边就是了，方便的话，翻开纸质书就是撸。另外，在读书笔记方面我做的也是有很大欠缺的，一本书读完，或者一部电影看完，只要不是内容空洞话作品，多多少少也该有点自己的理解与总结吧。转眼已到大二下半年，紧迫感似乎越来越强，面对学业上的考核，大三的实习校招，貌似留给我的阅读时间越来越少，且行且珍惜把。</p><p>中学，在高考中考的指挥棒下，自主时间实在有限，以后工作想必时间上的安排也必然紧张。粗想一下，大学貌似是我人生中为数不多的可以有大把时间读书，大把时间旅游，大把时间培养自主习惯的时候了，生活已经不易，希望有更多的人愿意与我一同追逐心中的书和远方。</p><h1 id="刘大佬认为的面试微软10本必读书"><a href="#刘大佬认为的面试微软10本必读书" class="headerlink" title="刘大佬认为的面试微软10本必读书"></a>刘大佬认为的面试微软10本必读书</h1><ol><li>Code: The Hidden Language of Computer Hardware and Software （《编码的奥秘》）</li><li>Computer System: A Programmer’s Perspective （《深入理解计算机系统》） / Windows via C/C++ （《Windows核心编程》 / 《程序员的自我修养》</li><li>Code Complete 2（《代码大全》）/ The Pragmatic Programmer （《程序员修炼之道》，我也把这本书称为《代码小全》）</li><li>Programming Pearls （《编程珠玑》） / Algorithms / Algorithm Design / 《编程之美》</li><li>The C Programming Language</li><li>The C++ Programming Language / Programming: Principles and Practice Using C++ / Accelerated C++</li><li>The Structure and Interpretation of Computer Programs （《计算机程序的构造和解释》）</li><li>Clean Code / Implementation Patterns</li><li>Design Patterns （《设计模式》） / Agile Software Development, Principles, Patterns, and Practices</li><li>Refactoring （《重构》）</li></ol><h1 id="云风的书单（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）"><a href="#云风的书单（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）" class="headerlink" title="云风的书单（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）"></a>云风的书单（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）</h1><ol><li>C++编程思想</li><li>Effective C++</li><li>深度探索C++对象模型</li><li>C++语言的设计和演化</li><li>C专家编程</li><li>C陷阱与缺陷</li><li>C语言接口与实现</li><li>Lua程序设计</li><li>Linkers and Loaders</li><li>COM本质论</li><li>Windows核心编程</li><li>深入解析Windows操作系统</li><li>程序员修炼之道</li><li>代码大全</li><li>UNIX编程艺术</li><li>设计模式</li><li>代码优化：有效使用内存</li><li>深入理解计算机系统</li><li>深入理解LINUX内核</li><li>TCP/IP 详解</li></ol><h1 id="来自stackoverflow的一个帖子"><a href="#来自stackoverflow的一个帖子" class="headerlink" title="来自stackoverflow的一个帖子"></a>来自stackoverflow的一个帖子</h1><ul><li><a href="https://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read" target="_blank" rel="noopener">原网址</a></li></ul><ol><li>Code Complete (2nd edition) by Steve McConnell</li><li>The Pragmatic Programmer</li><li>Structure and Interpretation of Computer Programs</li><li>The C Programming Language by Kernighan and Ritchie</li><li>Introduction to Algorithms by Cormen, Leiserson, Rivest &amp; Stein</li><li>Design Patterns by the Gang of Four</li><li>Refactoring: Improving the Design of Existing Code</li><li>The Mythical Man Month</li><li>The Art of Computer Programming by Donald Knuth</li><li>Compilers: Principles, Techniques and Tools by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman</li><li>Gödel, Escher, Bach by Douglas Hofstadter</li><li>Clean Code: A Handbook of Agile Software Craftsmanship by Robert C. Martin</li><li>Effective C++</li><li>More Effective C++</li><li>CODE by Charles Petzold</li><li>Programming Pearls by Jon Bentley</li><li>Working Effectively with Legacy Code by Michael C. Feathers</li><li>Peopleware by Demarco and Lister</li><li>Coders at Work by Peter Seibel</li><li>Surely You’re Joking, Mr. Feynman!</li><li>Effective Java 2nd edition</li><li>Patterns of Enterprise Application Architecture by Martin Fowler</li><li>The Little Schemer</li><li>The Seasoned Schemer</li><li>Why’s (Poignant) Guide to Ruby</li><li>The Inmates Are Running The Asylum: Why High Tech Products Drive Us Crazy and How to Restore the Sanity</li><li>The Art of Unix Programming</li><li>Test-Driven Development: By Example by Kent Beck</li><li>Practices of an Agile Developer</li><li>Don’t Make Me Think</li><li>Agile Software Development, Principles, Patterns, and Practices by Robert C. Martin</li><li>Domain Driven Designs by Eric Evans</li><li>The Design of Everyday Things by Donald Norman</li><li>Modern C++ Design by Andrei Alexandrescu</li><li>Best Software Writing I by Joel Spolsky</li><li>The Practice of Programming by Kernighan and Pike</li><li>Pragmatic Thinking and Learning: Refactor Your Wetware by Andy Hunt</li><li>Software Estimation: Demystifying the Black Art by Steve McConnel</li><li>The Passionate Programmer (My Job Went To India) by Chad Fowler</li><li>Hackers: Heroes of the Computer Revolution</li><li>Algorithms + Data Structures = Programs</li><li>Writing Solid Code</li><li>JavaScript - The Good Parts</li><li>Getting Real by 37 Signals</li><li>Foundations of Programming by Karl Seguin</li><li>Computer Graphics: Principles and Practice in C (2nd Edition)</li><li>Thinking in Java by Bruce Eckel</li><li>The Elements of Computing Systems</li><li>Refactoring to Patterns by Joshua Kerievsky</li><li>Modern Operating Systems by Andrew S. Tanenbaum</li><li>The Annotated Turing</li><li>Things That Make Us Smart by Donald Norman</li><li>The Timeless Way of Building by Christopher Alexander</li><li>The Deadline: A Novel About Project Management by Tom DeMarco</li><li>The C++ Programming Language (3rd edition) by Stroustrup</li><li>Patterns of Enterprise Application Architecture</li><li>Computer Systems - A Programmer’s Perspective</li><li>Agile Principles, Patterns, and Practices in C# by Robert C. Martin</li><li>Growing Object-Oriented Software, Guided by Tests</li><li>Framework Design Guidelines by Brad Abrams</li><li>Object Thinking by Dr. David West</li><li>Advanced Programming in the UNIX Environment by W. Richard Stevens</li><li>Hackers and Painters: Big Ideas from the Computer Age</li><li>The Soul of a New Machine by Tracy Kidder</li><li>CLR via C# by Jeffrey Richter</li><li>The Timeless Way of Building by Christopher Alexander</li><li>Design Patterns in C# by Steve Metsker</li><li>Alice in Wonderland by Lewis Carol</li><li>Zen and the Art of Motorcycle Maintenance by Robert M. Pirsig</li><li>About Face - The Essentials of Interaction Design</li><li>Here Comes Everybody: The Power of Organizing Without Organizations by Clay Shirky</li><li>The Tao of Programming</li><li>Computational Beauty of Nature</li><li>Writing Solid Code by Steve Maguire</li><li>Philip and Alex’s Guide to Web Publishing</li><li>Object-Oriented Analysis and Design with Applications by Grady Booch</li><li>Effective Java by Joshua Bloch</li><li>Computability by N. J. Cutland</li><li>Masterminds of Programming</li><li>The Tao Te Ching</li><li>The Productive Programmer</li><li>The Art of Deception by Kevin Mitnick</li><li>The Career Programmer: Guerilla Tactics for an Imperfect World by Christopher Duncan</li><li>Paradigms of Artificial Intelligence Programming: Case studies in Common Lisp</li><li>Masters of Doom</li><li>Pragmatic Unit Testing in C# with NUnit by Andy Hunt and Dave Thomas with Matt Hargett</li><li>How To Solve It by George Polya</li><li>The Alchemist by Paulo Coelho</li><li>Smalltalk-80: The Language and its Implementation</li><li>Writing Secure Code (2nd Edition) by Michael Howard</li><li>Introduction to Functional Programming by Philip Wadler and Richard Bird</li><li>No Bugs! by David Thielen</li><li>Rework by Jason Freid and DHH</li><li>JUnit in Action</li></ol>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>完全背包</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</url>
      <content type="html"><![CDATA[<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><p>有n种物品，每种物品的单件重量为w[i],价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，<br>使得背包内物品的总价值最大。其中每种物品都有无穷件。</p><p>完全背包与01背包的唯一区别：完全背包的物品数量每种有无穷件，而01背包的物品数量每种只有1件。</p><p>令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值</p><p>对每种物品有两种策略：</p><ol><li>不放第i件物品，那么dp[i][v] = dp[i-1][v]</li><li>放第i件物品。dp[i][v] = dp[i][v-w[i]]+c[i]<br>由此得出状态转移方程：<pre><code>**dp[i][v] = max(dp[i-1][v],dp[i][v-w[i]]+c[i]) (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V)**边界：dp[0][v] = 0(0&lt;=v&lt;=V)</code></pre>改写成一维形式：<pre><code>**dp[v] = max(dp[v],dp[v-w[i]]+c[i]) (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V)**边界：dp[v] = 0(0&lt;=v&lt;=V)</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=w[i];v&lt;=V;v++)&#123;</span><br><span class="line">    dp[v] = max(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="常见dp问题的模型总结"><a href="#常见dp问题的模型总结" class="headerlink" title="常见dp问题的模型总结"></a>常见dp问题的模型总结</h1><ol><li><p>最大连续子列和<br>令dp[i]表示以A[i]作为末尾的连续序列的最大和。</p></li><li><p>最长不下降子序列（LIS）<br>令dp[i]表示以A[i]结尾的最长不下降子序列长度</p></li><li><p>最长公共子序列（LCS）<br>令dp[i][j]表示字符串A的i号位和字符串B的j号位之前的LCS长度</p></li><li><p>最长回文子串<br>令dp[i][j]表示S[i]至S[j]所表示的子串是否是回文子串</p></li><li><p>数塔dp<br>令dp[i][j]表示从第i行第j个数字出发的到达最底层的所有路径上所能得到的最大和</p></li><li><p>DAG最长路<br>令dp[i]表示从i号顶点出发能获得的最长路径长度</p></li><li><p>01背包<br>令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值</p></li><li><p>完全背包<br>令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值</p></li></ol>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>01背包</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01%E8%83%8C%E5%8C%85/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01%E8%83%8C%E5%8C%85/</url>
      <content type="html"><![CDATA[<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><p>有n件物品，每件物品的重量为w[i]，价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，使得背包<br>内物品的总价值最大。其中每件物品都只有1件。<br>样例：</p><p>5 8  //n,v</p><p>3 5 1 2 2 //w[i]</p><p>4 5 2 1 3 //c[i]</p><h2 id="暴力枚举的想法"><a href="#暴力枚举的想法" class="headerlink" title="暴力枚举的想法"></a>暴力枚举的想法</h2><p>枚举每一件物品放或者不放进背包，显然每件物品都有两种选择，因此n件物品就有2^n种情况，<br>显然不是理想的解决方案</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>时间复杂度为O(nV)</p><p>令dp[i][v]表示前i件物品（1&lt;=i&lt;=n,0&lt;=v&lt;=V）恰好装入容量为v的背包中所能获得的最大价值。</p><p>考虑对第i件物品的选择策略，有两种策略：</p><ol><li><p>不放第i件物品，那么问题转化为前i-1件物品恰好装入容量为v的背包中所能获得的最大价值，即dp[i-1][v]</p></li><li><p>放第i件物品，那么问题转化为前i-1件物品恰好装入容量为v-w[i]的背包中所能获得的最大价值，即dp[i-1][v-w[i]]+c[i]</p></li></ol><p>由此得出状态转移方程：<br>      <strong>dp[i][v] = max{dp[i-1][v],dp[i-1][v-w[i]]+c[i]} (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V)</strong></p><p>边界： dp[0][v] = 0(0&lt;=v&lt;=V)（即前0件物品放入任何容量为v的背包中都只能获得价值0）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=w[i];v&lt;=V;v++)&#123;</span><br><span class="line">        dp[i][v] = max(dp[i<span class="number">-1</span>][v],dp[i<span class="number">-1</span>][v-w[i]]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码时间复杂度与空间复杂度均为O(nV),其中时间复杂度无法优化，但空间复杂度可以<br>优化的关键在于开一个一维数组dp[v]，枚举方向改变为i从1到n，<strong>v从V到0（逆序）</strong></p><p>状态转移方程： <strong>dp[v] = max{dp[v],dp[v-w[i]]+c[i]} (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=V;v&gt;=w[i];v--)&#123;</span><br><span class="line">        dp[v] = max(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时空间复杂度为O(V)<br>说明：如果是二维数组存放，v的枚举顺序或逆序皆可；但如果用一维数组存放，v的枚举必须为逆序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> w[maxn],c[maxn],dp[maxv];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,V;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;V);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=V;v++)&#123;</span><br><span class="line">        dp[v] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=V;v&gt;=w[i];v--)&#123;</span><br><span class="line">            dp[v] = max(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=V;v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[v]&gt;max)&#123;</span><br><span class="line">            max = dp[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>git-it</title>
      <link href="/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/git-it/"/>
      <url>/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/git-it/</url>
      <content type="html"><![CDATA[<h1 id="Git-it-Desktop-App"><a href="#Git-it-Desktop-App" class="headerlink" title="Git-it (Desktop App)"></a>Git-it (Desktop App)</h1><p><a href="https://travis-ci.org/jlord/git-it-electron" target="_blank" rel="noopener"><img src="https://travis-ci.org/jlord/git-it-electron.svg?branch=master" alt="Build Status"></a> <a href="http://standardjs.com/" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/code%20style-standard-brightgreen.svg" alt="js-standard-style"></a></p><ul><li><p>分享一款学习如何使用Git和Github的客户端应用<br><a href="https://github.com/jlord/git-it-electron/releases" target="_blank" rel="noopener">相应的发行版本</a><br>其中提供了Linux，Mac和Windos相应的版本，语言也有多种选择。<br>app对应的源代码也发布在这个人的GitHub页面</p></li><li><p>这款应用的所有贡献者仓库主也都记录并放在了她的Gitpage主页上了<br><a href="http://jlord.github.io/patchwork" target="_blank" rel="noopener">All the Git-it Workshop completers! </a></p></li></ul><p><img src="https://cloud.githubusercontent.com/assets/1305617/14594613/23873f64-04ed-11e6-9d3b-72f424dd0842.png" alt="screen shot 2016-04-17 at 10 37 55 pm"><br>Git-it is a desktop (Mac, Windows and Linux) app that teaches you how to use Git and GitHub on the <a href="https://en.wikipedia.org/wiki/Command-line_interface" target="_blank" rel="noopener">command line</a>.</p><p>Previously it ran _in_ terminal (the command line application) with a guide online but now the guide _is_ the app and it runs on your desktop on its own :sparkles: <strong>This will be the only maintained version going forward</strong> :arrow_right:</p><hr><h2 id="Hello-future-Forkers-Branchers-and-Pull-Requesters"><a href="#Hello-future-Forkers-Branchers-and-Pull-Requesters" class="headerlink" title="Hello future Forkers, Branchers and Pull Requesters!"></a>Hello future Forkers, Branchers and Pull Requesters!</h2><p>This application contains challenges for learning Git and GitHub—by using <em>real</em> Git and GitHub, not emulators. You’ll be learning the awesome (and not so scary) command line and GitHub which means when you finish all of the challenges you’ll have <em>real</em> repositories on your GitHub account and green squares on your <a href="https://github.com/blog/1360-introducing-contributions" target="_blank" rel="noopener">contribution chart</a>.</p><p><img src="https://raw.githubusercontent.com/jlord/git-it/master/ghcc.png" alt="contributions"></p><h2 id="What-to-Install"><a href="#What-to-Install" class="headerlink" title="What to Install"></a>What to Install</h2><p>You will need this app, Git-it as well as a text editor. You’ll also of course need Git and the first challenge in Git-it helps you get that set up. But if you want to get a head start, go for it! You’ll continue to use Git and your text editor throughout your bright social coding future.</p><p>As a part of the challenges you’ll also create a (free) account on GitHub. If you’ve already got one, high-five!</p><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><p>We recommend installing <a href="http://desktop.github.com" target="_blank" rel="noopener">GitHub Desktop</a> (free) because it installs Git in the most consistent way across supported operating systems (Windows and Mac). We won’t use the app itself in the challenges (but it is really useful once you get going in Git!), just the Git that it install for you.</p><p>Note—If you’re using Windows, you should use the <strong>Git Shell</strong> app as your terminal—it is installed with GitHub Desktop. In Mac and Linux you can use the app <strong>Terminal</strong>, which is already on your computer.</p><h4 id="Text-Editor"><a href="#Text-Editor" class="headerlink" title="Text Editor"></a>Text Editor</h4><p>I’m quite partial (I’m on the team!) but <a href="http://atom.io" target="_blank" rel="noopener">Atom</a> is a great text editor (also free) and it is built on <a href="http://electron.atom.io" target="_blank" rel="noopener">Electron.js</a>, just like Git-it. Visit the website and download the version for your operating system. <a href="https://www.sublimetext.com" target="_blank" rel="noopener">Sublime</a>, <a href="https://code.visualstudio.com" target="_blank" rel="noopener">Microsoft VS Code</a> and <a href="http://brackets.io" target="_blank" rel="noopener">Adobe Brackets</a> are other options.</p><h4 id="Git-it"><a href="#Git-it" class="headerlink" title="Git-it"></a>Git-it</h4><p>You can view the <a href="http://github.com/jlord/git-it-electron/releases" target="_blank" rel="noopener">releases</a> section of this repository to find the download for your operating system. Click to download your version. Once it has downloaded to your default Downloads directory, unzip the folder and run the Git-it executable. The executables for Mac, Windows and Linux:</p><p><img src="https://cloud.githubusercontent.com/assets/1305617/14696588/2b10abf8-0731-11e6-945e-f3d57114bce9.png" alt="executables"></p><ul><li><strong>Mac</strong> Right (control) click the Git-it icon, select Open and then Open again. You can drag the icon into your Applications directory if you want, but it’s not required. If needed, more <a href="https://github.com/jlord/git-it-electron/issues/121#issue-149747488" target="_blank" rel="noopener">detailed installation instructions</a> can be found in this issue.</li><li><strong>Windows</strong> Double-click the executable.</li><li><strong>Linux</strong> Double-click the executable. If the app isn’t running, <a href="https://github.com/jlord/git-it-electron/issues/182" target="_blank" rel="noopener">see this issue</a>.</li></ul><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started!"></a>Get Started!</h2><p>Open Git-it and click the button to begin the first challenge. Have your terminal and text editor open, too. Follow along with the instructions in each challenge and use the terminal or editor as instructed.</p><p>When you’ve completed the steps in a challenge click ‘Verify’. Depending on the challenge you may need to also select the folder you did your work in for Git-it to verify.</p><p><strong>Questions?</strong> <a href="http://github.com/jlord/git-it-electron/issues/new" target="_blank" rel="noopener">Open an issue</a> on this repository.</p><p><strong>Want to contribute or build locally?</strong> See the <a href="CONTRIBUTING.md">contributing documentation</a></p><hr><h3 id="Tips-For-Getting-Started"><a href="#Tips-For-Getting-Started" class="headerlink" title="Tips For Getting Started"></a>Tips For Getting Started</h3><p><strong>Code snippets</strong> often times look like <code>$ some code-stuff --here</code>. The dollar sign identifies the line as one a user would enter into the command line, but you don’t actually include it when you type it into terminal. In this case, you’d actually just type <code>some code-stuff --here</code>.</p><p><strong>Variables</strong> are indicated by <code>&lt;VARIABLENAME&gt;</code> in code snippets. When you actually use the line of code, replace <code>&lt;VARIABLENAME&gt;</code>, with your variable. For instance to make a new folder in terminal the format is, <code>mkdir &lt;FOLDERNAME&gt;</code>, so if you wanted to make a folder named ‘octocat’, you’d type: <code>mkdir octocat</code>.</p><p><strong>Command line, terminal and bash</strong> all basically mean the same thing: the MS-DOS, Doogie Howser looking screen full of words and numbers. It’s awesomely powerful and allows you to control your computer with text commands.</p><p>You can do a lot of things from your terminal like delete, rename, copy or create files and folders; run scripts and send things back and forth between servers (like the ones storing things on GitHub.com) and your computer (also a server!).</p>]]></content>
      
      <categories>
          
          <category> 业务开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 5. 最长回文子串</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      <content type="html"><![CDATA[<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p><p>示例 1：</p><p>输入: “babad”<br>输出: “bab”<br>注意: “aba”也是一个有效答案。<br>示例 2：</p><p>输入: “cbbd”<br>输出: “bb”</p><h1 id="解决思路-1-——-暴力枚举法"><a href="#解决思路-1-——-暴力枚举法" class="headerlink" title="解决思路 1 —— 暴力枚举法"></a>解决思路 1 —— 暴力枚举法</h1><p>暴力枚举法是这几种方法中最直观的求解，<br>求解过程中分别以每个元素为中间元素（奇数为最中间的一个数，偶数为中间元素的其中一个），<br>同时从左右出发，计算出最长的回文子串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> endIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存最大回文子串的起始与终点位置</span></span><br><span class="line">    <span class="keyword">int</span> resStart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resEnd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> countLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">      <span class="comment">/* 回文子串为奇串处理 */</span></span><br><span class="line">      startIndex = i;</span><br><span class="line">      endIndex = i;</span><br><span class="line">      countLen = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(startIndex &gt;= <span class="number">0</span> &amp;&amp; endIndex &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[startIndex] == s[endIndex]) &#123;</span><br><span class="line">          <span class="keyword">if</span>(startIndex == endIndex) &#123;</span><br><span class="line">            countLen++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            countLen += <span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          startIndex--;</span><br><span class="line">          endIndex++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前回文子串大于上一次最大回文子串</span></span><br><span class="line">      <span class="keyword">if</span>(countLen &gt; maxLen) &#123;</span><br><span class="line">        maxLen = countLen;</span><br><span class="line">        resStart = startIndex + <span class="number">1</span>;</span><br><span class="line">        resEnd = endIndex - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 回文子串为奇串处理 */</span></span><br><span class="line">      startIndex = i<span class="number">-1</span>;</span><br><span class="line">      endIndex = i;</span><br><span class="line">      countLen = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(startIndex &gt;= <span class="number">0</span> &amp;&amp; endIndex &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[startIndex] == s[endIndex]) &#123;</span><br><span class="line">          <span class="keyword">if</span>(startIndex == endIndex) &#123;</span><br><span class="line">            countLen++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            countLen += <span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          startIndex--;</span><br><span class="line">          endIndex++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前回文子串大于上一次最大回文子串</span></span><br><span class="line">      <span class="keyword">if</span>(countLen &gt; maxLen) &#123;</span><br><span class="line">        maxLen = countLen;</span><br><span class="line">        resStart = startIndex + <span class="number">1</span>;</span><br><span class="line">        resEnd = endIndex - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.substr(resStart, resEnd - resStart + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：最外层循环复杂度为O(n),内层两个循环的复杂度都为O(n/2),因此时间复杂度为O(n2)。</li><li>空间复杂度：在此算法中，没有使用额外的辅助空间，因此空间复杂度为O(1)。</li></ul><h1 id="解决思路-2-——-记忆化搜索"><a href="#解决思路-2-——-记忆化搜索" class="headerlink" title="解决思路 2 —— 记忆化搜索"></a>解决思路 2 —— 记忆化搜索</h1><p>回文字符串的子串也是回文，我们可以将最长回文子串分解一系列子问题，使用动态规划求解。<br>设状态f(i,j)表示区间[i,j]是否为回文串，<br>f(i,j) = false表示子串[i,j]不是回文，f(i,j)=true表示子串[i,j]是回文串，则有以下的关系：</p><p><img src="/img/4.jpg" alt="Alt"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    n = s.size();</span><br><span class="line">    <span class="keyword">bool</span> **f = <span class="keyword">new</span> <span class="keyword">bool</span>*[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      f[i] = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        f[i][j] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">      f[i][i] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        f[j][i] = (s[j] == s[i] &amp;&amp; (i-j &lt; <span class="number">2</span> || f[j+<span class="number">1</span>][i<span class="number">-1</span>]));</span><br><span class="line">        <span class="keyword">if</span>(f[j][i] &amp;&amp; maxLen &lt; (i-j+<span class="number">1</span>)) &#123;</span><br><span class="line">          maxLen = i - j + <span class="number">1</span>;</span><br><span class="line">          start = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">delete</span>[] f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] f;</span><br><span class="line">    <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：使用了两层循环,因此时间复杂度为O(n2)。</li><li>空间复杂度：使用了f[n][n]作为辅助空间，因此空间复杂度为O(n2)。</li></ul><h1 id="解决思路-3-——-Mancher’s-Algorithm"><a href="#解决思路-3-——-Mancher’s-Algorithm" class="headerlink" title="解决思路 3 —— Mancher’s Algorithm"></a>解决思路 3 —— Mancher’s Algorithm</h1><p>Mancher算法能够很快的得到一个字符串中以任意一个字符为中心的回文子串，<br>其基本原理使用已知回文串的左半部分来推导有半部分。</p><p>我们使用rad[i]表示以第i个字符为中心的最长回文半径，<br>假设我们求出了rad[0,…,i-1]的值，现在我们需要通过已知的结果计算出rad[i]的值，<br>在此我们定义maxRight是i位置前所有回文串能延伸到的最右端位置，并且此时回文串的中心位置为k（取第一个达到最右端的位置），<br>则我们可以得到maxRight = k + rad<a href="中心位置加上半径">k</a>，可以有以下两种情况：</p><p><img src="/img/3.jpg" alt="Alt"></p><p>第一种情况：位置i不在前面的任何回文串中，即i &gt; maxRight,这时则初始化rad[i]=1，然后rad[i]向两边延伸，即</p><p>while(s[i+rad[i]] == s[i-rad[i]])<br>  rad[i]++;<br>第二种情况：i这个位置被前面位置k为中心的回文串包含，即i &lt;= maxRight，这种情况下rad[i]就不是从1开始。由回文串的性质，我们可以知道2k-i这个位置与i关于k对称，在这种情况下由可分为三种情形：<br>第一种情形：以2k-i为中心的回文串有一部分在以i为中心回文串之外，<br>这种情况下rad[i]=maxRight-i=k+rad[k]-i,即为图中空心箭头长度，<br>那有没有可能rad[i]会更长呢？不可能，如果rad[i]会更长，则会延伸到k为中心的子串外，<br>由于i和2k-i的对称性可得到k为中心的子串会大于图中紫色对应的半径，与已知矛盾。</p><p><img src="/img/2.jpg" alt="Alt"></p><p>第二种情形：以2k-i为中心的回文串在以i为中心回文串之内，此时rad[i]=rad[2k-i],<br>那么这个时候rad[i]会更长吗？不可能，如果rad[i]长度更长，则延伸部分与2k-i正好对称，<br>这个时候2k-i子串半径则大于图中蓝色箭头的长度，矛盾。</p><p><img src="/img/1.jpg" alt="Alt"></p><p>第三种情形：以2k-i为中心的回文串与i为中心回文串左端部重叠，则ran[i]=rad[2k-i],并且rad[i]可能继续增加，所以有:<br>rad[i]=rad[2k-i];<br>while(s[i+rad[i]] == s[i-rad[i]])<br>  rad[i]++;<br>上面的方法存在一个问题，就是只能计算出奇数长度的回文子串，偶数的就不行，<br>怎么解决呢？这里使用一个比较好的方法，在原来的串中每两个字符之间添加一个特殊字符，<br>如aabbaca变成^#a#a#b#b#a#c#a#$，这里^$作为字符串的定界符是为了防止算法越界。<br>这样处理后，无论原来的回文子串长度是偶数还是奇数，现在都变成奇数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 字符串预处理，如输入"abba",返回"^#a#b#b#a#$"</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">preProcess</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"^$"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">"^"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">      ret += <span class="string">"#"</span> + s.substr(i,<span class="number">1</span>);</span><br><span class="line">    ret+= <span class="string">"#$"</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> tmpStr = preProcess(s);</span><br><span class="line">    <span class="keyword">int</span> n = tmpStr.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *rad = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> center = <span class="number">0</span>, maxRight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> sym_pos = <span class="number">2</span> * center - i;</span><br><span class="line"></span><br><span class="line">      rad[i] = (maxRight &gt; i) ? min(maxRight - i, rad[sym_pos]) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 以i为中心检索两边的字符串</span></span><br><span class="line">      <span class="keyword">while</span>(tmpStr[i + rad[i]] == tmpStr[i - rad[i]])</span><br><span class="line">        rad[i]++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(i + rad[i] &gt; maxRight) &#123;</span><br><span class="line">        center = i;</span><br><span class="line">        maxRight = i + rad[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找最长的半径</span></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> center_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(rad[i] &gt; maxLen) &#123;</span><br><span class="line">        maxLen = rad[i];</span><br><span class="line">        center_index = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.substr((center_index - maxLen) / <span class="number">2</span>, maxLen<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：Mancher算法时间复杂度为O(n)。</li><li>空间复杂度：空间复杂度也为O(n)。</li></ul>]]></content>
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最长回文子串</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p>问题描述：<br>给出一个字符串S，求S的最长回文子串的长度。</p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>枚举子串的两个端点i和j，判断[i,j]区间内的子串是否回文。<br>其中枚举端点需要O(n^2),判断回文需要O(n)因此总的复杂度为O(n^3)</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>时间复杂度为O(n^2)<br>令dp[i][j]表示S[i]至S[j]所表示的子串是否是回文子串，是则为1，不是为0.<br>根据S[i]是否等于S[j]，将转移情况分为两类：</p><ol><li>若S[i]==S[j]，只要S[i+1]到S[j-1]是回文子串，那么S[i]到S[j]就是回文子串；<br>否则，就不是。</li><li>若S[i]!=S[j]那么S[i]到S[j]一定不是回文子串。<br>由此得出状态转移方程：</li></ol><p>dp[i][j]= dp[i+1][j-1],S[i]==S[j]<br>          0,S[i]!=S[j]<br>边界：dp[i][i] = 1,dp[i][i+1] = (S[i]==S[i+1)?1:0</p><p>但是不能按照i和j从小到大进行枚举子串两个端点然后更新dp[i][j]，因为无法保证<br>dp[i+1][j-1]已经被计算过，从而无法得到正确的dp[i][j]</p><p>由于边界表示的是长度为1和2的子串，且每次转移时都对子串的长度减1，因此考虑按子串的长度和子串的初始位置进行枚举<br>即第一遍将长度为3的子串的dp值全部求出，第二遍通过第一遍结果计算长度为4的子串的值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">char</span> S[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gets(S);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(S),ans = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==S[i+<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                ans = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">3</span>;t&lt;=len;t++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+t<span class="number">-1</span>&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+t<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==S[j]&amp;&amp;dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                ans = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="字符串哈希-二分解法"><a href="#字符串哈希-二分解法" class="headerlink" title="字符串哈希+二分解法"></a>字符串哈希+二分解法</h2><p>时间复杂度为O(nlogn)<br>对给定的字符串str，可以先求出其字符串hash数组h1，然后再将str反转，<br>求出反转字符串rstr的hash数组h2，接着按回文串的奇偶情况讨论</p><ul><li><p>回文串的长度是奇数：枚举回文中心点i，二分子串的半径k，找到最大的使子串[i-k,i+k]是回文串的k。</p></li><li><p>回文串的长度是偶数：枚举回文空隙点，令i表示空隙左边第一个元素的下标，二分子串的半径k，找到最大的使子串<br>[i-k+1,i+k]是回文串的k。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> ll p = <span class="number">10000019</span>;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">200010</span>;</span><br><span class="line">ll powp[maxn],h1[maxn],h2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    powp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">        powp[i] = (powp[i<span class="number">-1</span>]*p)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calh</span><span class="params">(ll h[],<span class="built_in">string</span> &amp;str)</span></span>&#123;</span><br><span class="line">    h[<span class="number">0</span>] = str[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        h[i] = (h[i<span class="number">-1</span>]*p+str[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calSingleSubh</span><span class="params">(ll h[],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span> h[j];</span><br><span class="line">    <span class="keyword">return</span> ((h[j]-h[i<span class="number">-1</span>]*powp[j-i+<span class="number">1</span>])%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> len,<span class="keyword">int</span> i,<span class="keyword">int</span> isEven)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> h1l = i-mid+isEven,h1r = i;</span><br><span class="line">        <span class="keyword">int</span> h2l = len<span class="number">-1</span>-(i+mid),h2r = len<span class="number">-1</span>-(i+isEven);</span><br><span class="line">        <span class="keyword">int</span> hashl = calSingleSubh(h1,h1l,h1r);</span><br><span class="line">        <span class="keyword">int</span> hashr = calSingleSubh(h2,h2l,h2r);</span><br><span class="line">        <span class="keyword">if</span>(hashl!=hashr) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    getline(<span class="built_in">cin</span>,str);</span><br><span class="line">    calh(h1,str);</span><br><span class="line">    reverse(str.begin(),str.end());</span><br><span class="line">    calh(h2,str);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> maxlen = min(i,(<span class="keyword">int</span>)str.length()<span class="number">-1</span>-i)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = binarySearch(<span class="number">0</span>,maxlen,str.length(),i,<span class="number">0</span>);</span><br><span class="line">        ans = max(ans,k*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> maxlen = min(i+<span class="number">1</span>,(<span class="keyword">int</span>)str.length()<span class="number">-1</span>-i)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = binarySearch(<span class="number">0</span>,maxlen,str.length(),i,<span class="number">1</span>);</span><br><span class="line">        ans = max(ans,k*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h1><p>时间复杂度为O(n)<br>算法分析：<br>由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。</p><p>举个例子：s=”abbahopxpo”，转换为s_new=”$#a#b#b#a#h#o#p#x#p#o#”（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文abba和一个奇回文opxpo，被转换为#a#b#b#a#和#o#p#x#p#o#，长度都转换成了奇数。</p><p>定义一个辅助数组int p[]，其中p[i]表示以 i 为中心的最长回文的半径<br>p[i] - 1正好是原字符串中最长回文串的长度。</p><p><img src="https://segmentfault.com/img/remote/1460000014416801?w=590&amp;h=190/view" alt="Alt txt"><br>设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。</p><p>假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; mx)  </span><br><span class="line">    p[i] = min(p[<span class="number">2</span> * id - i], mx - i);</span><br></pre></td></tr></table></figure></p><p>2 * id - i为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快查找。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findBMstr</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[str.size() + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=  str.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i] = (p[<span class="number">2</span>*id - i] &lt; (mx - i) ? p[<span class="number">2</span>*id - i] : (mx - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(str[i - p[i]] == str[i + p[i]])</span><br><span class="line">            p[i]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i + p[i] &gt; mx)</span><br><span class="line">        &#123;</span><br><span class="line">            mx = i + p[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, ii;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            ii = i;</span><br><span class="line">            max = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = ii - max ;</span><br><span class="line">    <span class="keyword">int</span> end = ii + max;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] != <span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>  p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"12212321"</span>;</span><br><span class="line">    <span class="built_in">string</span> str0;</span><br><span class="line">    str0 += <span class="string">"$#"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str0 += str[i];</span><br><span class="line">        str0 += <span class="string">"#"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str0 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    findBMstr(str0);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>最长公共子序列</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>最长公共子序列问题描述：<br>给定两个字符串（或数字序列）A和B,求一个字符串，使得这个字符串是A和B的最长公共部分（子序列可以不连续）</p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>设字符串A和B的长度分别是n和m，那么对两个字符串中的每个字符，分别有选与不选两个决策，而得到子序列后<br>比较两个子序列是否相同有需要O(max(m,n))，这样总的复杂度就会达到O(2^(m+n)*max(m,n))，无法承受较大数据</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>令dp[i][j]表示字符串A的i号位和字符串B的j号位之前的LCS长度（下标从1开始）两种决策如下：</p><ol><li><p>若A[i]==B[j]则字符串A与字符串B的LCS增加了1位，即dp[i][j]=dp[i-1][j-1]+!</p></li><li><p>若A[i]!=B[j]，则字符串A的i号位和字符串B的j号位之前的LCS无法延长，因此dp[i][j]将会继承dp[i-1][j]与dp[i][j-1]<br>z中的较大值，即dp[i][j]= max{dp[i-1][j],dp[i][j-1]}</p></li></ol><p>由此可以得到状态转移方程：<br>dp[i][j]= dp[i-1][j-1]+1,A[i]==B[j]<br>          max{dp[i-1][j],dp[i][j-1]},A[i]!=B[j]<br>边界：dp[i][0]=dp[0][j]=0(0&lt;=i&lt;=n,0&lt;=j&lt;=m)<br>时间复杂度为O(nm)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> A[N],B[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    gets(A+<span class="number">1</span>);<span class="comment">//从下标为1开始读入</span></span><br><span class="line">    gets(B+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> lenA = <span class="built_in">strlen</span>(A+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> lenB = <span class="built_in">strlen</span>(B+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lenA;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=lenB;j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lenA;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lenB;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]==B[j])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[lenA][lenB]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>最长不下降子序列</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="最长不下降子序列"><a href="#最长不下降子序列" class="headerlink" title="最长不下降子序列"></a>最长不下降子序列</h1><p>LIS问题：<br>在一个数字序列中，找到一个最长的子序列（可以不连续），使得这个子序列是不下降的</p><h2 id="原始方法"><a href="#原始方法" class="headerlink" title="原始方法"></a>原始方法</h2><p>枚举每种情况，即对于每个元素有取和不取两种选择，然后判断序列是否为不下降序列。<br>如果是不下降序列，则更新最大长度，直到枚举完所有情况并得到最大长度。<br>但这种做法时间复杂度将达到O(2^n)显然不可取</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>用dp[i]表示以A[i]结尾的最长不下降子序列长度，则A[i]有两种情况</p><ol><li>如果存在A[i]之前的元素A<a href="j&lt;i">j</a>，使得A[j]&lt;=A[i]且dp[j]+1&gt;dp[i]（即把A[i]跟以A[j]结尾的LIS后面时能比当前以A[i]结尾的LIS长度更长）<br>，那么就把A[i]跟在以A[j]结尾的LIS后面，形成一条更长的不下降子序列，（令dp[i]=dp[j]+1）</li><li>如果A[i]之前的元素都比A[i]大，那么A[i]就只好自己形成一条LIS,但是长度为1，即这个子序列里面只有一个A[i]</li></ol><p>最后以A[i]结尾的LIS长度就是上述两点中能形成的最大长度</p><p>由此写出状态转移方程：<br>dp[i] = max{1,dp[j]+1}(j=1,2,…i-1&amp;&amp;A[j]&lt;A[i])<br>边界dp[i] = 1(1&lt;=i&lt;=n)<br>整体复杂度为O(n^2)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> A[N],dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;=A[j]&amp;&amp;(dp[j]+<span class="number">1</span>&gt;dp[i]))&#123;</span><br><span class="line">                dp[i] = dp[j]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>最大连续子列和</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%88%97%E5%92%8C/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%88%97%E5%92%8C/</url>
      <content type="html"><![CDATA[<h1 id="最大连续子列和问题"><a href="#最大连续子列和问题" class="headerlink" title="最大连续子列和问题"></a>最大连续子列和问题</h1><p>给定一个数字序列A1，A2，……An,求i，j(1&lt;=i&lt;=j&lt;=n),使得Ai+….Aj最大，输出这个最大和。</p><h3 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h3><p>枚举左端点和右端点（即枚举i和j），需要O(n^2)的复杂度，求和有需要O(n)的复杂度，因此总复杂度为O(n^3)</p><h3 id="方法二：预处理记录前缀和"><a href="#方法二：预处理记录前缀和" class="headerlink" title="方法二：预处理记录前缀和"></a>方法二：预处理记录前缀和</h3><p>记S[i] = A[0]+A[1]….+A[i],这样A[i]+…+A[j] = S[j]-S[i-1];该计算的复杂度为O(1),但总的时间复杂度为O(n^2)</p><h3 id="方法三：动态规划"><a href="#方法三：动态规划" class="headerlink" title="方法三：动态规划"></a>方法三：动态规划</h3><p>动态规划问题的核心与难点其实就在于确定状态和状态转移方程，以及边界分析。<br>步骤一：确定状态<br>令状态dp[i]表示以A[i]作为末尾的连续序列的最大和，<br>因此所求最大和便是dp[0],dp[1],dp[2]…dp[n-1]中的最大值。<br>步骤二：确定状态转移方程，求dp数组<br>以A[i]结尾的连续序列只有两种情况</p><ol><li>这个最大和的连续序列只有一个元素，即以A[i]开始，以A[i]结尾</li><li>这个最大和的连续序列有多个元素，即以A[p]开始，A[i]结尾<br>第一种情况，最大和就是A[i]<br>第二种情况，最大和是dp[i-1]+A[i]<br>所以可以得到状态转移方程<br>dp[i] = max{A[i],dp[i-1]+A[i]}<br>边界为dp[0] = A[0]<br>时间复杂度为O(n)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i] = max(a[i],dp[i<span class="number">-1</span>]+a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;dp[k])&#123;</span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="状态的无后效性"><a href="#状态的无后效性" class="headerlink" title="状态的无后效性"></a>状态的无后效性</h1><p>状态的无后效性是指：当前状态记录了信息，一旦当前状态确定，就不会再改变，且未来的决策只能在已有的一个或若干个状态的<br>基础上进行，历史信息只能通过已有的状态去影响未来的决策。</p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>dp简介</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dp%E7%AE%80%E4%BB%8B/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dp%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="动态规划的递归写法和递推写法"><a href="#动态规划的递归写法和递推写法" class="headerlink" title="动态规划的递归写法和递推写法"></a>动态规划的递归写法和递推写法</h1><p>动态规划是一种算法思想，没有固定写法，十分灵活，需要具体问题具体分析</p><p>动态规划是一种用来解决一类最优化问题的算法思想。<br>即将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得到原问题的最优解。<br>动态规划会将每个求解过的子问题的解记录下来，这样当下一次碰到同样的子问题时，就可以直接使用之前记录的结果。</p><h2 id="动态规划的递归写法"><a href="#动态规划的递归写法" class="headerlink" title="动态规划的递归写法"></a>动态规划的递归写法</h2><p>以求解斐波那契数列为例<br>f0=1,f1=1,f(n)=f(n-1)+f(n-2)(n&gt;=2)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f(n<span class="number">-1</span>)+f(n<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码就涉及到了很多重复计算，严重增大了时间复杂度<br>为了便重复计算，可以开一个dp数组，用来保存已经计算过的结果<br>其中dp[n]表示f(n)的结果<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dp[n]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[n];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dp[n] = f(n<span class="number">-1</span>)+f(n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种做法将复杂度由O(2^n)降到了O(n)，这也是名词记忆化搜索的由来。</p><h2 id="动态规划的递推写法"><a href="#动态规划的递推写法" class="headerlink" title="动态规划的递推写法"></a>动态规划的递推写法</h2><p>以数塔问题为例<br>从顶部出发在每一个节点可以选择向左或者向右走，一直走到底层，要求找出一条路径，<br>使得路径上的数字之和最大.<br>不妨令dp[i][j]表示从第i行第j个数字出发的到达底层的所有路径中能得到的最大和。<br>于是dp[1][1]就是dp[2][1]和dp[2][2]的较大值加上5<br>即： dp[1][1] = max(dp[2][1],dp[2][2]+f[1][1])</p><p>状态转移方程：<br>dp[i][j] = max(dp[i+1][j],dp[i+1][j+1]+f[i][j])<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn],dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;f[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        dp[n][j] = f[n][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            dp[i][j] = max(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>])+f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用递推写法采用自底向上，即从边界开始，不断向上解决问题，直到解决目标问题<br>使用递归写法采用自顶向下，即从目标问题开始，将她分解成子问题的组合，直到分解至边界为止</p><ul><li>一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决</li></ul><ol><li><p>分治与动态规划：分治和动态规划都是讲问题分解成子问题，然后合并子问题的解得到原问题的解。<br>但是分治法分解出的子问题时不重叠的，因此分治法解决的问题不拥有重叠子问题，而动态规划解决的问题拥有重叠子问题<br>另外，分治法解决的问题不一定是最优化问题，而动态规划解决的一定是最优化问题</p></li><li><p>贪心和动态规划：贪心和动态规划都要求原问题必须拥有最优子结构。<br>贪心并不等待子问题求解完毕后在选择使用哪一个，而是通过一种策略直接选择一个问题去求解，没被选择的子问题就<br>不在去求解，直接抛弃。<br>而动态规划不管是自底向上还是自顶向下，都是从边界开始向上得到目标问题的解。</p></li></ol>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>拓扑排序</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h1 id="有向无环图"><a href="#有向无环图" class="headerlink" title="有向无环图"></a>有向无环图</h1><p>如果一个有向图的任意顶点都无法通过一些有向边回到自身，那么称这个有向图为有向无环图。</p><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>拓扑排序是将有向无环图G的所有顶点排成一个线性序列，使得对图G中的任意两个顶点u，v，如果<br>存在边u-&gt;v,那么在序列中u一定在v前面。该序列被称为拓扑序列。<br>求解拓扑序列：</p><ol><li>定义一个队列q,并把所有入度为0的结点加入队列</li><li>取队首结点，输出。然后删去所有从它出发的边，并令这些边到达的顶点的入度减1，如果某个顶点的入度减为0，则将其加入队列。</li><li>反复进行2操作，直到队列为空。如果队列为空时入队的结点数目恰好为n，说明拓扑排序成功，图G为有向无环图；<br>否则，拓扑排序失败，图G中有环。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxv];</span><br><span class="line"><span class="keyword">int</span> n,m,inDegree[maxv];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,u);</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        G[u].clear();</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用拓扑排序可以判断一个給定的图是否为有向无环图。</p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>最小生成树</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>最小生成树（MST）是在一个給定的无向图G(v,e)中求一棵树T，使得这棵树拥有图G中的所有顶点，且所有边都是来自<br>图G中的边，并且满足整棵树的边权之和最小。</p><p>三个重要性质</p><ol><li>最小生成树是树，因此其边数等于顶点数减1，且树内一定不会有环。</li><li>对給定的图G（v,e），其最小生成树可以不唯一，但其边权之和一定是唯一的。</li><li>由于最小生成树是在无向图中生成的，因此其根结点可以是这棵树上的任意一个结点，于是，<br>如果题目中涉及最小生成树本身的输出，为了让最小生成树唯一，一般都会直接给出根结点。</li></ol><p>求最小生成树一般有两种算法，即prim算法和kruskal算法。这两种算法均采用了贪心的思想。</p><h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><p>基本思想：对图G（v，e）设置集合s，存放已被访问的顶点，然后每次从集合v-s中选择与集合s的最短距离最小的一个顶点（记为u）<br>访问并加入集合s。之后，令顶点u为中介点，优化所有从u能到达的顶点v与集合s之间的最短距离。<br>这样的操作执行n次，直到集合s已包含所有顶点。其实思路与Dijstra算法类似。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//邻接矩阵写法</span></span><br><span class="line"><span class="keyword">int</span> n,g[maxv][maxv];</span><br><span class="line"><span class="keyword">int</span> d[maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;<span class="comment">//默认0为初始点，返回最小生成树边权之和</span></span><br><span class="line">    fill(d,d+maxv,inf);</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,minm = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">//找到未被访问的顶点中d[]最小的</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minm)&#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minm = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找不到小于inf的d[u],则剩下的顶点和集合s不连通</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        ans+= d[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;<span class="comment">//v未被访问&amp;&amp;u能到达v&amp;&amp;以u为中介点可以使v离集合s更近</span></span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;g[u][v]!=inf&amp;&amp;g[u][v]&lt;d[v])&#123;</span><br><span class="line">                d[v] = g[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//邻接表写法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(d,d+maxv,inf);</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,minm = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minm)&#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minm = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        ans+ = d[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;Adj[u][j]&lt;div)&#123;</span><br><span class="line">                d[v] = g[u][[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h3><p>kruskal算法采用的是边贪心的策略<br>基本思想：在初始状态时隐去图中的所有边，这样图中每个顶点都自成一个连通块。之后执行如下步骤：</p><ol><li>对所有边按边权从小到大排序</li><li>按边权从小到大测试所有边，如果当前测试边所连接的两个顶点不在同一个连通块中，则把这条测试边加入到当前最小生成树中；否则，将边舍弃</li><li>执行步骤2，直到最小生成树中的边数等于总顶点数减1或是测试完所有边时结束。<br>当结束时如果最小生成树的边数小于总顶点数减1，说明该图不连通。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">int</span> cost;<span class="comment">//边权</span></span><br><span class="line">&#125;e[maxe];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost&lt;b.cost;</span><br><span class="line">&#125;</span><br><span class="line">伪代码</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    令最小生成树的边权之和为ans，最小生成树的当前边数为Num_Edge;</span><br><span class="line">    将所有边按边权从小到大排序;</span><br><span class="line">    <span class="keyword">for</span>(从小到大枚举所有边)&#123;</span><br><span class="line">        <span class="keyword">if</span>(当前测试边的两个端点在不同的连通块中)&#123;</span><br><span class="line">            将该测试边加入最小生成树中;</span><br><span class="line">            ans+=测试边的边权;</span><br><span class="line">            最小生成树的当前边数为Num_Edge+<span class="number">1</span>;</span><br><span class="line">            当边数Num_Edge等于顶点数减<span class="number">1</span>时结束循环;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">其中 并查集可以通过查询两个结点所在集合的根结点是否相同来判断他们是否在同一个集合</span><br><span class="line">而只要把测试边的两个端点所在集合合并，就能达到将边加入最小生成树的效果</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[n];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findfather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,Num_Edge = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e,e+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> fau = findfather(e[i].u);</span><br><span class="line">        <span class="keyword">int</span> fav = findfather(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(fau!=fav)&#123;</span><br><span class="line">            father[fau] = fav;</span><br><span class="line">            ans += e[i].cost;</span><br><span class="line">            Num_Edge++;</span><br><span class="line">            <span class="keyword">if</span>(Num_Edge==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Num_Edge!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kruskal算法的时间复杂度主要来源于对边进行排序<br>所以其时间复杂度为O(eloge)<br>综合来看：如果是稠密图（边多），则用prim算法；如果是稀疏图（边少），则用kruskal算法</p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>memset与fill</title>
      <link href="/%E8%AF%AD%E8%A8%80/memset%E4%B8%8Efill/"/>
      <url>/%E8%AF%AD%E8%A8%80/memset%E4%B8%8Efill/</url>
      <content type="html"><![CDATA[<h1 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h1><p>memset是计算机中C/C++语言函数。将s所指向的某一块内存中的后n个 字节的内容全部设置为ch指定的ASCII值，</p><p>第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作， 其返回值为s。</p><p>头文件:memory.h或string.h</p><p>函    数：void *memset</p><p>原    型 (void *s,int ch,size_t n);</p><p>void <em>memset(void </em>s, int ch, size_t n);</p><p>函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。</p><p>memset：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法</p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>第一：memset函数按字节对内存块进行初始化，所以不能用它将int数组初始化为0和-1之外的其他值（除非该值高字节和低字节相同）。</p><p>第二：memset(void *s, int ch,size_tn);中key实际范围应该在0~~255，</p><p>因为该函数只能取ch的后八位赋值给你所输入的范围的每个字节，</p><p>比如int a[5]赋值memset（a,-1,sizeof(int )<em>5）与memset（a,511,sizeof(int )</em>5） 所赋值的结果是一样的都为-1；</p><p>因为-1的二进制码为（11111111 11111111 11111111 11111111）而511的二进制码为（00000000 00000000 00000001 11111111）后八位都为（11111111)，</p><p>所以数组中每个字节，如a[0]含四个字节都被赋值为（11111111），其结果为a[0]（11111111 11111111 11111111 11111111），</p><p>及a[0]=-1，因此无论ch多大只有后八位二进制有效，而八位二进制 [2]  的范围（0~255）YKQ改。</p><p>而对字符数组操作时则取后八位赋值给字符数组，其八位值作为ASCII [3]  码。</p><p>第三： 搞反了 ch 和 n 的位置.</p><p>一定要记住如果要把一个char a[20]清零，一定是 memset(a,0,20*sizeof(char));</p><p>而不是 memset(a,20*sizeof(char),0);</p><h1 id="fill-函数"><a href="#fill-函数" class="headerlink" title="fill()函数"></a>fill()函数</h1><p>用途：</p><ul><li><p>按照单元赋值，将一个区间的元素都赋同一个值</p></li><li><p>fill(arr, arr + n, 要填入的内容);</p></li></ul><p>头文件：<algorithm></algorithm></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];    fill(arr, arr + <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="与memset-函数的区别："><a href="#与memset-函数的区别：" class="headerlink" title="与memset()函数的区别："></a>与memset()函数的区别：</h2><p>两者都可以用来对数组填充，memset是对按照字节来填充的，所以一般用来填充char型数组，也经常用于填充int型的全0或全-1操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(arr));</span><br></pre></td></tr></table></figure><p>fill是按照单元来填充的，所以可以填充一个区间的任意值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">fill(arr,arr+<span class="number">10</span>,<span class="number">65</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;fill(arr.begin(),arr.end(),<span class="number">65</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最短路问题</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>最短路径是图论中的一个经典问题：给定图G(v,e)，求一条从起点到终点的路径，使得这条路径上经过的<br>所有边的边权之和最小。</p><p>即解决如下问题：<br>对任意给出的图G（v，e）和起点s，终点t，如何求从s到t的最短路径<br>解决最短路径的常用算法有Dijkstra算法、Bellman-Ford算法，SPFA算法和Floyd算法</p><h3 id="Dijstra算法"><a href="#Dijstra算法" class="headerlink" title="Dijstra算法"></a>Dijstra算法</h3><p>Dijstra算法用来解决单源最短路问题，即给定图G和起点s，通过算法得到s到达其他每个顶点的最短距离。<br>基本思想：对图G（v，e）设置集合s，存放已被访问的顶点，然后每次从集合v-s中选择与起点s的最短距离最小的一个顶点<br>（记为u），访问并加入集合s。之后，令顶点u为中介点，优化起点s与所有从u能到达的顶点v之间的最短距离。<br>这样的操作执行n次，直到集合s已包含所有顶点。<br>算法策略：<br>设置集合s存放已被访问的顶点，然后执行n次下面的两个步骤</p><ol><li>每次从集合v-s中选择与起点s的最短距离最小的一个顶点（记为u），访问并加入集合s</li><li>之后，令顶点u为中介点，优化起点s与所有从u能到达的顶点v之间的最短距离</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">伪代码</span><br><span class="line">Dijkstra(G,d[],s)&#123;</span><br><span class="line">  初始化;</span><br><span class="line">  <span class="keyword">for</span>(循环n次)&#123;</span><br><span class="line">      u = 使d[u]最小的还未被访问的顶点的标号;</span><br><span class="line">      记u已被访问;</span><br><span class="line">      <span class="keyword">for</span>(从u出发能到达的所有顶点v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v未被访问&amp;&amp;以u为中介点使s到顶点v的最短距离d[v]更优)&#123;</span><br><span class="line">         优化d[v];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//邻接矩阵版</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> maxv = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> n,G[maxv][maxv];</span><br><span class="line"><span class="keyword">int</span> d[maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d,d+maxv,inf);<span class="comment">//fill函数将整个d数组赋值为inf</span></span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>,minm = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minm)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                minm = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>;v&lt;n;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[v] == <span class="literal">false</span>&amp;&amp;G[u][v]!=inf&amp;&amp;d[u]+G[u][v]&lt;d[v])&#123;</span><br><span class="line">                d[v] = d[u]+G[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表版</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> v,dis;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d,d+maxv,inf);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,minm=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minm)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                minm=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = Adj[u][j].v;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;d[u]+Adj[u][j].dis&lt;d[v])&#123;</span><br><span class="line">                d[v] = d[u] + Adj[u][j].dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h1><p>Dijstra算法可以很好地解决无负权图的最短路径问题，但如果出现了负权边，Dijstra算法会失效。<br>Bellman-Ford和Dijstra一样，也可以解决单源最短路径问题，同时能处理有负权边的情况。</p><p>由于Bellman-Ford算法需要遍历所有边，所以使用邻接表会比邻接矩阵方便<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis;<span class="comment">//v为邻接边的目标顶点，dis为邻接边的边权</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv]; <span class="comment">//图G的邻接表</span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//n为顶点数，maxv为最大顶点数</span></span><br><span class="line"><span class="keyword">int</span> d[maxv]; <span class="comment">//起点到达各边的最短路径长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d,d+maxv,inf);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">                <span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line">                <span class="keyword">if</span>(d[u]+dis&lt;d[v])&#123;</span><br><span class="line">                    d[v]=d[u]+dis;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下为判断负环的代码</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">            <span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line">            <span class="keyword">if</span>(d[u]+dis&lt;d[v])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于Bellman-Ford算法的时间复杂度达到了O(ve),这并不如意，所以需要进行优化，<br>Bellman-Ford的每轮操作都需要操作所有边，这其中会有大量无意义操作，严重影响了算法性能。<br>由于，只有当某个顶点u的d[u]值改变时，从它出发的邻接点v的d[v]值才有可能被改变。<br>所以可以如下优化：<br>建立一个队列，每次将队首顶点u取出，然后对从u出发的所有边u-&gt;v进行松弛操作，<br>即判断d[u]+length[u-&gt;v]&lt;d[v]是否成立，如果成立，则用d[u]+length[u-&gt;v]覆盖d[v];<br>如果v不在队列中，就把v加入队列。<br>这样操作直到队列为空（说明图中没有从源点可达的负环），或某个顶点的入队次数超过v-1（说明图中存在从源点可达的负环）</p><h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p>上述被优化后的算法即为SPFA算法，期望时间复杂度为O(ve)<br>但如果图中有从源点可达的负环，则SPFA的时间复杂度又会退化为O(ve)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Node&gt; ADj[maxv];</span><br><span class="line"><span class="keyword">int</span> n,d[maxv],num[maxv];</span><br><span class="line"><span class="keyword">bool</span> inq[maxv];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(inq,<span class="literal">false</span>,<span class="keyword">sizeof</span>(inq));</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">    fill(d,d+maxv,inf);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    inq[s]=<span class="literal">true</span>;</span><br><span class="line">    num[s]++;</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        inq[u]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">            <span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line">            <span class="keyword">if</span>(d[u]+dis&lt;d[v])&#123;</span><br><span class="line">                d[v]=d[u]+dis;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v])&#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    inq[v]=<span class="literal">true</span>;</span><br><span class="line">                    num[v]++;</span><br><span class="line">                    <span class="keyword">if</span>(num[v]&gt;=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Flord算法"><a href="#Flord算法" class="headerlink" title="Flord算法"></a>Flord算法</h1><p>Flord算法用来解决全源最短路问题。<br>即对給定的图G（v,e），求任意两点u，v之间的最短路径长度，时间复杂度为O(n^3)所以顶点数要限制约在200以内。<br>用邻接矩阵来实现Flord算法比较合适。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf =<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv =<span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dis[maxv][maxv];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Flord</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][k]!=inf&amp;&amp;dis[k][j]!=inf&amp;&amp;dis[i][k]+dis[k][j]&lt;dis[i][j])&#123;</span><br><span class="line">                    dis[i][j]=dis[i][k]+dis[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    fill(dis[<span class="number">0</span>],dis[<span class="number">0</span>]+maxv*maxv,inf);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dis[i][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        dis[u][v]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    Flord();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,dis[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>图的存储和遍历</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/</url>
      <content type="html"><![CDATA[<h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><p>图的存储一般有两种方式：邻接矩阵和邻接表</p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>设图G(V,E)的顶点标号为0,1，……n-1，则令二维数组G[n][n]的两维分别表示图的顶点标号。<br>即如果G[i][j]等于1，指顶点i和顶点j之间有边，如果G[i][j]等于0，指顶点i和顶点j之间没有边，<br>如果为有权图，则令G[i][j]存放边权。<br>但如果题目中顶点数过大，可能会造成内存超限。</p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>图的常用储存结构之一，由表头结点和表结点两部分组成，其中表头结点存储图的各顶点，<br>表结点用单向链表存储表头结点所对应顶点的相邻顶点（也就是表示了图的边）。<br>在有向图里表示表头结点指向其它结点（a-&gt;b）,无向图则表示与表头结点相邻的所有结点（a—b）<br><img src="https://img-blog.csdn.net/20170516155825235?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzMyNDAxMjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表头结点（表示图的顶点）  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vnode</span>&#123;</span>  </span><br><span class="line">       <span class="keyword">char</span> data;             <span class="comment">//顶点数据，这里用字符表示  </span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span> * <span class="title">firstarc</span>;</span>   <span class="comment">//指针指向第一条边   </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">//表结点（表示图的边）  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span>&#123;</span>  </span><br><span class="line">       <span class="keyword">int</span> wt;           <span class="comment">//权重  </span></span><br><span class="line">       <span class="keyword">int</span> adjvex;     <span class="comment">//顶点下标  </span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span> *<span class="title">nextarc</span>;</span>   <span class="comment">//指针指向下一条边  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span> * <span class="title">Arc</span>;</span>  </span><br><span class="line"><span class="comment">//图  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mgraph</span>&#123;</span>  </span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">vnode</span> <span class="title">vexs</span>[100];</span>  </span><br><span class="line">       <span class="keyword">int</span> vexsnum,arcnum;     <span class="comment">//顶点数，边数  </span></span><br><span class="line">&#125; *g;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mgraph</span>* <span class="title">Graph</span>;</span></span><br></pre></td></tr></table></figure><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h3 id="用DFS遍历图"><a href="#用DFS遍历图" class="headerlink" title="用DFS遍历图"></a>用DFS遍历图</h3><p>沿着一条路径直到无法继续前进，才退回到路径上离当前顶点最近的还存在未访问分支顶点的岔道口，并前往访问那些未访问的分支节点，直至遍历完成</p><ul><li>连通分量：在无向图中，如果两个顶点可以互相到达，则称这两个顶点连通，如果图G（V，E）的任意两个顶点都连通，则称图G为连通图，<br>否则，称图G为非连通图，且称其中的极大连通子图为连通分量。</li><li>强连通分量：在有向图中，如果两个顶点可以各自通过一条有向路径到达另一个顶点，则称这两个顶点强联通。如果一个图的任意两个顶点都强联通，<br>则称这个图为强连通图；否则这个图为非强连通图，且称其中的极大连通子图为强联通分量。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">伪代码</span><br><span class="line">DFS(u)&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(从u出发能到达的所有顶点v)</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)</span><br><span class="line">        DFS(v);</span><br><span class="line">&#125;</span><br><span class="line">DFSTrave(G)&#123;</span><br><span class="line">    <span class="keyword">for</span>(G的所有顶点u)</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)</span><br><span class="line">        DFS(u);</span><br><span class="line">&#125;</span><br><span class="line">邻接矩阵实现</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,G[maxv][maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=inf)&#123;</span><br><span class="line">            dfs(v,depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfstrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)&#123;</span><br><span class="line">            dfs(u,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">邻接表实现</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[maxv];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    vis[u] =<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">            dfs(v,depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfstrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)&#123;</span><br><span class="line">            dfs(u,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="用BFS遍历图"><a href="#用BFS遍历图" class="headerlink" title="用BFS遍历图"></a>用BFS遍历图</h3><p>类似树的遍历，遍历图需要使用一个队列，通过反复取出队首顶点，将该顶点可到达的未曾加入过队列的顶点全部入队，直到队列为空时遍历结束。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">伪代码</span><br><span class="line">BFS(u)&#123;</span><br><span class="line">    <span class="built_in">queue</span> q;</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q非空)&#123;</span><br><span class="line">        取出q的队首元素加以访问;</span><br><span class="line">        <span class="keyword">for</span>(从u出发能到达的所有顶点v)</span><br><span class="line">        <span class="keyword">if</span>(inq[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">            将v入队;</span><br><span class="line">            inq[v]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BFSTrave(G)&#123;</span><br><span class="line">    <span class="keyword">for</span>(G的所有顶点u)</span><br><span class="line">        <span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BFS(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">邻接矩阵实现</span><br><span class="line"><span class="keyword">int</span> n,G[maxv][maxv];</span><br><span class="line"><span class="keyword">bool</span> inq[maxv]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u.q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inq[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=inf)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                inq[v]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)&#123;</span><br><span class="line">            BFS(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">邻接表实现</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[maxv];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> inq[maxv]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">            <span class="keyword">if</span>(inq[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                inq[v]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)&#123;</span><br><span class="line">            BFS(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> edges[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">///邻接矩阵  </span></span><br><span class="line">    <span class="keyword">int</span> n;  </span><br><span class="line">    <span class="keyword">int</span> e;  </span><br><span class="line">&#125;graph;  </span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">100</span>];<span class="comment">///访问数组  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creategraph</span><span class="params">(graph &amp;G)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i,j;  </span><br><span class="line">    <span class="keyword">int</span> s,t;  </span><br><span class="line">    <span class="keyword">int</span> v;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.n;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.n;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            G.edges[i][j]=<span class="number">0</span>;<span class="comment">///邻接表初始化  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        vis[i]=<span class="literal">false</span>;<span class="comment">///访问数组初始化  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.e;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t&gt;&gt;v;<span class="comment">///读入顶点数边数和权值  </span></span><br><span class="line">        G.edges[s][t]=v;<span class="comment">///赋值  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(graph G,<span class="keyword">int</span> v)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,v);  </span><br><span class="line">    vis[v]=<span class="literal">true</span>;<span class="comment">///访问第v个定点，并将访问数组置为true  </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.n;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(G.edges[v][i]!=<span class="number">0</span>&amp;&amp;vis[i]==<span class="literal">false</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            dfs(G,i);<span class="comment">///如果i未被访问递归调用dfs  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(graph G,<span class="keyword">int</span> v)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Q;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,v);  </span><br><span class="line">    vis[v]=<span class="literal">true</span>;  </span><br><span class="line">    Q.push(v);  </span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> i,j;  </span><br><span class="line">        i=Q.front();<span class="comment">///取队头元素  </span></span><br><span class="line">        Q.pop();<span class="comment">///队头元素出队  </span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.n;j++)  </span><br><span class="line">        &#123;<span class="comment">///检查所有邻接点  </span></span><br><span class="line">            <span class="keyword">if</span>(G.edges[i][j]!=<span class="number">0</span>&amp;&amp;vis[j]==<span class="literal">false</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,j);  </span><br><span class="line">                vis[j]=<span class="literal">true</span>;  </span><br><span class="line">                Q.push(j);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n,e;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"输入图的顶点数和边数："</span>);  </span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;e;  </span><br><span class="line">        graph G;  </span><br><span class="line">        G.n=n;  </span><br><span class="line">        G.e=e;  </span><br><span class="line">        creategraph(G);  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"输出深度优先遍历序列："</span>);  </span><br><span class="line">        dfs(G,<span class="number">0</span>);  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"\n"</span>);  </span><br><span class="line">        creategraph(G);  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"输出广度优先遍历序列："</span>);  </span><br><span class="line">        bfs(G,<span class="number">0</span>);  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>堆的简介</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E7%9A%84%E7%AE%80%E4%BB%8B/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E7%9A%84%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="堆的定义与基本操作"><a href="#堆的定义与基本操作" class="headerlink" title="堆的定义与基本操作"></a>堆的定义与基本操作</h1><p>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子结点的值。<br>如果父亲结点的值大于或等于孩子结点的值，则称这样的堆为大顶堆，这时每个结点的值都是以它为根结点的子树的最大值；<br>如果父亲结点的值小于或等于孩子结点的值，则称这样的堆为小顶堆，这时每个结点的值都是以它为根结点的子树的最小值。<br>堆一般用于优先队列的实现，优先队列实现默认使用大顶堆。</p><h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><p>用数组来存储完全二叉树，则结点就按层序存储于数组中，其中第一个结点存于数组中的1号位，第i号结点的左孩子为2i，右孩子为2i+1<br>建堆采用结点向下调整的方法：<br>如果结点存在，总是将当前结点V与它的左右孩子进行比较，，假如孩子中存在权值比结点V大的，就将其中权值最大的那个孩子结点与结点V交换。<br>交换完毕后继续让结点V和孩子比较，直到结点V的孩子的权值都比结点V的权值小或是结点V不存在孩子结点<br>时间复杂度O(logn)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> heap[maxn],n=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//对heap数组在[low,high]范围进行向下调整</span></span><br><span class="line"><span class="comment">//low为欲调整结点的数组下标，high为堆的最后一个元素的数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=low,j=i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;=high&amp;&amp;heap[j+<span class="number">1</span>]&gt;heap[j])&#123;</span><br><span class="line">            i=j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(heap[j]&gt;heap[i])&#123;</span><br><span class="line">            swap(heap[j]&gt;heap[i]);</span><br><span class="line">            i=j;</span><br><span class="line">            j=i*<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        downAdjust(i,n);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">  heap[<span class="number">1</span>]=heap[n--];</span><br><span class="line">  downAdjust(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="往堆里添加一个元素"><a href="#往堆里添加一个元素" class="headerlink" title="往堆里添加一个元素"></a>往堆里添加一个元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=high,j=i/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;=low)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap[j]&lt;heap[i])&#123;</span><br><span class="line">            swap(heap[j],heap[i]);</span><br><span class="line">            i=j;</span><br><span class="line">            j=i/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    heap[++n]=x;</span><br><span class="line">    UpAdjust(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序是指使用堆结构对一个序列进行排序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    createHeap();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">        swap(heap[i],heap[<span class="number">1</span>]);</span><br><span class="line">        downAdjust(<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>并查集</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      <content type="html"><![CDATA[<h1 id="并查集的定义"><a href="#并查集的定义" class="headerlink" title="并查集的定义"></a>并查集的定义</h1><p>并查集是一种维护集合的数据结构：合并（Union）、查找（Find）、集合（Set）<br>并查集支持以下两个操作：</p><ul><li>合并：合并两个集合</li><li>查找：判断两个元素是否在一个集合<br>通过数组即可实现<h2 id="并查集基本操作"><a href="#并查集基本操作" class="headerlink" title="并查集基本操作"></a>并查集基本操作</h2></li></ul><ol><li><p>初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  father[i]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找<br>由于规定同一个集合中只存在一个根结点，因此查找操作就是对給定的结点寻找其根结点的过程<br>实现方式：递推或递归<br>思路：反复寻找父亲结点，直到找到根结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递推低吗</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=father[x])&#123;</span><br><span class="line">        x=father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==father[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> findFather(father[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>3.合并<br>合并是指把两个集合合并成一个集合，题目中一般给出两个元素，要求把这两个元素所在集合合并。<br>一般是先判断两个元素是否属于同一集合，只有当两个元素属于不同集合时才合并，而合并的过程一般是<br>把其中一个集合的根结点的父亲指向另一个集合的根结点。<br>思路：</p><ul><li>对于給定的两个元素a，b，判断它们是否属于同一集合。可以调用查找函数对这两个元素分别查找根结点，然后判断其根节点是否相同</li><li>合并两个集合：在第一步中获得了两个元素的根结点faA和faB，因此只需要把其中一个的父亲结点指向另一个结点。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> faA=findFather(a);</span><br><span class="line">  <span class="keyword">int</span> fab=findFather(b);</span><br><span class="line">  <span class="keyword">if</span>(faA!=faB)&#123;</span><br><span class="line">    father[faA]=faB;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>并查集产生的每一个集合都是一棵树</p><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>当题目给出的元素数量很多并且形成一条链，则上述查找函数效率较低，需进行优化<br>把当前查询结点的路径上的所有结点的父亲都指向根结点，查找的时候就不需要一直回溯去找父亲了，查询复杂度降为O(1）<br>转换步骤：</p><ol><li>按原先的写法获得x的根结点r</li><li>重新从x开始走一遍寻找根结点的过程，把路径上经过的所有结点的父亲全部改为根结点r<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=x;</span><br><span class="line">  <span class="keyword">while</span>(x!=father[x])&#123;</span><br><span class="line">    x=father[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(a!=father[x])&#123;</span><br><span class="line">    <span class="keyword">int</span> z=a;</span><br><span class="line">    a=father[a];</span><br><span class="line">    father[z]=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(v==father[v]) <span class="keyword">return</span> v;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f=findFather(father[v]);</span><br><span class="line">    father[v]=f;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>平衡二叉树</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[<h1 id="平衡二叉树的定义"><a href="#平衡二叉树的定义" class="headerlink" title="平衡二叉树的定义"></a>平衡二叉树的定义</h1><p>当使用序列{1,2,3,4,5}构建二叉查找树，会得到一棵长链条式的树，此时对这棵树中的结点进行查找，<br>时间复杂度会达到O(n)，为了优化数据查询，需要对树的结构进行调整，使树的高度在每次插入元素后仍能保持O(logn)<br>的级别，这样能让查询操作仍然为O(logn)的时间复杂度<br>AVL树仍然是一棵二叉查找树，只是在其基础上增加了平衡要求。<br>即对AVL树的任意结点来说，其左子树与右子树的高度之差的绝对值不超过1，其中左子树和右子树的高度之差称为该结点的平衡因子。<br>只要能随时保证每个结点的平衡因子的绝对值不超过1，AVL的高度就始终能保持O(logn)级别。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结点结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,height;</span><br><span class="line">    node *lchild,*rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//生成一个新结点，v为结点权值</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    node* Node = <span class="keyword">new</span> node;</span><br><span class="line">    Node-&gt;v=v;</span><br><span class="line">    Node-&gt;height=<span class="number">1</span>;</span><br><span class="line">    Node-&gt;lchild=Node-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取以root为根结点的子树的当前height</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算结点root的平衡因子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getHeight(root-&gt;lchild)-getHeight(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新结点root的height</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateHeight</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    root-&gt;height=max(getHeight(root-&gt;lchild),getHeight(root-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="平衡二叉树的基本操作"><a href="#平衡二叉树的基本操作" class="headerlink" title="平衡二叉树的基本操作"></a>平衡二叉树的基本操作</h2><ol><li><p>查找操作<br>类似于二叉查找树，由于AVL树的高度为O(logn)级别，所以查找操作的时间复杂度为O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"search failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==root-&gt;data)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;data)&#123;</span><br><span class="line">        search(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        search(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>旋转操作<br><img src="https://img-blog.csdn.net/20141201123218032?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29sbG9ubg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(node* &amp;root)</span></span>&#123;</span><br><span class="line">    node* temp=root-&gt;rchild;</span><br><span class="line">    root-&gt;rchild=temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild=root;</span><br><span class="line">    UpdateHeight(root);</span><br><span class="line">    UpdateHeight(temp);</span><br><span class="line">    root=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(node* &amp;root)</span></span>&#123;</span><br><span class="line">    node* temp=root-&gt;lchild;</span><br><span class="line">    root-&gt;lchild=temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild=root;</span><br><span class="line">    UpdateHeight(root);</span><br><span class="line">    UpdateHeight(temp);</span><br><span class="line">    root=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入操作<br>只要把最靠近插入结点的失衡结点调整到正常，路径上的所有结点就都会平衡<br>在二叉查找树的插入操作基础上从下往上判断结点是否失衡，因此需要在每个insert函数之后更新当前子树高度，<br>并在这之后根据树型是LL型、LR型、RR型、RL型之一来进行平衡操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=newNode(v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v&lt;root-&gt;v)&#123;</span><br><span class="line">        insert(root-&gt;lchild,v);</span><br><span class="line">        UpdateHeight(root);</span><br><span class="line">        <span class="keyword">if</span>(getBalanceFactor(root)==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild)==<span class="number">1</span>)&#123;</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild)==<span class="number">1</span>)&#123;</span><br><span class="line">                L(root-&gt;lchild);</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert(root-&gt;rchild,v);</span><br><span class="line">        UpdateHeight(root);</span><br><span class="line">        <span class="keyword">if</span>(getBalanceFactor(root)==<span class="number">-2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild)==<span class="number">1</span>)&#123;</span><br><span class="line">                R(root-&gt;rchild);</span><br><span class="line">                L(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AVL树的建立<br>建立在插入操作的基础上，依次插入n个结点即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    node* root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        insert(root,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>二叉查找树</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
      <content type="html"><![CDATA[<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><h2 id="二叉查找树的定义"><a href="#二叉查找树的定义" class="headerlink" title="二叉查找树的定义"></a>二叉查找树的定义</h2><p>二叉查找树是一种特殊的二叉树，又称二叉排序树、二叉搜索树。<br>二叉查找树的递归定义：</p><ol><li>二叉查找树要么为一棵空树。</li><li>二叉查找树要么为由根结点、左子树、右子树组成，其中左子树和右子树都是二叉查找树，<br>且左子树上所有结点的数据域均小于或等于根结点的数据域，右子树上所有结点的数据域均大于等于根节点的数据域。</li></ol><p>二叉查找树其实是一棵数据有序的树。即对树上的每个结点，都满足其左子树上所有结点的数据域均小于或等于根结点的数据域，<br>右子树上所有结点的数据域均大于根结点的数据域。</p><h1 id="二叉查找树的基本操作"><a href="#二叉查找树的基本操作" class="headerlink" title="二叉查找树的基本操作"></a>二叉查找树的基本操作</h1><ol><li>查找操作<br>由二叉查找树的性质得：可以只选择一棵子树进行遍历，因此查找将会是从树根到查找结点的一条路径，<br>故最坏时间复杂度为O(h),h为二叉查找树高度<br>基本思路：</li><li>如果当前根结点为空，则查找失败，返回</li><li>如果需要查找的值x等于当前根结点的数据域root-&gt;data，说明查找成功，访问</li><li>如果需要查找的值x小于当前根结点的数据域root-&gt;data,则向左子树root-&gt;lchild递归查找</li><li><p>如果需要查找的值x大于当前根结点的数据域root-&gt;data,则向右子树root-&gt;rchild递归查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"search failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==root-&gt;data)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;data)&#123;</span><br><span class="line">        search(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        search(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入操作<br>对一棵二叉查找树来说，查找某个数据域的结点一定是沿着确定的路径进行的。<br>当某个需要查找的值在二叉查找树中查找成功，说明结点已经存在；<br>反之，查找失败的地方一定是结点需要插入的位置。<br>插入操作的时间复杂对也是O(h)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            root=newNode(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==root-&gt;data)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;data)&#123;</span><br><span class="line">        insert(root-&gt;lchild,x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert(root-&gt;rchild,x);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉查找树的建立<br>建立一棵二叉查找树就是先后插入n个结点的过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    node* root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        insert(root,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉查找树的删除（确保删除后仍是一棵二叉查找树）<br>一般有两种做法，时间复杂度都为O(h)<br>删除操作的基本思路：</p></li><li>如果当前结点root为空，说明不存在权值为x的结点，返回</li><li>如果当前结点root的权值恰为给定的权值x，说明找到了想要删除的结点，进入删除处理<br>a. 如果当前结点root不存在左右孩子，说明是叶子结点，直接删除<br>b. 如果当前结点root存在左孩子，那么在左子树中寻找结点前驱pre，然后让pre的数据覆盖root，接着在右子树中删除节点next<br>c. 如果当前结点root存在右孩子，那么在右子树中寻找结点后继next，然后让next的数据覆盖root，接着在右子树中删除节点next</li><li>如果当前结点root的权值大于给定的权值x，则在左子树中递归删除权值为x的结点</li><li>如果当前结点root的权值大于給定的权值x，则在右子树中递归删除权值为x的结点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找以root为根结点的树中的最大权值结点</span></span><br><span class="line"><span class="function">node* <span class="title">findMax</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;rchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=root-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找以root为根结点的树中权值最小的结点</span></span><br><span class="line"><span class="function">node* <span class="title">findMin</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=root-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(node* &amp;root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data==x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;root-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            root=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        node* pre=findMax(root-&gt;lchild);</span><br><span class="line">        root-&gt;data=pre-&gt;data;</span><br><span class="line">        deleteNode(root-&gt;lchild,pre-&gt;data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        node* next=findMin(root-&gt;rchild);</span><br><span class="line">        root-&gt;data=next-&gt;data;</span><br><span class="line">        deleteNode(root-&gt;rchild,next-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data&gt;x)&#123;</span><br><span class="line">    deleteNode(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    deleteNode(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="二叉查找树的性质"><a href="#二叉查找树的性质" class="headerlink" title="二叉查找树的性质"></a>二叉查找树的性质</h2><p>对二叉查找树进行中序遍历，遍历的结果是有序的</p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>树的遍历</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      <content type="html"><![CDATA[<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><h3 id="树的静态写法"><a href="#树的静态写法" class="headerlink" title="树的静态写法"></a>树的静态写法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">typename</span> data;<span class="comment">//数据域</span></span><br><span class="line">  <span class="keyword">int</span> child[maxn];<span class="comment">//指针域，存放所有子结点的下标</span></span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;</span><br><span class="line">    <span class="built_in">vector</span> child;</span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    Node[index].data=v;</span><br><span class="line">    Node[index].child.clear();</span><br><span class="line">    <span class="keyword">return</span> index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树的先根遍历"><a href="#树的先根遍历" class="headerlink" title="树的先根遍历"></a>树的先根遍历</h3><p>先访问根结点，在访问子树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,Node[root].data);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[root].child/size();i++)&#123;</span><br><span class="line">        preorder(Node[root].child[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="树的层序遍历"><a href="#树的层序遍历" class="headerlink" title="树的层序遍历"></a>树的层序遍历</h3><p>与二叉树的层序遍历类似，一般使用一个队列来存放结点在数组中的下标，每次取出队首元素来访问，并将<br>其所有子结点加入队列，直到队列为空。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> front=q.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,Node[front].data);</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[front].child.size();i++)&#123;</span><br><span class="line">            q.push(Node[front].child[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要对结点的层次进行记录</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> layer;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    Node[root].layer=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> front=q.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,Node[front].data);</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[front].child.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> child = Node[front].child[i];</span><br><span class="line">            q.push(Node[front].child[i]);</span><br><span class="line">            q.push(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Memory</title>
      <link href="/%E8%AF%AD%E8%A8%80/Memory/"/>
      <url>/%E8%AF%AD%E8%A8%80/Memory/</url>
      <content type="html"><![CDATA[<ul><li>转载于<a href="https://github.com/xuelangZF/CS_Offer/blob/master/C%2B%2B/Memory.md" target="_blank" rel="noopener">https://github.com/xuelangZF/CS_Offer/blob/master/C%2B%2B/Memory.md</a></li></ul><p>内存管理是C++最令人切齿痛恨的问题，也是C++最有争议的问题，C++高手从中获得了更好的性能，更大的自由，C++菜鸟的收获则是一遍一遍的检查代码和对C++的痛恨，但内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生。</p><p>在C/C++中，进程地址空间分成5个区：</p><ol><li>正文(text)段：正文段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入口处（修改）操作——它是不可写的。</li><li><code>DATA段（数据段）</code>：初始化数据段包含程序中明确地赋初值的变量，例如初始化后的全局变量和静态局部变量。</li><li><code>BSS段（未初始化数据段）</code>：BSS段包含了程序中未初始化的全局变量，程序开始执行前，内核将此段中的数据初始化为0或者空指针。</li><li>堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</li><li>栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li></ol><p>下图显示了这些段的一种典型安排方式：</p><p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/C++_Memory_1.jpg" alt=""></p><p>看下面例子：</p><pre><code>void f() {     int* p=new int[5]; }</code></pre><p>在栈内存中存放了一个指向一块堆内存的指针p。程序首先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中指针 p。</p><h1 id="内存分配回收"><a href="#内存分配回收" class="headerlink" title="内存分配回收"></a>内存分配回收</h1><p>有时候需要一次为很多对象分配/释放内存，为此 C++ 提供了 new/delete 操作符。为了让 new 分配一个对象数组，需要在类型名后跟一对方括号，在其中指明要分配的对象的数目。</p><pre><code>int *pia = new int[10];typedef int arrT[10];   // arrT 表示 10 个int的数组类型 int *p = new arrT;      // 分配一个 10 个 int 的数组，p指向第一个int。编译器执行时和第一句完全一样</code></pre><p>虽然通常称new T[] 分配的内存为动态数组，但当我们用new分配一个数组时，并未得到一个<code>数组类型的对象</code>，而是得到一个相应元素类型的<strong>指针</strong>。由于分配的内存并不是一个数组类型，因此不能对动态数组调用 begin 或 end，也不能用范围 for 语句来处理动态数组中的元素，sizeof 的结果也和真正的数组类型的对象不同。</p><p>默认情况下，new 分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。不过也可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号。</p><pre><code>int *pia = new int[10];int *pia2 = new int[10](0);</code></pre><p>使用new操作符来分配对象内存时会经历三个步骤：</p><ol><li>调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</li><li>编译器运行相应的构造函数以构造对象，并为其传入初值。</li><li>对象构造完成后，返回一个指向该对象的指针。</li></ol><p>当我们使用一条 delete 表达式删除一个动态分配的对象时：</p><pre><code>delete sp;          // 销毁 *sp, 然后释放 sp 指向的内存空间delete [] arr;      // 销毁数组中的元素，然后释放对应的内存空间</code></pre><p>实际上执行了两步操作：</p><ol><li>对 sp 所指的对象或者 arr 所指的数组中的元素执行对应的析构函数。</li><li>编译器调用标准库operator delete(或operator delete[])函数释放内存空间。</li></ol><p>数组中的元素按逆序销毁，即最后一个元素首先被销毁，然后是倒数第二个，依次类推。当释放一个指向数组的指针时，空方括号对是必需的：它指示编译器此指针指向一个对象数组的第一个元素。<strong>如果在 delete 一个指向数组的指针时忽略了方括号，或者在 delete 一个指向单一对象的指针时使用了方括号，其行为是未定义的。</strong></p><p>［<a href="http://www.nowcoder.com/questionTerminal/84598a88502c499d995db941c5fb62a2" target="_blank" rel="noopener">内存管理错误代码</a>］<br>［<a href="http://www.nowcoder.com/questionTerminal/9fb652d48bee45bcb47771b2e3c6f690" target="_blank" rel="noopener">delete 内存泄漏</a>］  </p><h2 id="malloc-和-free-操作"><a href="#malloc-和-free-操作" class="headerlink" title="malloc 和 free 操作"></a>malloc 和 free 操作</h2><p><code>void *malloc(long NumBytes)</code> 分配 NumBytes 个字节，并返回了指向这块内存的首指针。如果分配失败，则返回一个空指针（NULL）。分配失败的原因有多种，比如说空间不足就是一种。malloc() 是从堆里面分配空间，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</p><p>malloc()分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息——分配块的长度，分配块是否已经可用（free 掉）。用结构体来记录管理信息，如下：</p><pre><code>struct mem_control_block {     int is_available;    //该块是否可用；    int size;            //该块可用空间的大小 };</code></pre><p><code>void free(void *FirstByte)</code> 将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存，让它重新得到自由。free()释放的是<code>指针指向的内存</code>！指针并没有被释放，指针仍然指向原来的存储空间。指针是一个变量，只有程序结束时才被销毁。释放了内存空间后，原来指向这块空间的指针还是存在！只不过现在指针指向的内容是未定义的，因此，释放内存后最好把指针指向NULL，防止后面不小心又解引用该指针了。</p><p>free()函数非常简单，只有一个参数，只要把指向申请空间的指针传递给free()即可。这是因为 free 是根据结构体 mem_control_block 的信息来释放malloc()申请的空间。</p><pre><code>void free(void *ptr){    struct mem_control_block *free;    free = ptr - sizeof(struct mem_control_block);    free-&gt;is_available = 1;    return;}</code></pre><p>malloc 的一个具体使用例子在 <a href="https://gist.github.com/xuelangZF/573b1da0fbe0e7c6a568bd9530456766" target="_blank" rel="noopener">gist</a> 上。</p><h2 id="new-和-malloc-的对比"><a href="#new-和-malloc-的对比" class="headerlink" title="new 和 malloc 的对比"></a>new 和 malloc 的对比</h2><ol><li>new/delete是C++操作符，malloc/free是C/C++函数。</li><li>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的大小。</li><li>new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构，而malloc只负责分配空间。</li><li>new 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void <em> ，需要通过强制类型转换将 void</em> 指针转换成我们需要的类型。</li><li>效率上：malloc的效率高一点，因为只分配了空间。</li><li>operator new /operator delete 可以被重载，而 malloc/free 并不允许重载。</li></ol><h2 id="常见的内存错误"><a href="#常见的内存错误" class="headerlink" title="常见的内存错误"></a>常见的内存错误</h2><p>常见内存错误以及解决办法:</p><ul><li>内存分配未成功，却使用了它。（在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用<code>assert(p!=NULL)</code>进行检查。如果是用malloc或new来申请内存，应该用<code>if(p==NULL)</code>或<code>if(p!=NULL)</code>进行防错处理。）</li><li>内存分配虽然成功，但是尚未初始化就引用它。（无论用何种方式创建数组，都应该初始化）</li><li>内存分配成功并且已经初始化，但操作越过了内存的边界。例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</li><li>忘记了释放内存，造成内存泄露。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete）。</li><li>释放了内存却继续使用它。</li></ul><h1 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h1><p>缓冲区是一块可读写的连续的计算机内存区域，高级语言定义的变量、数组、结构体等在运行时可以说都是保存在缓冲区内的。除了代码段和受操作系统保护的数据区域，其他的内存区域都可以作为<code>缓冲区</code>，因此缓冲区溢出的位置可能在.Data 和 .BSS段，也可能在堆、栈段。</p><ul><li>.Data段和.BSS段存储了用户程序的全局变量，静态变量等；</li><li>栈空间存储了用户程序的<code>函数栈帧</code>（包括参数、局部数据等），用来实现函数调用机制。</li><li>堆空间存储了程序运行时动态申请的内存数据等。</li></ul><p>在C/C++语言中，通常使用<code>字符数组</code>和<code>malloc/new</code>内存分配函数来分配缓冲区。使用这些缓冲区时，理想的情况是程序检查数据长度，不允许输入超过缓冲区长度的字符。但是绝大多数程序并不会保证数据长度总是与所分配的缓冲区空间相匹配，这就会导致<code>缓冲区溢出</code>问题。</p><h2 id="函数栈帧"><a href="#函数栈帧" class="headerlink" title="函数栈帧"></a>函数栈帧</h2><p>栈的主要功能是实现函数的调用，在介绍栈溢出原理之前，需要弄清函数调用时栈空间发生了怎样的变化。每次函数调用时，系统会把函数的返回地址（函数调用指令后紧跟指令的地址），一些关键的寄存器值保存在栈内，函数的实际参数和局部变量（包括数据、结构体、对象等）也会保存在栈内。这些数据统称为<code>函数调用的栈帧</code>，而且每次函数调用都会有个独立的栈帧，这也为递归函数的实现提供了可能。</p><p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/C++_Memory_2.jpg" alt=""></p><p>如图所示，定义了一个简单的函数function，它接受一个整形参数，做一次乘法操作并返回。当调用function(0)时，arg参数记录了值0入栈，并将call function指令下一条指令的地址0x00bd16f0保存到栈内，然后跳转到function函数内部执行。每个函数定义都会有函数头和函数尾代码，如图绿框表示。因为函数内需要用ebp寄存器保存函数栈帧基址，因此先保存ebp原来的值到栈内，然后将栈指针esp内容保存到ebp。函数返回前需要做相反的操作——将esp指针恢复，并弹出ebp。</p><p>之所以会有缓冲区溢出的可能，主要是因为<strong>栈空间内保存了函数的返回地址</strong>。该地址保存了函数调用结束后后续执行的指令的位置，对于计算机安全来说，该信息是很敏感的。如果有人恶意修改了这个返回地址，并使该返回地址指向了一个新的代码位置，程序便能从其它位置继续执行。也就是说攻击者可以利用缓冲区溢出来窜改进程运行时栈，从而改变程序正常流向，轻则导致程序崩溃，重则系统特权被窃取。</p><h2 id="溢出原理"><a href="#溢出原理" class="headerlink" title="溢出原理"></a>溢出原理</h2><p>从根本上讲，在程序将数据读入或复制到缓冲区中的任何时候，它需要在复制之前检查是否有足够的空间。遗憾的是，C 和 C++ 附带的大量危险函数（或普遍使用的库）无法做到这点。程序对这些函数的任何使用都是一个警告信号，因为除非慎重地使用它们，否则它们就会成为程序缺陷。</p><p>比如在使用不安全的strcpy库函数时，系统会盲目地将data的全部数据拷贝到buffer指向的内存区域。buffer的长度是有限的，一旦data的数据长度超过BUF_LEN，便会产生缓冲区溢出。如下图所示：</p><p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/C++_Memory_3.jpg" alt="溢出示例"></p><p>由于栈是低地址方向增长的，因此局部数组buffer的指针在缓冲区的下方。当把data的数据拷贝到buffer内时，超过缓冲区区域的高地址部分数据会“淹没”原本的其他栈帧数据，根据淹没数据的内容不同，可能会有产生以下情况：</p><ol><li>淹没了其他的局部变量。如果被淹没的局部变量是条件变量，那么可能会改变函数原本的执行流程。这种方式可以用于破解简单的软件验证。</li><li>淹没了ebp的值。修改了函数执行结束后要恢复的栈指针，将会导致栈帧失去平衡。</li><li>淹没了返回地址。这是栈溢出原理的核心所在，通过淹没的方式修改函数的返回地址，使程序代码执行“意外”的流程！</li><li>淹没参数变量。修改函数的参数变量也可能改变当前函数的执行结果和流程。</li><li>淹没上级函数的栈帧，情况与上述4点类似，只不过影响的是上级函数的执行。当然这里的前提是保证函数能正常返回，即函数地址不能被随意修改。</li></ol><p>如果在data本身的数据内就保存了一系列的指令的二进制代码，一旦栈溢出修改了函数的返回地址，并将该地址指向这段二进制代码的真实位置，那么就完成了基本的溢出攻击行为。</p><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p><p>内存泄漏是最难发现的常见错误之一，因为除非用完内存或调用malloc失败，否则都不会导致任何问题。实际上，使用C/C++这类没有垃圾回收机制的语言时，很多时间都花在处理如何正确释放内存上。如果程序运行时间足够长，如后台进程运行在服务器上，只要服务器不宕机就一直运行，一个小小的失误也会对程序造成重大的影响，如造成某些关键服务失败。</p><p>C++中的内存泄露一般指<code>堆中的内存泄露</code>。堆内存是我们手动malloc/realloc/new申请的，程序不会自动回收，需要调用free或delete手动释放，否则就会造成内存泄露。内存泄露常见的原因大概有以下几种：</p><ol><li>“无主”内存：申请内存后，指针指向内存的起始地址，若丢失或修改这个指针，那么申请的内存将丢失且没法释放。</li><li>异常分支导致资源未释放：程序正常执行没有问题，但是如果遇到异常，正常执行的顺序或分支会被打断，得不到执行。所以在异常处理的代码中，要确保系统资源的释放。</li><li>类的析构函数为非虚函数：析构函数为虚函数，利用多态来调用指针指向对象的析构函数，而不是基类的析构函数。</li></ol><p>下面来看一个简单的内存泄漏示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *x = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> *y = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">// free(x);</span></span><br><span class="line">    <span class="comment">// delete []y;</span></span><br><span class="line">    <span class="comment">// x = NULL;</span></span><br><span class="line">    <span class="comment">// y = NULL;</span></span><br><span class="line">&#125;                    <span class="comment">// problem here: memory leak -- x, y not freed</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存泄漏检测"><a href="#内存泄漏检测" class="headerlink" title="内存泄漏检测"></a>内存泄漏检测</h2><p>内存泄露检测的关键在于记录分配内存和释放内存的操作，看看能不能匹配。跟踪每一块内存的声明周期，例如：每当申请一块内存后，把指向它的指针加入到List中，当释放时，再把对应的指针从List中删除，到程序最后检查List就可以知道有没有内存泄露了。</p><p>在一般的linux发行版中，有一个自带的工具可以很方便的替你完成这些事，这个工具就是mtrace。mtrace为内存分配、释放函数（malloc, realloc, memalign, free）安装hook函数，这些hook函数记录内存申请和释放的trace信息。 </p><p>不过还有一款强大的检测工具 Valgrind，它是运行在Linux上一套基于仿真技术的程序调试和分析工具，包含一个内核——一个软件合成的CPU，和一系列的小工具，每个工具都可以完成一项任务──调试，分析，或测试等，其中Memcheck 工具可以用来方便的检测内存泄漏。</p><p>可以用下面命令检测程序是否发生内存泄漏：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --leak-check=yes ./demo.o</span><br></pre></td></tr></table></figure><p>对于下面的程序来说</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* still_reachable;</span><br><span class="line">Node* possible_lost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *tmp = <span class="keyword">new</span> Node;   <span class="comment">// definitely_lost</span></span><br><span class="line">    tmp-&gt;next = <span class="keyword">new</span> Node;   <span class="comment">// indirectly_lost</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    show();</span><br><span class="line">    still_reachable = <span class="keyword">new</span> Node;</span><br><span class="line">    possible_lost = <span class="keyword">new</span> Node[<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有四种类型的内存泄漏（关于这四种泄漏类型的详细内容，参考  <a href="http://valgrind.org/docs/manual/mc-manual.html#mc-manual.leaks" target="_blank" rel="noopener">Memory leak detection</a>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">==45310== LEAK SUMMARY:</span><br><span class="line">==45310==    definitely lost: 16 bytes <span class="keyword">in</span> 1 blocks</span><br><span class="line">==45310==    indirectly lost: 16 bytes <span class="keyword">in</span> 1 blocks</span><br><span class="line">==45310==      possibly lost: 2,096 bytes <span class="keyword">in</span> 2 blocks</span><br><span class="line">==45310==    still reachable: 16 bytes <span class="keyword">in</span> 1 blocks</span><br><span class="line">==45310==         suppressed: 20,125 bytes <span class="keyword">in</span> 189 blocks</span><br><span class="line">==45310== Reachable blocks (those to <span class="built_in">which</span> a pointer was found) are not shown.</span><br></pre></td></tr></table></figure><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://www.cnblogs.com/QG-whz/p/5140930.html" target="_blank" rel="noopener">细说new与malloc的10点区别</a><br><a href="http://stackoverflow.com/questions/93039/where-are-static-variables-stored-in-c-c" target="_blank" rel="noopener">Where are static variables stored (in C/C++)?</a><br><a href="http://www.inf.udec.cl/~leo/teoX.pdf" target="_blank" rel="noopener">Memory management in C: The heap and the stack</a><br><a href="http://www.cnblogs.com/clover-toeic/p/3737011.html" target="_blank" rel="noopener">缓冲区溢出详解</a><br><a href="http://www.cnblogs.com/fanzhidongyzby/p/3250405.html" target="_blank" rel="noopener">缓冲区溢出攻击</a><br><a href="http://blog.jobbole.com/95375/" target="_blank" rel="noopener">C/C++内存泄漏及检测</a><br><a href="http://valgrind.org/docs/manual/mc-manual.html#mc-manual.leaks" target="_blank" rel="noopener">Doc: Valgrind：Memory leak detection</a><br><a href="http://zhiqiang.org/note/md/check-cpp-memory-with-valgrind.html" target="_blank" rel="noopener">用valgrind检查C++程序的内存泄漏</a><br><a href="http://www.csee.umbc.edu/~chang/cs313.s02/stack.shtml" target="_blank" rel="noopener">C Function Call Conventions and the Stack</a>  </p>]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      <content type="html"><![CDATA[<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p>二叉树的遍历是指通过一定的顺序访问二叉树的所有结点。<br>一般包括：先序遍历、中序遍历、后序遍历、层次遍历<br>先序、中序、后序的遍历一般通过深度优先搜索实现，层次遍历一般通过广度优先搜索实现。</p><h2 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1. 先序遍历"></a>1. 先序遍历</h2><p>遍历顺序：根结点-&gt;左子树-&gt;右子树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">    preorder(root-&gt;lchild);</span><br><span class="line">    preorder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h2><p>遍历顺序：左子树-&gt;根结点-&gt;右子树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">    inorder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h2><p>遍历顺序：左子树-&gt;右子树-&gt;根结点<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(root-&gt;lchild);</span><br><span class="line">    postorder(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-层序遍历"><a href="#4-层序遍历" class="headerlink" title="4. 层序遍历"></a>4. 层序遍历</h2><p>层序遍历指按层次的顺序从根结点向下逐层进行遍历，且对同一层的节点为从左到右遍历。<br>基本思路：从根结点开始广度优先搜索</p><ul><li>将根结点root加入队列</li><li>取出队首结点，访问它</li><li>如果该结点有左孩子，将左孩子入队。</li><li>如果该结点有右孩子，将右孩子入队</li><li><p>返回第二步，直到队列为空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node* now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,noe-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;lchild!=<span class="literal">NULL</span>) q.push(now-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;rchild!=<span class="literal">NULL</span>) q.push(now-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果题目要求计算每个结点所处层次，可以在二叉树结点的定义中添加一个记录层次的layer变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> layer;</span><br><span class="line">    node* lchild;</span><br><span class="line">    node* rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node*&gt; q;</span><br><span class="line">    root-&gt;layer=<span class="number">1</span>;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node* now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,noe-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                now-&gt;lchild-&gt;layer=now-&gt;layer+<span class="number">1</span>;</span><br><span class="line">                q.push(now-&gt;lchild);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;rchild!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            now-&gt;rchild-&gt;layer=now-&gt;layer+<span class="number">1</span>;</span><br><span class="line">                q.push(now-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>问题：给定一棵二叉树的先序遍历序列和中序遍历序列（或者给定后序序列和中序序列），要求重建这棵二叉树。</p><h3 id="中序序列-确定左右子树-可以与先序序列、后序序列、层序序列（确定根结点）中的任意一个来构建唯一地二叉树，后三者任意搭配都不能构建唯一的二叉树"><a href="#中序序列-确定左右子树-可以与先序序列、后序序列、层序序列（确定根结点）中的任意一个来构建唯一地二叉树，后三者任意搭配都不能构建唯一的二叉树" class="headerlink" title="中序序列(确定左右子树)可以与先序序列、后序序列、层序序列（确定根结点）中的任意一个来构建唯一地二叉树，后三者任意搭配都不能构建唯一的二叉树"></a>中序序列(确定左右子树)可以与先序序列、后序序列、层序序列（确定根结点）中的任意一个来构建唯一地二叉树，后三者任意搭配都不能构建唯一的二叉树</h3><p>假设已知先序序列为pre1,pre2……中序序列为in1,in2……<br>则先序序列中的第一个元素pre1是当前二叉树的根结点<br>当前二叉树的根结点又将中序序列划分为左子树和右子树，在中序序列中找到某个结点ink，使得ink=pre1。<br>左子树结点个数numLeft=k-1，同时可得出左右子树的先序和中序序列区间。<br>递归边界：先序序列的长度小于等于0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> prel ,<span class="keyword">int</span> prer,<span class="keyword">int</span> inl,<span class="keyword">int</span> inr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prel&lt;prer)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* root=<span class="keyword">new</span> node;</span><br><span class="line">    root-&gt;data=pre[prel];</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k=inl;k&lt;=inr;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[k]==pre[prel])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numLeft=k-inl;</span><br><span class="line">    root-&gt;lchild=create(prel+<span class="number">1</span>,prel+numLeft,inl,k<span class="number">-1</span>);</span><br><span class="line">    root-&gt;rchild=create(prel+numLeft+<span class="number">1</span>,prer,k+<span class="number">1</span>,inr);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二叉树的静态实现"><a href="#二叉树的静态实现" class="headerlink" title="二叉树的静态实现"></a>二叉树的静态实现</h3><p>不用指针，只用数组实现二叉树基本操作</p><ul><li>静态二叉链表<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;</span><br><span class="line">    <span class="keyword">int</span> lchild;</span><br><span class="line">    <span class="keyword">int</span> rchild;</span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    Node[index].data=v;</span><br><span class="line">    Node[index].lchild=<span class="number">-1</span>;</span><br><span class="line">    Node[index].rchild=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二叉树的查找、插入、建立"><a href="#二叉树的查找、插入、建立" class="headerlink" title="二叉树的查找、插入、建立"></a>二叉树的查找、插入、建立</h3><p>root为根结点在数组中的下标<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> x,<span class="keyword">int</span> newdata)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Node[root].data==x)&#123;</span><br><span class="line">        Node[root].data=newdata;</span><br><span class="line">    &#125;</span><br><span class="line">    search(Node[root].lchild,x,newdata);</span><br><span class="line">    search(Node[root].rchil,x,newdata);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="number">-1</span>)&#123;</span><br><span class="line">        root==newNode(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x插在左子树)&#123;</span><br><span class="line">        insert(Node[root].lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    insert(Node[root].rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        insert(root,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的遍历-1"><a href="#二叉树的遍历-1" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Node[root].data);</span><br><span class="line">    preorder(Node[root].lchild);</span><br><span class="line">    preorder(Node[root].rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(Node[root].lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Node[root].data);</span><br><span class="line">    inorder(Node[root].rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(Node[root].lchild);</span><br><span class="line">    postorder(Node[root].rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Node[root].data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,Node[now].data);</span><br><span class="line">        <span class="keyword">if</span>(Node[now].lchild!=<span class="number">-1</span>) q.push(Node[now].lchild);</span><br><span class="line">        <span class="keyword">if</span>(Node[now].rchild!=<span class="number">-1</span>) q.push(Node[now].rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>《素媛》与《熔炉》</title>
      <link href="/%E9%9A%8F%E7%AC%94/%E3%80%8A%E7%B4%A0%E5%AA%9B%E3%80%8B%E4%B8%8E%E3%80%8A%E7%86%94%E7%82%89%E3%80%8B/"/>
      <url>/%E9%9A%8F%E7%AC%94/%E3%80%8A%E7%B4%A0%E5%AA%9B%E3%80%8B%E4%B8%8E%E3%80%8A%E7%86%94%E7%82%89%E3%80%8B/</url>
      <content type="html"><![CDATA[<h1 id="现实依旧残酷"><a href="#现实依旧残酷" class="headerlink" title="现实依旧残酷"></a>现实依旧残酷</h1><p>　　最近看了两部韩国电影，正好五一假期有空，想写点什么。在知乎上看过一个话题，人开始废掉的标志是什么？记得有人答说当一个人沉迷于短期便可轻易获得快感的事物时，有人答说当一个开始拒绝输出的时候便是废掉的开始。我感到恐慌，我意识到尽管一天到晚都在读书，在听歌看电影，在接受各种信息，但我不能一位接收而不输出，其实这也是我搞这个静态博客的初衷。我知道自己文笔不行，但我还是想写点东西，想记录点生活。论文学，读了《红楼梦》便知道什么才是大家之作，这样的奇书需要怎么的积淀才能写就。很明显，一般人都达不到这样的高度，但这并不妨碍我继续输出自己的想法，学编程也一样，当一个人学编程只看书看视频听课，却从不自己不敲代码，那么注定是失败的学习者，而敲代码的过程，其实也就是输出的过程。<br>　　<img src="/img/熔炉.jpg" alt="Alt text"></p><p>　　回到正题，为什么要把素媛和熔炉放到一起，一个显然的原因就是这两部都是反映未成年人被性侵的黑现实题材，我不清楚是因为自己接触的电影太少，还是不了解国内状况，为什么中国相应的题材电影没有令我印象深刻的，难道我们国家已经社会和谐，大家都生活在了一个幸福美满的国度里了吗，甚至已经没必要在去关注未成年人的成长问题？素媛和熔炉都是根据真实事件改编的电影，韩国在反映黑暗面现实题材的电影方面似乎做得比较好，有些放在国内怕是审批都过不了，两部电影最后的结局让人痛心与无奈，但这也是电影出彩的一个方面之一吧。以往很多电影，剧情发展到后期，基本就是坏蛋绳之以法，恶有恶报。但不得不承认，现实中很多人的恶报来的并没那么快，被害人可能死不瞑目，犯人却依旧逍遥法外的情况并不少，冤判，错判，更恶劣的，权钱交易，有钱有势的才是爹，普通人的生命就如草芥一般。寒假看的红楼梦，其实曹公也写到了很多底层人的生活，起初读红楼梦可能只关注到宝玉、宝钗、黛玉三者恋为主线的少男少女之间的情情爱爱，但这其实就低估了曹公的作品了，从繁华到幻灭，情确实是红楼梦的一大主题，但其实里面写到了很多卑微者的命运，很多人无力反抗这样命运，最终只能认命。<br>　　<img src="/img/素媛.jpg" alt="Alt text"><br>　　2012年夏天，7岁女童独自在家睡觉，半夜被一男子入室掳走，实施了强奸和殴打，事后该男子用树枝和其他条状硬物捅女童的阴道和肠道，女童被附近的居民发现在一条小河边，当时下着雨，女童重度昏迷，大小便失禁，血肉模糊。送医治疗后经诊断，肠道没有一处完好的地方，手术几乎把肠子全部切除，阴道和肠道中间的部分全部破坏，阴道在外伤的情况下又被粪便感染，子宫受损，也就是说，子宫，阴道，肠道都受到重创，安装了人造肛门之后，终身都要带着便便袋生活，有可能无月经无生育能力。孩子很惨，但凶手抓到后拒不认罪，不赔偿，孩子的父母都是普通老百姓，支付医药费都很困难，一直申诉，一方面是为女儿讨公道，一方面是想得到赔偿给孩子更好的治疗。这就是素媛背后的真实事件，其实比起熔炉，素媛这部电影倒是让人感到更加温暖。影片其实可以注意到很多人物心理、行为等在事发前后发生了巨大的变化。素媛的爸爸就令人感动，在平常日子里，从吃饭时的自顾自，对素媛的生活，学习等等虽不能说毫不在意吧，但确实没花多少心思在自己的女儿身上，事发后，后悔自然无用，但我们看到了一个父亲应有的担当，你能想象一个大男人，在大夏天穿着那种厚厚的卡通套装，只为陪伴在女儿身边，为了接触他，让她开心，安心，试问生活中的父亲都表现的如何？之所以说这部电影暖心，不仅仅是事发家庭成员自身的坚强，当然其实他们也已经到了崩溃的边缘，记得素媛的母亲甚至抱怨，为什么那么多小孩，这种事为什么偏偏发生在自己的女儿身上，我宁愿所有人的小孩都遭受同样的伤害！这其实也是痛苦的一种发泄。<br>　　素媛其实除了批判，总体上格调还是偏暖的。其中有很多震撼的地方，尤其是素媛，这个9岁的小女孩竟然能这么懂事，心智竟然已经如此成熟。发生不幸，他仍能想到自己的爸妈，能体会到爸妈的痛苦，甚至知道为自己治病家里要花不少钱，他会内疚。素媛与夙愿，这是一个寓意着希望的女孩，活着就是希望，更何况还能看到她灿烂的笑容。最后判决如此不公，冲动的父亲甚至打算与凶手同归于尽，但就在砸向凶手的瞬间，冲动的父亲被素媛抱住了，她不希望父亲做傻事。事发后，身边的朋友捐款的捐款，素媛的同学也在默默支持着他。这里有个叫荣植的小胖子很可爱，他后面来到素媛的店门口，对他父亲说，当时如果等素媛一起上学，素媛就不会出这种事了，他觉得很自责，然后嚎啕大哭，这是一个小孩的真性情。回到主旋律，还是反映了社会对未成年人的淡漠，素媛其实是一个非常单纯善良的小女孩，即是自己上学迟到了，但不给坏叔叔撑伞却还是于心不忍，注意到这里他只是认为想帮助别人，但实际上身边的人非但没有夸她，反认为是她的错。也许很多人心想，你何苦这么好心，自己都要来不及上课了，还想着别人？另外，事发后还有一帮人很令人淡漠，一帮是那群媒体记者，于他们而言，这是热点，当然得蜂拥往上挤，可是除了采访，他们几乎完全没有顾及当事人的感受。另一帮人就是法庭上那帮家伙了，我很好奇为嫌疑人辩护的律师内心是什么想法，当她对着一个9岁的受害女孩提问时能如此正气？<br>　　而《熔炉》怕是就比较沉重了。完全反应的是人性的黑暗面，格调悲凉而沉重。<br>　　《熔炉》，是根据韩国光州一所聋哑学校校长性侵儿童的真实事件改编的电影，真实事件中，从校长到老师共10余人，先后对超过30名聋哑儿童进行性侵，有很多连10岁都还不到。其实小说和电影的改编免不了要进行艺术方面的加工，现实中的黑暗恐怕更是令人难以想象。为什么于我而言，素媛偏向温暖，而熔炉却是令人沉痛。事实上，两者之间的社会危害性的强度也是显然有强弱之分的。素媛里的犯人仅仅只是一个普通的无奈，一个有前科的混混，另外素媛还有很多关系她的人，不仅仅只是她的父母。而熔炉不同，熔炉事件的双方是差距悬殊的，一方是有权有势的聋哑学校校长，另一方很多甚至都是无父无母的残障儿童，在这样差距悬殊的情况下，一旦人性黑暗面涌现，受害的一方是显然并且是毫无还手之力的。影片中孩子们唯一的幸运是遇到了一个好老师，男主和女主为了救孩子确实尽了全力，我影片结尾我们都看到了，罪恶的一方并没有受到相应的处罚，其实这也是很多现实事件的真实写照。倘若，这些孩子一直没有遇到善良的能帮助他们的人，结果又会如何，惨遭毒手的孩子只会继续增加。社会上好人确实不少，但坏人不能说已经没有了，尤其是一些有权有势的坏人克服不了自己人性黑暗的一面，那么造成的后果必然是灾难性的，弱势群体得不到保护，一方面作为法治社会体现了制度上的欠缺，法律不够完善，另一方面，这是一起社会事件，更大程度上反映了集体意识的淡漠。事不关己高高挂起，何苦自讨没趣去得罪哪些大人物呢？越得不到重视，黑暗面便越猖狂，社会也就越畸形。<br>　　最后撇开电影，回到自己。说实话，影片中的事件都是我无法想象和体会的，或者说触动可能还不是特别强烈。因为我长这么大，都还算生活在一个相对阳光的环境里，认识了很多人，可以说有好有坏。但其实人性是复杂的，一般碰到的人很少回想小说或电影里讲人性展现的非常露骨，人们可能会不知不觉隐藏自己的某一面。无论怎么说，我接触到的同学，老师，长辈，陌生人，可能这个让你讨厌，那个令你烦恼，但不至于说他是一个坏人，未成年人受到欺凌的事件我遇到过，但也许并没有引起自己的关注，首先那时我自己也是个小孩，因为没碰到很严重的，我会以为他们只是一言不合，打起架来了。从小到大，由于自己多愁善感的性格，可以说是烦恼不断，但困扰自己的无非是些普普通通的小事，人生不如意事十之八九嘛。但如果电影中的事件发生在自己身边，自己会表现为一个怎样的角色，我甚至不敢想，为什么不敢想，因为很可能，如果受害者不是自己的亲人，可能也就是感叹一番，为自己茶余饭后多了点谈资罢了，我真的会去做些什么吗？会作为正义的化身，不顾生死与暗势力反抗吗？至于其他人，可能还在为自己的房贷车贷发愁呢。熔炉的真实事件是涉及到了暗杀的程度，没有勇气，只有一腔热血的你会不会坚持正义？再进步一步，如果受害者是自己或者是自己的亲人，你会怎么做，这时怕是做不到无动于衷了吧？你又能做些什么？注意到，一般受害的往往是弱势群体，也就是你没钱没权没话语权。你相信法庭吗？你相信律师吗？你相信警察吗？不瞎写了，代码还没敲完呢…回见　　</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影视 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>葬花词</title>
      <link href="/%E6%91%98%E5%BD%95/%E8%91%AC%E8%8A%B1%E8%AF%8D/"/>
      <url>/%E6%91%98%E5%BD%95/%E8%91%AC%E8%8A%B1%E8%AF%8D/</url>
      <content type="html"><![CDATA[<h1 id="程高通行本《葬花吟》"><a href="#程高通行本《葬花吟》" class="headerlink" title="　　　程高通行本《葬花吟》"></a>　　　程高通行本《葬花吟》</h1><p><img src="/img/黛玉葬花.jpg" alt="Alt text"></p><p>　　　　　　　　　花谢花飞花满天，红消香断有谁怜？<br>　　　　　　　　　游丝软系飘春榭，落絮轻沾扑绣帘。<br>　　　　　　　　　闺中女儿惜春暮，愁绪满怀无释处。<br>　　　　　　　　　手把花锄出绣帘，忍踏落花来复去。<br>　　　　　　　　　柳丝榆荚自芳菲，不管桃飘与李飞；<br>　　　　　　　　　桃李明年能再发，明年闺中知有谁？<br>　　　　　　　　　三月香巢已垒成，梁间燕子太无情！<br>　　　　　　　　　明年花发虽可啄，却不道人去梁空巢也倾。<br>　　　　　　　　　一年三百六十日，风刀霜剑严相逼；<br>　　　　　　　　　明媚鲜妍能几时，一朝漂泊难寻觅。<br>　　　　　　　　　花开易见落难寻，阶前愁杀葬花人，<br>　　　　　　　　　独倚花锄泪暗洒，洒上空枝见血痕。<br>　　　　　　　　　杜鹃无语正黄昏，荷锄归去掩重门；<br>　　　　　　　　　青灯照壁人初睡，冷雨敲窗被未温。<br>　　　　　　　　　怪奴底事倍伤神？半为怜春半恼春。<br>　　　　　　　　　怜春忽至恼忽去，至又无言去未闻。<br>　　　　　　　　　昨宵庭外悲歌发，知是花魂与鸟魂？<br>　　　　　　　　　花魂鸟魂总难留，鸟自无言花自羞；<br>　　　　　　　　　愿侬此日生双翼，随花飞到天尽头。<br>　　　　　　　　　天尽头，何处有香丘？<br>　　　　　　　　　未若锦囊收艳骨，一抔净土掩风流3。<br>　　　　　　　　　质本洁来还洁去，强于污淖陷渠沟。<br>　　　　　　　　　尔今死去侬收葬，未卜侬身何日丧？<br>　　　　　　　　　侬今葬花人笑痴，他年葬侬知是谁？<br>　　　　　　　　　试看春残花渐落，便是红颜老死时；<br>　　　　　　　　　一朝春尽红颜老，花落人亡两不知！</p>]]></content>
      
      <categories>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树的定义与性质</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%80%A7%E8%B4%A8/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%80%A7%E8%B4%A8/</url>
      <content type="html"><![CDATA[<h2 id="树的定义与性质"><a href="#树的定义与性质" class="headerlink" title="树的定义与性质"></a>树的定义与性质</h2><p>由若干结点和若干条边组成的数据结构。<br>常用性质：</p><ol><li>树可以没有结点，这种情况把树称为空树。</li><li>树的层次从根结点开始算起，即根结点为第一层，根结点子树的根结点为第二层，以此类推。</li><li>把结点的子树棵数称为结点的度，树中结点的最大的度称为树的度。</li><li>由于一条边连接两个结点，且树中不存在环，因此对有n个结点的树，边数一定是n-1.<br>满足连通、边数等于顶点数-1的结构一定是一棵树。</li><li>叶子结点被定义为度为0的结点，因此当树中只有一个结点（即只有根结点）时，根结点也算作叶子结点。</li><li>结点的深度是指从根结点（深度为1）开始自顶向下逐层累加至该结点的深度值。<br>结点的高度是指从最底层叶子结点开始自底向上逐层累加至该结点时的高度值。<br>树的深度是指树中结点的最大深度，树的高度是指树中结点的最大高度。对树而言，深度与高度相等。</li><li>多棵树组合在一起称为森林，即森林是若干树的集合。<h2 id="二叉树的递归定义（用自身定义自身）"><a href="#二叉树的递归定义（用自身定义自身）" class="headerlink" title="二叉树的递归定义（用自身定义自身）"></a>二叉树的递归定义（用自身定义自身）</h2></li><li>二叉树要么没有根结点，是一棵空树。</li><li>二叉树要么由根结点、左子树。右子树组成，且左子树和右子树都是二叉树。</li></ol><ul><li>两种特殊二叉树</li></ul><ol><li>满二叉树： 每一层的结点个数都达到了当层能达到的最大结点数</li><li>完全二叉树： 除了最下面一层之外，其余层的结点个数都达到了当层能达到的最大结点数，<br>且最下面一层只从左到右连续存在若干结点，而这些结点右边的结点全部不存在。</li></ol><ul><li>树的其他概念</li></ul><ol><li>层次：层次类似于家谱中的辈分关系</li><li>孩子结点、父亲结点、兄弟结点、祖先结点、子孙结点：一个结点的子树的根结点称为它的孩子结点，<br>而它称为孩子节点的父亲结点。与该结点同父亲的结点称为该结点的兄弟结点。<h2 id="二叉树的存储结构与基本操作"><a href="#二叉树的存储结构与基本操作" class="headerlink" title="二叉树的存储结构与基本操作"></a>二叉树的存储结构与基本操作</h2></li><li><p>二叉树的存储结构<br>与链表类似，只是指针域改为两个——指向左子树的根结点地址和右子树的根结点地址。<br>如果某个子树不存在，则指向NULL</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">typename</span> data;<span class="comment">//数据域</span></span><br><span class="line">  node* lchild;<span class="comment">//指向左子树根结点的指针</span></span><br><span class="line">  node* rchild;<span class="comment">//指向右子树根结点的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//根结点初始化</span></span><br><span class="line">node* root=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//往二叉树中插入结点</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">  node* Node = <span class="keyword">new</span> node;<span class="comment">//申请一个node型变量的地址空间</span></span><br><span class="line">  Node-&gt;data=v;<span class="comment">//结点权值</span></span><br><span class="line">  Node-lchild=Node-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> Node;<span class="comment">//返回新建结点的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉树的查找、修改<br>查找操作是指在给定数据域的条件下，在二叉树中找到所有数据域为给定数据域的结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root,<span class="keyword">int</span> x,<span class="keyword">int</span> newdata)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;<span class="comment">//空树（递归边界）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data==x)&#123;<span class="comment">//找到数据域为x的结点，把它修改为newdata</span></span><br><span class="line">        root-&gt;data=newdata;</span><br><span class="line">    &#125;</span><br><span class="line">    search(root-&gt;lchild,x,newdata);<span class="comment">//往左子树搜索x（递归式）</span></span><br><span class="line">    search(root-&gt;rchild,x,newdata);<span class="comment">//往右子树搜索x（递归式）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉树结点的插入<br>结点的插入位置一般取决于数据域需要在二叉树中存放的位置，且对給定结点来说，它在二叉树中的插入位置只会有一个。<br>即二叉树结点的插入位置就是数据域在二叉树中查找失败的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;<span class="comment">//空树，即查找失败，即插入位置（递归边界）</span></span><br><span class="line">        root=newNode(x);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x需插在左子树)&#123;</span><br><span class="line">        insert(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    insert(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">上述中，根结点指针root使用了&amp;引用，即在函数中修改root会直接修改原变量，如果不用引用，就无法将</span><br><span class="line">新结点接到二叉树上面，而search函数中修改的是指针root指向的内容，而不是root本身，所以不需要引用。</span><br></pre></td></tr></table></figure></li><li><p>二叉树的创建</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        node* root=<span class="literal">NULL</span>;<span class="comment">//新建空根结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            insert(root,data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>root==NULL与*root==NULL的区别<br>即结点不存在与结点存在但没有内容的区别</p></li><li>完全二叉树存储结构<br>对完全二叉树的任一结点x，其左孩子编号一定为2x，右孩子编号为2x+1.<br>完全二叉树可以通过建立一个大小为2^k的数组来存放所有结点的信息，其中k为完全二叉树的最大高度<br>且1号位必须存放根结点，该数组中元素存放的顺序恰好为该完全二叉树的层序遍历序列<br>判断某个结点是否为叶结点的标志为：该结点（下标记为t）的左子结点的编号2*t大于结点总个数n<br>判断某个结点是否为空结点的标志：该结点下标t大于结点总个数n。</li></ol>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>组合数</title>
      <link href="/%E8%AF%AD%E8%A8%80/%E7%BB%84%E5%90%88%E6%95%B0/"/>
      <url>/%E8%AF%AD%E8%A8%80/%E7%BB%84%E5%90%88%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="例1：求n！中有多少质因子p"><a href="#例1：求n！中有多少质因子p" class="headerlink" title="例1：求n！中有多少质因子p"></a>例1：求n！中有多少质因子p</h3><p>  直观想法：计算从1~n的每个数各有多少个质因子p，然后将结果累加，时间复杂度为O(nlogn).<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=i;</span><br><span class="line">        <span class="keyword">while</span>(temp%p==<span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            temp/=p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///O(logn)的算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    whil(n)&#123;</span><br><span class="line">    ans+=n/p;</span><br><span class="line">    n/=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n/p+cal(n/p,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="组合数的计算"><a href="#组合数的计算" class="headerlink" title="组合数的计算"></a>组合数的计算</h2><p><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D219/sign=001e9280d1b44aed5d4eb9e58a1d876a/279759ee3d6d55fb34fde7ec66224f4a21a4ddc5.jpg" alt="Alt text"><br>互补性质</p><p>即从m个不同元素中取出n个元素的组合数=从m个不同元素中取出 (m-n) 个元素的组合数；</p><p>这个性质很容易理解，例如C(9,2)=C(9,7)，即从9个元素里选择2个元素的方法与从9个元素里选择7个元素的方法是相等的。<br>规定：C(n,0)=1<br>2.组合恒等式<br>若表示在 n 个物品中选取 m 个物品，则如存在下述公式：C(n,m)=C(n,n-m)=C(n-1,m-1)+C(n-1,m)。</p><h3 id="通过定义直接计算"><a href="#通过定义直接计算" class="headerlink" title="通过定义直接计算"></a>通过定义直接计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">c</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans*=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        ans/=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n-m;i++)&#123;</span><br><span class="line">        ans/=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过递推公式计算"><a href="#通过递推公式计算" class="headerlink" title="通过递推公式计算"></a>通过递推公式计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res[<span class="number">67</span>][<span class="number">67</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">c</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(m==<span class="number">0</span>||m==n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(res[n][m]!=<span class="number">0</span>) <span class="keyword">return</span> res[n][m];</span><br><span class="line">   <span class="keyword">return</span> res[n][m]=c(n<span class="number">-1</span>,m)+c(n<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///打表计算</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n=<span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        res[i][<span class="number">0</span>]=res[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">            res[i][j]=res[i<span class="number">-1</span>][j]+res[i<span class="number">-1</span>][j<span class="number">-1</span>];<span class="comment">///递推计算c(i,j)</span></span><br><span class="line">            res[i][i-j]=res[i][j];<span class="comment">///c(i,i-j)=c(i,j)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过定义式的变形计算"><a href="#通过定义式的变形计算" class="headerlink" title="通过定义式的变形计算"></a>通过定义式的变形计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">c</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    ans=ans*(n-m+i)/i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算C-n-m-p"><a href="#计算C-n-m-p" class="headerlink" title="计算C(n,m)%p"></a>计算C(n,m)%p</h1><h3 id="通过递推公式计算-1"><a href="#通过递推公式计算-1" class="headerlink" title="通过递推公式计算"></a>通过递推公式计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">递归：</span><br><span class="line"><span class="keyword">int</span> res[<span class="number">1010</span>][<span class="number">1010</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>||m==n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(res[n][m]!=<span class="number">0</span>) <span class="keyword">return</span> res[n][m];</span><br><span class="line">    <span class="keyword">return</span> res[n][m]=(c(n<span class="number">-1</span>,m)+c(n<span class="number">-1</span>,m<span class="number">-1</span>))%p;</span><br><span class="line">&#125;</span><br><span class="line">递推：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    res[i][<span class="number">0</span>]=res[i][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">        res[i][j]=(res[i<span class="number">-1</span>][j]+res[i<span class="number">-1</span>][j<span class="number">-1</span>])%p;</span><br><span class="line">        res[i][i-j]=res[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据定义式计算"><a href="#根据定义式计算" class="headerlink" title="根据定义式计算"></a>根据定义式计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> ,n,<span class="keyword">int</span> m,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;prime[i]&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> c=cal(n,prime[i])-cal(m,prime[i])-cal(n-m,prime[i]);</span><br><span class="line">        ans=ans*binaryPow(prime[i],c,p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据定义式的变形计算"><a href="#根据定义式的变形计算" class="headerlink" title="根据定义式的变形计算"></a>根据定义式的变形计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///求c(n,m)%p,且m&lt;p,p为素数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        ans=ans*(n-m+<span class="number">1</span>)%p;</span><br><span class="line">        ans=ans*inverse(i,p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///求c(n,m)%p,m任意,p为素数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>,nump=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=n-m+i;</span><br><span class="line">        <span class="keyword">while</span>(temp%p==<span class="number">0</span>)&#123;</span><br><span class="line">            nump++;</span><br><span class="line">            temp/=p;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=ans*temp%p;</span><br><span class="line">        temp=i;</span><br><span class="line">        <span class="keyword">while</span>(temp%p==<span class="number">0</span>)&#123;</span><br><span class="line">            nump--;</span><br><span class="line">            temp/=p;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=ans*inverse(temp,p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nump&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lucas定理<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lucas</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> c(n%p,m%p)*Lucas(n/p,m/p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>algorithm头文件下常用函数</title>
      <link href="/%E8%AF%AD%E8%A8%80/algorithm%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/%E8%AF%AD%E8%A8%80/algorithm%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="algorithm头文件下常用函数"><a href="#algorithm头文件下常用函数" class="headerlink" title="algorithm头文件下常用函数"></a>algorithm头文件下常用函数</h1><h3 id="1-max-min-abs"><a href="#1-max-min-abs" class="headerlink" title="1. max(),min(),abs()"></a>1. max(),min(),abs()</h3><p>max(x,y)和min(x,y)分别返回x和y中的最大值和最小值，且参数必须是两个。<br>abs(x) 返回x的绝对值。x必须为整数，浮点型的绝对值要用math头文件下的fabs</p><h3 id="2-swap"><a href="#2-swap" class="headerlink" title="2. swap()"></a>2. swap()</h3><p>swap(x,y)用来交换x和y的值</p><h3 id="3-reverse"><a href="#3-reverse" class="headerlink" title="3. reverse()"></a>3. reverse()</h3><p>reverse(it,it2) 可以将数组指针在[it,it2)之间的元素或容器的迭代器在[it,it2)范围内的元素进行反转。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    reverse(a,a+<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str=<span class="string">"abcdefghi"</span>;</span><br><span class="line">    reverse(str.begin()+<span class="number">2</span>,str.begin()+<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-next-permutation"><a href="#4-next-permutation" class="headerlink" title="4. next_permutation()"></a>4. next_permutation()</h3><p>next_permutation() 给出一个序列在全排列中的下一个序列<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>]);</span><br><span class="line">    &#125;<span class="keyword">while</span>(next_permutation(a,a+<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-fill"><a href="#5-fill" class="headerlink" title="5. fill()"></a>5. fill()</h3><p>fill() 可以把数组或容器中的某一段区间赋为某个相同的值。和memset不同，这里的赋值可以使数组类型对应范围中的任意值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    fill(a,a+<span class="number">5</span>,<span class="number">233</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-sort"><a href="#6-sort" class="headerlink" title="6. sort()"></a>6. sort()</h3><p>默认为递增排序</p><ul><li><p>若要递减排序，需要增加比较函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+n,cmp);</span><br></pre></td></tr></table></figure></li><li><p>结构体数组排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.x&gt;b.x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a.x!=b.x) <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>容器排序，在STL标砖容器中，只有vector/string/deque可以sort</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    vi.push_back(<span class="number">3</span>);</span><br><span class="line">    vi.push_back(<span class="number">1</span>);</span><br><span class="line">    vi.push_back(<span class="number">2</span>);</span><br><span class="line">    sort(vi.begin(),vi.end(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,vi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-lower-bound-和upper-bound"><a href="#7-lower-bound-和upper-bound" class="headerlink" title="7. lower_bound()和upper_bound()"></a>7. lower_bound()和upper_bound()</h3><p>lower_bound 和 upper_bound()需要用在一个有序数组或容器中。<br>lower_bound(first,last,val) 用来寻找在数组或容器的[first,last)范围内第一个值大于等于<br>val元素的位置，如果是数组，返回该位置的指针；若果是容器，返回该位置的迭代器<br>upper_bound(first,last,val) 用来寻找在数组或容器的[first,last)范围内第一个值大于<br>val元素的位置，如果是数组，返回该位置的指针；若果是容器，返回该位置的迭代器<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,lower_bound(a,a+<span class="number">10</span>,<span class="number">3</span>)-a,upper_bound(a,a+<span class="number">10</span>,<span class="number">3</span>)-a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pair简介</title>
      <link href="/%E8%AF%AD%E8%A8%80/pair%E7%AE%80%E4%BB%8B/"/>
      <url>/%E8%AF%AD%E8%A8%80/pair%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><p>pair 可以看作一个内部有两个元素的结构体，且这两个元素的类型是可以指定的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair1</span>&#123;</span></span><br><span class="line">    typename1 first;</span><br><span class="line">    typename2 second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-pair定义"><a href="#1-pair定义" class="headerlink" title="1. pair定义"></a>1. pair定义</h3><p>需要添加<map>或<utility>头文件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;typename1,typename2&gt; name;</span><br><span class="line">pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line">pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p(<span class="string">"haha"</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//临时构建pair</span></span><br><span class="line">pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(<span class="string">"hhha"</span>,<span class="number">5</span>);</span><br><span class="line">make_pair(<span class="string">"hhha"</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure></utility></map></p><h3 id="2-pair中元素访问"><a href="#2-pair中元素访问" class="headerlink" title="2. pair中元素访问"></a>2. pair中元素访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line">    p.first=<span class="string">"haha"</span>;</span><br><span class="line">    p.second=<span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p.first&lt;&lt;<span class="string">" "</span>&lt;&lt;p.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    p=make_pair(<span class="string">"xixi"</span>,<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p.first&lt;&lt;<span class="string">" "</span>&lt;&lt;p.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    p=pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(<span class="string">"heihei"</span>,<span class="number">555</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p.first&lt;&lt;<span class="string">" "</span>&lt;&lt;p.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-pair常用函数"><a href="#3-pair常用函数" class="headerlink" title="3. pair常用函数"></a>3. pair常用函数</h3><p>两个pair类型可直接用==、！=、&lt;、&lt;=、&gt;、&gt;=比较大小，先比较first，若first相等，在比较second<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p1(<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p2(<span class="number">5</span>,<span class="number">15</span>);</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p3(<span class="number">10</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(p1&lt;p3) <span class="built_in">printf</span>(<span class="string">"p1&lt;p3\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(p1&lt;=p3) <span class="built_in">printf</span>(<span class="string">"p1&lt;=p3\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(p1&lt;p2) <span class="built_in">printf</span>(<span class="string">"p1&lt;p2\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-pair常见用途"><a href="#4-pair常见用途" class="headerlink" title="4. pair常见用途"></a>4. pair常见用途</h3><ul><li>代替二元结构体及其构造函数，节省编码时间</li><li>作为map的键值对进行插入<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp.insert(make_pair(<span class="string">"heihei"</span>,<span class="number">5</span>));</span><br><span class="line">    mp.insert(pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(<span class="string">"haha"</span>,<span class="number">6</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>stack简介</title>
      <link href="/%E8%AF%AD%E8%A8%80/stack%E7%AE%80%E4%BB%8B/"/>
      <url>/%E8%AF%AD%E8%A8%80/stack%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="stack常见用法"><a href="#stack常见用法" class="headerlink" title="stack常见用法"></a>stack常见用法</h1><p>stack 指栈，是STL中实现的一个后进先出的容器</p><h3 id="1-stack定义"><a href="#1-stack定义" class="headerlink" title="1. stack定义"></a>1. stack定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; name;</span><br></pre></td></tr></table></figure><h3 id="2-stack内容器元素访问"><a href="#2-stack内容器元素访问" class="headerlink" title="2. stack内容器元素访问"></a>2. stack内容器元素访问</h3><p>只能通过top()来访问栈顶元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        st.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,st.top());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-stack常用函数"><a href="#3-stack常用函数" class="headerlink" title="3. stack常用函数"></a>3. stack常用函数</h3><ol><li><p>push()<br>push(x) 将元素x压栈，时间复杂度 O(1)</p></li><li><p>top()<br>top() 获得栈顶元素，时间复杂度 O(1)</p></li><li><p>pop()<br>pop() 用来弹出栈顶元素，时间复杂度 O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        st.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,st.top());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>empty()<br>empty() 判断stack是否为空，为空返回true，否则返回false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">if</span>(st.empty()==<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    st.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(st.empty()==<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>size()<br>返回stack内元素个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        st.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,st.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="stack常见用途"><a href="#stack常见用途" class="headerlink" title="stack常见用途"></a>stack常见用途</h3><p>stack 常被用于模拟实现一些递归，防止程序对栈内存的限制而导致程序运行出错</p>]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>queue简介</title>
      <link href="/%E8%AF%AD%E8%A8%80/queue%E7%AE%80%E4%BB%8B/"/>
      <url>/%E8%AF%AD%E8%A8%80/queue%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="queue的常见用法"><a href="#queue的常见用法" class="headerlink" title="queue的常见用法"></a>queue的常见用法</h1><p>queue 队列，在stl中实现了一个先进先出的容器。</p><h4 id="1-queue的定义"><a href="#1-queue的定义" class="headerlink" title="1. queue的定义"></a>1. queue的定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><h3 id="2-queue容器内的元素访问"><a href="#2-queue容器内的元素访问" class="headerlink" title="2. queue容器内的元素访问"></a>2. queue容器内的元素访问</h3><p>在STL中通过front()访问队首元素，通过back()访问队尾元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,q.front(),q.back());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-queue-的常用函数"><a href="#3-queue-的常用函数" class="headerlink" title="3. queue 的常用函数"></a>3. queue 的常用函数</h3><ol><li>push()<br>push(x) 将x进行入队</li><li>front()访问队首元素，back()访问队尾元素。</li><li><p>pop() 令队首元素出队</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,q.front());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>empty()<br>empty()检测queue是否为空，为空，返回true；否则，返回false</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">if</span>(q.empty()==<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(q.empty()==<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>size()<br>size()返回queue内元素的个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="优先队列-priority-queue的常见用法"><a href="#优先队列-priority-queue的常见用法" class="headerlink" title="优先队列 priority_queue的常见用法"></a>优先队列 priority_queue的常见用法</h1><p>优先队列，底层用堆实现。队首元素一定是当前队列中优先级最高的一个。<br>可以在任何时候往优先队列中加入元素，而优先队列底层的数据结构堆（heap）会随时调整结构，<br>使每次的队首元素都是优先级最大的。</p><h3 id="1-priority-queue的定义"><a href="#1-priority-queue的定义" class="headerlink" title="1. priority_queue的定义"></a>1. priority_queue的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><h3 id="2-priority-queue容器内元素访问"><a href="#2-priority-queue容器内元素访问" class="headerlink" title="2. priority_queue容器内元素访问"></a>2. priority_queue容器内元素访问</h3><p>通过top()函数来访问队首（堆顶）元素，即优先级最高的元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">3</span>);</span><br><span class="line">    q.push(<span class="number">4</span>);</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.top());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-priority-queue的常用函数"><a href="#3-priority-queue的常用函数" class="headerlink" title="3. priority_queue的常用函数"></a>3. priority_queue的常用函数</h3><ol><li><p>push()<br>push(x) 将元素x入队，时间复杂度O(logn)</p></li><li><p>top()<br>top() 获得队首元素，时间复杂度O(1)</p></li><li><p>pop()<br>pop() 令队首元素出队，时间复杂对O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">3</span>);</span><br><span class="line">    q.push(<span class="number">4</span>);</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.top());</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.top());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>empty()<br>empty()检测优先队列是否为空，为空，返回true，否则返回false，时间复杂度O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">if</span>(q.empty()==<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(q.empty()==<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>size()<br>size() 返回队列内元素个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-priority-queue内元素优先级位置"><a href="#4-priority-queue内元素优先级位置" class="headerlink" title="4. priority_queue内元素优先级位置"></a>4. priority_queue内元素优先级位置</h3><ul><li><p>基本数据类型的优先级位置<br>一般是数字大的优先级越高<br>以下两种优先队列定义等价</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">//vector&lt;int&gt; 是指承载底层数据结构堆的容器，less&lt;int&gt;则是对第一个参数的比较类</span></span><br><span class="line"><span class="comment">//less&lt;int&gt;表示数字大的优先级越大，greater&lt;int&gt;表示数字小的优先级越大</span></span><br></pre></td></tr></table></figure></li><li><p>结构体的优先级设置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span>&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line">frind <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> fruit &amp;f1,<span class="keyword">const</span> fruit &amp;f2)&#123;</span><br><span class="line">  <span class="keyword">return</span> f1.price&gt;f2.price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>map简介</title>
      <link href="/%E8%AF%AD%E8%A8%80/map%E7%AE%80%E4%BB%8B/"/>
      <url>/%E8%AF%AD%E8%A8%80/map%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="map-映射"><a href="#map-映射" class="headerlink" title="map(映射)"></a>map(映射)</h1><p>  平时定义的数组，其实都是一种映射，但都是将int型映射到其他类型。而map可以将任何基本类型映射到任何基本类型。<br>  比如建立string型到int型的映射。</p><h3 id="map的定义"><a href="#map的定义" class="headerlink" title="map的定义"></a>map的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;typename1,typename2&gt; mp;</span><br><span class="line">其中 typename1是键的类型，typename2是值的类型</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;,<span class="built_in">string</span>&gt; mp;</span><br></pre></td></tr></table></figure><h3 id="map内元素访问"><a href="#map内元素访问" class="headerlink" title="map内元素访问"></a>map内元素访问</h3><p>map一般有两种访问方式：通过下标访问或通过迭代器访问。</p><ol><li><p>通过下标访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'c'</span>] = <span class="number">20</span>;</span><br><span class="line">    mp[<span class="string">'c'</span>] = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mp[<span class="string">'c'</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过迭代器访问<br>map&lt;typename1,typename2&gt;::iterator it;<br>map可以使用it-&gt;first来访问键，使用it-&gt;second来访问值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'m'</span>] =<span class="number">20</span>;</span><br><span class="line">    mp[<span class="string">'r'</span>] =<span class="number">30</span>;</span><br><span class="line">    mp[<span class="string">'a'</span>] =<span class="number">40</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c %d\n"</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//map会以键从小到大的顺序自动排序，这是由于map内部是使用红黑树实现的（set也是），</span></span><br><span class="line">在建立映射的过程中会自动实现从小到大的排序功能</span><br></pre></td></tr></table></figure></li></ol><h3 id="map常用函数实例解析"><a href="#map常用函数实例解析" class="headerlink" title="map常用函数实例解析"></a>map常用函数实例解析</h3><ol><li><p>find()<br>find(key)返回键为key的映射的迭代器，时间复杂度为O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'a'</span>] =<span class="number">1</span>;</span><br><span class="line">    mp[<span class="string">'b'</span>] =<span class="number">2</span>;</span><br><span class="line">    mp[<span class="string">'c'</span>] =<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it = mp.find(<span class="string">'b'</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c %d\n"</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>erase()<br>erase()两种用法：删除单个元素、删除一个区间内所有元素</p></li></ol><ul><li>删除单个元素<br>mp.erase(it), 时间复杂度O(1)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'a'</span>] =<span class="number">1</span>;</span><br><span class="line">    mp[<span class="string">'b'</span>] =<span class="number">2</span>;</span><br><span class="line">    mp[<span class="string">'c'</span>] =<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it = mp.find(<span class="string">'b'</span>);</span><br><span class="line">    mp.erase(it);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it =mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c %d\n"</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>mp.erase(key) 时间复杂度为O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'a'</span>] =<span class="number">1</span>;</span><br><span class="line">    mp[<span class="string">'b'</span>] =<span class="number">2</span>;</span><br><span class="line">    mp[<span class="string">'c'</span>] =<span class="number">3</span>;</span><br><span class="line">    mp.erase(<span class="string">'b'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it =mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c %d\n"</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除一个区间内所有元素<br>mp.erase(first,last) first:要删除的区间的其实迭代器<pre><code>last: 要删除的区间的末尾迭代器的下一个地址。时间复杂度：O(last-first)</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'a'</span>] =<span class="number">1</span>;</span><br><span class="line">    mp[<span class="string">'b'</span>] =<span class="number">2</span>;</span><br><span class="line">    mp[<span class="string">'c'</span>] =<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it = mp.find(<span class="string">'b'</span>);</span><br><span class="line">    mp.erase(it,mp.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it =mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c %d\n"</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>size()<br>size()用来获得map中映射的对数，时间复杂度为O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'a'</span>] =<span class="number">1</span>;</span><br><span class="line">    mp[<span class="string">'b'</span>] =<span class="number">2</span>;</span><br><span class="line">    mp[<span class="string">'c'</span>] =<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mp.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>clear()<br>clear()用来清空map中的所有元素，复杂度为O(n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'a'</span>] =<span class="number">1</span>;</span><br><span class="line">    mp[<span class="string">'b'</span>] =<span class="number">2</span>;</span><br><span class="line">    mp[<span class="string">'c'</span>] =<span class="number">3</span>;</span><br><span class="line">    mp.clear();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mp.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="map常见用途"><a href="#map常见用途" class="headerlink" title="map常见用途"></a>map常见用途</h3><ul><li>需要建立字符（字符串）与整数之间的映射</li><li>判断大整数或其他类型数据是否存在的题目，把map当bool数组</li><li>字符串和字符串之间的映射<br>map的键和值是唯一的，如果一个键要对应多个值，只能用multimap</li></ul></li></ol>]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>string简介</title>
      <link href="/%E8%AF%AD%E8%A8%80/string%E7%AE%80%E4%BB%8B/"/>
      <url>/%E8%AF%AD%E8%A8%80/string%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="string-的常见用法"><a href="#string-的常见用法" class="headerlink" title="string 的常见用法"></a>string 的常见用法</h1><h3 id="1-string的定义"><a href="#1-string的定义" class="headerlink" title="1. string的定义"></a>1. string的定义</h3><p>string str;<br>string str= “abcd”;</p><h3 id="2-string-内容访问"><a href="#2-string-内容访问" class="headerlink" title="2. string 内容访问"></a>2. string 内容访问</h3><ul><li><p>通过下标访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str=<span class="string">"abcd"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str=<span class="string">"abcd"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str.c_str());<span class="comment">///用C_str()将string类型转换为字符数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过迭代器访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str=<span class="string">"abcd"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">string</span>::iterator it=str.begin();it!=str.end();it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-string-常用函数"><a href="#3-string-常用函数" class="headerlink" title="3.string 常用函数"></a>3.string 常用函数</h3><ul><li><p>operator +=<br>string加法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1=<span class="string">"abcd"</span>,str2=<span class="string">"xya"</span>,str3;</span><br><span class="line">    str3=str1+str2;</span><br><span class="line">    str1+=str2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>compare operator<br>两个string类型可直接使用==、！=、&lt;、&lt;=、&gt;、&gt;=比较大小，比较规则为字典序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1=<span class="string">"aaa"</span>,str2=<span class="string">"bbb"</span>,str3=<span class="string">"ccc"</span>,str4=<span class="string">"qqq"</span>;</span><br><span class="line">    <span class="keyword">if</span>(str1&lt;str2) <span class="built_in">printf</span>(<span class="string">"ok\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>length()/size()<br>返回string的长度，两者用法基本相同</p></li><li><p>insert()<br>insert(pos,string),在pos号位置插入字符串string<br>insert(it,it2,it3) it为原字符串的欲插入位置，it2，it3为待插字符串的首尾迭代器<br>表示串[it2,it3)将被插在it位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"abcxyz"</span>,str2=<span class="string">"opq"</span>;</span><br><span class="line">    str.insert(str.begin()+<span class="number">3</span>,str2.begin(),str2.end());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>erase()</p></li></ul><ol><li><p>删除单个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"abcxyzefs"</span>;</span><br><span class="line">    str.erase(str.begin()+<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除一个区间内所有元素</p></li></ol><ul><li><p>str.erase(first,last) 删除[first,last)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"abcxyzefs"</span>;</span><br><span class="line">    str.erase(str.begin()+<span class="number">2</span>,str.end()<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>str.erase(pos,length) pos 为要删除的起始位置，length为删除的字符个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"abcxyzefs"</span>;</span><br><span class="line">    str.erase(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>clear() 清空string中的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"abcxyzefs"</span>;</span><br><span class="line">    str.clear();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,str.length());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>substr()<br>substr(pos,len) 返回从pos号位开始，长度为len的子串，时间复杂度为O(len)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"Thank you for your smile!"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str.substr(<span class="number">0</span>,<span class="number">5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>string::npos<br>string::npos 是一个常数，其本身值为-1，由于属于unsigned_int 类型，可认作unsigned_int类型的最大值<br>string::npos用以作为find函数失败时的的返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">string</span>::npos==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1 is true."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">string</span>::npos==<span class="number">4294967295</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"4294967295 is alse true"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>find()<br>str.find(str2),当str2是str的子串，返回其在str中第一次出现的位置；如果不是，那么返回string::npos<br>str.find(str2,pos) 从str的pos号位开始匹配str2<br>复杂度为O(mn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str= <span class="string">"Thank you for your smile"</span>;</span><br><span class="line">    <span class="built_in">string</span> str2=<span class="string">"you"</span>;</span><br><span class="line">    <span class="built_in">string</span> str3=<span class="string">"me"</span>;</span><br><span class="line">    <span class="keyword">if</span>(str.find(str2)!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;str.find(str2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str.find(str2,<span class="number">7</span>)!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;str.find(str2,<span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str.find(str3)!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;str.find(str3)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"no position for me"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>replace()<br>str.replace(pos,len,str2) 把str从pos号位开始，长度为len的子串替换为str2<br>str.replace(it1,it2,str2) 把str的迭代器[it1,it2)范围的子串替换为str2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str= <span class="string">"Thank you for your smile"</span>;</span><br><span class="line">    <span class="built_in">string</span> str2=<span class="string">"you"</span>;</span><br><span class="line">    <span class="built_in">string</span> str3=<span class="string">"me"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str.replace(<span class="number">10</span>,<span class="number">4</span>,str2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str.replace(str.begin(),str.begin()+<span class="number">5</span>,str3)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>set简简介</title>
      <link href="/%E8%AF%AD%E8%A8%80/set%E7%AE%80%E4%BB%8B/"/>
      <url>/%E8%AF%AD%E8%A8%80/set%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="set的常见用法"><a href="#set的常见用法" class="headerlink" title="set的常见用法"></a>set的常见用法</h1><p>  set指集合，是一个内部自动有序且不含重复元素的容器。</p><h3 id="1-set的定义"><a href="#1-set的定义" class="headerlink" title="1. set的定义"></a>1. set的定义</h3><p>set<typename> name;<br>set<int> name;<br>set<double> name;<br>set<char> name;<br>set<node> name;<br>set数组定义<br>set<trpename> Arrayname[arraysize];<br>set<int> a[100];<br>// a[0]~a[99]中的每一个都是一个set容器</int></trpename></node></char></double></int></typename></p><h3 id="2-set容器内元素的访问"><a href="#2-set容器内元素的访问" class="headerlink" title="2. set容器内元素的访问"></a>2. set容器内元素的访问</h3><p>set只能通过迭代器访问<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;::iterator ir;</span><br><span class="line">得到迭代器it后，可通过*it访问<span class="built_in">set</span>内的元素</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    st.insert(<span class="number">3</span>);</span><br><span class="line">    st.insert(<span class="number">4</span>);</span><br><span class="line">    st.insert(<span class="number">5</span>);</span><br><span class="line">    st.insert(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = st.begin();it!=st.end();it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="set的常用函数"><a href="#set的常用函数" class="headerlink" title="set的常用函数"></a>set的常用函数</h3><ol><li>insert()<br>insert(x)可将x插入set容器中，并自动排序和去重，时间复杂度为O(logn)</li><li><p>find()<br>find(x)返回set中对应值x的迭代器，时间复杂度为O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        st.insert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = st.find(<span class="number">2</span>);<span class="comment">///在set里查找2，返回其迭代器</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*it);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>erase()<br>两种用法： 删除单个元素</p><pre><code>删除一个区间内的所有元素</code></pre></li></ol><ul><li><p>st.erase(it), it为所需要删除元素的迭代器，时间复杂度为O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    st.insert(<span class="number">100</span>);</span><br><span class="line">    st.insert(<span class="number">200</span>);</span><br><span class="line">    st.insert(<span class="number">111</span>);</span><br><span class="line">    st.insert(<span class="number">300</span>);</span><br><span class="line">    st.insert(<span class="number">100</span>);</span><br><span class="line">    st.erase(st.find(<span class="number">100</span>));</span><br><span class="line">    st.erase(st.find(<span class="number">200</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=st.begin();it!=st.end();it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>st.erase(value) value为所要删除元素的值，时间复杂度为O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    st.insert(<span class="number">100</span>);</span><br><span class="line">    st.insert(<span class="number">200</span>);</span><br><span class="line">    st.insert(<span class="number">111</span>);</span><br><span class="line">    st.insert(<span class="number">300</span>);</span><br><span class="line">    st.insert(<span class="number">100</span>);</span><br><span class="line">    st.erase(<span class="number">111</span>);</span><br><span class="line">    st.erase(<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=st.begin();it!=st.end();it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除一个区间内的所有元素<br>st.erase(first,last) 删除[first,last),时间复杂度为O（last-first）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    st.insert(<span class="number">20</span>);</span><br><span class="line">    st.insert(<span class="number">10</span>);</span><br><span class="line">    st.insert(<span class="number">40</span>);</span><br><span class="line">    st.insert(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = st.find(<span class="number">30</span>);</span><br><span class="line">    st.erase(it,st.end());</span><br><span class="line">    <span class="keyword">for</span>(it = st.begin();it!=st.end();it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>clear()<br>clear()用来清空set中的所有元素，复杂度为O（n）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    st.insert(<span class="number">20</span>);</span><br><span class="line">    st.insert(<span class="number">10</span>);</span><br><span class="line">    st.insert(<span class="number">40</span>);</span><br><span class="line">    st.insert(<span class="number">30</span>);</span><br><span class="line">    st.clear();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,st.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set常见用途"><a href="#set常见用途" class="headerlink" title="set常见用途"></a>set常见用途</h3><p>set主要作用 为自动去重并按升序排序<br>set中元素具有唯一性，如果要处理不唯一情况，要用multiset<br>c++11标准中增加了unordered_set,以散列代替set内部的红黑树（一种自平衡二叉查找树）实现，<br>使其可以用来处理只去重但不排序的需求，速度比set快很多</p></li></ol>]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vector简介</title>
      <link href="/%E8%AF%AD%E8%A8%80/vector%E7%AE%80%E4%BB%8B/"/>
      <url>/%E8%AF%AD%E8%A8%80/vector%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="vector的常见用法"><a href="#vector的常见用法" class="headerlink" title="vector的常见用法"></a>vector的常见用法</h1><p>vector 翻译为向量，也可理解为 变长数组，即长度根据需要而自动改变的数组。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">vector</span>的定义</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; name;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; name;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; name;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; name;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; name;</span><br><span class="line">二维：</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; Arrayname[arraySize];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></p><h3 id="2-vector容器内元素访问"><a href="#2-vector容器内元素访问" class="headerlink" title="2. vector容器内元素访问"></a>2. vector容器内元素访问</h3><ul><li>通过下标访问<br>和访问普通数组一样，对一个定义为vector<typename> vi的vector容器来说，直接访问vi[index]即可。<br>这里的下标范围为0~vi.size()-1</typename></li><li>通过迭代器访问<br>迭代器（iterator）可以理解为类似一种指针的东西，其定义为：<br>vector<int>::iterator it;<br>vector<double>::iterator it;<br>这样即得到迭代器 it 通过*it访问vector里的元素<br>vector<int> vi;<br>for(int i=1;i&lt;=5;i++){<br>vi.push_back(i);<br>}<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vi.begin();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*(it+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">v[i] 等价于 *(vi.begin()+i)</span><br><span class="line">begin()  用于取vi的首元素地址</span><br><span class="line">而end() 用于取vi尾元素地址的下一个地址，即 左闭右开</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vi.begin();</span><br><span class="line">    <span class="keyword">for</span>(it = vi.begin();it!=vi.end();it++)</span><br><span class="line">    &#123;<span class="comment">///vector的迭代器不支持it&lt;vi.end(),所以只能用it!=vi.end();</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></int></double></int></li></ul><h3 id="vector常用函数"><a href="#vector常用函数" class="headerlink" title="vector常用函数"></a>vector常用函数</h3><ol><li><p>push_back() 在vector后面添加一个元素，时间复杂度为O（1）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vi.size();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,vi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>pop_back() 删除vector的尾元素，时间复杂度为O（）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vi.pop_back();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vi.size();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,vi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>size() 用来获得vector中元素的个数，时间复杂度为O（），size()返回unsigned类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,vi.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>clear() 用来清空vector中所有元素，时间复杂度为o（n）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vi.clear();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,vi.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>insert() insert(it,x)用来向vector的任意迭代器it处插入一个元素x，时间复杂度为O（n）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vi.insert(vi.begin()+<span class="number">2</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vi.size();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,vi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>erase()<br>erase() 有两种用法：删除单个元素；</p><pre><code>删除一个区间内的所有元素。时间复杂度为O（N）</code></pre></li></ol><ul><li><p>删除单个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vi.erase(vi.begin()+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vi.size();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,vi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除一个区间内的所有元素<br>erase(first,last) 即删除[first,last)内的所有元素<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vi.erase(vi.begin()+<span class="number">1</span>,vi.begin()+<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vi.size();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,vi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="vector常见用途"><a href="#vector常见用途" class="headerlink" title="vector常见用途"></a>vector常见用途</h3><ol><li><p>存储数据</p></li><li><p>用邻接表存储图</p></li></ol></li></ul>]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>素数问题</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B4%A0%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B4%A0%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><p>  素数又称为质数，是指除了1和本身外，不能被其他数整除的一类数。</p><h3 id="素数判断"><a href="#素数判断" class="headerlink" title="素数判断"></a>素数判断</h3><p>直接遍历循环复杂度为O(n);<br>复杂度为O(sqrt(n))的算法;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sqr = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span>*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sqr;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简洁写法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="素数表的获取"><a href="#素数表的获取" class="headerlink" title="素数表的获取"></a>素数表的获取</h3><p>思路一： 根据判断素数的方法，直接从1~n进行枚举，若为素数则加入表中，枚举部分复杂度为O(n),判断素数部分复杂度为O(sqrt(n)),<br>所以总复杂度为O(n*sqrt(n)),该算法对于n小于10^5可以承受;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sqr = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span>*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sqr;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">101</span>],num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> p[<span class="number">101</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find_Prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">101</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isprime(i)) &#123;</span><br><span class="line">            prime[num++]=i;</span><br><span class="line">            p[i]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Find_Prime();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,prime[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路二：埃氏筛法，复杂度为O(nloglogn).<br>       欧拉筛法，复杂度为O(n).<br>素数筛法的关键在于筛字，即从小到大枚举所有数，对每一个素数，筛去它的所有倍数，剩下的均为素数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn],num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> p[maxn]=&#123;<span class="number">0</span>&#125;;<span class="comment">//如果i为素数，则p[i]为false,否则，p[i]为true</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find_Prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            prime[num++]=i;<span class="comment">//将素数i存入数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;maxn;j+=i)&#123;<span class="comment">//筛去所有i的倍数，两个循环条件均不能加=</span></span><br><span class="line">                p[j]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Find_Prime();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,prime[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>大整数运算</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<h1 id="大整数运算"><a href="#大整数运算" class="headerlink" title="大整数运算"></a>大整数运算</h1><p>  大整数的含义为：用基本数据类型无法存储其精度的整数，即没有办法用已有的数据类型来表示并计算，而需要去模拟加减乘除的过程，</p><h2 id="大整数的存储"><a href="#大整数的存储" class="headerlink" title="大整数的存储"></a>大整数的存储</h2><p>  使用数组存储，即整数的高位存储在数组的高位，整数的低位存储在数组的低位。由于运算时都是从整数的低位到高位进行枚举，<br>  所以顺序存储与该思维相合。<br>  注意点：当整数按字符串%s读入时是逆位存储的，所以需要反转至另一数组。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bign</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> d[<span class="number">1000</span>];</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  bign()&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">  len = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">bign <span class="title">change</span><span class="params">(<span class="keyword">char</span> str[])</span></span>&#123;</span><br><span class="line">    bign a;</span><br><span class="line">    a.len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)&#123;</span><br><span class="line">        a.d[i]=str[a.len-i<span class="number">-1</span>]-<span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">比较两个bign变量的大小：先判断两者的len大小，如果不相等，以长的</span><br><span class="line">为大；如果相等，则从高位到低位进行比较，直到出现某一位不等，结束比较。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(bign a,bign b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.len&gt;b.len) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.len&lt;b.len) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.d[i]&gt;b.d[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a.d[i]&lt;b.d[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><p>对两个数其中的每一位进行加法的步骤：将该位上的两个数字相加，得到的结果取个位数作为该位结果，取十位数作为新的进位<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bign</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> d[<span class="number">1000</span>];</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  bign()&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">  len = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">bign <span class="title">change</span><span class="params">(<span class="keyword">char</span> str[])</span></span>&#123;</span><br><span class="line">    bign a;</span><br><span class="line">    a.len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)&#123;</span><br><span class="line">        a.d[i]=str[a.len-i<span class="number">-1</span>]-<span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">bign <span class="title">add</span><span class="params">(bign a,bign b)</span></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=a.d[i]+b.d[i]+carry;</span><br><span class="line">        c.d[c.len++]=temp%<span class="number">10</span>;</span><br><span class="line">        carry=temp/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry!=<span class="number">0</span>)&#123;</span><br><span class="line">        c.d[c.len++]=carry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(bign a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,a.d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">1000</span>],str2[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,str1,str2);</span><br><span class="line">    bign a=change(str1);</span><br><span class="line">    bign b=change(str2);</span><br><span class="line">    print(add(a,b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">上述写法两个对象都是非负整数，如果有一方是负的，可以在转换到数组这一步时</span><br><span class="line">去掉其负号，然后采用高精度减法；如果两个都是负的，就都去掉负号后采用高精度加法，最后加上负号。</span><br></pre></td></tr></table></figure></p><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><p>步骤：对每一步，比较被减位和减位，如果不够减，则令被减位的高位减1，被减位加10在进行减法；如果够减，则直接减。<br>减法后高位可能有多余的0，要除去它们，但也要保证结果至少有一位数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">sub</span><span class="params">(bign a,bign b)</span></span>&#123;</span><br><span class="line">        bign c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.d[i]&lt;b.d[i])&#123;</span><br><span class="line">                a.d[i+<span class="number">1</span>]--;</span><br><span class="line">                a.d[i]+=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            c.d[c.len++]=a.d[i]-b.d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(c.len<span class="number">-1</span>&gt;=<span class="number">1</span>&amp;&amp;c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">            c.len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="高精度与低精度的乘法"><a href="#高精度与低精度的乘法" class="headerlink" title="高精度与低精度的乘法"></a>高精度与低精度的乘法</h3><p>步骤：取bign的某位与int型整体相乘，再与进位相加，所得结果的个位数作为该位结果，高位作为新的进位。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">multi</span><span class="params">(bign a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=a.d[i]*b+carry;</span><br><span class="line">        c.d[c.len++]=temp%<span class="number">10</span>;</span><br><span class="line">        carry=temp/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(carry!=<span class="number">0</span>)&#123;</span><br><span class="line">        c.d[c.len++]=carry%<span class="number">10</span>;</span><br><span class="line">        carry/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="高精度与低精度的除法"><a href="#高精度与低精度的除法" class="headerlink" title="高精度与低精度的除法"></a>高精度与低精度的除法</h3><p>步骤：上一步的余数乘以10加上该步的位，得到该步临时的被除数，将其与除数比较：如果不够除，则该位的商为0；如果够除，<br>则商即为对应的商，余数即为对应的余数。最后一步要注意高位可能有多余的0，要去除它们，但也要保证结果至少有一位数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">divide</span><span class="params">(bign a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;r)</span></span>&#123;<span class="comment">//r为余数</span></span><br><span class="line">    bign c;</span><br><span class="line">    c.len=a.len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        r=r*<span class="number">10</span>+a.d[i];</span><br><span class="line">        <span class="keyword">if</span>(r&lt;b) c.d[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            c.d[i]=r/b;</span><br><span class="line">            r=r%b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.len=<span class="number">1</span>&gt;=<span class="number">1</span>&amp;&amp;c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">        c.len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>为自己去去去“功利化”</title>
      <link href="/%E9%9A%8F%E7%AC%94/%E4%B8%BA%E8%87%AA%E5%B7%B1%E5%8E%BB%E5%8E%BB%E2%80%9C%E5%8A%9F%E5%88%A9%E5%8C%96%E2%80%9D/"/>
      <url>/%E9%9A%8F%E7%AC%94/%E4%B8%BA%E8%87%AA%E5%B7%B1%E5%8E%BB%E5%8E%BB%E2%80%9C%E5%8A%9F%E5%88%A9%E5%8C%96%E2%80%9D/</url>
      <content type="html"><![CDATA[<h1 id="想找回纯粹的自己"><a href="#想找回纯粹的自己" class="headerlink" title="想找回纯粹的自己"></a>想找回纯粹的自己</h1><p>　　　不知从何时起，发现自己只剩下眼前的苟且，所谓的诗和远方早已不见踪影。不知是社会的悲哀，还是我自己的悲哀，从中学到大学，越发觉得自己成了一个精致的利己主义者。也许你会说人不为己天诛地灭，势利本就是人的一种本性，哪有那么多高尚者能为他人考虑多过为自己考虑。<br>　　　一个大学生，虽说不是什么９８５重点高校，但却仍旧找不到自己所真正热爱的，长时间为日后从事什么职业而迷茫岂不可笑。一路走来，自己始终缺乏主见与自信，每当周边的人鸡汤一撒，立马觉得，哇，这位大佬说的有道理，然后被人牵着鼻子一直走。高中生活就不提太多了，大家都是在高考的指挥棒下走过来的，相信高中是怎么一回事的清楚得很，成绩平平的我当时就读于本地现成的一所普通中学，和绝大多数同学一样，过完了普普通通的三年，你还别说，我们这普通高中管得还挺严，我可以说是老老实实地度过了高中三年，作为一个听话的好学生．．．当然是天天努力学习哈，老师说了，你现在混混日子，到时候就是人家去浙大，你去浙中大，哈哈哈。高二文理分科，尽管我高一文科学得比理科好多了，但还是毫不犹豫地选择了读理科，然后就是两年被学霸血虐的日子了，为什么选理科，大家都说了，理科好选专业呀，理科方便找工作呀．．高三一年埋头于题海，虽然成绩平平，但还是付出了不少的努力。<br>　　　高考结束后，查了成绩，语文竟然没及格，想想估计选择题没对几个吧，不过这都是过去式了。接着得开始选学校，选专业了吧。这时，又到了七大姑八大姨发挥作用的时候了，亲戚们一个个热心的为我出谋划策，学医吧，现在医生挺吃香，年纪大了，更是经验丰富；读师范吧，当老师多稳定，一年还有寒暑假；当时没想太多，一看自己这分数，怕是连杭师范，浙中大都没啥希望，但还是报了，记得浙中大这一栏，前面几个全是医学类药学类的，最后面加了个计算机还是医信，结果就来了浙中大的计算机专业，也算是被调剂来了吧。当时得到通知，家里人一看，一脸蒙蔽，在中医药学计算机？不是在逗我吧，中医药还有这专业？后面老姐无奈的说，计算机也还行吧，这几年互联网还蛮火，程序员工资也还不错，认真学就是了。进入学校，得知学校目标就是培养软件开发人员，听老师的，努力刷题敲代码才是王道呀，然后就走上了刷题的不归路，然而惭愧的表示，自己到现在也没敲多少代码．．不知道为什么，我总是充满焦虑，和老朋友聊天，人家就觉得我考虑的也太长远了，活好当下难道不是更重要吗？平时听多了房子，车子，甚至于学校里的老师也时不时与你感叹现实不易，言外之意，你现在不努力学习，毕业了那什么去找工作，找不到工作拿什么买房买车娶媳妇．．．现在不努力学习，怎么赚大钱，当大官．．呵呵，读大学的意义就只有这样了吗，混得好不好，就看钱多钱少？官大官小？为什么参加竞赛？为了拿奖呗？为什么要拿奖？为了保研呀，为了找份好工作呀！为什么要读研？为了以后找份更好的工作呀！为什么想找份更好的工作？希望自己经济独立，不为生活所迫！这一切看起来是这么自然，这么理所当然。功利心貌似也无可厚非，但这是我想要的吗？能不能让其在我的脑海中淡化点呢，能不能在我看电影的时候，想着的是剧情如何如何精彩；能不能在我看小说的时候，想着的是这个人物多么多么丰富，作者构思多么多么独特；能不能在我听音乐的时候，想着的是旋律多么多么动听，歌词多么多么感人。而不是动不动来一句，你做这些有什么用呢？很多事情难道一定得有用才值得去做吗？尊重差异化是我的原则之一，有的人并不适合当学霸，你别跟我提什么励志鸡汤，很多事情不是努力就能改变的。大学尽管已是一个小社会了，但能不能多保留点纯粹？当热爱运动的在球场上挥洒汗水，热爱阅读的沉浸在图书馆中，痴迷科研的废寝于实验室，热爱音乐的与吉他为伴，热爱美术的与画笔为伴，这时，身边能不能少点这样的声音，整天干这些有用吗？能赚到钱吗？能养你女朋友吗？当然了，也许是不能。对很多人来说，干一辈子还抵不上拆迁户一次拿的钱，《百年孤独》作者马尔克斯，早期创作时一直租着房子，而且付不起租金，当拿到了诺贝尔奖金时，他找到了房东，付给他欠下的房租，然而这个房东拒绝了。生活离不开物质，但不应被物质所绑架，希望见到老同学，他还会敞开心怀与我交谈，最重要最开心的是，我们还是当年的我们，只是长大了一点。</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>模式匹配</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      <content type="html"><![CDATA[<h2 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h2><p>1、 BF算法是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串P的第一个字符进行匹配，若相等，则继续比较S的第二个字符和P的第二个字符；若不相等，则比较S的第二个字符和P的第一个字符，其实相当于将整个模式串往后移了一位，依次比较下去，直到得出最后的匹配结果。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BF_Find</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="built_in">string</span>&amp; t)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,count=<span class="number">0</span>;<span class="comment">//初始化  </span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;s.size())  <span class="comment">//未比较到串尾  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(s.at(i)==t.at(j)) <span class="comment">//继续比较后续字符  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">            count++;&#125;  </span><br><span class="line">       <span class="keyword">else</span>   <span class="comment">//指针后退重新匹配  </span></span><br><span class="line">       &#123;  </span><br><span class="line">           i=i-j+<span class="number">1</span>;  </span><br><span class="line">           j=<span class="number">0</span>;  </span><br><span class="line">           count=<span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(count==t.size())  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"BF算法模式匹配成功,起始位置是:"</span>&lt;&lt;i-count+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">            <span class="keyword">return</span> (i-count+<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"字符串匹配失败!"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>2、KMP算法与BF算法的区别就在于KMP算法巧妙的消除了指针i的回溯问题，只需确定下次匹配j的位置即可，使得问题的复杂度由O(mn)下降到O(m+n)。</p><p>在KMP算法中，为了确定在匹配不成功时，下次匹配时j的位置，引入了next[]数组，next[j]的值表示P[1…j-1]中最长的后缀等于相同字符序列的前缀的长度。</p><p>　 对于next[]数组的定义如下：</p><p>   （1) next[j] = 0（ j = 1）（t1与Si比较不相等时，下一步进行t1与Si+1的比较）</p><p>　 （2) next[j] = max(k)（1&lt;k&lt;j且 P[1…k-1]=P[j-k+1,j-1]）</p><p>{设next[j]=k;(1&lt;k&lt;j)</p><p>若tk=tj 则next[j+1]=k+1;即next[j+1]=next[j]+1;</p><p>若tk!=tj 则next[j+1]=next[k]+1;               </p><p>}</p><p>　 （3) next[j] = 1  (k=1)(不存在相同子串，下一步进行t1与si的比较)</p><p>因此KMP算法的思想就是：在匹配过程称，若发生不匹配的情况，则目标串的指针i不变，将模式串的指针j移动到next[j]的位置继续进行匹配；当指针j退至0时，指针i和指针j需同时增加1。也就是说，当发生不匹配的情况，让模式串继续往后移，而移动的位数就是模式串的长度-部分匹配值（最长相同前后缀的长度），因为BF里面每次指针i回溯，会导致符合匹配的字符再一次匹配，增大了时间开销。</p><p>求next数组是难点，一般有递推法（用一个while循环）和直接法两种。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BF_Find</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="built_in">string</span>&amp; t)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,count=<span class="number">0</span>;<span class="comment">//初始化  </span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;s.size())  <span class="comment">//未比较到串尾  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(s.at(i)==t.at(j)) <span class="comment">//继续比较后续字符  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">            count++;&#125;  </span><br><span class="line">       <span class="keyword">else</span>   <span class="comment">//指针后退重新匹配  </span></span><br><span class="line">       &#123;  </span><br><span class="line">           i=i-j+<span class="number">1</span>;  </span><br><span class="line">           j=<span class="number">0</span>;  </span><br><span class="line">           count=<span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(count==t.size())  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"BF算法模式匹配成功,起始位置是:"</span>&lt;&lt;i-count+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">            <span class="keyword">return</span> (i-count+<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"字符串匹配失败!"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="keyword">int</span> *next)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> len = s.size();  </span><br><span class="line">     next[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">     next[<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">1</span>;  </span><br><span class="line">     <span class="keyword">while</span>(i &lt; len - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">            <span class="keyword">int</span> j = next[i];  </span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s.at(j) != s.at(i)) j = next[j];  </span><br><span class="line">            <span class="keyword">if</span>(s.at(j) == s.at(i))  next[i + <span class="number">1</span>] = j + <span class="number">1</span>;<span class="comment">//根据next的定义推导出公式  </span></span><br><span class="line">            <span class="keyword">else</span> next[i + <span class="number">1</span>] = j;  </span><br><span class="line">            i++;  </span><br><span class="line">      &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getnextval</span><span class="params">(<span class="built_in">string</span> &amp; s,<span class="keyword">int</span> *next)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;  </span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> len=s.size();  </span><br><span class="line">    <span class="keyword">while</span>(i&lt;len)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||s.at(i)==s.at(j))&#123;  </span><br><span class="line">            ++i;++j;  </span><br><span class="line">            <span class="keyword">if</span> (s.at(i)!=s.at(j)) next[i]=j;  </span><br><span class="line">            <span class="keyword">else</span> next[i]=next[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> j=next[j];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP_Find</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="built_in">string</span>&amp;t)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"> <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;  </span><br><span class="line"> <span class="keyword">int</span> n =t.size();  </span><br><span class="line"> <span class="keyword">int</span> *next = <span class="keyword">new</span> <span class="keyword">int</span>[n];  </span><br><span class="line"> GetNext(t,next);  </span><br><span class="line"> <span class="keyword">while</span>(i&lt;s.size()&amp;&amp;j&lt;t.size()) <span class="comment">//两个串均未比较到串尾  </span></span><br><span class="line">  &#123;  </span><br><span class="line">     <span class="keyword">if</span>((j == <span class="number">0</span>)||(s.at(i)==t.at(j))) <span class="comment">//继续比较后续字符  </span></span><br><span class="line">              &#123;  </span><br><span class="line">                  i++;  </span><br><span class="line">                  j++;  </span><br><span class="line">              &#125;  </span><br><span class="line">              <span class="keyword">else</span>  </span><br><span class="line">              &#123;  </span><br><span class="line">                  j = next[j];<span class="comment">//模式串后移  </span></span><br><span class="line">              &#125;  </span><br><span class="line">   &#125; <span class="keyword">if</span>(j==t.size())  </span><br><span class="line">  &#123;  </span><br><span class="line">   <span class="keyword">int</span> index=i-t.size()+<span class="number">1</span>;  </span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"KMP算法：子串从长串的第"</span>&lt;&lt;index&lt;&lt;<span class="string">"位开始匹配成功!"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">   <span class="keyword">return</span> index;  </span><br><span class="line">  &#125;  </span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"字符串匹配失败!"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">string</span> str1,str2;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入主串:"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str1;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入子串:"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str2;  </span><br><span class="line">    KMP_Find(str1,str2);  </span><br><span class="line">    BF_Find(str1,str2);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>My movie list of 2017</title>
      <link href="/%E9%9A%8F%E7%AC%94/My-movie-list-of-2017/"/>
      <url>/%E9%9A%8F%E7%AC%94/My-movie-list-of-2017/</url>
      <content type="html"><![CDATA[<ol><li>《肖申克的救赎》</li><li>《海边的曼彻斯特》</li><li>《梦与狂想的王国》</li><li>《辛德勒的名单》</li><li>《至爱梵高》</li><li>《熔炉》</li><li>《窃听风暴》</li><li>《美丽心灵》</li><li>《v字仇杀队》</li><li>《忠犬八公的故事》</li><li>《春光乍泄》</li><li>《钢琴家》</li><li>《阿甘正传》</li><li>《霸王别姬》</li><li>《沉默的羔羊系列》</li><li>《蝴蝶效应系列》</li><li>《杀人游戏》</li><li>《海洋》</li><li>《千钧一发》</li><li>《源代码》</li><li>《超脱》</li><li>《猫鼠游戏》</li><li>《心迷宫》</li><li>《寻梦环游记》</li><li>《猫妖记》</li><li>《芳华》</li><li>《奇幻森林》</li></ol>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影视 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>八大排序</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<ol><li>插入排序（直接插入排序、希尔排序）</li><li>交换排序（冒泡排序、快速排序）</li><li>选择排序（直接选择排序、堆排序）</li><li>归并排序</li><li>分配排序（基数排序）<br>所需辅助空间最多：归并排序<br>所需辅助空间最少：堆排序<br>平均速度最快：快速排序<br>不稳定：快速排序、希尔排序、堆排序<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3>基本思想：在要排序的一组数中，假设前面（n-1）个数已经有序，现在要把第n个数插到前面的有序数中，<br>使得这n个数也是有序的。如此反复循环，直到全部有序。</li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/icHoerKO3NjIlME1HxoRpx2g9rGuM9jjjzMHUUY5t9bzvIgXLsl7BTAO98LkGdTQmP7ImVfCMlPfqTYpavPYwnQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="Alt txt"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">     <span class="keyword">int</span> j=i-<span class="number">1</span>;</span><br><span class="line">     temp=a[i];</span><br><span class="line">     <span class="keyword">for</span>(;j&gt;=<span class="number">0</span>&amp;&amp;temp&lt;a[j];j--)&#123;</span><br><span class="line">       a[j+<span class="number">1</span>]=a[j];<span class="comment">//将大于temp的值整体后移一位</span></span><br><span class="line">     &#125;</span><br><span class="line">     a[j+<span class="number">1</span>]=temp;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">     System.out.println(a[i]);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h4><ul><li><p>最佳情况：O(n)</p></li><li><p>最坏情况：O(n^2)</p></li><li><p>平均时间复杂度：O(n^2)</p></li><li><p>空间复杂度：O(1)</p></li><li><p>稳定排序算法</p></li></ul><h3 id="希尔排序（最小增量排序）"><a href="#希尔排序（最小增量排序）" class="headerlink" title="希尔排序（最小增量排序）"></a>希尔排序（最小增量排序）</h3><p>基本思想：先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d。<br>对每组中全部元素进行直接插入排序，然后再用一个较小的增量对它进行分组，在每组中再进行直接插入排序。<br>当增量减到1，进行直接插入排序后，排序完成。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/icHoerKO3NjIlME1HxoRpx2g9rGuM9jjjwrHoBoCfZVDAv1MkCsUmmeibwPnOcnJkDbnVxaaL9DILl5xjouNibPJg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="Alt"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellFort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">double</span> d1=a.length;</span><br><span class="line">   <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">     d1=Math.ceil(d1/<span class="number">2</span>);</span><br><span class="line">     <span class="keyword">int</span> d = (<span class="keyword">int</span>) d1;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;d;x++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=x+d;i&lt;a.length;i+=d)&#123;</span><br><span class="line">         <span class="keyword">int</span> j=i-d;</span><br><span class="line">         temp=a[i];</span><br><span class="line">         <span class="keyword">for</span>(;j&gt;=<span class="number">0</span>&amp;&amp;temp&lt;a[j];j-=d)&#123;</span><br><span class="line">           a[j+d]=a[j];</span><br><span class="line">         &#125;</span><br><span class="line">         a[j+d]=temp;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(d==<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li><p>最佳情况：O(nlogn)</p></li><li><p>最坏情况：O(nlogn)</p></li><li><p>平均时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(1)</p></li><li><p>不稳定排序算法</p></li></ul><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；<br>然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/icHoerKO3NjIlME1HxoRpx2g9rGuM9jjjbk6QzDFcI1AnGFibAEIaFJrOKDYoiaS0naDEmdJdpABtiaWdibtoF8z2eA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="Alt txt"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> position=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> j=i+<span class="number">1</span>;</span><br><span class="line">    position=i;</span><br><span class="line">    <span class="keyword">int</span> temp=a[i];</span><br><span class="line">    <span class="keyword">for</span>(;j&lt;a.length;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j]&lt;temp)&#123;</span><br><span class="line">        temp=a[j];</span><br><span class="line">        position=j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[position]=a[i];</span><br><span class="line">    a[i]=temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li><p>最佳情况：O(n^2)</p></li><li><p>最差情况：O(n^2)</p></li><li><p>平均时间复杂度：O(n^2)</p></li><li><p>空间复杂度：O(1)</p></li><li><p>不稳定排序算法</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>基本思想：堆排序是一种树形选择排序，是对直接选择排序的优化。<br>堆的定义：具有n个元素的序列（h1,h2…hn）,当且仅当满足(hi&gt;=h2i,hi&gt;=2i+1)或(hi&lt;=h2i,hi&lt;=2i+1)(i=1,2,….,n/2)时称为堆。<br>堆顶元素（即第一个元素）必为最大项（大顶堆）。<br>完全二叉树可以很直观地表示堆的结构。</p></li></ul><p>堆排序需要两个过程</p><ol><li>建堆</li><li>堆顶与堆的最后一个元素交换位置<br>这就对应了堆排序的两个函数</li><li>建堆</li><li>交换，从堆中踢出最大数</li><li>剩余结点再建堆，再交换踢出最大数</li><li>以此类推：最后堆中剩余的最后两个结点交换，踢出一个，排序完成。</li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/icHoerKO3NjIlME1HxoRpx2g9rGuM9jjjXBrfeVDA6b8RC2xmb2QOlxFiaHMjykEtekzCSAAibISibwCEUcETt6S5Q/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="Alt"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] data,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=data[i];</span><br><span class="line">    data[i]=data[j];</span><br><span class="line">    data[j]=tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] data,<span class="keyword">int</span> lastIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(lastIndex-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      <span class="keyword">int</span> k=i;</span><br><span class="line">      <span class="keyword">while</span>(k*<span class="number">2</span>+<span class="number">1</span>&lt;=lastIndex)&#123;</span><br><span class="line">        <span class="keyword">int</span> biggerIndex=<span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(biggerIndex&lt;lastIndex)&#123;</span><br><span class="line">          <span class="keyword">if</span>(data[biggerIndex]&lt;data[biggerIndex+<span class="number">1</span>])&#123;</span><br><span class="line">            biggerIndex++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data[k]&lt;data[biggerIndex])&#123;</span><br><span class="line">          swap(data,k,biggerIndex);</span><br><span class="line">          k=biggerIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"开始排序"</span>);</span><br><span class="line">    <span class="keyword">int</span> arrayLength=a.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arrayLength-<span class="number">1</span>;i++)&#123;</span><br><span class="line">      buildMaxHeap(a,arrayLength-<span class="number">1</span>-i);</span><br><span class="line">      swap(a,<span class="number">0</span>,arrayLength-<span class="number">1</span>-i);</span><br><span class="line">      System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>&#125;;</span><br><span class="line">  </span><br><span class="line">    heapSort(a);</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li><p>最佳情况：O(nlogn)</p></li><li><p>最坏情况：O(nlogn)</p></li><li><p>平均时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(1)</p></li><li><p>不稳定排序算法</p></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>基本思想：在要排序的一组数中。对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，<br>让较大的数往下沉，较小的往上冒。<br>即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/icHoerKO3NjIlME1HxoRpx2g9rGuM9jjjlVPfcLDp2YuTzOO0DTrQhvumKmYr4qaMTsvvt8GBx5vAbv7I6tQ2jQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="Alt txt"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">        temp=a[j];</span><br><span class="line">        a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>]=temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">  System.out.println(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li><p>最佳情况：O(n) </p></li><li><p>最差情况：O(n^2)</p></li><li><p>平均时间复杂度：O(n^2)</p></li><li><p>空间复杂度为O(1)</p></li><li><p>稳定排序算法</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>基本思想：选择一个基准元素，通常选择第一个元素或者最后一个元素，<br>通过一趟扫描，将待排序序列分成两部分，一部分比基准元素小，一部分大于等于基准元素，<br>此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。</p></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/icHoerKO3NjIlME1HxoRpx2g9rGuM9jjjRsxQEic8G80IsV7wW1MF3OR5A1f2SloUFGg01xQZqlCerav7ebHfj1A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="Alt"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMiddle</span><span class="params">(<span class="keyword">int</span>[] list,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=list[low];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">      <span class="keyword">while</span>(low&lt;high&amp;&amp;list[high]&gt;=tmp)&#123;</span><br><span class="line">        high--;</span><br><span class="line">      &#125;</span><br><span class="line">      list[low]=list[high];</span><br><span class="line">      <span class="keyword">while</span>(low&lt;high&amp;&amp;list[low]&lt;=tmp)&#123;</span><br><span class="line">        low++;</span><br><span class="line">      &#125;</span><br><span class="line">      list[high]=list[low];</span><br><span class="line">    &#125;</span><br><span class="line">    list[low]=tmp;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] list, <span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">      <span class="keyword">int</span> middle=getMiddle(list, low, high);</span><br><span class="line">      quickSort(list,low,middle-<span class="number">1</span>);</span><br><span class="line">      quickSort(list,middle+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] a2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a2.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      quickSort(a2,<span class="number">0</span>,a2.length-<span class="number">1</span>);;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>&#125;;</span><br><span class="line">    </span><br><span class="line">     quick(a);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">       System.out.println(a[i]);</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a>算法分析：</h4><ul><li><p>最佳情况：O(nlogn)</p></li><li><p>最坏情况：O(n^2)</p></li><li><p>平均时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(nlogn)</p></li><li><p>不稳定排序算法</p></li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>基本思想：归并排序法是将两个（或两个以上）有序表合并成一个新的有序表，<br>即把待排序序列分为若干个子序列，每个子序列是有序的。然后把子序列合并成整体有序序列。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/icHoerKO3NjIlME1HxoRpx2g9rGuM9jjjezRsKjelic9f8s83C1enOwpIvVVLdvqLtbckwK7z9Iibww3VReNwncTQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="Alt"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">      <span class="keyword">int</span> center=(left+right)/<span class="number">2</span>;</span><br><span class="line">      sort(data,left,center);</span><br><span class="line">      sort(data, center+<span class="number">1</span>, right);</span><br><span class="line">      merge(data,left,center,right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] data,<span class="keyword">int</span> left,<span class="keyword">int</span> center,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [] tmpArr=<span class="keyword">new</span> <span class="keyword">int</span>[data.length];</span><br><span class="line">    <span class="keyword">int</span> mid=center+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> third=left;</span><br><span class="line">    <span class="keyword">int</span> tmp=left;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=center&amp;&amp;mid&lt;=right)&#123;</span><br><span class="line">      <span class="keyword">if</span>(data[left]&lt;=data[mid])&#123;</span><br><span class="line">        tmpArr[third++]=data[left++];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        tmpArr[third++]=data[mid++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(mid&lt;=right)&#123;</span><br><span class="line">      tmpArr[third++]=data[mid++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=center)&#123;</span><br><span class="line">      tmpArr[third++]=data[left++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tmp&lt;=right)&#123;</span><br><span class="line">      data[tmp]=tmpArr[tmp++];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(data));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>&#125;;</span><br><span class="line">    sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li><p>最佳情况：O(n)</p></li><li><p>最坏情况：O(nlogn)</p></li><li><p>平均时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(n)</p></li><li><p>稳定排序算法</p></li></ul><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基本思想：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/icHoerKO3NjIlME1HxoRpx2g9rGuM9jjjACLdk1fHF8JsldRdXXYdjXKGw2LG7ImPMZ3BkiaibiaveI0JEPas6BgdQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="Alt"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>&#125;;</span><br><span class="line">   sort(a);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">     System.out.println(a[i]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max=array[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array[i]&gt;max)&#123;</span><br><span class="line">      max=array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> time=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(max&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    max/=<span class="number">10</span>;</span><br><span class="line">    time++;</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;ArrayList&gt;queue=<span class="keyword">new</span> ArrayList&lt;ArrayList&gt;();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt;queue1=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    queue.add(queue1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;time;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;array.length;j++)&#123;</span><br><span class="line">      <span class="keyword">int</span> x= array[j]%(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i+<span class="number">1</span>)/(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i);</span><br><span class="line">      ArrayList&lt;Integer&gt;queue2=queue.get(x);</span><br><span class="line">      queue2.add(array[j]);</span><br><span class="line">      queue.set(x,queue2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">      <span class="keyword">while</span>(queue.get(k).size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt;queue3=queue.get(k);</span><br><span class="line">        array[count]=queue3.get(<span class="number">0</span>);</span><br><span class="line">        queue3.remove(<span class="number">0</span>);</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a>算法分析：</h4><ul><li><p>最佳情况：O(n*k)</p></li><li><p>最坏情况：O(n*k)</p></li><li><p>平均时间复杂度：O(n*k)</p></li><li><p>空间复杂度：O(n)</p></li><li><p>稳定排序算法</p></li></ul>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>洛神赋</title>
      <link href="/%E6%91%98%E5%BD%95/%E6%B4%9B%E7%A5%9E%E8%B5%8B/"/>
      <url>/%E6%91%98%E5%BD%95/%E6%B4%9B%E7%A5%9E%E8%B5%8B/</url>
      <content type="html"><![CDATA[<p><img src="/img/luoshenfu.jpg" alt="Alt text"></p><h1 id="洛神赋"><a href="#洛神赋" class="headerlink" title="洛神赋"></a>洛神赋</h1><p>　　　　　　　【作者】曹植 【朝代】魏晋<br>黄初三年，余朝京师，还济洛川。古人有言，斯水之神，名曰宓妃。感宋玉对楚王神女之事，遂作斯赋。其辞曰：</p><p>余从京域，言归东藩。背伊阙，越轘辕，经通谷，陵景山。日既西倾，车殆马烦。尔乃税驾乎蘅皋，秣驷乎芝田，容与乎阳林，流眄乎洛川。于是精移神骇，忽焉思散。俯则末察，仰以殊观，睹一丽人，于岩之畔。乃援御者而告之曰：“尔有觌于彼者乎？彼何人斯？若此之艳也！”御者对曰：“臣闻河洛之神，名曰宓妃。然则君王所见，无乃日乎？其状若何？臣愿闻之。”</p><p>余告之曰：“其形也，翩若惊鸿，婉若游龙。荣曜秋菊，华茂春松。仿佛兮若轻云之蔽月，飘摇兮若流风之回雪。远而望之，皎若太阳升朝霞；迫而察之，灼若芙蕖出渌波。秾纤得衷，修短合度。肩若削成，腰如约素。延颈秀项，皓质呈露。芳泽无加，铅华弗御。云髻峨峨，修眉联娟。丹唇外朗，皓齿内鲜，明眸善睐，靥辅承权。瑰姿艳逸，仪静体闲。柔情绰态，媚于语言。奇服旷世，骨像应图。披罗衣之璀粲兮，珥瑶碧之华琚。戴金翠之首饰，缀明珠以耀躯。践远游之文履，曳雾绡之轻裾。微幽兰之芳蔼兮，步踟蹰于山隅。</p><p>于是忽焉纵体，以遨以嬉。左倚采旄，右荫桂旗。壤皓腕于神浒兮，采湍濑之玄芝。余情悦其淑美兮，心振荡而不怡。无良媒以接欢兮，托微波而通辞。愿诚素之先达兮，解玉佩以要之。嗟佳人之信修，羌习礼而明诗。抗琼［王弟］以和予兮，指潜渊而为期。执眷眷之款实兮，惧斯灵之我欺。感交甫之弃言兮，怅犹豫而狐疑。收和颜而静志兮，申礼防以自持。</p><p>于是洛灵感焉，徙倚彷徨，神光离合，乍阴乍阳。竦轻躯以鹤立，若将飞而未翔。践椒涂之郁烈，步蘅薄而流芳。超长吟以永慕兮，声哀厉而弥长。</p><p>尔乃众灵杂遢，命俦啸侣，或戏清流，或翔神渚，或采明珠，或拾翠羽。从南湘之二妃，携汉滨之游女。叹匏瓜之无匹兮，咏牵牛之独处。扬轻袿之猗靡兮，翳修袖以延伫。体迅飞凫，飘忽若神，凌波微步，罗袜生尘。动无常则，若危若安。进止难期，若往若还。转眄流精，光润玉颜。含辞未吐，气若幽兰。华容婀娜，令我忘餐。</p><p>于是屏翳收风，川后静波。冯夷鸣鼓，女娲清歌。腾文鱼以警乘，鸣玉鸾以偕逝。六龙俨其齐首，载云车之容裔，鲸鲵踊而夹毂，水禽翔而为卫。</p><p>于是越北沚。过南冈，纡素领，回清阳，动朱唇以徐言，陈交接之大纲。恨人神之道殊兮，怨盛年之莫当。抗罗袂以掩涕兮，泪流襟之浪浪。悼良会之永绝兮。哀一逝而异乡。无微情以效爱兮，献江南之明。虽潜处于太阳，长寄心于君王。忽不悟其所舍，怅神宵而蔽光。</p><p>于是背下陵高，足往神留，遗情想像，顾望怀愁。冀灵体之复形，御轻舟而上溯。浮长川而忘返，思绵绵督。夜耿耿而不寐，沾繁霜而至曙。命仆夫而就驾，吾将归乎东路。揽騑辔以抗策，怅盘桓而不能去。</p><p>备注：赋，是我国古代的一种文体，它讲究文采，韵律，兼具诗歌和散文性质。是以“铺采摛文，体物写志”为手段，侧重于写景，借景抒情。以“颂美”和“讽喻”为目的的一种有韵文体。它多用铺陈叙事的手法，赋必须押韵，这是赋区别于其他文体的一个主要特征。 起于战国，盛于两汉。赋最早出现于诸子散文中，叫”短赋“；以屈原为代表的”骚体“是诗向赋的过渡，叫”骚赋“；汉代正式确立了赋的体例，称为“辞赋”；魏晋以后，赋日益向骈文方向发展，叫做“骈赋”；唐代又由骈体转为律体，叫“律赋”；宋代用散文的形式写赋，称“文赋”。著名的赋体文章有司马相如的《子虚赋》，杜牧的《阿房宫赋》，欧阳修的《秋声赋》，苏轼的《赤壁赋》等。<br>作者曹植以浪漫主义的手法，通过梦幻的境界，描写人神之间的真挚爱情，但终因“人神殊道”无从结合而惆怅分离。</p>]]></content>
      
      <categories>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>长恨歌</title>
      <link href="/%E6%91%98%E5%BD%95/%E9%95%BF%E6%81%A8%E6%AD%8C/"/>
      <url>/%E6%91%98%E5%BD%95/%E9%95%BF%E6%81%A8%E6%AD%8C/</url>
      <content type="html"><![CDATA[<h1 id="长恨歌"><a href="#长恨歌" class="headerlink" title="　　　　　长恨歌"></a>　　　　　长恨歌</h1><p>　　　　　　　　　　　　　　　　　　【唐】　白居易<br>　　　　　　　　　　汉皇重色思倾国，御宇多年求不得。</p><p>　　　　　　　　　　杨家有女初长成，养在深闺人未识。</p><p>　　　　　　　　　　天生丽质难自弃，一朝选在君王侧。</p><p>　　　　　　　　　　回眸一笑百媚生，六宫粉黛无颜色。</p><p>　　　　　　　　　　春寒赐浴华清池，温泉水滑洗凝脂。</p><p>　　　　　　　　　　侍儿扶起娇无力，始是新承恩泽时。</p><p>　　　　　　　　　　云鬓花颜金步摇，芙蓉帐暖度春宵。</p><p>　　　　　　　　　　春宵苦短日高起，从此君王不早朝。</p><p>　　　　　　　　　　承欢侍宴无闲暇，春从春游夜专夜。</p><p>　　　　　　　　　　后宫佳丽三千人，三千宠爱在一身。</p><p>　　　　　　　　　　金屋妆成娇侍夜，玉楼宴罢醉和春。</p><p>　　　　　　　　　　姊妹弟兄皆列土，可怜光彩生门户。</p><p>　　　　　　　　　　遂令天下父母心，不重生男重生女。</p><p>　　　　　　　　　　骊宫高处入青云，仙乐风飘处处闻。</p><p>　　　　　　　　　　缓歌谩舞凝丝竹，尽日君王看不足。</p><p>　　　　　　　　　　渔阳鼙鼓动地来，惊破霓裳羽衣曲。</p><p>　　　　　　　　　　九重城阙烟尘生，千乘万骑西南行。</p><p>　　　　　　　　　　翠华摇摇行复止，西出都门百余里。</p><p>　　　　　　　　　　六军不发无奈何，宛转蛾眉马前死。</p><p>　　　　　　　　　　花钿委地无人收，翠翘金雀玉搔头。</p><p>　　　　　　　　　　君王掩面救不得，回看血泪相和流。</p><p>　　　　　　　　　　黄埃散漫风萧索，云栈萦纡登剑阁。</p><p>　　　　　　　　　　峨嵋山下少人行，旌旗无光日色薄。</p><p>　　　　　　　　　　蜀江水碧蜀山青，圣主朝朝暮暮情。</p><p>　　　　　　　　　　行宫见月伤心色，夜雨闻铃肠断声。</p><p>　　　　　　　　　　天旋地转回龙驭，到此踌躇不能去。</p><p>　　　　　　　　　　马嵬坡下泥土中，不见玉颜空死处。</p><p>　　　　　　　　　　君臣相顾尽沾衣，东望都门信马归。</p><p>　　　　　　　　　　归来池苑皆依旧，太液芙蓉未央柳。</p><p>　　　　　　　　　　芙蓉如面柳如眉，对此如何不泪垂。</p><p>　　　　　　　　　　春风桃李花开日，秋雨梧桐叶落时。</p><p>　　　　　　　　　　西宫南内多秋草，落叶满阶红不扫。</p><p>　　　　　　　　　　梨园弟子白发新，椒房阿监青娥老。</p><p>　　　　　　　　　　夕殿萤飞思悄然，孤灯挑尽未成眠。</p><p>　　　　　　　　　　迟迟钟鼓初长夜，耿耿星河欲曙天。</p><p>　　　　　　　　　　鸳鸯瓦冷霜华重，翡翠衾寒谁与共。</p><p>　　　　　　　　　　悠悠生死别经年，魂魄不曾来入梦。</p><p>　　　　　　　　　　临邛道士鸿都客，能以精诚致魂魄。</p><p>　　　　　　　　　　为感君王辗转思，遂教方士殷勤觅。</p><p>　　　　　　　　　　排空驭气奔如电，升天入地求之遍。</p><p>　　　　　　　　　　上穷碧落下黄泉，两处茫茫皆不见。</p><p>　　　　　　　　　　忽闻海上有仙山，山在虚无缥渺间。</p><p>　　　　　　　　　　楼阁玲珑五云起，其中绰约多仙子。</p><p>　　　　　　　　　　中有一人字太真，雪肤花貌参差是。</p><p>　　　　　　　　　　金阙西厢叩玉扃，转教小玉报双成。</p><p>　　　　　　　　　　闻道汉家天子使，九华帐里梦魂惊。</p><p>　　　　　　　　　　揽衣推枕起徘徊，珠箔银屏迤逦开。</p><p>　　　　　　　　　　云鬓半偏新睡觉，花冠不整下堂来。</p><p>　　　　　　　　　　风吹仙袂飘飘举，犹似霓裳羽衣舞。</p><p>　　　　　　　　　　玉容寂寞泪阑干，梨花一枝春带雨。</p><p>　　　　　　　　　　含情凝睇谢君王，一别音容两渺茫。</p><p>　　　　　　　　　　昭阳殿里恩爱绝，蓬莱宫中日月长。</p><p>　　　　　　　　　　回头下望人寰处，不见长安见尘雾。</p><p>　　　　　　　　　　惟将旧物表深情，钿合金钗寄将去。</p><p>　　　　　　　　　　钗留一股合一扇，钗擘黄金合分钿。</p><p>　　　　　　　　　　但教心似金钿坚，天上人间会相见。</p><p>　　　　　　　　　　临别殷勤重寄词，词中有誓两心知。</p><p>　　　　　　　　　　七月七日长生殿，夜半无人私语时。</p><p>　　　　　　　　　　在天愿作比翼鸟，在地愿为连理枝。</p><p>　　　　　　　　　　天长地久有时尽，此恨绵绵无绝期。</p>]]></content>
      
      <categories>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>好了歌</title>
      <link href="/%E6%91%98%E5%BD%95/%E5%A5%BD%E4%BA%86%E6%AD%8C/"/>
      <url>/%E6%91%98%E5%BD%95/%E5%A5%BD%E4%BA%86%E6%AD%8C/</url>
      <content type="html"><![CDATA[<h1 id="红楼梦原文"><a href="#红楼梦原文" class="headerlink" title="红楼梦原文"></a>红楼梦原文</h1><p>甄士隐知投人不著，心中未免悔恨，再兼上年惊唬，急忿怨痛已伤，暮年之人，贫病交攻，竟渐渐的露出那下世的光景来。可巧这日拄了拐杖挣到街前散散心时，忽见那边来了一个跛足道人，疯癫落拓，麻鞋鹑衣，口内念着几句言词道：</p><h3 id="世人都晓神仙好，惟有功名忘不了！"><a href="#世人都晓神仙好，惟有功名忘不了！" class="headerlink" title="世人都晓神仙好，惟有功名忘不了！"></a>世人都晓神仙好，惟有功名忘不了！</h3><h3 id="古今将相在何方？荒冢一堆草没了。"><a href="#古今将相在何方？荒冢一堆草没了。" class="headerlink" title="古今将相在何方？荒冢一堆草没了。"></a>古今将相在何方？荒冢一堆草没了。</h3><h3 id="世人都晓神仙好，只有金银忘不了！"><a href="#世人都晓神仙好，只有金银忘不了！" class="headerlink" title="世人都晓神仙好，只有金银忘不了！"></a>世人都晓神仙好，只有金银忘不了！</h3><h3 id="终朝只恨聚无多，及到多时眼闭了。"><a href="#终朝只恨聚无多，及到多时眼闭了。" class="headerlink" title="终朝只恨聚无多，及到多时眼闭了。"></a>终朝只恨聚无多，及到多时眼闭了。</h3><h3 id="世人都晓神仙好，只有娇妻忘不了！"><a href="#世人都晓神仙好，只有娇妻忘不了！" class="headerlink" title="世人都晓神仙好，只有娇妻忘不了！"></a>世人都晓神仙好，只有娇妻忘不了！</h3><h3 id="君生日日说恩情，君死又随人去了。"><a href="#君生日日说恩情，君死又随人去了。" class="headerlink" title="君生日日说恩情，君死又随人去了。"></a>君生日日说恩情，君死又随人去了。</h3><h3 id="世人都晓神仙好，只有儿孙忘不了！"><a href="#世人都晓神仙好，只有儿孙忘不了！" class="headerlink" title="世人都晓神仙好，只有儿孙忘不了！"></a>世人都晓神仙好，只有儿孙忘不了！</h3><h3 id="痴心父母古来多，孝顺儿孙谁见了？"><a href="#痴心父母古来多，孝顺儿孙谁见了？" class="headerlink" title="痴心父母古来多，孝顺儿孙谁见了？"></a>痴心父母古来多，孝顺儿孙谁见了？</h3><p>士隐听了，便迎上来道：“你满口说些甚么？只听见些‘好了’‘好了’。”那道人笑道：“你若果听见‘好了’二字，还算你明白。可知世上万般，好便是了，了便是好。若不了，便不好；若要好，须是了。我这歌儿便名《好了歌》。”士隐本是有夙慧的，一闻此言，心中早已彻悟，因笑道：“且住！待我将你这《好了歌》注解出来何如？”道人笑道：“你就请解。”士隐乃说道：<br>陋室空堂，当年笏满床。<br>衰草枯杨，曾为歌舞场。<br>蛛丝儿结满雕梁，绿纱今又糊在蓬窗上。<br>说甚么脂正浓、粉正香，如何两鬓又成霜？<br>昨日黄土陇头送白骨，今宵红灯帐底卧鸳鸯。<br>金满箱，银满箱，展眼乞丐人皆谤。<br>正叹他人命不长，那知自己归来丧！<br>训有方，保不定日后作强梁。<br>择膏粱，谁承望流落在烟花巷！<br>因嫌纱帽小，致使锁枷杠，<br>昨怜破袄寒，今嫌紫蟒长。<br>乱烘烘你方唱罢我登场，反认他乡是故乡。<br>甚荒唐，到头来都是为他人作嫁衣裳。</p>]]></content>
      
      <categories>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>归并排序</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>  最基本的2-路归并排序。<br>  原理：将序列两两分组，将序列归并为[n/2]个组，组内单独排序；然后将这些组再两两归并，<br>  生成[n/4]个组，组内在单独排序；以此内推，直到只剩下一个组为止。<br>  时间复杂度为O(nlogn)<br>例：将序列{66,12,33,57,64,27,18}进行2路归并排序</p><ol><li><p>第一趟</p>{ { 12,66 },{ 33,57 },{ 27,64 },{ 18 } }</li><li><p>第二题</p>{ { 12,33,57,66 },{ 18,27,64 } }</li><li><p>第三趟{12,18,27,33,57,64,66}</p></li></ol><ul><li><p>递归实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l1,<span class="keyword">int</span> r1,<span class="keyword">int</span> l2,<span class="keyword">int</span> r2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=l1,j=l2;</span><br><span class="line">    <span class="keyword">int</span> temp[maxn],index=<span class="number">0</span>;<span class="comment">//temp临时存放合并后的数组，index为其下标</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=r1&amp;&amp;j&lt;=r2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])&#123;</span><br><span class="line">            temp[index++]=a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp[index++]=a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=r1) temp[index++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r2) temp[index++]=a[j++];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">        a[l1+i]=temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    mergeSort(a,left,mid); <span class="comment">//左子区间归并排序</span></span><br><span class="line">    mergeSort(a,mid+<span class="number">1</span>,right);<span class="comment">//右子区间归并排序</span></span><br><span class="line">    merge(a,left,mid,mid+<span class="number">1</span>,right); 将左右子区间合并</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非递归实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">2</span>;step/<span class="number">2</span>&lt;=n;step*=<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i+=step)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=i+step/<span class="number">2</span><span class="number">-1</span>;  </span><br><span class="line">        <span class="keyword">if</span>(mid+<span class="number">1</span>&lt;=n)&#123;     <span class="comment">//sort(a+i,a+min(i+step,n+1));</span></span><br><span class="line">            merge(a,i,mid,mid+<span class="number">1</span>,min(i+step<span class="number">-1</span>,n))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>区间贪心</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83/</url>
      <content type="html"><![CDATA[<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>  贪心是用来解决一类最优化问题，并希望由局部最优策略来推得全局最优结果的算法思想。<br>  贪心算法使用的问题一定满足最优子结构性质，即一个问题的最优解可以由它的子问题的最优解有效地构造出来。</p><h2 id="区间不相交问题："><a href="#区间不相交问题：" class="headerlink" title="区间不相交问题："></a>区间不相交问题：</h2><p>  给出n个开区间(x,y),从中选择尽可能多的区间，使得这些开区间两两没有交集。<br>  首先考虑最简单的情况，即开区间I1被开区间I2包含，那么I1显然是最好的选择，因为这样就有更大的空间去容纳其他区间。<br>  之后将所有开区间按左端点x从大到小排序，总是先选择左端点最大的区间。当然也可以考虑选择右端点最小的区间。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">110</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inteval</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Inteval a,Inteval b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a.x!=b.x) <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n),n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;q[i].x,&amp;q[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(q,q+n,cmp);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>,lastx = q[<span class="number">0</span>].x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i].y&lt;=lastx)&#123;</span><br><span class="line">                lastx=q[i].x;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="区间选点问题："><a href="#区间选点问题：" class="headerlink" title="区间选点问题："></a>区间选点问题：</h2><p>  给出n个闭区间[x,y],求最少需要确定多少个点，才能使每个闭区间中都至少存在一个点。</p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ZCMU2034</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/ZCMU-2034/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/ZCMU-2034/</url>
      <content type="html"><![CDATA[<h1 id="阶乘计算"><a href="#阶乘计算" class="headerlink" title="阶乘计算"></a>阶乘计算</h1><p>Time Limit: 1 Sec  Memory Limit: 128 MB<br>Submit: 43  Solved: 34<br>[Submit][Status][Web Board]<br>Description<br>输入一个正整数n，输出n!的值。<br>其中n!=1<em> 2 </em> 3 <em>…</em>n。<br>算法描述<br>n!可能很大，而计算机能表示的整数范围有限，需要使用高精度计算的方法。使用一个数组A来表示一个大整数a，A[0]表示a的个位，A[1]表示a的十位，依次类推。<br>将a乘以一个整数k变为将数组A的每一个元素都乘以k，请注意处理相应的进位。<br>首先将a设为1，然后乘2，乘3，当乘到n时，即得到了n!的值。</p><p>Input<br>　　输入包含一个正整数n，n&lt;=1000。</p><p>Output<br>　　输出n!的准确值。</p><p>Sample Input<br>10<br>Sample Output<br>3628800<br>HINT<br>Source<br>基础练习</p><p>相当于是大数的阶乘，也就是基本类型存不下，需要用数组来进行模拟。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3000</span>],i,j,n;  </span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">0</span>,s;  </span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);  </span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3000</span>;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            s=a[j]*i+c;  </span><br><span class="line">            a[j]=s%<span class="number">10</span>;  </span><br><span class="line">            c=s/<span class="number">10</span>;<span class="comment">//保留进位  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2999</span>;i&gt;=<span class="number">0</span>;i--)  </span><br><span class="line">        <span class="keyword">if</span>(a[i])  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">for</span>(j=i;j&gt;=<span class="number">0</span>;j--)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[j]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZCMU </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ZCMU-1620</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/ZCMU-1620/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/ZCMU-1620/</url>
      <content type="html"><![CDATA[<h2 id="1620-全排列"><a href="#1620-全排列" class="headerlink" title="1620: 全排列"></a>1620: 全排列</h2><p>Time Limit: 1 Sec  Memory Limit: 128 MB<br>Submit: 198  Solved: 89<br>[Submit][Status][Web Board]<br>Description<br>给定n个数 a[0] , a[1] …….. a[n-1], 输出其全排列。</p><p>Input<br>第一行输入一个数n，（n&lt;7）</p><p>接下来一行输入n个数。</p><p>Output<br>按字典序从小到大输出全排列</p><p>Sample Input<br>3<br>1 2 3<br>3<br>1 2 2<br>Sample Output<br>1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1<br>1 2 2<br>2 1 2<br>2 2 1<br>HINT</p><ul><li><p>全排列，枚举排列常用的方法有两种：一种是递归枚举，另一种是用STL中的next_permutation</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_permutation</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> *p,<span class="keyword">int</span> *a,<span class="keyword">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!i||p[i]!=p[i<span class="number">-1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ok=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c1=<span class="number">0</span>,c2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cur;j++)<span class="keyword">if</span>(a[j]==p[i]) c1++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) <span class="keyword">if</span>(p[i]==p[j]) c2++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(c1&lt;c2)&#123;</span><br><span class="line">            a[cur]=p[i];</span><br><span class="line">            print_permutation(n,p,a,cur+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,p[<span class="number">10</span>],a[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(p,p+n);</span><br><span class="line">        print_permutation(n,p,a,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        sort(a,a+n);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n<span class="number">-1</span>]);</span><br><span class="line">        &#125;<span class="keyword">while</span>(next_permutation(a,a+n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZCMU </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《控方证人》观后感</title>
      <link href="/%E9%9A%8F%E7%AC%94/%E3%80%8A%E6%8E%A7%E6%96%B9%E8%AF%81%E4%BA%BA%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/"/>
      <url>/%E9%9A%8F%E7%AC%94/%E3%80%8A%E6%8E%A7%E6%96%B9%E8%AF%81%E4%BA%BA%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/</url>
      <content type="html"><![CDATA[<p><img src="/img/1522739023761.png" alt="Alt text"><br>  　　这个周末有点小忙哈哈，没办法，得准备Ｊａｖａ课件呀，好歹也是个愚人节呢，得让自己放松下，于是花了点时间看了部老电影《控方证人》，一部上世纪６０年代的电影，一部黑白片。我一般不大会特意去找某部电影，一些早已被广为认可的经典我会时不时抽几部欣赏欣赏，很少有令我失望过，当然，这次也不例外。<br>  　　很好的一部剧情片，惊悚我倒没怎么感觉到，但不得不说，一流的演员以及一流的剧本让我佩服不已，至少我是被骗到了，结局在我的意料之外，当然中间确实有些困惑的地方，我很理解为什么沃尔的妻子竟然当起了控方证人。影片开始，个性鲜明的律师威尔弗里德爵士便出现在荧幕上，很有意思的一个家伙，一看到雪茄就耐不住想吸上一口，看似嘴不饶人，其实内心善良热诚。他身边的护士尽管一天到晚啰里啰嗦招人烦，却也是真正为威尔弗里德爵士的健康着想。紧接着，剧情展开，控方与被告的辩论也即将展开。<br>  　　我为什么说我被骗到了，起初我真的认为沃尔是无辜的，是被冤枉的，富婆的死只是被某个入室抢劫犯误杀了，紧接着，伟大的威尔弗里德爵士作为正义的化身，冒着身体旧病复发的风险为沃尔展开辩护，然后一步步过关斩将，去的胜利，沃尔无罪释放！看，结局多么美好，但细想一番，若真是如此，这剧情片恐怕也难成为经典了。开头的警巡，包括之后的女佣，这两人的证词在我看来都很正常，警巡，按照职业习惯进行了正常的回答。至于女佣，势利的姿态可以说是展现的很充分，哈哈，这世上没有无缘无故的恨，沃尔的出现让本该属于她的遗产瞬间成为一场空，他恨透了沃尔，巴不得看着他上绞刑架．．但后一位控方证人让我难以理解，那就是沃尔的妻子克里斯汀，她的出现让我困惑，我相信威尔弗里德爵士当时也是和我相似的心情。看似恩爱的夫妻有什么理由说反目就反目呢，难道之前的感情本就是虚假的？没看到结尾，我真的没猜到这对夫妻竟然都在演戏，在法庭上演了一出精彩的戏。只不过人人喊打的克里斯汀确是陷入爱情的有心人，而看似无辜的沃尔才是花心大萝卜，才是真凶。法律规定，嫌疑人的妻子是无法为其辩护的，证词无效，于是克里斯汀就想到了该当控告，直到最后决定判决的那几分情书信纸，也不过只是她的计划一部分。好可怕的一个女人，竟然铁定了心犯伪证罪也要救这样一个花心大萝卜，难以理解。两个人一唱一和的一出戏，骗过了整个法庭，我没有想到，沃尔竟然真的杀了富婆，更没想到克里斯汀知道是他杀了富婆还要牺牲自己就他，更没想到两人的感情，谁是真心，谁是假意让我一脸蒙蔽，人生如戏，全靠演技呀！哈哈哈～～</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影视 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的2017书单</title>
      <link href="/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%842017%E4%B9%A6%E5%8D%95/"/>
      <url>/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%842017%E4%B9%A6%E5%8D%95/</url>
      <content type="html"><![CDATA[<p>1、《平凡的世界》<br>2、《霜冷长河》<br>3、《霍乱时期的爱情》<br>4、《文化苦旅》<br>5、《千年一叹》<br>6、《许三观卖血记》<br>7、《白夜行》<br>8、《嫌疑人X的献身》<br>9、《解忧杂货店》<br>10、《资治通鉴》<br>11、《活着》<br>12、《三体》<br>13、《百年孤独》<br>14、《活着为了讲述》<br>15、《人生》<br>16、《偷影子的人》<br>17、《黄金时代》<br>18、《无声告白》<br>19、《小王子》<br>20、《夜莺与玫瑰》<br>21、《飘》<br>22、《海边的卡夫卡》<br>23、《东方快车上的谋杀案》<br>24、《挪威的森林》<br>25、《雪国》<br>26、《不能承受的生命之轻》<br>27、《恶意》<br>28、《陶庵梦忆》<br>29、《红楼梦》<br>30、《沉默的大多数》<br>31、《少年维特的烦恼》<br>32、《傲慢与偏见》<br>33、《麦田里的守望者》<br>34、《北岛诗集》<br>35、《顾城诗集》<br>36、《海子诗集》<br>37、《余光中散文诗集》<br>38、《鳄鱼街》<br>39、《自由在高处》<br>40、《愿你与这世界温暖相拥》<br>41、《很高兴见到你》<br>42、《无证之罪》<br>43、《白马山庄杀人事件》<br>44、《浮士德》<br>45、《老人与海》<br>46、《北鸢》<br>47、《菜根谭》<br>48、《单恋》<br>49、《鬼谷子》<br>50、《人类群星闪耀时》<br>51、《人间词话》<br>52、《古文观止》<br>53、《假面饭店》<br>54、《幻夜》<br>55、《看见》<br>56、《撒哈拉的故事》<br>57、《月亮和六便士》<br>58、《漫漫自由路》<br>59、《1984》<br>60、《1980年代的爱情》<br>61、《本草纲目》<br>62、《傅雷家书》<br>63、《我们三》<br>64、《围城》<br>65、《钱钟书传》<br>66、《草房子》<br>67、《我的职业是小说家》<br>68、《爱你就像爱生命》<br>69、《这些人那些事》<br>70、《明朝那些事》</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++字符串操作</title>
      <link href="/%E8%AF%AD%E8%A8%80/C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
      <url>/%E8%AF%AD%E8%A8%80/C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h1 id="1）字符串操作"><a href="#1）字符串操作" class="headerlink" title="1）字符串操作"></a>1）字符串操作</h1><p>strcpy(p, p1) 复制字符串<br>strncpy(p, p1, n) 复制指定长度字符串<br>strcat(p, p1) 附加字符串<br>strncat(p, p1, n) 附加指定长度字符串<br>strlen(p) 取字符串长度<br>strcmp(p, p1) 比较字符串<br>strcasecmp忽略大小写比较字符串<br>strncmp(p, p1, n) 比较指定长度字符串<br>strchr(p, c) 在字符串中查找指定字符<br>strrchr(p, c) 在字符串中反向查找<br>strstr(p, p1) 查找字符串<br>strpbrk(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找该集合的任一元素<br>strspn(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找不属于该集合的任一元素的偏移<br>strcspn(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找属于该集合的任一元素的偏移  </p><ul><li>具有指定长度的字符串处理函数在已处理的字符串之后填补零结尾符 </li></ul><h1 id="2）字符串到数值类型的转换"><a href="#2）字符串到数值类型的转换" class="headerlink" title="2）字符串到数值类型的转换"></a>2）字符串到数值类型的转换</h1><p>strtod(p, ppend) 从字符串 p 中转换 double 类型数值，并将后续的字符串指针存储到 ppend 指向的 char* 类型存储。<br>strtol(p, ppend, base) 从字符串 p 中转换 long 类型整型数值，base 显式设置转换的整型进制，设置为 0 以根据特定格式判断所用进制，0x, 0X 前缀以解释为十六进制格式整型，0    前缀以解释为八进制格式整型<br>atoi(p) 字符串转换到 int 整型<br>atof(p) 字符串转换到 double 符点数<br>atol(p) 字符串转换到 long 整型 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">int</span> c, <span class="keyword">size_t</span> count)</span></span>;  </span><br><span class="line">将dest前面count个字符置为字符c.  返回dest的值. </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>;  </span><br><span class="line">从src复制count字节的字符到dest. 如果src和dest出现重叠, 函数会自动处理.  返回dest的值. </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>;  </span><br><span class="line">从src复制count字节的字符到dest. 与memmove功能一样, 只是不能处理src和dest出现重叠.  返回dest的值. </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">int</span> c, <span class="keyword">size_t</span> count)</span></span>;  </span><br><span class="line">在buf前面count字节中查找首次出现字符c的位置. 找到了字符c或者已经搜寻了count个字节, 查找即停止. 操作成功则返回buf中首次出现c的位置指针, 否则返回<span class="literal">NULL</span>. </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *_memccpy(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">int</span> c, <span class="keyword">size_t</span> count);  </span><br><span class="line">从src复制<span class="number">0</span>个或多个字节的字符到dest. 当字符c被复制或者count个字符被复制时, 复制停止. </span><br><span class="line"></span><br><span class="line">如果字符c被复制, 函数返回这个字符后面紧挨一个字符位置的指针. 否则返回<span class="literal">NULL</span>.</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">实现<span class="built_in">strcpy</span>函数,将源串strSrc的内容复制到目标串strDest，返回值为指向目标串的指针</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *strDest,<span class="keyword">const</span> <span class="keyword">char</span> *strSrc)</span><span class="comment">//源字符串+const，表明其为输入参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert((strDest!=<span class="literal">NULL</span>&amp;&amp;(strSrc!=<span class="literal">NULL</span>)));</span><br><span class="line">    <span class="comment">//对源地址和目的地址加非0判断</span></span><br><span class="line">    <span class="keyword">char</span> *address=strDest;</span><br><span class="line">    <span class="keyword">while</span>((*strDest++=*strSrc++)!=<span class="string">'\0'</span>);</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br><span class="line">实现<span class="built_in">strcat</span>函数：将源串添加到str1的末尾，同时覆盖旧串末尾的<span class="string">'\0'</span>,在新串末尾+<span class="string">'\0'</span>,返回指向str1的指针。</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p=str1;</span><br><span class="line">    assert((str1!=<span class="literal">NULL</span>)&amp;&amp;(str2!=<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(*str1!=<span class="string">'\0'</span>)</span><br><span class="line">        str1++;</span><br><span class="line">    <span class="keyword">while</span>(*str1++=*str2++);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcmp</span>函数：比较str1和str2两个字符串的大小，若str1&gt;str2，则返回正数；若str1&lt;str2，则返回负数；若str1==str2，则返回<span class="number">0</span>。</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">strcmp</span>(<span class="keyword">const</span> <span class="keyword">char</span> *str1,<span class="keyword">const</span> <span class="keyword">char</span> *str2)</span><br><span class="line">&#123;</span><br><span class="line">    assert((str1!=<span class="literal">NULL</span>)&amp;&amp;(str2!=<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(*str1&amp;&amp;*str2&amp;&amp;(*str1==*str2))</span><br><span class="line">    &#123;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *str1-*str2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s,<span class="keyword">int</span> c,<span class="keyword">size_t</span> n)</span> <span class="comment">//将已开辟内存空间s的首n个字节的值设为c</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(s!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span> *tmp=(<span class="keyword">char</span> *)s;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        *tmp++=(<span class="keyword">char</span>)c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest,<span class="keyword">const</span> <span class="keyword">void</span> *src,<span class="keyword">size_t</span> n)</span><span class="comment">//从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(dest!=<span class="literal">NULL</span>&amp;&amp;src!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span> *tmpdest=(<span class="keyword">char</span> *)dest;</span><br><span class="line">    <span class="keyword">char</span> *tmpsrc=(<span class="keyword">char</span> *)src;</span><br><span class="line">    <span class="keyword">while</span>(n-- &gt;<span class="number">0</span>)</span><br><span class="line">        *tmpdest++=*tmpsrc++;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现C的strstr"><a href="#实现C的strstr" class="headerlink" title="实现C的strstr"></a>实现C的strstr</h2><p>功能：从字符串str1中查找是否有字符串str2，<br>    -如果有，从str1中的str2位置起，返回str1中str2起始位置的指针，如果没有，返回null。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mystrstr</span><span class="params">(<span class="keyword">char</span> *s1 , <span class="keyword">char</span> *s2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(*s1==<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(*s2)   </span><br><span class="line">            <span class="keyword">return</span>(<span class="keyword">char</span>*)<span class="literal">NULL</span>;  </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">char</span>*)s1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(*s1)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(s2[i]==<span class="number">0</span>)   </span><br><span class="line">                <span class="keyword">return</span> s1;  </span><br><span class="line">            <span class="keyword">if</span>(s2[i]!=s1[i])   </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        s1++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">strStr</span><span class="params">(<span class="keyword">char</span> *haystack, <span class="keyword">char</span> *needle)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// Start typing your C/C++ solution below  </span></span><br><span class="line">        <span class="comment">// DO NOT write int main() function  </span></span><br><span class="line">        <span class="keyword">int</span> i,j;  </span><br><span class="line">        <span class="keyword">for</span> (i = j = <span class="number">0</span>; haystack[i] &amp;&amp; needle[j];) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;  </span><br><span class="line">                ++i;  </span><br><span class="line">                ++j;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                i = i - j + <span class="number">1</span>;  </span><br><span class="line">                j = <span class="number">0</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> needle[j]?<span class="number">0</span>:(haystack + i - j);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="用C语言实现函数void-memmove-void-dest-const-void-src-size-t-n-。"><a href="#用C语言实现函数void-memmove-void-dest-const-void-src-size-t-n-。" class="headerlink" title="用C语言实现函数void memmove(void dest, const void *src, size_t n)。"></a>用C语言实现函数void <em>memmove(void </em>dest, const void *src, size_t n)。</h3><p>memmove函数的功能死拷贝src所指向内存内容前n个字节到dest所指的地址上。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">my_memmove</span><span class="params">( <span class="keyword">void</span> * <span class="keyword">const</span> dest, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> src, <span class="keyword">size_t</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// check parameters</span></span><br><span class="line">   <span class="keyword">if</span>( <span class="number">0</span> == n )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>( <span class="literal">NULL</span> == dest || <span class="literal">NULL</span> == src )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span> * psrc = (<span class="keyword">char</span> *)src;</span><br><span class="line">   <span class="keyword">char</span> * pdest = (<span class="keyword">char</span> *)dest;</span><br><span class="line">   <span class="keyword">if</span>( pdest &lt;= psrc || pdest &gt; psrc + n )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"forward overlapping"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="comment">// copy forward direction</span></span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">      &#123;</span><br><span class="line">         *pdest = *psrc;</span><br><span class="line">         pdest++;</span><br><span class="line">         psrc++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"backward overlapping"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="comment">// copy backward direction</span></span><br><span class="line">      pdest = pdest + n;</span><br><span class="line">      psrc = psrc + n;</span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">size_t</span> i = <span class="number">0</span>; i&lt; n; i++ )</span><br><span class="line">      &#123;</span><br><span class="line">         *pdest = *psrc;</span><br><span class="line">         pdest--;</span><br><span class="line">         psrc--;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> *src = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">   <span class="built_in">sprintf</span>( src, <span class="string">"%s"</span>, <span class="string">"hello world!"</span> );</span><br><span class="line">   <span class="keyword">char</span> * dest = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">   <span class="built_in">memset</span>( dest, <span class="number">0</span>, <span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span> ) );</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; src &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">char</span> * result = (<span class="keyword">char</span>*)my_memmove( dest, src, <span class="built_in">strlen</span>(src) );</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">delete</span> src;</span><br><span class="line">   <span class="keyword">delete</span> dest;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="设计一个反转字符串的函数-char-reverse-str-char-str-不使用系统函数。"><a href="#设计一个反转字符串的函数-char-reverse-str-char-str-不使用系统函数。" class="headerlink" title="设计一个反转字符串的函数 char reverse_str(char str),不使用系统函数。"></a>设计一个反转字符串的函数 char <em>reverse_str(char </em>str),不使用系统函数。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现字符串反转     </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">reverse</span><span class="params">(<span class="keyword">char</span> *str)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="keyword">if</span>( !str )     </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;     </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);     </span><br><span class="line">    <span class="keyword">if</span>( len &gt; <span class="number">1</span> )     </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="keyword">char</span> ctemp =str[<span class="number">0</span>];     </span><br><span class="line">        str[<span class="number">0</span>] = str[len<span class="number">-1</span>];        </span><br><span class="line">        str[len-1] = '/0';// 最后一个字符在下次递归时不再处理     </span><br><span class="line">        reverse(str+<span class="number">1</span>); <span class="comment">// 递归调用     </span></span><br><span class="line">        str[len<span class="number">-1</span>] = ctemp;     </span><br><span class="line">    &#125;     </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> str;     </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 非递归实现字符串反转  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">reverse</span><span class="params">(<span class="keyword">char</span> *str)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="keyword">if</span>( !str )     </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;     </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);     </span><br><span class="line">    <span class="keyword">char</span> temp;     </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++ )     </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="comment">// 交换前后两个相应位置的字符     </span></span><br><span class="line">        temp = *(str + i);     </span><br><span class="line">        *(str + i) = *(str + len - <span class="number">1</span> - i);     </span><br><span class="line">        *(str + len - <span class="number">1</span> - i) = temp;     </span><br><span class="line">    &#125;     </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> str;     </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span> src[] = &#123;<span class="string">"abcdef"</span>&#125;;  </span><br><span class="line">    <span class="keyword">char</span> *pdest = reverse(src);  </span><br><span class="line">  </span><br><span class="line">    getchar();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的2016电影</title>
      <link href="/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%842016%E7%94%B5%E5%BD%B1/"/>
      <url>/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%842016%E7%94%B5%E5%BD%B1/</url>
      <content type="html"><![CDATA[<p>1、《马力和马克思》<br>2、《怦然心动》<br>3、《天堂电影院》<br>4、《海上钢琴师》<br>5、《教父系列》<br>6、《控方证人》<br>7、《千与千寻》<br>8、《从你的全世界路过》<br>9、《战狼2》<br>10、《金刚狼3》<br>11、《大话西游系列》<br>12、《鬼子来了》<br>13、《让子弹飞》<br>14、《天才枪手》<br>15、《比利比恩的中场战事》<br>16、《麦兜的故事》<br>17、《美国丽人》<br>18、《泰坦尼克号》<br>19、《阿飞正传》<br>20、《x森林系列》<br>21、《辩护人》<br>22、《记忆碎片》<br>23、《哈尔的移动城堡》<br>24、《烈日灼心》<br>25、《一条狗的使命》<br>26、《致命魔术》<br>27、《星际穿越》<br>28、《驯龙高手》<br>29、《幸福终点站》<br>30、《时空恋旅人》<br>31、《致命ID》<br>32、《你的名字》<br>33、《幽灵公主》<br>34、《盗梦空间》</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影视 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的2016书单</title>
      <link href="/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%842016%E4%B9%A6%E5%8D%95/"/>
      <url>/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%842016%E4%B9%A6%E5%8D%95/</url>
      <content type="html"><![CDATA[<h1 id="你好-这是我的2016书单。"><a href="#你好-这是我的2016书单。" class="headerlink" title="你好,这是我的2016书单。"></a>你好,这是我的2016书单。</h1><p>1、《一句顶一万句》<br>2、《寻路中国》<br>3、《人类简史》<br>4、《一只特立独行的猪》<br>5、《三国演义》<br>6、《世说新语》<br>7、《战国策》<br>8、《春风沉醉的夜晚》<br>9、《水浒传》<br>10、《茶花女》<br>11、《天黑以后》<br>12、《悟空传》<br>13、《苦妓回忆录》<br>14、《不属于我们的世纪》<br>15、《身份的焦虑》<br>16、《追忆似水年华》<br>17、《约翰克里斯多夫》<br>18、《无名的裘德》<br>19、《高老头》<br>20、《浮生六记》<br>21、《二手时间》<br>22、《洗澡》<br>23、《爱情和其他魔鬼》<br>24、《芳华》<br>25、《冰与火之歌》<br>26、《远山淡影》<br>27、《目送》<br>28、《自深深处》<br>29、《巨人的陨落》<br>30、《余华短篇集》<br>31、《基督山伯爵》<br>32、《三个火枪手》<br>33、《和喜欢的一切在一起》<br>34、《弗兰克尔自传》<br>35、《重新认识你自己》<br>36、《二十四史》<br>37、《长恨歌》<br>38、《面包树上的女人》<br>39、《追随你的心》<br>40、《不能不去爱的两件事》<br>41、《在这复杂世界里》<br>42、《坏小孩》<br>43、《季羡林私人史》<br>44、《金瓶梅》<br>45、《孤独六讲》<br>46、《我们生活在巨大的差距里》<br>47、《分身》<br>48、《宿命》<br>49、《快乐是在心里》<br>50、《我的精神家园》<br>51、《万历十五年》<br>52、《撒切尔夫人传》<br>53、《飞鸟集》<br>54、《幻灭》<br>55、《当我跑步时我谈些什么》<br>56、《富爸爸、穷爸爸》<br>57、《雅舍小品》<br>58、《一个女子恋爱的时候》<br>59、《从一到无穷大》<br>60、《虚无的十字架》<br>61、《资本论》<br>62、《白说》<br>63、《在细雨中呼喊》</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>满江红</title>
      <link href="/%E9%9A%8F%E7%AC%94/%E6%BB%A1%E6%B1%9F%E7%BA%A2/"/>
      <url>/%E9%9A%8F%E7%AC%94/%E6%BB%A1%E6%B1%9F%E7%BA%A2/</url>
      <content type="html"><![CDATA[<h1 id="满江红–岳飞"><a href="#满江红–岳飞" class="headerlink" title="　　　　满江红–岳飞"></a>　　　　满江红–岳飞</h1><p>　　　　　　　　怒发冲冠，<br>　　　　　　凭栏处，潇潇雨歇。<br>　　　　　　　　抬望眼，<br>　　　　　　　　仰天长啸，<br>　　　　　　　　壮怀激烈。<br>　　　　　　　三十功名尘与土，<br>　　　　　　　八千里路云和月。<br>　　　　　　某等闲，白了少年头，<br>　　　　　　　　　空悲切，<br>　　　　　　　　　靖康耻，<br>　　　　　　　　　犹未雪。<br>　　　　　　　　　臣子恨，<br>　　　　　　　　　何时灭！<br>　　　　　　　　　驾长车，<br>　　　　　　　　踏破贺兰山缺。<br>　　　　　　　　壮志饥餐胡虏肉，<br>　　　　　　　　笑谈渴饮匈奴血。<br>　　　　　　　待从头，收拾旧山河，<br>　　　　　　　　　朝天阙。</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
