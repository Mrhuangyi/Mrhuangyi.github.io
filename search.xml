<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>翟天临事件的背后</title>
      <link href="/%E9%9A%8F%E7%AC%94/%E7%BF%9F%E5%A4%A9%E4%B8%B4%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%83%8C%E5%90%8E/"/>
      <url>/%E9%9A%8F%E7%AC%94/%E7%BF%9F%E5%A4%A9%E4%B8%B4%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%83%8C%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<blockquote><p>翟天临最近可真是热搜榜上的红人，成功吸引了我这个不关注娱乐圈的IT男的关注，让我们来看看这次事件为什么会让全国人民如此愤怒。</p></blockquote><p>我没有看过翟天临的影视剧作品，所以这方面我不太好做评论，但听说演技还是不错的。这次的学术事件引得众人议论纷纷，让翟天临成为年初热搜榜霸榜明星。其实这也不奇怪，和前不久的吴秀波风波比起来，两者事件性质完全不同，娱乐圈私生活混乱的新闻几乎都见怪不怪了，但翟天临这次的问题横跨娱乐圈、学术圈、政商圈，是个十分严重的社会事件。可以说刺痛了广大贫寒学子以及认真科研的师生那脆弱的神经。</p><p>我平时不追星，对娱乐圈也不大感兴趣，除了之前的天价片酬问题，这是我又一次关注该圈。我还专门去网上搜了翟天临的百科介绍，学业一栏的履历如下：</p><blockquote><p>2006年，考入北京电影学院表演本科班。2010年毕业于北京电影学院06级表演本科班；同年，在北京电影学院表演系硕士研究生班就读，并担任表演本科班助教老师。2014年，考取北京电影学院电影学专业博士研究生  。2016年9月，获得北京电影学院2016-2017年度博士研究生学业奖学金   。2018年6月30日，翟天临完成博士学位的全部学习，正式获得北京电影学院博士研究生学位  。2019年1月10日，翟天临正式被北京大学光华管理学院录用为工商管理学博士后。</p></blockquote><p>够光鲜吧，一路北影本硕博学位到手，并且顺利被北大光华学院录用为博士后。最近部分网友甚至调侃：确定翟天临不是友军？燃烧自己，照亮黑幕。作为广大吃瓜群众的一员，为什么全国网友对翟天临如此口诛笔伐，其实大家不满的决不仅仅是针对翟天临的学术不端，而是背后的教育腐败，高校腐败，教育不公正，是对北影和北大两所高校的不满。可以说反腐的路还任重而道远！中国绝对不会只有一个翟天临，这之前，这之后，必然还有李天临、王天临，这次只不过是碰巧他被推上了风口浪尖。</p><p>如今的社会是个拜金的社会，所有人都一致向钱看，大家都开始意识到钱相当重要，有钱有权好办事，但我们还是希望有一些地方是没有被金钱玷污的，比如学位，比如博士。不论在哪里，博士都应该是个大家听了都会肃然起敬的对象，是学术，是科研的象征。但这下好了，翟天临用亲身经历告诉我们，在中国用钱买个博士学位不是什么问题。我这里不想太多地抨击翟天临，大家都明白，光靠他一个人，还没有能力这么轻松就骗个博士学位，并且进入北大博士后工作站。翟天临无非是败给了自己的人性阴暗的那一面，膨胀的虚荣心和侥幸心理让他与正途越走越远，最后德不配位，闹了这么一出戏。他的背后必然存在着数不尽的钱权色的交易链。中国的腐败得有多厉害，就连我这样一个还没本科毕业的学生就亲历了不少黑幕。之前学车的时候，当时刚要考科三的时候，由于本身练车的时间很短，自己也不是很有信心，教练竟然就来对我说：“要不让你爸花点钱，给那些安全员交点小费，买个保险？”…我心想着：纳尼，还有这种操作，科二2000块，科三1500…当时跟我一起去考的还真有人花这钱了。虽然我也很想一把通过，但还是决定大不了补考吧。这是驾考里的腐败，另外机关里的腐败就更多了，县城里某个一把手快退下来，在这之前，还不忘帮自己的亲戚安排个好工作…当官的知道自己家即将拆迁，连忙加工多盖了一层楼，然后多拿了1000多万的补贴款。</p><p>然而不管外界如何，我们希望象牙塔般的校园是干净的，但国内高校的行政化管理注定这不太可能，事实证明也是如此。这次广大群众希望北影和北大给出一个说的过去的交代。刚刚北大发布了调查通告，果然还是秉承着大事化小，小事化了的宗旨，总结起来就是翟天临确实存在学术不端，我们会对审查小组严肃批评，下不为例，并且推掉翟天临博士后的录用。全篇的官腔，连一个人名都没提到，这是直接的甩锅，甩给北影呀。北大作为国内一等高校，最高学府，这次估计是让不少人失望了。我不知道这次光华学院博士后的录用背后有没有利益输送，所以不太好多说什么。但我想审查小组那几位应该也都是业内专业的人士，都不傻，如果没有利益输送，会就这么把一个水博招进来当全职博士后？只能说，连国之脊梁，国之重器–北大，在名利面前都开始弯腰了。你还想让国内的年轻人不谈赚钱，只谈情怀，谈事业么？</p><p>北大的做法基本就是甩锅，表态跟打太极似的，至少在申明里面没有看到一句实质性的针对某责任人的惩罚。如果北影也能这么糊弄过去，我也就呵呵了。北影可是实实在在的博士学位授予单位。北影里面的问题和北大比起来只会多不会少，最后调查结果如何，处置如何还得看上面的意思，把学校查个底朝天是不大可能的，顶多是拉几个顶罪的然后息事宁人，大家继续各赚各的钱。彻查起来那就不是几个人的事了，整条利益链，利益网你想想看得有多少人，你还让人家学校办不办了。北影表演系的张辉院长也是有意思，被网友戏称玩了一出现代版“烽火戏诸侯”。与原配离婚，并与小24岁的学生结婚，当然这属于私生活，没啥好议论的，但这位院长竟然用公款给她拍电影、让她当女主角，请了一个流量明星当配角，自己给自己颁奖，把艺术创作活生生玩成了过家家。吃瓜群众都已经有点忙不过来了，一个瓜啃完立马又抛了一个过来。</p><p>希望这次事件别又是光打雷不下雨。给期待教育公正的孩子一点点盼头。我只敢用公正这个词，不敢用公平。教育资源从来就没有公平过，正如你要让教育和金钱完全撇开关系这也是不可能的，但我们希望就算你很有钱，权力很大，你享受了普通人接触不到的优质资源，但在最后那个学位证面前，在神圣的学术殿堂面前，每个人都是靠自己真实的学术研究拿到的。说起来高考已经算是很公平的一种招生途径了……我们希望高校稍微干净点，权钱色之类的交易少一点。改革开放40年的成果是可喜的，但问题还不少，甚至说严重的问题相当多。就不要一天到晚喊着中国哪里哪里强大了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>为什么我说考验人性多半会令你失望</title>
      <link href="/%E9%9A%8F%E7%AC%94/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%AF%B4%E8%80%83%E9%AA%8C%E4%BA%BA%E6%80%A7%E5%A4%9A%E5%8D%8A%E4%BC%9A%E4%BB%A4%E4%BD%A0%E5%A4%B1%E6%9C%9B/"/>
      <url>/%E9%9A%8F%E7%AC%94/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%AF%B4%E8%80%83%E9%AA%8C%E4%BA%BA%E6%80%A7%E5%A4%9A%E5%8D%8A%E4%BC%9A%E4%BB%A4%E4%BD%A0%E5%A4%B1%E6%9C%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="永远不要去尝试考验人性-人性真的经不起考验"><a href="#永远不要去尝试考验人性-人性真的经不起考验" class="headerlink" title="永远不要去尝试考验人性,人性真的经不起考验!"></a>永远不要去尝试考验人性,人性真的经不起考验!</h1><blockquote><p>下述内容多为个人见解，难免会犯学术上的错误，欢迎指正。</p></blockquote><a id="more"></a><p>我可能有一天会不与代码打交道，但我这一生不可能不与人打交道，这是避免不了的。这也大大激发了了我对人性理解的兴趣，各类学科里面与人性关联度最高的，又属心理学最甚。为了防止有些人说我以偏概全，说还有某某圣人并非如此，某某大贤已经四大皆空，无欲无求，考验他们的人性纯粹多此一举。我只说大多数情况下的心理状态是如何如何。因为绝大多数人都只是普通人，大部分人既不是圣人，也不是恶人，只是一个普通人，你可以想想看你生活到现在遇到的人，是不是大多和你一样，有自己的欲望和所求，有自己的弱点和困惑。既然是普通人，那么面对各种压力或者说诱惑，不说他真实表现如何，你觉得他的内心想法是如何的呢？</p><p>先来看看人性是什么，字面意思我觉得就是指人的本性，也就是请抛开各种约束，诸如道德，法律等等，人的心理表现已经相对应会做出的行为表现。百度百科的解释分了狭义和广义两种：</p><blockquote><p>狭义上是指人的本质心理属性，也就是人之所以为人的那一部分属性，是人与其它动物相区别的属性；广义上是指人普遍所具有的心理属性，其中包括人与其它动物所共有的那部分心理属性。无论是人的本质心理属性，还是人与动物所共有的属性，由于它们都是人所共有的心理属性，那么这种属性也就不可能是后天的结果，只能是人类天性，属于无条件反射。</p></blockquote><p>我们可以看到不论是狭义还是广义，都是人所共有的心理属性，也就是说指的是先天的，无条件的反射。所以我在之前就提到了，既然是讲人性，就不要将各种外在约束引进来，包括教育，各种行为规范，道德准则等等。因为在这些条件下做出的表现大多并不属于真正的人性表现。是经过了包装的。上述提到的定义其实也就指向了人性的本质，这里其实也引出了关于人性一直以来存在的贯穿于东西方世界的争论，人性本善还是本恶？中国古代关于这个问题一直争论不休，基本四中观点都涵盖了：包括孟子的性善论，认为人生来即有恻隐、善恶、辞让、是非四种“善端”，扩而充之，便可形成仁、义、礼、智的善性。荀子的性恶论，认为“人之性恶，其善伪也。”（《荀子·性恶》）善性是后天人为的。性无善无恶论，这包括：告子的“性无善无不善”论，认为“生之谓性”，“食色，性也”；性有善有恶论，这包括先秦世硕等的有善有恶论，汉杨雄的性善恶混论，董仲舒等的性三品论等：杨雄认为“人之性也，善恶混，修其善则为善人，修其恶则为恶人”；明清之际王夫之的性“日生日成”论，认为人性绝非在“初生之顷”就定型，一成不易，而是随着环境和教养的不同，“性屡移而异”，“未成可成，已成可革”，认为人性是可以培养和不断完善的；北宋的司马光的人性的先天不等论，司马光认为人生来在人性善恶上就先天不平等，无论圣人还是愚人善恶都是兼而有之，只是有些在善性上会占优势，有些人在恶性上会占优势。</p><p>人性最大的一个特点就是复杂性，因此首先我不认同纯粹的人性本恶或者性本善，我的观点就是有善有恶论，只不过是在恶性上占优势还是在善性上占优势因人而异。为什么我说复杂是人性的特点，这其实是很好理解，你看过很多真正出色艺术作品，小说也好，电影也好，电视剧也一样，真正塑造人物形象出色的，往往都是十分立体的人物形象。不像很多常规意义上的，哦，那谁谁谁是个好人，思想端庄正直，那谁谁谁是个坏人，无恶不作。一个人也许他不贪财，但他不一定不好色；一个人也许不好色，但他不一定不慕名；一个人也许不慕名，但他不一定不求权……同样的，一个贪财好色之人也可能重情重义，一个恶贯满盈之人也可能诚实有信，一诺千金。抗日战争时期，有一大波被人唾骂的汉奸，你能想象在这之前，这当中也有人做出过堪称为民族英雄的壮举。生活中人间人嫌弃的一个猥琐男，用钱各种抠门，色眯眯的眼睛不停在那些漂亮女生身上来回移动的家伙，怕是没几个人愿意和他交往，但是当一个同学得了绝症，竟然只有这个人拿出了自己几乎全部的几千块钱积蓄帮助他。</p><p>和复杂性关联比较大的一个特点就是变化性，也就是说人性不是一成不变的，而是可以一直变化着的。这一点说起来或许要困难不少。不是都说了人性是先天性的吗，是人所共有的生理，心理属性吗？难道是你通过教育，通过感化就能改变得了的吗？我认为是可变的，只是程度不同。我在之前提过，我支持的观点是人性有善有恶论，无非每个人善恶的比重不同，在成长过程中，可能一件不经意的小事，但对当事人却造成了极大的震撼，就是这份份震撼，不知不觉间就撼动了在他内心深处的善恶比重。看过武侠小说的人应该遇到过不少这种情况，一个一开始冷酷无情，杀人如麻的杀手为何在后期竟然渐渐放下了恶念，开始走自己的自我救赎之路？一个原先气质轩昂，众人称赞的武林正派人士，为何后期会走上背信弃义，追名逐利的道路？这些人都出现了变化，而这种变化往往都是有引子的。那个杀人如麻的冷血家伙可能有了温柔体贴的妻子，可爱聪慧的孩子，有了一个令人羡慕的美满家庭，他不想自己的亲人的命运因为自己而走上绝路，自然要做出内心的博弈。</p><p>人性另一个逃不开的特点就是自利性。当我提到自利，利己这样的字眼，很多人可能无意中就想到了阴暗面去，这又容易出问题，自利实在是太正常太普遍了，自利绝对不是错，不希望很多人想歪了。很多学者批判现在的学生一个个都是精致的利己主义者，这种批判是否合乎情理呢，或许他们是想说现在的人少了太多奉献精神，牺牲精神，集体精神。但这种批判从某个角度是不合人性的。人性本就是利己的，这是无可辩驳的，而且利己其实不是什么错，这才是真实人性的展现，这反倒有助于社会发展，进步，只要能够正视这样的本性，你想想看专制统治时期，统治者会让这种利己的思想得到发展吗？统治者只会想尽办法巩固自己的统治地位，让底层民众为皇族服务，以为皇族做出贡献为荣。利己心只得压抑着，过度放大显然就漏了马脚，因为这么做往往会触碰到统治阶级的蛋糕，这可是要杀头的哦。</p><p>除了自利性，还有就是普遍性，这我在最开头就说过了，定义里面也讲明了，人性人性，不就是人所共有的本性吗。既然如此，不论你是国家领袖，还是平民百姓；不论你是大学者，大教授，还是普通学生，职场白领，都有着许多共性的人性展露。你看看贪污腐败的问题，上到国务院高层，下到乡镇级村委，纵观历史各朝，哪朝哪代是没有贪污腐败现象的？这里其实展现了很好的人性问题。封建时期腐败问题严重，当然很大一部分是制度问题，纯粹让人性背锅就过分了。古代官场上的腐败，腐败之广，腐败之难治等等，都体现了人性的普遍性，自利性，贪婪性，很多大臣已经做到了一人之下，万人之上，为什么还是要贪污，要知道人性的贪婪可不是那么容易满足的哦。官场上的权臣之术，勾心斗角，权利角逐，无一不是人性的外在表现，帝王有着自己的野心，大臣打着自己的算盘，你想着捞够名和利就功成身退，我想着要你鞠躬尽瘁死而后已。</p><p>人性还有一个很好的表现常常展现的淋漓尽致，那就是性欲望，性欲很显然的，是来自内在本源驱动的。但是人类文化的发展，需要对性欲加工，性欲毫无限制的表现很多人认为是趋于兽性的，我们需要爱情来掩盖性欲，我们需要夫妻制来限制性欲，这都是人类文化前进的需求。但人的性与本身至今还是如初，不论你是否已婚，是否有了恋人，当一个充满魅惑的女子在你面前，往往还是能够勾起你本能的性欲，但是道德准则，爱情准则，法律准则告诫你，好好收起你内心的性欲吧，你是有妻子的，有家室的人了。当然也还是会有人出问题，出轨的现象有不少，这里当然也不能全让人性背锅，也许感情变了，也许不爱了，但也许真的只是一时的性欲冲昏了头脑。</p><p>人性的复杂让我不可能用几段文字将其介绍完尽，回过头，来看看很多人喜欢考验人性结果最后自讨苦吃的结局。这种事还是少做比较好，来看看考验人性的本质，既然你想要考验人性，那么其实你多半想要考验的其实是人性的阴暗面，也就是常常被人们藏起来的那一面。我说人性是有善有恶的，但你既然指的是考验，我想你总不会是想看看对方到底还能有多善良，多忠诚，多完美无缺，你想考验一下对方会不会背叛你，对方会不会不为名利所动，对方会不会不为美色所动。你想知道他能不能抗住自己的人性阴暗面，而不是想看看对方人性的阳光面有多美好，多善良。另外既然你说了是考验，那么本质上带有欺骗性，你想要看看对方在尽可能没有约束的环境下会做出何样的的选择。绝大多数人是普通人，普通人的定力又是相当有限，有了钱，想要更多，这才是人性，而不是知足常乐，有了恋人，想要长得更漂亮，身材更火辣，更温柔的对象，这才是人性；已经步入小康，想要往更高阶级爬，这才是人性；胜利了而骄傲，失败了而气馁，这才是人性。当你选择了考验，发现对方不过如此你又能如何，再说既然是欺骗，对方做出了遵从本性的选择实在是情理之中，你只能失望而归。生活已经如此艰难，你又何苦再让对方再人性的挣扎面前多几分纠结，最后甚至闹得不欢而散，好好珍惜对方为了你已经克服了人性的阴暗面吧，何苦还要在用欺骗的手法逼出人性的另一面呢，人性如何，由人性的普遍性可知大家很多时候都是心知肚明的。当你想要考验对方的时候，麻烦你先认真想想自己的本性如何，当真在七情六欲面前能够自控自如，收放自如？</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Maven入门指南</title>
      <link href="/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/Maven%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
      <url>/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/Maven%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven是什么？"><a href="#Maven是什么？" class="headerlink" title="Maven是什么？"></a>Maven是什么？</h1><p>Maven是一个项目管理工具，当然也有很多人称它为一个构建工具。<br>它包含了一个项 目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在 生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。   </p><p>其实Maven主要的作用就是解析一些XML文档，管理生命周期和插件。<br>其他的主要职责基本都是被委派给Maven插件，这些仓库可以从中央Maven核心仓库获取。这些插件有专人维护，你可以从远处仓库下载得到，这又体现了Maven插件的全局性重用。  </p><p>Maven维护了项目的模型，实现了如下重要特征：</p><ul><li>依赖管理</li></ul><p>由于项目是根据一个包含组标识符，构件标识符和版本的唯一的坐标定义的。项<br>        目间可以使用这些坐标来声明依赖。  </p><ul><li>远程仓库</li></ul><p>和项目依赖相关的，我们可以使用定义在项目对象模型(POM)中的坐标来创建 Maven 构件的仓库。</p><ul><li>全局性构建逻辑重用</li></ul><p>插件被编写成和项目模型对象(POM)一起工作，它们没有被设计成操作某一个 已知位置的特定文件。一切都被抽象到模型中，插件配置和自定义行为都在模型 中进行。</p><ul><li>工具可移植性/集成</li></ul><p>像 Eclipse，NetBeans，和 InteliJ 这样的工具现在有共同的地方来找到项目 的信息。</p><ul><li>便于搜索和过滤构件</li></ul><p>像 Nexus 这样的工具允许你使用存储在 POM 中的信息对仓库中的内容进行索引 和搜索。</p><h1 id="Maven的安装和配置"><a href="#Maven的安装和配置" class="headerlink" title="Maven的安装和配置"></a>Maven的安装和配置</h1><h3 id="下载Maven"><a href="#下载Maven" class="headerlink" title="下载Maven"></a>下载Maven</h3><p>首先从Apache Maven项目的web站点下载Maven:<a href="http://maven.apache.org/download.html" target="_blank" rel="noopener">http://maven.apache.org/download.html</a>.<br>注意选择好你所需的版本</p><h3 id="安装Maven"><a href="#安装Maven" class="headerlink" title="安装Maven"></a>安装Maven</h3><ul><li>在Mac上安装Maven</li></ul><p>1 如果你的操作系统是MAC OSX ，首先还是到官网下载好Maven的二进制版本。<br>2 解压下载的安装包到某一目录，比如：/Users/xxx/Documents/maven<br>3 配置环境变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile 打开.bash_profile文件，在该文件中添加设置环境变量的命令</span><br><span class="line">export M2_HOME=/Users/xxx/Documents/maven/apache-maven-3.5.0</span><br><span class="line">export PATH=$PATH:$M2_HOME/bin</span><br><span class="line">添加之后保存并推出，执行以下命令使配置生效：</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure></p><p>4 输入：mvn -v命令查看配置是否生效。</p><ul><li>在Windows上安装Maven<br>其实操作都差不多，包括Linux也是。都是先去官网下载压缩包，然后解压到某一目录，之后配置环境变量，然后输入mvn -v验证是否成功。<br>在这里假设Maven安装目录是 c:\Program Files\maven-2.0.9<br>当你把Maven解 压到安装目录后，你需要设置两个环境变量——PATH和M2_M2_HOME。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\tobrien &gt; set M2_HOME=c:\Program Files\maven-2.0.9</span><br><span class="line">C:\Users\tobrien &gt; set PATH=%PATH%;%M2_HOME%\bin</span><br></pre></td></tr></table></figure></li></ul><p>或者你也可以直接修改settings.xml文件。<br>打开%M2_HOME%/conifg/settings.xml文件，在文件中可以看到localRepository配置的就是本地仓库，本地仓库地址的目录最好是全英文格式，不要包含汉字空格等其他特殊字符。<br><img src="http://huangyiblog.com/maven.png" alt="alt"></p><h1 id="在eclipse上配置Maven"><a href="#在eclipse上配置Maven" class="headerlink" title="在eclipse上配置Maven"></a>在eclipse上配置Maven</h1><p><strong>打开Eclipse点击window&gt;prferences</strong></p><p><img src="https://images2017.cnblogs.com/blog/1196650/201711/1196650-20171101153146201-1619143316.png" alt="alt"></p><p><img src="https://images2017.cnblogs.com/blog/1196650/201711/1196650-20171101153604576-2057741024.png" alt="alt"></p><p><strong>之后继续finsh，apply就是了</strong></p><h3 id="连接到本地仓库"><a href="#连接到本地仓库" class="headerlink" title="连接到本地仓库"></a>连接到本地仓库</h3><p>还是回到maven选项下：<br>点击user settings在用户配置界面中，有两个设置框，一个是Global Settings（全局配置信息）和User Settings（只针对这个工作空间进行设置）。根据自己的实际情况设置相应的settings文件。</p><p><img src="https://images2017.cnblogs.com/blog/1196650/201711/1196650-20171101160920951-1995380760.png" alt="alt"></p><h3 id="新建maven-WEB项目"><a href="#新建maven-WEB项目" class="headerlink" title="新建maven WEB项目"></a>新建maven WEB项目</h3><ul><li><p>1.开启eclipse，右键new——&gt;other<br><img src="https://img-blog.csdn.net/20161220154404611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVuZGFuXzUyMDUyMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="alt"></p></li><li><p>2.选择maven project，显示创建maven项目的窗口<br><img src="https://img-blog.csdn.net/20161220154417033?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVuZGFuXzUyMDUyMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="alt"></p></li><li><p>3.在搜索框中搜索“web”，选择next<br><img src="https://img-blog.csdn.net/20161220154427167?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVuZGFuXzUyMDUyMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="alt"></p></li><li><p>4.输入maven项目的基本信息<br><img src="https://img-blog.csdn.net/20161220154437345?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVuZGFuXzUyMDUyMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="alt"></p></li></ul><h1 id="在IDEA上配置maven"><a href="#在IDEA上配置maven" class="headerlink" title="在IDEA上配置maven"></a>在IDEA上配置maven</h1><p><strong>首先打开IDEA 选择File——Settings</strong></p><p><img src="http://img.blog.csdn.net/20160520145500957" alt="alt"></p><h3 id="新建maven-WEB项目-1"><a href="#新建maven-WEB项目-1" class="headerlink" title="新建maven WEB项目"></a>新建maven WEB项目</h3><p><img src="http://img.blog.csdn.net/20160520154034969" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> 业务开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>215数组中的第K个最大元素</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/215%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/215%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><p>分析：我觉得这道题很典型很重要，要吃透还是很花时间的，我要理解估计还得花不少时间，这道题虽然本身不是什么复杂算法或高级数据结构，但是很考验基本功。或许很多人面试的时候被问到过10万个数里面取第k大的数算法怎么设计，这种属于海量数据问题，思路又要变化下，你回答的时候肯定不可能直接给出一个算法就结束了，主要是如何针对不同场景和限制如何给出最优解，这就很考验基本功了。这里面最核心的就是考虑时间和内存的限制了。<br>先不管海量数据的情景，回到这题，我们一般考虑哪些思路。</p><h3 id="1-最直接的想法，先对整个数组进行排序，然后取第k大的数。"><a href="#1-最直接的想法，先对整个数组进行排序，然后取第k大的数。" class="headerlink" title="1 最直接的想法，先对整个数组进行排序，然后取第k大的数。"></a>1 最直接的想法，先对整个数组进行排序，然后取第k大的数。</h3><p>至于如何排序，那内容就多了。比如快排，堆排，偷懒的人可能直接调用STL里的sort函数就过了，但面试不能这么干，另外估计选择快排比较多的，比竟快排平均花费时间最少。<br>时间复杂度O(nlogn)</p><h3 id="2-利用快速选择的想法。"><a href="#2-利用快速选择的想法。" class="headerlink" title="2 利用快速选择的想法。"></a>2 利用快速选择的想法。</h3><p>也就是快排的分治思想。取一个指针pivot</p><ul><li>如果pivot == k，则正好找到了第k小的元素</li><li>如果pivot &gt; k，则第k小的元素存在于pivot左边</li><li>如果pivot &lt; k，则第k小的元素存在于pivot右边<h3 id="3-利用最小堆"><a href="#3-利用最小堆" class="headerlink" title="3 利用最小堆"></a>3 利用最小堆</h3>维护一个容量为k的最小堆，在建完堆后将取堆内第k个数即可。<br>关于快速选择的算法可以参考下算法导论。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(nums.rbegin(), nums.rend());</span><br><span class="line">        <span class="keyword">return</span> nums[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (nums.size() == <span class="number">0</span> || k &lt; <span class="number">1</span> || k &gt; nums.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> partition(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, nums.size() - k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = start, right = end;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[(start + end) / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; nums[left] &lt; pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; nums[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                swap(nums, left, right);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> partition(nums, start, right, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= left) &#123;</span><br><span class="line">            <span class="keyword">return</span> partition(nums, left, end, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[k];</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        shuffle(nums);</span><br><span class="line">        k = nums.length - k;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> pivot = partition(nums, low, high);</span><br><span class="line">            <span class="keyword">if</span>(pivot &lt; k) &#123;</span><br><span class="line">                low = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pivot &gt; k) &#123;</span><br><span class="line">                high = pivot - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参考算法第四版</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> j = high + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; high &amp;&amp; less(a[++i], a[low]));</span><br><span class="line">            <span class="keyword">while</span>(j &gt; low &amp;&amp; less(a[low], a[--j]));</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a, low, j);</span><br><span class="line">                    <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v &lt; w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在partition前将数组顺序打乱，保证不出现最坏情况。</span></span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = random.nextInt(i + <span class="number">1</span>);</span><br><span class="line">            exch(a, i, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val : nums) &#123;</span><br><span class="line">            pq.offer(val);</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展问题：</p><ul><li>输入是两个整数数组，他们任意两个数的和又可以组成一个数组，求这个和中前k个数怎么做？</li><li>有两个序列A和B,A=(a1,a2,…,ak),B=(b1,b2,…,bk)，A和B都按升序排列。对于1&lt;=i,j&lt;=k，求k个最小的（ai+bj）。</li><li>给定一个数列a1,a2,a3,…,an和m个三元组表示的查询，对于每个查询(i，j，k)，输出ai，ai+1，…，aj的升序排列中第k个数。</li></ul><h2 id="如果情境改为10亿个数的topK问题，怎么想。"><a href="#如果情境改为10亿个数的topK问题，怎么想。" class="headerlink" title="如果情境改为10亿个数的topK问题，怎么想。"></a>如果情境改为10亿个数的topK问题，怎么想。</h2><h3 id="最好想的，还是先全部排序，然后查找。"><a href="#最好想的，还是先全部排序，然后查找。" class="headerlink" title="最好想的，还是先全部排序，然后查找。"></a>最好想的，还是先全部排序，然后查找。</h3><p>最快的排序算法的时间复杂度一般为O（nlogn），如快速排序。<br>但是如果计算机内存不够大，这种方法很容易受内存限制。</p><p>主要解决方案：</p><ul><li><p>分治+Trie树</p></li><li><p>hash+小顶堆</p></li></ul><h3 id="局部淘汰法"><a href="#局部淘汰法" class="headerlink" title="局部淘汰法"></a>局部淘汰法</h3><p>用一个容器保存前1万个树，然后将剩余的所有数字一一和容器内最小的数字比较，如果后续元素比容器内的最小元素大就删掉容器内的最小元素，并将该元素插入容器，最后遍历玩这1亿个数，得到最终结果。</p><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>将1亿个数据分成100份，每份100万个数据，找出每份数据中最大的1万个，最后在剩下的100 X 10000个数据。也就是100万个数据里面找前1万</p><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>通过hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，</p><h3 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h3><p>先读入前10000个数来创建大小为10000的小顶堆，建堆的时间复杂度为O(mlogm),然后遍历后续数字，并与堆顶数字(最小)进行比较，如果比堆顶的数字大，替换堆顶元素调整堆为小顶堆。这个过程直到1亿个数全部遍历完。然后按照中序遍历的方式输出当前堆中的所有1万个数字。该算法的时间复杂度为O(nmlogm),空间复杂度是常数。</p><h3 id="几种应用情境"><a href="#几种应用情境" class="headerlink" title="几种应用情境"></a>几种应用情境</h3><ul><li>单机+单核+足够大内存</li><li>单机+多核+足够大内存</li><li>单机+单核+受限内存</li><li>多机+受限内存</li></ul><p>扩展问题：</p><ul><li>有10000000个记录，这些查询串的重复度比较高，如果除去重复后，不超过3000000个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。请统计最热门的10个查询串，要求使用的内存不能超过1GB。</li><li>有一个1GB大小的文件，里面的每一行是一个词，词的大小不超过16个字节，内存限制大小是1MB。返回频数最高的100个词。</li><li>提取某日访问网站次数最多的那个IP。</li><li>10亿个整数找出重复次数最多的100个整数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何为Nginx服务器配置ssl证书</title>
      <link href="/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/%E5%A6%82%E4%BD%95%E4%B8%BANginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6/"/>
      <url>/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/%E5%A6%82%E4%BD%95%E4%B8%BANginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="如何为Nginx服务器配置ssl证书"><a href="#如何为Nginx服务器配置ssl证书" class="headerlink" title="如何为Nginx服务器配置ssl证书"></a>如何为Nginx服务器配置ssl证书</h1><p>&emsp;&emsp;我前不久才把自己的hexo博客部署到阿里云服务器上，买的学生机LAMP6.0.1,操作系统是centos，部署成功后就去申请备案，备案前期的资料审核还是快的，最后一步管局审核写着不超过20天，结果真的过了20天才发信息来审核通过…<br>&emsp;&emsp;之前的审核过程中，你的域名是不能进行访问，只能通过IP地址访问网站。审核通过后你可以通过http进行访问,但是不能通过进行https:进行访问。所以我们先来看看这两者的区别。</p><h2 id="http与https的基本定义"><a href="#http与https的基本定义" class="headerlink" title="http与https的基本定义"></a>http与https的基本定义</h2><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h2 id="http与https的区别"><a href="#http与https的区别" class="headerlink" title="http与https的区别"></a>http与https的区别</h2><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，这就是https的诞生。<br>阿里云官网的回答</p><blockquote><p>HTTP是过去很长一段时间我们经常用到的一种传输协议。HTTP协议传输的数据都是未加密的，这就意味着用户填写的密码、账号、交易记录等机密信息都是明文，随时可能被泄露、窃取、篡改，从而被黑客加以利用，因此使用HTTP协议传输隐私信息非常不安全。</p></blockquote><blockquote><p>HTTPS是一种基于SSL协议的网站加密传输协议，网站安装SSL证书后，使用HTTPS加密协议访问，可激活客户端浏览器到网站服务器之间的SSL加密通道(SSL协议)，实现高强度双向加密传输，防止传输数据被泄露或篡改。简单讲，HTTPS=HTTP+SSL，即HTTPS是HTTP的安全版。</p></blockquote><p>HTTPS加密、加密、及验证过程，如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2017/3/26/a480d891b7240325055da1e6b2f75ac3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="alt"></p><p>按照网上博客的资料，两者主要有以下具体区别：<br>1、HTTPS更安全：HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议的信息明文传输安全；</p><p>2、HTTPS需要申请证书：HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费，费用大概与.com域名差不多，每年需要大约几十元的费用。而常见的HTTP协议则没有这一项；</p><p>3、端口不同：HTTP使用的是大家最常见的80端口，而HTTPS连接使用的是443端口；</p><p>4、状态不同：HTTP的连接很简单，是无状态的。而HTTPS协议是SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全；</p><h2 id="为Nginx服务器配置ssl证书具体步骤"><a href="#为Nginx服务器配置ssl证书具体步骤" class="headerlink" title="为Nginx服务器配置ssl证书具体步骤"></a>为Nginx服务器配置ssl证书具体步骤</h2><p>一：购买并申请免费证书</p><p>前往阿里云域名控制台–&gt;进入域名管理–&gt;申请免费开启ssl证书<br>这个过程比较快，一般申请成功后不需要多久证书就会发到你的证书控制台。<br>在证书控制台下载Nginx版本证书，下载到本地的是一个压缩文件，解压后里面包含.pem文件是证书文件，.key文件是证书的私钥文件（申请证书时如果没有选择系统创建CSR，则没有该文件）。</p><p>二、进入服务器配置Nginx.conf<br>按照官方文档，我们首先进入服务器的Nginx目录下，新建一个目录cert<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir cert</span><br></pre></td></tr></table></figure></p><p>目录建完以后就需要把你之前下载的证书解压后的文件都拷贝到该目录下面。从本地拷贝文件到远程服务器可以用scp命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /Users/study/xxxxx root@xxx:/etc/nginx/cert</span><br></pre></td></tr></table></figure></p><p>我当时没注意，结果直接把整个文件夹给拷进去了，这样一来等会编辑文件路径的时候就不能忘了修改。<br>拷贝结束后就可以编辑Nginx.conf文件进行配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    ssl on;</span><br><span class="line">    root html;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    ssl_certificate   cert/a.pem;</span><br><span class="line">    ssl_certificate_key  cert/a.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root html;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我主要提几个初次接触的小白容易碰到的问题：</p><ul><li>include /etc/nginx/default.d/*.conf;这一行不需要取消注释</li><li>server_name 可以改为你自己的域名</li><li><p>location/{}里面的root注意要填写你当时配置的项目位置。</p><p>配置好以后保存并退出。<br>之后重新加载并启动nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line">systemctl restart nginx.service</span><br></pre></td></tr></table></figure></li></ul><p>这里很多人一开始可能会出现启动失败的错误，这时不要慌，我的建议是最好学会查看日志文件，看看命令行提示报了什么错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure></p><p>我碰到过的有一种是属于80端口被某个进程占用，当时我是直接强制杀死该进程解决的。其他启动失败的原因多数是你nginx.conf文件配置出错了，比如如法错误，多了什么或少了什么。<br>我当时启动成功后采用https方式访问域名，结果一直都是显示Nginx welcome的首页面，这里其实就是我之前提到过的location/{}里面写错了。当时还有点慌，因为我不记得我把自己的hexo放在哪里了，但还好，把Nginx.conf往上翻就能找到我以前配置过的hexo的root信息，直接复制下来即可。</p><p>到这里，证书配置基本就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> 业务开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>普通人如何稳固对自我价值的认同感</title>
      <link href="/%E9%9A%8F%E7%AC%94/%E6%99%AE%E9%80%9A%E4%BA%BA%E5%A6%82%E4%BD%95%E7%A8%B3%E5%9B%BA%E5%AF%B9%E8%87%AA%E6%88%91%E4%BB%B7%E5%80%BC%E7%9A%84%E8%AE%A4%E5%90%8C%E6%84%9F/"/>
      <url>/%E9%9A%8F%E7%AC%94/%E6%99%AE%E9%80%9A%E4%BA%BA%E5%A6%82%E4%BD%95%E7%A8%B3%E5%9B%BA%E5%AF%B9%E8%87%AA%E6%88%91%E4%BB%B7%E5%80%BC%E7%9A%84%E8%AE%A4%E5%90%8C%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="普通人自我认同感很低怎么办？"><a href="#普通人自我认同感很低怎么办？" class="headerlink" title="普通人自我认同感很低怎么办？"></a>普通人自我认同感很低怎么办？</h1><p>&emsp;&emsp;最近又到了清华本科特将评选的日子，看了他们的简历，众多网友耐不住了。纷纷调侃“神仙打架”又开始了。<br>&emsp;&emsp;不过毕竟神仙们打架对我们这些普通人影响其实并不是很大，毕竟距离太远了（指实力上的距离）。大多数人自我认同感低，其实还是因为身边的人，再加上各种网文贩卖焦虑，比如之前的某某单车创始人企业被收购，90后已经实现财务自由。于是有了你已被同龄人抛弃了之类的…在目前经济为王的社会里，各种浮躁的心态层出不穷，不论是在校的学生，还是在企业里的白领，似乎无时无刻不在焦虑着。为什么焦虑，因为怀疑，因为对自我价值的怀疑，导致对自己所做的努力，所做的事情同样产生怀疑。<br>&emsp;&emsp;首先焦虑是正常的，对自己有所怀疑也是正常的。但注意我标题注明的是你几乎已经怀疑过了度。也就是说你甚至已经有些不认同自我价值了。到了这一步，问题其实已然不小。我想写这篇随笔，自然不是因为空想就想到了这么个话题。而是我自己就属于迷茫，不自信的一类人中的一个典型。不知道解决方案，但是写这篇随笔可以让我反思，让我平视，然后再次让自己正常的融入到学习生活中去。能达到这一点就足够。<br>&emsp;&emsp;不同年龄段的人烦恼各不相同，但心态缺失类似的。我正处于学生时代的后期了，倘若不读研，那么在学校的日子几乎按着指头数也能数过来了。学校里终究还只是个象牙塔，与社会的庞杂相比还是相对单纯的多了，至少涉及物质层面的问题会少很多。说撑了无非就是些各种奖学金，助学金之类的。当然，不排除很多人爱慕虚荣，喜欢攀比。许多人的焦虑可能更多来自于学习。学渣与学霸之间的爱恨情仇似乎是学生时代过不去的一道坎也。当你看到身边的某某学霸又拿了个竞赛大奖，某某保研到了国内C9高效，某某某还在纠结于几个知名大厂的offer该选哪个时，你可能会有些触动，你可能还不知道自己想干嘛，毕业了工作能找到吗？上述几个例子自然是少数人，但是当你看到自己的同学如此优秀，你应该怀抱什么样的心态？嫉妒？自卑？蔑视？这里其实已经体现了自我认同感偏低的外因，那就是身边的人光芒四射，你找不到自己了。<br>&emsp;&emsp;有一点还是要明确。我是相信存在智商碾压这回事的。努力确实是个好东西，但是收获未必如你所期望的，毕竟这个过程还得乘上个系数，不然就不存在我在最开头提到的“神仙打架的事情”了。那么好，如今你可能和我一样有些焦虑，有些自我怀疑，害怕自己和身边的神仙差距越来越大，怎么处理。在此之前，你或许也还算努力吧，上课认真听讲，课后也会去翻翻书，你也为了目标有所付出。但是这离你想要的生活并未接近多少。再想想，要不随大流，一起开几把黑，打打王者，看看小说，让自己过得轻松点不行么？嘻嘻，当然没问题，而且要注意，打王者，看小说等等操作与我的问题并不矛盾，很简单，玩游戏就会影响自我认同感吗？没啥关系吧？刚刚前几天LG还拿了世界总决赛冠军呢，多少高校宿舍，朋友圈里的男同胞在自豪的呐喊。那么问题在哪呢？如果这么想，反正我这么菜，还不如上课开开黑，让自己过得舒坦点何乐而不为。这里有个前提，你默认了自己是个菜鸟(自黑的除外)，你从心底里认为了自己不是个优秀的人，即使努力了也是菜鸟一枚，这就有了问题。你并不怎么认同自己，导致你不愿为了些什么东西制定个小计划，小目标什么的，持之以恒的去做点什么。这就糟糕了。<br>&emsp;&emsp;当你开始转变，开始有所努力，慢慢认同自己的时候，你可能一不当心就陷入了另一个误区。那就是自我欺骗。你开始渐渐相信自己其实也很优秀，自己的存在不说对很多人，但对身边的人也还有点价值。于是你开始努力学习，认真生活，你希望让自己变得更加优秀，你希望放大自己的价值。你可能每天都有在刷算法题，你可能每天都在看技术书学习。然而过了段时间，你发现你刷了很多题，但问你一个算法原理你却还是云里雾里，你看了很多课外书，但问你个知识点你却是两眼发呆。你以为每天都在努力，那么自然每天都在收获，结果却是在原地踏步。这就会让你产生盲目的自我认同感。我们拿阅读技术书举例。你读过这本书，并不代表你读懂了，你读懂一个技术点，并不代表你会用了，你已经能够实践了，能够用了，并不代表你已经会变通了，因为你不了解它的底层是什么原理，只知道代码这么写会产生这样的效果。<br>&emsp;&emsp;当你发现了误区，你又开始慢慢转变，你希望让假懂慢慢变成真懂，你希望自己不是假优秀，而是确实肚子里有点货，，慢慢慢慢，可能情况就会有所好转，只要能一步步走上正轨，那么对自我价值的认同感自然也就慢慢上来了。到后面，或许会这么想，“神仙”们的确很厉害，但我在陆地上当个”将军”也不错，“马云、王健林”们的确有钱，而我虽然实现不了财务自由，但也勉强够用了。有勇气平视大家，才能交到好朋友哦！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>回顾自己部署hexo博客的血泪史</title>
      <link href="/%E9%9A%8F%E7%AC%94/%E5%9B%9E%E9%A1%BE%E8%87%AA%E5%B7%B1%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%A1%80%E6%B3%AA%E5%8F%B2/"/>
      <url>/%E9%9A%8F%E7%AC%94/%E5%9B%9E%E9%A1%BE%E8%87%AA%E5%B7%B1%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%A1%80%E6%B3%AA%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="回顾下自己使用hexo博客踩过的坑"><a href="#回顾下自己使用hexo博客踩过的坑" class="headerlink" title="回顾下自己使用hexo博客踩过的坑"></a>回顾下自己使用hexo博客踩过的坑</h1><blockquote><p>从一开始接触hexo博客到现在也过去好几个月了，在很多大佬看来搭建部署个个人博客是个很小儿科的事情，但对我这样一个菜鸟来说陆陆续续的几乎是采坑无数，现在回想起来都是泪啊，尤其是碰到一些bug，百度谷歌都找不到你想要的解答时，真的绝望的感觉。我这次虽然是坐个总结，但时间过去很久了，一些具体的bug，以及处理代码我就不写出来了，所以如果你想在这里看到一些实操干货的话，可能要失望了，毕竟我写的不是教程。</p></blockquote><p>我使用hexo博客主要经历了如下几个阶段：</p><ul><li>下载hexo，选择主题，编辑配置文件，部署到GitHub</li><li>想优化主题，自定义了一些css样式，加入了一些插件</li><li>后面换了电脑，想要在多终端协同管理hexo</li><li>纠结于GitHub pages 访问速度不给力，考虑CDN，最后还是想部署到阿里云服务器。　<a id="more"></a></li></ul><p>　　一开始和很多人一样活跃于博客园，ＣＳＤＮ等第三方博客平台，那是还是大学刚开学的时候吧，还不怎么写博客，到了后面偶尔也学一些大佬写点题解啥的，但也并不积极。到了大二，学的东西、课程越来越多，内容越积越多，但显而易见的是，我们不可能记住所有内容，如何有效的总结知识点，最好将书上的变成自己的，如何深入理解，如何提升自己的写作水平，总的来说，写博客还是一个不错的提升自己的方式。可这时，可能是想追求个性，想有一个自己的个人博客，当时主要就想到了ＷｏｒｄＰｒｅｓｓ和ｈｅｘｏ，但是用ＷｏｒｄＰｒｅｓｓ还是要买域名和云服务器，虽说阿里云和腾讯云等服务商对学生的优惠力度都很大，但我最初并不是很想花钱，于是选择了ｈｅｘｏ。选择ｈｅｘｏ其实也有很多好处，帮我入门了ｇｉｔ和ＧｉｔＨｕｂ。决定以后，边去网上找各种教程，下载ｎｏｄｅ、ｈｅｘｏ、ｎｅｘｔ主题等等，之后配置文件，然后ｈｅｘｏ　ｎｅｗ　ｐｏｓｔ，ｈｅｘｏ　ｓ，测试效果，这个过程中，出过一些小问题，但最后都能够成功部署，只是有一个小ｂｕｇ。部署成果后，导航栏的几个主要图标无法正常显示，我一直不明白到底是哪里出了问题，因为每一步都是按照网上的教程操作的，谷歌了好久也没解决。当时没辙，我就去问了我们的ｗｅｂ老师，然而老师说他也没搞过这个，所以并不了解，但是还是给出了建议，因为大部分ｂｕｇ，９９％前人肯定都遇到过，可以先去谷歌百度搜，实在不行可以去知乎等社区提问。我后面就去知乎发表提问，并要求了几位内行人回答，期初也没得到我想要的解答，但几天过去，总算是等来了我想要的。问题其实很简单，还是配置文件上没有填正确，之所以没有填正确。有两个主要原因：１版本问题，２自己不注意看官方注释。首先网上给出的教程并没有问题，但我完全照搬就出了问题，因为他们针对的版本与我再用的版本并不一样，而恰好我的版本在导航栏配置哪里格式有所区别，导致最后图标无法正常显示。总之，倒腾了半天，最后总算还顺利，我发布了自己的第一篇博客并且成功部署到了ＧｉｔＨｕｂ，网页上也能正常浏览。<br>　　我当时选择的是ｎｅｘｔ主题，我很喜欢这样简约大方的风格，大量留白，不花里胡哨，同时也能够满足我的需求，我只想写写东西，这样的就已经足够。但是还不够，我想往里面加点东西，改点东西。这个过程，也很心累，因为我前端没好好学，而页面设计这方面涉及的主要都是前端的点。我修改了一些样式，字体，颜色什么的，接了网易云嵌入式链接，开头评论功能，增加友链，用七牛做图床等等，总之就是各种折腾。有时看了自己改的很不满意又得想办法改回去。这个过程有一点很重要，就是了解ｈｅｘｏ主题的整体框架配置，知道哪个文件夹，哪个文件主要是负责哪一块的！<br>　　后面我买了台二手ＭＢＰ，想在这台电脑上也能管理发布ｈｅｘｏ博客，于是又想办法，在网上各种搜教程，如何在两台电脑上管理ｈｅｘｏ。最后的解决方案是利用ＧｉｔＨｕｂ分支，新建一个分支，然后将原电脑上所需的本地文件拷到新电脑，在新电脑上把内容ｐｕｓｈ到相应分支。这个过程也很不容易，主要是我不怎么理解ＧｉｔＨｕｂ的分支操作，哎，但还算好吧，没有花太多时间。<br>　　又过了一段时间，随之我发布的博客内容越来越多，而ＧｉｔＨｕｂ　ｐａｇｅｓ的访问速度又不稳定，有时还很令人纠结，这我就受不了了，我想着怎么才能加速访问，比较ＧｉｔＨｕｂ是国外的服务器，虽然免费给你一定空间使用，但访问速度我真的不满意。网上有说把博客再部署到ＣＯＤｉｎｇ上面的，也有说用ＣＤＮ的，我考虑过ＣＤＮ，当时选的是加速乐，但是生效要很久，我也没测试效果如何。最后想着趁现在自己还是学生，干脆去阿里云买个云服务器得了。服务器买了以后，问题又来了，如何将本地博客迁移到云服务器上了，这个过程有时让我掉了一堆头发。一开始就出了问题，按照网上的教程，我装好ｎｏｄｅ，ｇｉｔ，ｈｅｘｏ，Ｎｇｉｎｘ等等所需的软件，但是当我启动Ｎｇｉｎｘ的时候一直出错，无法启动，最初人物是自己在编辑．ｃｏｎｆ文件的时候可能哪里多了分号点号啥的，一直没搞清楚问题是啥，到后面干脆重置了虚拟机，将各种软件重新装了一遍。这是再次启动Ｎｇｉｎｘ，还是启动不了，真是崩溃的心都有了，没辙，只好按照命令行的提示，查看日志提示是哪里有ｂｕｇ，你别说，我这种菜鸟一开始看提示都还不大看得懂，只好又将提示代码复制到谷歌搜解答，但是这还不能马上搜到，因为有些时候一段提示信息可能会对应一堆可能的ｂｕｇ，但我这次还算运气可以吧。最后的结论是我的服务器上８０端口ｈｔｔｐｄ被占用，也就是说Ａｐａｃｈｅ和Ｎｇｉｎｘ不能同时启用吧，之后便停用８０端口，然后重新加载Ｎｇｉｎｘ，在游览器输入服务器ＩＰ，总算是见到了ｗｅｌｃｏｍｅ的页面了，松了一口气呀。之后要做的就是新建ｇｉｔ库，配置ｇｉｔｈｏｏｋｓ，配置Ｎｇｉｎｘ的ｓｅｒｖｅｒ的ｌｏｃａｔｉｏｎ等等，然后修改本地ｈｅｘｏ的．ｃｏｎｆｉｇ文件，然后将博客部署到服务器上。到这里你在输入ＩＰ到游览器便能够看到你的博客了。<br>　　上面就是我倒腾ｈｅｘｏ的主要历程，但是还有个问题要讲下，那就是域名，域名我很早就买了，也是在阿里云上买的，当时就是解析到了ＧｉｔＨｕｂ的ＸＸＸ．ｇｉｔｈｕｂ．ｉｏ，这样输入域名也能访问我的博客，另外由于访问的是国外服务器，所以我的域名也没有备案，换句话说，其实我也备不了案，因为我没有买服务器，也就没有备案服务号。后来我买了服务器就想着干脆也去备案下吧．．结果一开始我就觉得好烦，得我自己去打印核验单邮寄到贵州，还得用阿里云的幕布拍照，总觉得麻烦。现在还在备案中．．．　　</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《软技能》代码之外的生存指南读后思考</title>
      <link href="/%E9%98%85%E8%AF%BB/%E3%80%8A%E8%BD%AF%E6%8A%80%E8%83%BD%E3%80%8B%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97%E8%AF%BB%E5%90%8E%E6%80%9D%E8%80%83/"/>
      <url>/%E9%98%85%E8%AF%BB/%E3%80%8A%E8%BD%AF%E6%8A%80%E8%83%BD%E3%80%8B%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97%E8%AF%BB%E5%90%8E%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="一本非技术非管理只谈人的书。"><a href="#一本非技术非管理只谈人的书。" class="headerlink" title="一本非技术非管理只谈人的书。"></a>一本非技术非管理只谈人的书。</h1><p><img src="http://huangyiblog.com/ruanjineng.jpg" alt="alt"></p><p> 　　昨天花了点时间看完了这本《软技能》，主要面向的是软件开发人员如何提升自己的软实力，如何更好的发展与生活，整本书洋洋洒洒几百页，但是除了提到一些Java，c等语言的名词之外并没有一行代码，没有技术干货，也不是教你如何走上管理层的。总体来说，书籍的内容涵盖面很广，但都不是很深入，也算适合我这种初级阶段的小白人员学习。属于实用类的书籍吧，虽然有些内容略有鸡汤意味，但总体还行，大多都是些切实可行的建议。</p><a id="more"></a><blockquote><p>“在我刚开始从事编程工作时，软件开发人员的典型形象就是一个书呆子，瘦骨嶙峋，戴着一副厚厚的眼镜，活脱一付笔尖保护套的模样。现在，这一形象似乎已经改变，不过是变得更糟了。如今，很多人认为，软件开发人员都是胖胖的男士，留着络腮胡子，穿着一件脏兮兮的白色T恤还吃着比萨。”</p></blockquote><p>摘录来自: [美] John Z. Sonmez. “软技能：代码之外的生存指南。”</p><p>　　上面一段话摘录自书中第６篇首页，有点夸张，其实我很不喜欢经常人为的给某个群体贴上标签，这免不了的会以偏概全。但不论是程序员自黑，还是他黑，仿佛程序员这个群体就是给人一种书呆子、木讷、呆板、低情商的感觉。很多时候这是种调侃，不否人生活中也有很多程序员多才多艺，交际活跃，但既然会在大众之中产生这样的印象，就需要引起我们的警觉。我首先就是想到了自己，我是个什么样的形象呢？嗯，确实有点呆，内敛，不注重健身，瘦骨嶙峋，不爱社交，宅男一枚，不会打扮自己．．．天哪，我都不敢细想，但从我个人体验来看，很多ＣＳ专业的同学也没比我好多少（我这里主要指程序员，因为很多ＣＳ专业的学生从一开始就决定了自己以后并不打算从事软件开发的工作）。我不知道这只是性格原因还是的确跟所学专业有关，但这本书最大的目的就是让你走出技术，关注技术之外的点。注意，没有人说技术就不重要，但很多时候，在职场发展中技术往往不是最重要的，你在企业往某个方向深耕几年，你的技术一般都是拿的出手的，对很多普通人来说，可能技术水平差距并不十分明显，大部分人的智商范围相差我相信应该不大，这时拉开差距的是什么？<br>　　这本书内容主要分为７篇，分别为职业、自我营销、学习、生产力、理财、健身、精神。作者主要从上述７方面进行阐述，提了很多实际的行动指南，理论依据。你会发现上面７块已经很广，几乎贯穿我们的一大部分生活。想要在工作与生活之间取得良好的平衡，想要在职业发展道路上有个良好的进展，上述几个方向都是你不容忽视的点。<br>　　职业篇里面其实提了几个程序员经常误入的点，我主要例举几点：<br>　　１交际方面，很多搞技术的容易自以为是，只喜欢“别管我，我只想一个人安静地写代码！”，我是觉得这种做法一方面对自己能力的提升很不利，另一方面，对于团队合作影响很不好。<br>　　２自我定位方面，不要到了求职的时候还不清楚自己准备投什么岗位，或者说学了半天还不清楚自己准备走什么发展方向。<br>　　３如何写好简历，如何有效面试，很多时候这都能决定你能否拿到ｏｆｆｅｒ<br>　　４盲目陷入对技术的狂热。<br>　　自我营销篇有几个点是作者反复强调的，你应该学会如何推销自己，如何包装自己，其实方式有很多，但你得坚持做下去，把行动拿出来，一开始也许不容易，但一年两年做下来，你会感受到成长的。什么是自我营销？我们应该学会如何提升自己的核心竞争力，如何打造自己的个人品牌，这对个人成长十分重要！如何在帮助他人的前提下提升自己。作者反复提到了每个开发人员都应该写个人博客，这一点可能有些人并不认同，你会说很多技术大牛并不写博客，只是闷声敲代码，照样牛的一撇。但注意，这并不能否定写博客能够给人带来成长，当你坚持几年写高质量技术博客，你会发现这会为你带来很多，这个过程中你不仅帮助了很多其他的开发者，更是让自己的思考更进一层楼。当然，作者还例举了很多其他例子：“博客 播客 视频 给杂志投稿 书籍 代码营 技术会议”等等。</p><blockquote><p>“你自己的博客，以及你在别人的博客上发表的特邀文章 创建自己的播客频道，同时接受其他播客频道的访谈 在YouTube这样的视频网站上上传自己的分享内容和课程主题视频 给软件开发相关的杂志写文章 著书或者自出版 大多数代码营都允许参加者自由发言 拓展社交网络的好方法，如果能在研讨会上发言尤佳”<br>摘录来自: [美] John Z. Sonmez. “软技能：代码之外的生存指南。” 　　</p></blockquote><p>　　我现在还是一名学生，或许更多的会关注学习篇。如何学习是个老生常谈的话题了。尤其在ＩＴ业，技术更新迭代如此之快，没有匹配的学习能力很难在洪流中存活下来。我们都很清楚，知识你是学不完的，最重要的是学习方法论，你掌握了如何高效学习，自然不用担心走向陌生的领域。但我自己感觉虽然花在学习上的时间还算比较多的，但是效率却是相当差强人意，至于学习渠道，比较常见的无非是看书，看视频，看博客，看官方文档，配以代码实践，项目实践等。就拿看书来说好了，我看书效率就比较低，主要有几个大的问题：<br>　　１专注度不够，没有带着问题，带着思考去读。<br>　　２连续度不够，有些技术书内容很庞杂，很难啃，这是事实，但是我有时这周看了几章，就这几天没去看，到了下周又接着看几章，看了后面忘了前面，很难系统系掌握。<br>　　３浅尝辄止，碰到复杂的地方就略过，不利于深入理解。<br>　　最后主要还提到了如何理财与健身。身体是革命的本钱，你说健康重不重要，要命的是我自己的体质就很不像样，大二有段时间我还坚持到钱塘江边慢跑，但是却没坚持多久。如今大三没有了体育课，平时主动锻炼的时间真的是少的可怜。理财我完全是个门外汉了，我不懂投资理财，有些人提到买房投资，但是看看这两年杭州的房价，我也就呵呵了，刚需都还是个大问题，还有钱投资？不过理财确实是个很实用的东西，我平时只知道开源节流，这或许能让你勉强在大城市生活，做得好每年还能有些积蓄。但有一点，钱往往都不是靠省出来的，做金钱的奴隶感受可并不好。业余时间还是要多学点金融和历史，这两方面不在乎你学啥专业，但是学好了，你绝对受益匪浅。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>11. 盛最多水的容器</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="alt"></p><p>示例:</p><p>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49</p><p>分析：考虑两种思路<br>解法一：暴力法<br>用两重for循环，考虑没对可能的线段组合并每次取较大值。<br>时间复杂度为O(n^2),要超时<br>解法二：双指针<br>定义两个指针，一个指向开头，一个指向结尾，每次更新最大面积的时候，将指向较短线段的指针向着指向较长线段指针的方向移动一步，因为如果是将指向较长线段的指针往内侧移的话，矩形区域的面积还是要受制于较短的线段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  maxArea11.cpp</span></span><br><span class="line"><span class="comment">//  LeetCode</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by a on 2018/10/25.</span></span><br><span class="line"><span class="comment">//  Copyright © 2018 Leetcode. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//时间复杂度O(n^2),空间复杂度O(1)</span></span><br><span class="line">    <span class="keyword">int</span> maxarea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; height.size(); j++) &#123;</span><br><span class="line">            maxarea = max(maxarea, min(height[i], height[j]) * (j - i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxarea;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line">    <span class="keyword">int</span> maxarea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = height.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        maxarea = max(maxarea, min(height[left], height[right] )* (right - left));;</span><br><span class="line">        <span class="keyword">if</span>(height[left] &lt; height[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxarea;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; height;</span><br><span class="line">    <span class="keyword">int</span> n, x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        height.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxarea1 = maxArea(height);</span><br><span class="line">    <span class="keyword">int</span> maxarea2 = maxArea2(height);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; maxarea1 &lt;&lt; <span class="string">" "</span> &lt;&lt; maxarea2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java容器概述</title>
      <link href="/%E8%AF%AD%E8%A8%80/Java%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0/"/>
      <url>/%E8%AF%AD%E8%A8%80/Java%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Java容器-Container"><a href="#Java容器-Container" class="headerlink" title="Java容器(Container)"></a>Java容器(Container)</h1><h2 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h2><p>容器可以管理对象的生命周期、对象与对象之间的依赖关系。<br>直白点说容器就是一段Java程序，能够帮助你管理对象间的关系，而不需要你自行编写程序处理。<br>维基百科定义：</p><blockquote><p>在计算机科学中，容器是指实例为其他类的对象的集合的类、数据结构、[1][2]或者抽象数据类型。换言之，它们以一种遵循特定访问规则的系统的方法来存储对象。容器的大小取决于其包含的对象（或元素）的数目。<br>潜在的不同容器类型的实现可能在空间和时间复杂度上有所差别，这使得在给定应用场景中选择合适的某种实现具有灵活性。</p></blockquote><a id="more"></a><h2 id="Java内部的容器类"><a href="#Java内部的容器类" class="headerlink" title="Java内部的容器类"></a>Java内部的容器类</h2><p>Java内部的容器类主要分为两类：Collection(集合)与Map(图)</p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p><img src="http://huangyiblog.com/java-collections.png" alt="alt"></p><p><strong>Set</strong></p><ul><li><strong><em>HashSet</em></strong></li></ul><ol><li>基于哈希表实现，底层使用HashMap来保存所有元素。</li><li>不能保证迭代顺序</li><li>允许使用null元素</li></ol><ul><li><strong><em>LinkedHashSet</em></strong></li></ul><ol><li>LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承于HashSet。</li><li>内部使用双向链表维护插入顺序。</li></ol><ul><li><strong><em>TreeSet</em></strong></li></ul><ol><li>基于（TreeMap）红黑树实现</li><li>TreeSet非同步，线程不安全</li><li>TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。</li></ol><p><strong>List</strong></p><ul><li><strong><em>ArrayList</em></strong></li></ul><ol><li>实现 List 接口、底层使用数组保存所有元素。</li><li>相当于动态数组，支持动态扩容。</li><li>不同步</li></ol><ul><li><strong><em>vector</em></strong></li></ul><ol><li>Vector 可以实现可增长的对象数组。</li><li>Vector 实现 List 接口，继承 AbstractList 类，同时还实现RandmoAccess 接口，Cloneable 接口</li><li>Vector 是线程安全的</li></ol><ul><li><strong><em>LinkedList</em></strong><br>LinkedList 是基于链表实现的（通过名字也能区分开来），<br>所以它的插入和删除操作比 ArrayList 更加高效。但也是由于其为基于链表的，所以随机访问的效率要比 ArrayList 差。</li></ul><p><strong>Queue</strong></p><ul><li><p><strong><em>LinkedList</em></strong><br>可以用于实现双向队列</p></li><li><p><strong><em>PriorityQueue</em></strong><br>通过二叉小顶堆实现，可以用一棵完全二叉树表示。<br>可以用于实现优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。</p><h3 id="Map-用于映射（键值对）问题处理"><a href="#Map-用于映射（键值对）问题处理" class="headerlink" title="Map(用于映射（键值对）问题处理)"></a>Map(用于映射（键值对）问题处理)</h3></li></ul><p><img src="http://huangyiblog.com/java-collections1.png" alt="alt"></p><p><strong>HashMap</strong></p><ol><li>HashMap根据键的HashCode来实现，访问速度较快，遍历顺序并不确定。</li><li>HashMap最多只允许一条记录的键为null，允许多条记录的值为null。</li><li>HashMap线程不安全，也就是说任意时刻可以有多个线程同时写HashMap，所以可能会导致数据的不一致。</li><li>如何确保线程安全？可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</li></ol><p><strong>HashTable</strong></p><ol><li>HashTable是遗留类，多数功能与HashMap类似，继承自Dictionary类。</li><li>HashTable是线程安全的。也就是说任意时刻只有一个线程能够写HashTable。</li><li>HashTable的并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。</li></ol><p><strong>LinkedHashMap</strong><br>基于哈希表和链表实现，借助双向链表确保迭代顺序是插入的顺序。</p><p><strong>TreeMap</strong></p><ol><li>基于红黑树实现</li><li>默认按照键值得升序进行排序。</li><li>在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，<br>否则会在运行时抛出java.lang.ClassCastException类型的异常。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>24. 两两交换链表中的节点</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>分析：<br>解法一：<br>题目要求两两链表中的结点，比较好想得应该还是直接遍历整个链表list，每次swap(list-&gt;val,list-&gt;next-&gt;val),但是题目明确要求了不能只是单纯的改变结点的数据域，所以上述方法尽管输出一样，但并不符合要求。<br>解法二：<br>首先定义一个dummy哑结点指向head作为首结点来辅助操作。<br>之后定义一个current指向给定链表，定义一个前去指针pre指向dummy，定义一个临时链表temp储存每次要进行操作的两个结点。例如给定链表{1,2,3,4},先让temp指向3，然后分割{1,2}和{3,4},<br>让2的后继指针指向1，之后让dummy指向2，让1指向3，最后让pre指向1，current指向3继续遍历。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  swapNodes.cpp</span></span><br><span class="line"><span class="comment">//  LeetCode</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by a on 2018/10/19.</span></span><br><span class="line"><span class="comment">//  Copyright © 2018 Leetcode. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">creat</span><span class="params">( <span class="keyword">int</span> Array[])</span> </span>&#123;</span><br><span class="line">    ListNode *p, *pre, *head;</span><br><span class="line">    head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    pre = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        p-&gt;val = Array[i];</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;next = p;</span><br><span class="line">        pre = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">( ListNode* head )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;next) &#123;</span><br><span class="line">        swap(p-&gt;val, p-&gt;next-&gt;val);</span><br><span class="line">        p = p-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs2</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    ListNode* pre = dummy;</span><br><span class="line">    ListNode* temp;</span><br><span class="line">    <span class="keyword">while</span>(current &amp;&amp; current-&gt;next) &#123;</span><br><span class="line">        temp = current-&gt;next-&gt;next;</span><br><span class="line">        current-&gt;next-&gt;next = current;</span><br><span class="line">        pre-&gt;next = current-&gt;next;</span><br><span class="line">        current-&gt;next = temp;</span><br><span class="line">        pre = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Array[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    ListNode* head1 = creat(Array);</span><br><span class="line">    ListNode* head2 = creat(Array);</span><br><span class="line">    ListNode* L = swapPairs(head1);</span><br><span class="line">    <span class="comment">//L = L-&gt;next;</span></span><br><span class="line">    ListNode* res = swapPairs2(head2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(L != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, L-&gt;val);</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(res != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, res-&gt;val);</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>支持推理小说家紫金陈</title>
      <link href="/%E9%98%85%E8%AF%BB/%E6%94%AF%E6%8C%81%E6%8E%A8%E7%90%86%E5%B0%8F%E8%AF%B4%E5%AE%B6%E7%B4%AB%E9%87%91%E9%99%88/"/>
      <url>/%E9%98%85%E8%AF%BB/%E6%94%AF%E6%8C%81%E6%8E%A8%E7%90%86%E5%B0%8F%E8%AF%B4%E5%AE%B6%E7%B4%AB%E9%87%91%E9%99%88/</url>
      
        <content type="html"><![CDATA[<h1 id="紫金陈主要作品"><a href="#紫金陈主要作品" class="headerlink" title="紫金陈主要作品"></a>紫金陈主要作品</h1><ul><li>《推理之王1：无证之罪》（2014年实体书出版）</li><li>《推理之王2：坏小孩》（2014年实体书出版）</li><li>《推理之王3：长夜难明》（2017年出版）</li><li>《浙大夜惊魂》（2010年出版改名《禁忌之地》）</li><li>《谋杀官员1》（2012年）</li><li>《谋杀官员2：化工女王的逆袭》（2012年）</li><li>《谋杀官员3：物理教师的时空诡计》（2013年1月更新完）</li><li>《谋杀官员4：代上帝之手(完结)》（2013年）<blockquote><p>因为我自己主要就阅读了他的上述作品，所以其他书没有全都一一例举。</p></blockquote></li></ul><a id="more"></a><p>　　一提到推理小说，估计很多人又想到了我们的邻居－－岛国日本，推理小说早期兴起于欧美，后来在日本也有了极大的发展。平时我们读的很多推理或者侦探小说相比大多都是欧美或者日本的作品比较多吧。著名的作者比如美国的埃德加·爱伦·坡，英国的阿加莎·克里斯蒂，日本的江川户乱步、东野圭吾等都是推理小说界的大神，不仅高产还高质量，我已开始读的也是日本的推理小说比较多。大一看了几本东野大神的作品后无意中接触到了国内紫金陈写的《无证之罪》，顿时来了兴趣，陆陆续续的也看了他的一些代表作，就我个人而言还是蛮喜欢他的推理作品，虽然不像有些大神那么高产，也不是每一本都布局十分巧妙，但吸引人的点还是很多的。<br>　　我已开始接触《无证之罪》后就顺便看完了他的推理之王系列的另外两本，《坏小孩》与《长夜难明》，之后又看了他较早的几部作品，从《浙大惊魂夜》（后来再版改名为《禁忌之地》）到《谋杀官员系列》，可以看出作者在每部作品的布局构思上都花了很大心思。紫金陈本名陈徐，毕业于浙江大学，主要走的是社会派本格推理路线，比如《谋杀官员系列》就是他的本格推理代表作。他的作品里的主要人物背景很多也是浙大毕业的校友，至于社会背景大多在以浙江各个市为模板进行创作。《无证之罪》很多人会拿来与东野圭吾的《嫌疑人Ｘ的献身》进行对比，认为在情节完善和人物塑造等方面还有很多不足之处，作者融入中国社会的背景，但同样是一位高智商大神为了帮助失误犯了罪的可怜人摆脱警察的故事。《坏小孩》的故事我大都忘了，比较早看的一本，其实说起来推理之王系列我最推崇的是《长夜难明》，他的说我也就这本买过实体说。不过说起来《长夜难明》或许并算不上推理吧，情节也不悬疑，只能说属于社会派推理比较好，但反映的社会问题还是很沉重的，虽然是小说，但现实生活中有没有类似的案情或者更为残酷的事实恐怕很难说，或许黑暗一直存在只是没有笼罩在你身上罢了。很多人应该看过韩国的一部电影《熔炉》，内容很沉重，在韩国法律界社会界都引起了极大的反响。《长夜难明》反应了类似的社会法律问题，书中直至结局也没能揪出幕后大老虎，尽管已经有人为此献出了生命的代价，但是在权利的悬殊面前你很难立马冲破黑暗。甚至很有可能一味的付出却给自己带来了毁灭的报复。总感觉现实中这么正义凛然的人很少，大家内心都有自己的想法，为什么要为了不相干的人去得罪人，做吃力不讨好的事？但如果人人都这么想，那些弱势群体就一直被压榨下去吗？<br>　　《谋杀官员系列》也不是每本都很精彩，有很多欠缺的地方还是明显的，尽管作为推理小说，或许不是非得文笔一流，但文笔不足的间接影响就是导致了人物造型，性格塑造方面不够鲜活，包括一些悬疑的点也很牵强。另外第二部和第四部都写到了屌丝对女神的爱，我就想说作者就不能放过广大屌丝吗，另外我想着尽管矮穷丑，但好歹是浙大高材生至于这么自卑吗，还是真的爱得真切，无法自拔。第四部结尾的有点牵强，竟然又扯出来了同性恋，但好在不是个完美的结尾，最后提到女神骆慧慧的孩子既不是李卫平也不是王红名的时候，估计很多人也蒙了，人性的复杂也只在这种时刻才能感受到。第二部又是一个单相思的家伙为了自己喜欢的人不惜付出一切为她犯罪，书名《化工女王的逆袭》估计误导了很多人，一直以为所谓的“同伙”就是化工女甘佳宁，结果这只是个幌子，但是“同伙”这个点设计的还是比较好的。另外这部反映的官场腐败等政治问题也挺厉害的，官场的腐败从上到下，从一手遮天的大老虎到仗势欺人的看家狗都让人不寒而栗，权利没有约束是很恐怖的。<br>　　我一般看这种推理小说并不怎么较真，不会太计较情节上的漏洞，除非是太明显的，毕竟自己只是个门外汉，娱乐为主哈哈。上述几本书看完倒也没花掉我多少时间，想想自己书架上的几本技术方面的恐龙📚，我内心就拔凉拔凉了，若是真想一本本从头看到尾，我又能吸收到少呢．．．　　</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>137. 只出现一次的数字 II</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-II/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-II/</url>
      
        <content type="html"><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,3,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,1,0,1,99]</span><br><span class="line">输出: 99</span><br></pre></td></tr></table></figure></p><p>解法一：<br>创建一个长度为sizeof(int)的数组count[sizeof(int)]，用count[i]来表示在i位出现的1的次数，如果count[i]是3的倍数，跳过，否则，取出该位。<br>时间复杂度O(n),空间复杂度O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> w = <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> count[w];</span><br><span class="line">        fill_n(&amp;count[<span class="number">0</span>], w, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">                count[j] += (nums[i] &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">                count[j] %= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w; i++) &#123;</span><br><span class="line">            res += count[i] &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解法二：<br>用二进制模拟三进制运算。<br>用one记录到当前处理的元素为止，二进制1出现“1次”（mod 3 之后的 1）的有哪些二进制位；用two记录到当前计算的变量为止，二进制1出现“2次”（mod 3 之后的 2）的有哪些二进制位。当one和two中的某一位同时为1时表示该二进制位上1出现了3次，此时需要清零。<br>时间复杂度O(n),空间复杂度O(1)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> one  = <span class="number">0</span>, two = <span class="number">0</span>, three = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            two |= (one &amp; i);</span><br><span class="line">            one ^= i;</span><br><span class="line">            three = ~(one &amp; two);</span><br><span class="line">            one &amp;= three;</span><br><span class="line">            two &amp;= three;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>解法三：<br>我们把数组中数字的每一位累加起来对3取余，剩下的结果就是那个单独数组该位上的数字.<br>用二进制表示的过程为00-&gt;01-&gt;10-&gt;00,用a 和 b来表示一开始的状态的十位和个位：<br>b = b ^ r &amp; ~a;<br>a = a ^ r &amp; ~b;<br>刚开始的时候，a和b都是0，当遇到数字1的时候，b更新为1，a更新为0，就是01的状态；再次遇到1的时候，b更新为0，a更新为1，就是10的状态；再次遇到1的时候，b更新为0，a更新为0，就是00的状态，相当于重置了；所以最后的结果保存在b中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            b = (b ^ nums[i]) &amp; ~a;</span><br><span class="line">            a = (a ^ nums[i]) &amp; ~b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://soulmachine.gitbooks.io/algorithm-essentials/java/bitwise-operations/single-number-ii.html" target="_blank" rel="noopener">https://soulmachine.gitbooks.io/algorithm-essentials/java/bitwise-operations/single-number-ii.html</a></p><p><a href="https://leetcode.com/problems/single-number-ii/discuss/43294/challenge-me-thx" target="_blank" rel="noopener">https://leetcode.com/problems/single-number-ii/discuss/43294/challenge-me-thx</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>谈谈一部争议较大的日漫《缘之空》</title>
      <link href="/%E5%BD%B1%E9%9F%B3/%E8%B0%88%E8%B0%88%E4%B8%80%E9%83%A8%E4%BA%89%E8%AE%AE%E8%BE%83%E5%A4%A7%E7%9A%84%E6%97%A5%E6%BC%AB%E3%80%8A%E7%BC%98%E4%B9%8B%E7%A9%BA%E3%80%8B/"/>
      <url>/%E5%BD%B1%E9%9F%B3/%E8%B0%88%E8%B0%88%E4%B8%80%E9%83%A8%E4%BA%89%E8%AE%AE%E8%BE%83%E5%A4%A7%E7%9A%84%E6%97%A5%E6%BC%AB%E3%80%8A%E7%BC%98%E4%B9%8B%E7%A9%BA%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="我先给出自己的主要观点："><a href="#我先给出自己的主要观点：" class="headerlink" title="我先给出自己的主要观点："></a>我先给出自己的主要观点：</h2><ul><li>我不认为悠是渣男，恰恰相反，整部番里我觉得悠才是内心最纠结的可怜人。</li><li>我不支持兄妹乱伦的爱情，但我相信可能会有这样真实的感情。</li><li>我支持平行世界的剧情设计。</li><li>对我而言这部番吸引我的是BGM。</li><li>我不赞同有人纯粹拿这部番当里番来看，我不觉得这是部里番。</li><li>我不相信柏拉图式的爱情，完全没有性的爱情我觉得不存在。</li></ul><a id="more"></a><p>　　日本动漫产业一直以来都是其他国家难以匹敌的一块，我平时看的动漫虽然不能说很少吧，但多是完全谈不上，你可能无法想象一些宅男腐女追番有多么疯狂，其实在其他方面我也是这种状况，看书，看电影，似乎各种都有所投入，但都只是了解很少一部分。动漫能吸引人主要有几个点：剧情、画风、配音、ＢＧＭ。有时我是真佩服那些声优和作曲家，明明剧情狗血的要命，也能让我感动起来．．．我这次想写关于缘之空的故事，其实是因为三轮学创作的ｂｇｍ太好听了（×……————……×）　嘻嘻……<br>　　缘之空算是一部比较早期的作品了，是根据游戏改变过来的。当初游戏本就是分线路展开剧情的。所以后面改编成动画采用平行世界也没什么好奇怪的。游戏里主要有５条线，分别是宆悠线（也就是争议最大的兄妹线）、奈绪线、一叶线、悠瑛线、班长线。不过动漫里好像把班长那条线去掉了，只讲述了４条线。首先我们先来科普下平行世界的问题，我是在看之前就已经了解了剧情的构造，所以很多地方并不会觉得很奇怪或是难以理解。百度百科的定义如下：多元宇宙是一个理论上的无限个或有限个可能的宇宙的集合，包括了一切存在和可能存在的事物：所有的空间、时间、物质、能量以及描述它们的物理定律和物理常数。多元宇宙所包含的各个宇宙被称为平行宇宙（parallel universes）。好吧说实话我没怎么看明白，平行世界是否存在我也不知道，我这种物理渣渣还是就不要太纠结于这个了，一部动漫而已，太较真吃不消。按照字面意思来理解，缘之空其实就是讲述了男主悠在不同宇宙和一群相同的人之间发生的不同的故事。有和穹之间的故事，和奈绪之间的故事，和一叶之间的故事，还有瑛。<br>　　也许是改编成动漫时衔接的处理有些瑕疵，很多人认为悠是个渣男，脚踩都不止两只船了，可其实按照剧情设计，悠并没有脚踩两只船，他有同时在和两个女生交往吗？他有花心般的欺骗吗？和其他几个女生的交集更像是普通中学少男少女的青涩的爱情，只是到后来悠才意识的自己真正喜欢的是谁。穹妹给人的感觉有种红楼梦里林黛玉的影子，柔弱，多病，少话，内心却又感情丰富，有脾气有个性。这双胞胎兄妹的父母死于交通事故，两人相依为命，一起来到了祖父曾经生活过的奥木尔町生活，也是在这里发生了一系列的故事。<br>　　穹悠线饱受争议，就是因为双胞胎兄妹之间产生了情愫并甚至接受这样的情感。现实生活中包括我自己，想必很多人也是一样，很难想象或者说理解亲兄妹之间怎么能萌生出爱情的火花呢，从小一起长大。不知道你们有没有了解过韦斯特马效应，韦斯特马效应由芬兰人类学家爱德华·韦斯特马克在他的著作《The History of Human Marriage》（人类婚姻史）中提出，指出两个早年共同长大的儿童在成年后通常不会对彼此产生性吸引力：有血缘关系者也会存在亲缘监测机制（亲缘监测机制异常除外，三代以内越近越明显。）来保护；无血缘关系者由于生活在一起或可不会成年后产生性吸引；出生后六年的成长环境是一个关键时间点，其间生活在一起二者性吸引几率全会大大降低。但穹和悠却并不满足韦斯特马效应的前提，之前穹生病，兄妹二人长时间并未生活在一起，但突然间双亲离世，两人再次相遇，也许真有可能产生喜欢的情愫也说不定。但是兄妹恋终究是不被人认可的，所以可以感受悠的挣扎，悠和穹不一样，穹什么都不在乎，在乎的只有悠而已，悠作为哥哥，需要负起的应当是父亲般的责任，但却喜欢上了自己的妹妹，说出来谁能接受，不光会被人以异样的眼光看待，也没有做好一个哥哥的本分。动漫最后的处理是两人从湖中死里逃生最后一起移居他乡。我不知道这样的结局如何，如何确实互相爱慕，即使是兄妹，那么该不该在一起呢？我不知道，我不支持乱伦恋，但真实的感情并不能由外力改变，这是我相信的。<br>　　最后关于尺度问题，的确，这部动漫里有一些暴露的镜头，但我个人觉得并不过分，如果是爱情的话，这本也就是爱情的一部分，何必去特意躲闪。我大一暑假花了很长时间看完《金瓶梅》，好吧，我没那么纯洁，做不到看金瓶梅看出圣经来，但还是不否认这是一部伟大的文化作品，很多人认为金瓶梅的格调不如红楼梦，红楼梦当之无愧是我国古典文学的巅峰，但如果仅仅只是因为一个重点讲情、一个重点讲欲来评判高低那就太不公平了。缘之空很多人还是无法接受的，被禁我觉得也正常，有时也不能一天到晚黑广电，从国家层面来说，还是需要宣扬社会主义核心价值观比较好~~</p>]]></content>
      
      
      <categories>
          
          <category> 影音 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动漫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>19. 删除链表的倒数第N个节点</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure></p><p>说明：</p><p>给定的 n 保证是有效的。</p><p>进阶：</p><p><strong>你能尝试使用一趟扫描实现吗？</strong></p><p>分析：删除倒数第n个链表结点，两种想法。<br>解法一：正向扫描，删除倒数第n个结点，就是删除第(len - n + 1)个结点（len 为链表长度）,可以先扫描整个链表，求出链表长度，然后再次扫描链表，找到len - n 的位置，最后删除该位置的后一个结点。</p><p>解法二：双指针，定义两个指针都指向链表首结点，第一个指针先走n + 1步，之后两个指针同步前进，当第一个指针到达表尾时，第二个指针指向的就是要删除的倒数第n个结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveNthFromEnd</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        addVal(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ListNode res = removeNth(head, 3);</span></span><br><span class="line">        ListNode res = removeNth2(head, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">while</span>(res != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.print(res.val + <span class="string">" "</span>);</span><br><span class="line">        res = res.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addVal</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">ListNode node = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">ListNode current = head;</span><br><span class="line"><span class="keyword">while</span>(current.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">current = current.next;</span><br><span class="line">&#125;</span><br><span class="line">current.next = node;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNth</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(n)，空间复杂度O(1）</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode first = dummy;</span><br><span class="line">    ListNode second = dummy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(first != <span class="keyword">null</span>) &#123;</span><br><span class="line">    first = first.next;</span><br><span class="line">    second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    second.next = second.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNth2</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode first = head;</span><br><span class="line">    <span class="keyword">while</span>(first != <span class="keyword">null</span>) &#123;</span><br><span class="line">    len++;</span><br><span class="line">    first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    len = len - n;</span><br><span class="line">    first = dummy;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    len--;</span><br><span class="line">    first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    first.next = first.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何在Windows和Mac平台上协同管理hexo博客</title>
      <link href="/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/%E5%A6%82%E4%BD%95%E5%9C%A8Windows%E5%92%8CMac%E5%B9%B3%E5%8F%B0%E4%B8%8A%E5%8D%8F%E5%90%8C%E7%AE%A1%E7%90%86hexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/%E5%A6%82%E4%BD%95%E5%9C%A8Windows%E5%92%8CMac%E5%B9%B3%E5%8F%B0%E4%B8%8A%E5%8D%8F%E5%90%8C%E7%AE%A1%E7%90%86hexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="如何在多台电脑协同管理hexo博客"><a href="#如何在多台电脑协同管理hexo博客" class="headerlink" title="如何在多台电脑协同管理hexo博客"></a>如何在多台电脑协同管理hexo博客</h1><p>我很早就想搞个个人博客，其实写博客主要有3种选择：</p><ul><li>1 在第三方平台注册账号，直接在平台上写作并发布，例如博客圆，CSDN，新浪，网易等,这种方式最简单方便。</li><li>2 自己搭建博客。这种看个人需求，能力强的，可以完全前后端都自己代码实现，但大多数人一般也是直接采用模版的，简单省事。不过自己搭建的话需要去云服务商购买域名和云服务器，服务器的话学生优惠还是比较大的，阿里云，腾讯云上面都能买。</li><li>3 利用GitHub pages和hexo搭建静态博客，本地编写md文件，然后部署到github转化为html，相当于是托管于github。这种方法至少不用花钱买服务器，当然，你要是想绑定域名的话也可以照样去云服务商买一个，然后绑定到你的XXX.github.io上面。</li></ul><a id="more"></a><p>现在假设你已经在之前的Windows平台上搭好了hexo博客，并且能够正常部署运行。但因为需要，你要在另一台Mac系统的电脑上也能够管理你的hexo博客，可以利用Git分支来实现。</p><h1 id="在另一设备上管理博客"><a href="#在另一设备上管理博客" class="headerlink" title="在另一设备上管理博客"></a>在另一设备上管理博客</h1><ol><li>配置好环境</li></ol><ul><li>安装Node.js</li><li>安装Git</li><li>安装hexo<br>node.js可以直接去官网下载相应的匹配版本，Git的话，如果你的电脑安装是Mac并且安装了xcode，那么便不用再重新安装，xcode里便已经装有Git。</li></ul><ol start="2"><li>配置GitHub的SSH key<br>在新电脑上使用GitHub都需要先进行SSH key的配置，来获得GitHub的权限，以便本地和服务器之间数据的连接。</li></ol><ul><li>先测试你的电脑上是否已有ssh密钥,打开终端输入：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure></li></ul><p>如果没有，则进入下一步，生成ssh key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>将你的ssh key复制到GitHub上，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：将ssh key复制进去。</li><li>最后测试你的ssh是否配置成功<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ol><p>具体如何配置hexo博客可以参考：<a href="https://www.titanjun.top/2018/03/08/%E5%9F%BA%E4%BA%8EGitHub%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">使用hexo快速搭建个人博客</a></p><h1 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h1><ol><li><p>进入你的username.github.io仓库主要，新建一个分支，名字可以自定义，下面以hexo为例：<br><img src="http://huangyiblog.com/hexo1.jpg" alt="alt"></p></li><li><p>切换到hexo分支，并将该分支设置为默认分支后并保存。<br><img src="http://huangyiblog.com/hexo2.jpg" alt="alt"></p></li></ol><h1 id="上传配置文件到GitHub"><a href="#上传配置文件到GitHub" class="headerlink" title="上传配置文件到GitHub"></a>上传配置文件到GitHub</h1><ol><li>克隆hexo分支<br>将之前新建的分支克隆到本地<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b hexo git@github.com/username/username.github.io</span><br></pre></td></tr></table></figure></li></ol><p>查看当前所在分支是否为新建的hexo分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p><ol start="2"><li>上传部署文件</li></ol><ul><li><p>将你原先电脑里的配置文件拷贝到你的username.github.io文件目录下，这里的拷贝有几个文件或文件夹是必须要拷贝的：<br><strong>拷贝文件时要注意如果你的themes主题文件下下面有.git文件夹，要先将.git文件夹删除，否则主题文件会上传失败，一个GitHub仓库只能有一个.git</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line"> package.json</span><br><span class="line"> scaffolds/</span><br><span class="line"> source/</span><br><span class="line"> themes/</span><br></pre></td></tr></table></figure></li><li><p>拷贝完以后执行npm install 安装必要的组件</p></li><li><p>执行如下命令更新分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;add new files&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li><li><p>测试是否成功<br>可以执行hexo new “post”,hexo s预览是否有效，之后便用hexo d -g上传部署。</p></li></ul><ul><li>使用Mac系统操作hexo命令是要求在最前面加上sudo，否则会报错，提示你权限不足。<blockquote><p>master分支和hexo分支各自保存着一个版本，master分支用于保存博客静态资源，提供博客页面供人访问；hexo分支用于备份博客部署文件，供自己维护更新，两者在一个GitHub仓库内也不会有任何冲突</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 业务开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>来普陀山拜观音了</title>
      <link href="/%E9%9A%8F%E7%AC%94/%E6%9D%A5%E6%99%AE%E9%99%80%E5%B1%B1%E6%8B%9C%E8%A7%82%E9%9F%B3%E4%BA%86/"/>
      <url>/%E9%9A%8F%E7%AC%94/%E6%9D%A5%E6%99%AE%E9%99%80%E5%B1%B1%E6%8B%9C%E8%A7%82%E9%9F%B3%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>　　鉴于中国国情，一直以来我都是十分抵触国庆出游的，原因你懂得。但这次可能有点坐不住了，我姐说要带母亲去泰国旅游，家里没了人，我咋办呀～不行，我也得出去玩，我想了想，恩，爬山挺不错的，我喜欢。然后就去找高中同学商量着一起国庆去爬山。爬什么山呢，浙江附近有名的山还是有不少的，黄山，三清山，庐山，雁荡山．．．这些我都考虑过，后来同学提了句普陀山怎么样，我立马便决定，好，就去普陀山，顺便看看大海，拜拜观音。从后面看来，我的决定还是比较正确的。<br>　　那时还没到中秋，我们俩就提前把去舟山的车票，民宿订好了，民宿订的是个混合旅馆，住两晚。国庆景区人山人海，这是一直被人诟病的事实，但我这次总体体验还行，天公作美呀，这两天天气出奇的好，温度适宜，海风凉爽。起初我还有点担心台风的问题，但最后收到预警通知时我们都已经准备返程了。你说运气好不好。当然唯一有点遗憾的就是没去东极岛，我只知道这是韩寒拍后会无期的取景地，中国的第一缕阳光照射的地方，不过东极岛本就不在我的计划范围内，真说遗憾到也谈不上，毕竟是个小岛，而且也远，票都不一定抢的到。<br>　　２号一大早起床，我就屁颠屁颠坐地铁来到杭州东站等大巴，坐着大巴离开杭州后的高速路上都很顺水，没发生什么堵车的问题，一直到了宁波镇海那边，速度有所减缓，真正发生堵车的地方就是在金塘大桥。这座桥是通往舟山的关键道路，也是图中碰到的第一座并且也是最长的一座跨海大桥。当然，比杭州湾跨海大桥要小点。<br><img src="http://huangyiblog.com/zs2.jpg" alt="alt"><br>看到大海以后最大的感慨就是为何如此混黄不清，与我心目中蔚蓝色大海相去甚远。但稍微想想，浙江的海应该都是灰黄灰黄的吧，不知道是因为地处钱塘江入海口还是其他原因。但浩瀚的气势还是有的，和我看惯了的千岛湖、西湖完全就是两种风格。<br>进入舟山以后车子就开的较慢了，一路时停时走的来到了舟山普陀区，我当时也不记得自己买了到哪里的车票，结果就一路坐着过了观音大桥来到了朱家尖慈航广场，我一看，这哪行，我们定的民宿是在普陀区大岭下呀，然后有坐上车回程，司机带我们到彩虹广场放我们下来，我就顺便吃了饭再去民宿。<br>　　到了民宿后，我们结识了这次出行的第一位室友，聊了几句，发现他和我们一样也是大三学生，是个高高瘦瘦还有些帅气的萧山小伙子。我看到脖子上手臂上通红通红的，估计是被晒成这样的，当时他刚好玩累了回来，一脸虚脱样。他和我们不一样，我们是第一次来舟山，去普陀山拜观音的，他可不是第一次来了，他有两个大学同学是舟山人，这次放假就顺便陪他们来舟山玩两天再回家。到了傍晚，我们都没怎么饿，我就和同学商量着晚上去哪玩，这时萧山小哥说：“听说沈家门那边的鲁家峙大桥夜景挺不错的，我们一起去逛逛吧”，我们也没其他主意，于是在手机地图上查了查鲁家峙大桥的位置，写着距离２.４公里，我们一看，那也没多少路吗，直接走过去就得了。从大岭下出发，我们三人没走多久就遇到了个山洞，没想到这山洞出乎意料的长，我们三一前一后的排成一列，足足走了将近２０分钟才走到另一头，边上时不时几辆电瓶车飞驰而过，让我们老老实实贴着边缘走着，还真是不容易。没多久我们就来到了鲁家峙大桥桥底，上桥还得走个楼梯，从桥上往下望还是挺高的，桥下就是大海，这要掉下去可不是开玩笑的，我也不敢走太边上。我们在桥上赏了赏夜景，吹了吹海风，就返程了，返程我们可吃不消再走回去了，是坐公交回去的。回到民宿后，又和这位萧山小哥聊了聊，他在临安的浙江农林大学学法学，还准备要考研，司法考什么的，他倒是和我们聊起了昨晚和它住一起的室友，他说那位老哥昨晚大半夜的还在打电话，一个劲的拿头撞墙。我们听了一惊，只是咋回事呀，有啥想不开的？原来是被女朋友放了鸽子，放了鸽子还不算，他女朋友还要和他分手，而他早早地订好住宿，昨晚却在那电话里拼了命的求复合，一直闹腾到了大半夜，哎。我们那天也真是累了，第二天还得早起买票去，于是早早就上床休息了。<br><img src="http://pc5wd3ju6.bkt.clouddn.com/zs1.jpg" alt="alt"></p><p>　　第二天６点多，我和同学起床吃了碗馄饨后就坐着公交来到慈航广场买船票了，那时还好，虽然已经有不少人在排队了，但还不算夸张，总之我们还是很庆幸自己出发的比较早。从朱家尖到普陀山的普通客船是３０元一人，普陀山进山门票是１８０，我们买了学生票９０元。进山后，我们往左开始游山，依次游览了百花园，观音<img src="http://huangyiblog.com/zs3.jpg" alt="alt">古洞，磐陀石等，那时人还不多，所以游览起来还是蛮舒服的。普陀山应该也是个佛教圣地，山上寺庙众多，经常看到一些墙上写着喃无哦米投佛，我们一路翻山，来到百步沙，这是个沙滩，我们随即脱了鞋子去沙滩玩了，这时我又想到了天气好的好处，大暑假的你让我在这沙滩上晒太阳我怕是不大吃得消。我们俩走沙滩上都留了好久，捐起裤脚走在海边，看着海浪一波波涌来，但不敢走太里面，万一一不当心海浪盖过膝盖，那我的裤子是得湿透了。这之后已经快中午了，人山人海的架势也有点显现了，我们之后绕到了不肯去观音院和紫竹林，我一开始还以为这紫竹林是一大片竹林呢，结果到了以后半根竹子都没见着…逛了大半天，真事还没干，来普陀山怎么也得拜下南海观音吧，但是当我们到了南海观音雕像时已经是人山人海了，还有不少拿着香在哪虔诚的拜观音，我们就走在人群里，都不知道他们是在拜观音还是在拜我了。<br><img src="http://huangyiblog.com/zs4.jpg" alt="alt"></p><p><img src="http://huangyiblog.com/zs5.jpg" alt="alt"><br>我们的最后一站是南天门，二石壁立如门，所以不要以为南天门真的是扇门，只是三块大石头，两边各一块，顶上一块，状似一扇门，也就是所谓的南天门。南天门逛完后我们便返程了，还真是挺累的，走了大半天的路。<br>　　到了晚上，我们又结识了一位新室友，昨晚那位萧山小哥回家去了，今天搬进来了另一位小伙子。这小伙子更有意思，我们一直聊天聊到后半夜都意犹未尽。他也是个大三学生，还和我一样学的是计算机，你说巧不巧，同行遇同行，两眼泪汪汪，我们竟然开始聊起来了学习．．对的，你没听错，我们一开始聊得是学习．．我问他有什么打算，准备走什么方向，他是在江西读书，想考研，以后走算法方向，不过不是ＡＩ算法，而是数据处理那方面的。但我们聊学习没聊多久就转移了话题，你也知道两个学渣聊不出多大花头。我对这位小哥倒是很感兴趣，慢慢慢慢兴致也就上来了，首先，他是新疆人，这就足以勾起我很大好奇心了，平时我可是很少接触到新疆人呢。而且他有些想法我也比较认同。我告诉我们他这次从江西那边过来，先在宁波玩了两天然后又来舟山玩，他已经去了全国很多地方，他对我们说他出去旅游很多时候并不是为了看景点啥的，而是接触各种各样的人，到四处游玩可以让他接触很多没见过的东西，碰到很多不一样的人，这些人都有自己的一些习俗，想法，和他们聊天是件很有意思的事。我们之后聊了很多很多，有关于他中学是谈对象的故事，有关于他一个土豪室友的故事，还有很多关于新疆的故事，我们俩真是第一次听说新疆竟然是这样的。据他说新疆治安那时真的厉害，目标就是震慑一些犯罪分子，恐怖分子。记得之前发生了一件什么事，整个新疆整整半年停网停通讯，当然他没具体说什么事，毕竟属于机密事件，我也不敢乱写，不然得惹上不小麻烦。而且他们那边你可不能偷偷翻墙，一翻墙你就得接受“教育”了．．．总是我们各种瞎扯，时不时发点感慨，哇，土豪的世界我理解不了，哇，新疆竟然发生过这种事，我们听来就更听故事似的。<br>　　最后大家都累了，便熄灯安稳入睡了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>128. 最长连续序列</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>给定一个未排序的整数数组，找出最长连续序列的长度。</p><p>要求算法的时间复杂度为 O(n)。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [100, 4, 200, 1, 3, 2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure></p><p>分析：如果先进行排序在遍历求最长连续序列的长度，那么时间复杂度需要O(nlogn)，但是这题要求时间复杂度为O(n).考虑用哈希表的想法，用一个哈希表unordered_map&lt;int,bool&gt; used来记录每个元素是否使用，以该元素在中心，向左右遍历，直到不连续为止，每次记录下向左向右扩张的最长长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; used;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            used[nums[i]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[nums[i]]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">            used[nums[i]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = nums[i] + <span class="number">1</span>; used.find(j) != used.end(); ++j) &#123;</span><br><span class="line">                used[j] = <span class="literal">true</span>;</span><br><span class="line">                ++length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = nums[i] - <span class="number">1</span>; used.find(j) != used.end(); --j) &#123;</span><br><span class="line">                used[j] = <span class="literal">true</span>;</span><br><span class="line">                ++length;</span><br><span class="line">            &#125;</span><br><span class="line">            longest = max(longest, length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>4. 两个排序数组的中位数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/4-%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/4-%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。</p><p>请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。</p><p>你可以假设 nums1 和 nums2 不同时为空。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">中位数是 2.0</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure></p><p>分析：题目要求求出两个有序数组的中位数，其实这个问题属于TOPKth问题的一个特例，就是让你求两个有序数组的第k大数。<br>思路：比较直观简单的想法就是合并两个有序数组然后再求中位数，但这种做法时间复杂度为O(m + n).可是题目里面要求时间复杂度控制为O(log(m + n)).换一种双指针想法，首先用一个计数器记录当前已找到的第m大的元素，同时让两个指针pA和pB分别指向两个数组的第一个元素，使用类似于归并排序的思想，如果数组nums1当前元素较小，那么pA++，同时m++；反之，pB++，同时m++。当m == k 遍历结束。时间复杂度O(k),空间复杂度O(1).但是如果k很接近m + n ,那么时间复杂度还是O(m + n)的。<br>在换一种想法，要求O(log(m + n))复杂度，我们想到二分查找，但是直接用二分，时间复杂度在O(log(m*n))，只能说用类似二分的做法。<br>我们假设nums1和nums2的元素个数都大于k / 2.我们比较nums1[k/2-1]和nums2[k/2-1]，有以下三种情况：</p><ul><li>nums1[k/2-1] == nums2[k/2-1]</li><li>nums1[k/2-1] &gt; nums2[k/2-1]</li><li>nums1[k/2-1] &lt; nums2[k/2-1]</li><li>如果nums1[k/2-1] &lt; nums2[k/2-1]，则nums1[0]~nums1[k/2-1]之间肯定在topK元素范围内，同理，如果nums1[k/2-1] &gt; nums2[k/2-1],则nums2[0] – nums2[k/2-1]肯定在topK元素范围内；如果nums1[k/2-1] == nums2[k/2-1] ，说明已找到第k大元素。<br>采用递归写法的话，终止条件为：</li><li>当nums1或nums2为空时，直接返回nums1[k-1]或nums2[k-1]</li><li>当k == 1时，返回min(nums1[0],nums2[0]);</li><li>当nums1[k/2-1]  == nums2[k/2-1],返回nums1[k/2-1]或nums2[k/2-1]</li></ul><p>关于具体的数学证明可以参考下官网给出的提解，蛮详细的。<br><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenA = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> lenB = nums2.size();</span><br><span class="line">        <span class="keyword">if</span>((lenA + lenB) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> r1 = (<span class="keyword">double</span>) findKth(nums1, <span class="number">0</span>, lenA, nums2, <span class="number">0</span>, lenB, (lenA + lenB) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">double</span> r2 = (<span class="keyword">double</span>) findKth(nums1, <span class="number">0</span>, lenA, nums2, <span class="number">0</span>, lenB, (lenA + lenB) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (r1 + r2) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, <span class="number">0</span>, lenA, nums2, <span class="number">0</span>, lenB, (lenA + lenB + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> startA, <span class="keyword">int</span> endA, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B,<span class="keyword">int</span> startB, <span class="keyword">int</span> endB, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = endA - startA;</span><br><span class="line">        <span class="keyword">int</span> m = endB - startB;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> B[startB + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> A[startA + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> A[startA] &lt; B[startB] ? A[startA] : B[startB];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> midA = (startA + endA) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> midB = (startB + endB) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[midA] &lt;= B[midB]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n / <span class="number">2</span> + m / <span class="number">2</span> + <span class="number">1</span> &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">return</span> findKth(A, startA, endA, B, startB, midB, k);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> findKth(A, midA + <span class="number">1</span>, endA, B, startB, endB, k - n / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(n / <span class="number">2</span> + m / <span class="number">2</span> + <span class="number">1</span> &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">return</span> findKth(A, startA, midA, B, startB, endB, k);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> findKth(A, startA, endA, B, midB + <span class="number">1</span>, endB, k - m / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Ubuntu与win10双系统引导修复的问题</title>
      <link href="/%E9%9A%8F%E7%AC%94/%E5%85%B3%E4%BA%8EUbuntu%E4%B8%8Ewin10%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E4%BF%AE%E5%A4%8D%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/%E9%9A%8F%E7%AC%94/%E5%85%B3%E4%BA%8EUbuntu%E4%B8%8Ewin10%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E4%BF%AE%E5%A4%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p>我的电脑之前是在Windows10系统上装了一个Fedora版本的linux，基本上使用都没什么问题，说实话，因为我大部分软件或开发工具啥的主要都装在Windows系统上，所以平时还是win10用的比较多。但最近听说国内有一款仿Ubuntu的深度deepin系统也挺不错的，而且界面还挺像mac，所以就急着将自己电脑上的Fedora换成了deepin，但估计就是在安装deepin的时候出了叉子。我到现在也没搞清楚是哪里出了问题，动了什么不该动的东西，导致win10的启动引导程序坏了，最后结果就是按下开机键只能进入deepin了。即是你在刚开机时按下ESC进入系统选择界面选择Windows也是照样进不了。</p><h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><p>发现进不了Windows只能进deepin我就开始有点慌了，要知道我很多软件和工具都是装在Windows上面，而linux还只是个壳子。我可不想重装系统，当然也不得不做好这最坏的打算。当时试了很多方法行不通，就又将deepin换成了Ubuntu，但结果还是一样，这倒是在意料之中。起初以为只是Ubuntu与win10不兼容，需要修复一下引导就行，但按理说不应该的，我室友的组装机用的就是这两个系统，从来没出什么问题。我上网查了查，有人说直接进入Ubuntu终端，运行sudo -updategrub，更新一下grub就行了，但我试了好几次，包括修改grub.cfg文件，但都行不通，每次update以后根本不显示found Windows这样的字眼。这是便意识到想必是win10的引导已经损坏了，再在linux上面瞎搞估计也无济于事。这样一来，我就去网上找资料，查如何修复win10引导。主要步骤如下：</p><ul><li>首先你得有个win64位的PE系统启动U盘，在开机的时候按下ESC键进入系统选择界面（我的电脑是ESC，这个不同版本电脑可能有所不同，也有可能你是F11，F12）,之后选择你的U盘启动系统进入。</li><li>进入系统后，打开你的DG（DiskGenuis）分区工具</li></ul><p><img src="http://huangyiblog.com/dg1.PNG" alt="alt"></p><p>使用这个工具之前需要注意一个问题，那就是你的硬盘是什么格式的，是GPT还是MBR？<br>-</p><p>很多人写的修复方法都是针对硬盘类型为mbr的，就是直接选中的系统盘，如下图：点击硬盘选项下的重建主引导记录。</p><p><img src="http://huangyiblog.com/dg2.png" alt="alt"></p><p>然而问题出现了，当我点击 硬盘选项后，重建主引导记录这一栏是灰色的，无法选中。原因就是我的硬盘类型是GPT的。</p><ul><li><p>接下来要做的就是修复GPT格式的引导，首先我们注意到ESP分区没有盘符，我们需要给他指定一个盘符：<br><img src="http://huangyiblog.com/dg3.PNG" alt="alt"></p></li><li><p>指派好了就关闭DG工具，回到桌面，</p></li></ul><p>打开cmd命令行，输入以下命令并运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　bcdboot c:\windows /s g: /f uefi /l zh-cn</span><br></pre></td></tr></table></figure></p><p>　　其中：<br>   c:\windows  硬盘系统目录，根据实际情况修改</p><p>　　/s g:     指定esp分区所在磁盘，根据实际情况修改</p><p>　　/f uefi   指定启动方式为uefi</p><p>　　/l zh-cn  指定uefi启动界面语言为简体中文</p><p>　　注：64位7PE不带/s参数，故7PE不支持bios启动下修复</p><p><img src="http://huangyiblog.com/dg4.PNG" alt="alt"></p><ul><li>创建成功后重新启动电脑，选择Windows boot manager进入系统，到这里win10的引导也就修复完成。</li></ul><h1 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h1><p>win10引导修复完成后的结果是，每次开机都是默认直接进入Windows，如果想要进入Ubuntu，还是要刚开机时按下ESC手动选择进入，而不是和之前一样，出现一个双系统选择界面供你直接选择。我进入Ubuntu之后尝试修复此问题，主要进行了如下操作：<br>1 进入Ubuntu终端，输入如下命令利用bootrepair修复引导<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 进入root用户</span><br><span class="line">sudo -i</span><br><span class="line"># 添加软件源并更新</span><br><span class="line">add-apt-repository ppa:yannubuntu/boot-repair &amp;&amp;　apt-get update</span><br><span class="line">＃　安装boot-repair并启动软件</span><br><span class="line">apt-get install -y boot-repair &amp;&amp; boot-repair</span><br></pre></td></tr></table></figure></p><p>2 查看Windows10磁盘所在引导，然后继续进入Ubuntu终端，修改引导</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo -i</span><br><span class="line">vim /boot/grub/grub.cfg</span><br><span class="line">//再该文件末尾修改win10引导信息。</span><br><span class="line">//之后再更新引导</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>3 庆幸的是更新引导之后的确出现了found Windows的字眼，但是当我重启电脑，发现并没有改变什么，还是只能直接进入Windows，所以挺困惑的。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JavaWeb开发环境设置</title>
      <link href="/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/JavaWeb%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"/>
      <url>/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/JavaWeb%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="第一步：下载所需要的开发工具"><a href="#第一步：下载所需要的开发工具" class="headerlink" title="第一步：下载所需要的开发工具"></a>第一步：下载所需要的开发工具</h1><ul><li>我这里的javaweb项目选择eclipse的javaee，下载网站：<a href="https://www.eclipse.org/downloads/packages/" target="_blank" rel="noopener">https://www.eclipse.org/downloads/packages/</a></li><li>服务器下载Tomcat，下载网站：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a></li><li>java jdk下载：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li><li>jdk的环境配置这里我就不写了。</li><li>注意点：版本问题，每个软件版本都不是随便下的，首先不提倡急着下载最新版的，容易出bug。另外尤其要注意jdk版本和Tomcat版本的兼容问题，有一个版本过高或过低都是不行的。<br>关于版本匹配：可以参考下图（Tomcat官网有介绍）<br><img src="http://pc5wd3ju6.bkt.clouddn.com/tomcatversion.PNG" alt="alt"></li></ul><h1 id="第二步：eclipse配置"><a href="#第二步：eclipse配置" class="headerlink" title="第二步：eclipse配置"></a>第二步：eclipse配置</h1><p>1 如下图：<br>进入preferences<br><img src="http://pc5wd3ju6.bkt.clouddn.com/jw1.PNG" alt="alt"></p><p>2 进入java选项下的installed JREs配置jdk目录</p><p><img src="http://pc5wd3ju6.bkt.clouddn.com/jw2.PNG" alt="alt"></p><p><img src="http://pc5wd3ju6.bkt.clouddn.com/jw3.PNG" alt="alt"></p><p>3 进入server配置tomcat的运行环境</p><p><img src="http://pc5wd3ju6.bkt.clouddn.com/jw4.PNG" alt="alt"></p><h1 id="第三步，新建一个javaweb项目，验证"><a href="#第三步，新建一个javaweb项目，验证" class="headerlink" title="第三步，新建一个javaweb项目，验证"></a>第三步，新建一个javaweb项目，验证</h1><p>如下图，在web选项新建一个Dynamic Web Project,并新建一个jsp，在里面任意输入内容后并允许，若能够正常输出，则配置成功。<br><img src="http://pc5wd3ju6.bkt.clouddn.com/jw5.PNG" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> 业务开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 与Ｇithub入门介绍</title>
      <link href="/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/Git-%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/Git-%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Git是什么？"><a href="#Git是什么？" class="headerlink" title="Git是什么？"></a>Git是什么？</h1><p>　　Git 是一款免费、开源的分布式版本控制系统，最早由 LinilusTorvalds 创建，用于管理 Linux 内核开发， 现已成为分布式版本控制的主流工具。版本控制系统（VCS）： 一种可以管理和追逐软件代码或其他类似类容的不同版本的工具。我们知道一旦启动一个项目，数据短暂且易失，对于相关的文本和代码，我们需要寻找合适的备份策略。而版本控制系统就是很好的备份策略，方便开发人员对变更进行追踪管理。。Git 由 Linus Torvalds 发明，起初是为了方便管理 Linux1内核的开发工作。如今，Git 已经在大量的项目中得到了 非常成功的应用。　　</p><h1 id="Git常见功能"><a href="#Git常见功能" class="headerlink" title="Ｇｉｔ常见功能"></a>Ｇｉｔ常见功能</h1><ol><li>从服务器上克隆数据库（包括代码和版本信息）到单机上。</li><li>在自己的机器上创建分支，修改代码。</li><li>在本地上自己创建的分支上提交代码。</li><li>在单机上合并分支。</li><li>新建⼀个分⽀，把服务器上最新版的代码fetch下来，然后跟⾃⼰的主分⽀合并。</li><li>⽣成补丁（patch），把补丁发送给主开发者。   </li><li>看主开发者的反馈，如果主开发者发现两个⼀般开发者之间有冲突（他们之间可 以合作解决的冲突），就会要求他们先解决冲突，然后再由其中⼀个⼈提交。如果 主开发者可以⾃⼰解决，或者没有冲突，就通过。</li><li>⼀般开发者之间解决冲突的⽅法，开发者之间可以使⽤ pull 命令解决冲突，解决 完冲突之后再向主开发者提交补丁</li></ol><h1 id="Git初步入门"><a href="#Git初步入门" class="headerlink" title="Git初步入门"></a>Git初步入门</h1><ul><li><p>如果你是第一次安装使用Git，你需要设置署名和邮箱：</p><pre><code>$ git config --global user.name &quot;⽤户名&quot;$ git config --global user.email &quot;电⼦邮箱&quot;</code></pre></li></ul><h2 id="关于git的常用命令，阮一峰老师有一篇博客讲的蛮好的。"><a href="#关于git的常用命令，阮一峰老师有一篇博客讲的蛮好的。" class="headerlink" title="关于git的常用命令，阮一峰老师有一篇博客讲的蛮好的。"></a>关于git的常用命令，阮一峰老师有一篇博客讲的蛮好的。</h2><p>  链接：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p><p>阮老师用了一张图介绍了最常用的6个命令。<br><img src="http://huangyiblog.com/git.png" alt="alt"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* Workspace：工作区</span><br><span class="line">* Index / Stage：暂存区</span><br><span class="line">* Repository：仓库区（或本地仓库）</span><br><span class="line">* Remote：远程仓库</span><br></pre></td></tr></table></figure><ul><li><p>将代码仓库clone到本地，其实就是将代码复制到你的机器⾥，并交由Git来管理：</p><pre><code>$ git clone git@github.com:someone/symfony-docs-chs.git</code></pre></li><li><p>初始化本地仓库，当前目录下会出现一个名为 .git 的目录</p><p>  $ git init</p></li><li><p>新建一个目录，将其初始化为Git代码库</p><p>  $ git init [project-name]</p></li><li><p>下载一个项目和它的整个代码历史</p><p>   $ git clone [url]</p></li><li><p>删除工作区文件，并将这次删除放入暂存区</p><p>  $ git rm [file1] [file2] …</p></li><li><p>向这个本地的代码仓库添加当前目录的所有改动。</p><pre><code>$ git add .</code></pre></li><li><p>提交文件到本地仓库</p><p>   $ git commit -m “Hello”   </p></li><li><p>提交暂存区的指定文件到仓库</p><p>   $ git commit [file1] [file2] … -m [message]</p></li><li><p>添加某个文件</p><p>   $ git add -p</p></li><li><p>查看现在的状态</p><p>  $ git status</p></li><li><p>推送所有分支到远程仓库</p><p>   $ git push [remote] –all</p><h1 id="Github是什么"><a href="#Github是什么" class="headerlink" title="Github是什么"></a>Github是什么</h1></li><li><p>维基百科的说明：</p></li></ul><p>GitHub 是⼀个共享虚拟主机服务，⽤于存放使⽤ Git 版本控制的软件代码 和内容项⽬。它由 GitHub 公司（曾称 Logical Awesome）的开发者 Chris Wanstrath、PJHyett和TomPreston-Werner使⽤RubyonRails编写⽽成。</p><ul><li><p>官方介绍：<br>GitHubisthebestplacetosharecodewithfriends,co-workers,classmates, andcompletestrangers. OvereightmillionpeopleuseGitHubtobuildamazingthingstogether.</p></li><li><p>对普通用户来说，它还可以是：<br>1 网站<br>2 静态博客<br>3 管理配置文件<br>4 资料收集库<br>5 简历<br>6 管理代码片段<br>7 托管的编程环境<br>8 写作<br>……</p></li><li>界面主要功能<br>1 Git仓库<br>2 Organization<br>可以统一管理账户和权 限，还能统一支付一些费用。<br>3 Issue<br>Issue功能，是将一个任务或问题分配给一个 Issue进行追踪和管理的功能。每一个功能更改或修正都对应一个Issue，讨论或修正都以这个 Issue为中心进行。只要查看Issue，就能知道和这个更改相关的一切信 息，并以此进行管理。<br>4 Wiki<br>通过Wiki功能，任何人都能随时对一篇文章进行更改并保存，因 此可以多人共同完成一篇文章。该功能常用在开发文档或手册的编写 中。<br>5 Pull Request<br>开发者向GitHub的仓库推送更改或功能添加后，可以通过Pull Request 功能向别人的仓库提出申请，请求对方合并。</li></ul><p>GitHub可以托管各种git库，并提供⼀个web界⾯，但与其它像SourceForge 或 GoogleCode 这样的服务不同，GitHub 的独特卖点在于从另外⼀个项⽬ 进⾏分⽀的简易性。为⼀个项⽬贡献代码⾮常简单：⾸先点击项⽬站点的 “fork” 的按钮，然后将代码检出并将修改加⼊到刚才分出的代码库中，最后通过内建的 “pullrequest” 机制向项⽬负责⼈申请代码合并。</p><h1 id="GitHub项目创建"><a href="#GitHub项目创建" class="headerlink" title="GitHub项目创建"></a>GitHub项目创建</h1><p>可以直接在web页面new repository。<br>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;first commit&quot;</span><br><span class="line">$ git remote add origin 地址</span><br><span class="line">$ git push -u origin master //将代码由本地仓库上传到Github远程仓库</span><br></pre></td></tr></table></figure></p><h1 id="Pull-Request-的概要"><a href="#Pull-Request-的概要" class="headerlink" title="Pull Request 的概要"></a>Pull Request 的概要</h1><ul><li>Pull Request 是自己修改源代 码后，请求对方仓库采纳该修改时采取的一种行为。</li></ul><p><img src="http://pc5wd3ju6.bkt.clouddn.com/pushrequest.PNG" alt="alt"></p><p>PR流程：<br>1 fork对方的repository<br>2 clone你之前fork的repository到你的本地电脑</p><pre><code>git clone git@url</code></pre><p>3 与对方GitHub的repository建立连接</p><pre><code>git remote add upstream url</code></pre><p>4 建立工作分支</p><pre><code>git checkout -b xiaoming-branch</code></pre><p>5 添加代码</p><p>6 提交修改<br>用 git diff命令查看修改是否已经正确进行。<br>使用 git add PRTest ，git commit ,git push等系列命令提交</p><p>7 发起Pull Request</p>]]></content>
      
      
      <categories>
          
          <category> 业务开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018上半年的阅读整理</title>
      <link href="/%E9%98%85%E8%AF%BB/2018%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%9A%84%E9%98%85%E8%AF%BB%E6%95%B4%E7%90%86/"/>
      <url>/%E9%98%85%E8%AF%BB/2018%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%9A%84%E9%98%85%E8%AF%BB%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>　　转眼间，２０１８大半年就过去了，今天想把自己这半年来的一些阅读整理下,看看哪些书自个感觉还不错，哪些书虽不错但因自己能力有限无法深读，哪些书只是为了消遣时间。<br>　　１《卑鄙的圣人：曹操》<br>　　这本书姑且可算作是本历史书吧，至少让我从另一个视角了解到了曹操，其实说起来，读三国的时候，其他人暂且不提，你若是问我曹操和刘备你喜欢哪个，毫无疑问我更看好曹操。三国乱世，枭雄方能立足，假仁假义的君子有何用。你说曹操奸诈也好，卑鄙也好，但你得承认他很牛，对用兵为政有自己的一套见解，作诗也是一把好手。曹操若非奸雄，别说后来的三国鼎立，怕是都活不到那时就已命丧黄泉了。<br>　　２《包法利夫人》<br>　　《包法利夫人》是法国作家福楼拜创作的长篇小说。<br>　　小说描写包法利夫人爱玛为摆脱不幸婚姻，追求不正当爱情而导致堕落毁灭的悲剧。表面上是一个淫妇不满婚后情感而渴望爱情因此通奸偷晴，但确实一个真正可怜的角色，不光是情感上的，同时也是当时所处社会的悲剧。<br>　　３《红楼梦评论》王国维<br>　　因为对红楼梦特别着迷，所以有些人写的一些关于红楼梦我的看法我也会去了解下，这本书或许也不算不上是本书吧，有点像是一篇论文，简要的论述了红楼梦在伦理，美术，艺术、哲学等方面的价值。<br>　　４《依偎》<br>　　依偎是丁捷写的一部爱情小说，有点悲剧色彩。这本小说剧情展开也挺特别，主要根据安芬和小天互相讲故事来展开，最后一步步发现两人之间竟然还有着不为人知的联系并且深深相爱。<br>　　５《陪安东尼度过漫长岁月》<br>　　这本书的写法也挺奇葩，至少很少看到，算是挺治愈的一本书。<br>　　６《罗密欧与朱丽叶》<br>　　莎士比亚的一部很经典的悲剧。<br>　　７《奥赛罗》<br>　　同样是莎士比亚的一部悲剧<br>　　８《道德经》<br>　　．．．篇幅不长，我看的是一段古文后面一段白话文解释的，有些倒还能理解，有些看着就有点玄乎了，或许是自己水平太差。<br>　　９《伊豆的舞女》<br>　　《伊豆的舞女》是川端康成早期的代表作和成名作，也是一篇杰出的中篇小说。<br>　　展现了少男少女初恋时的朦胧与美好，挺清新的。<br>　　１０《告白》<br>　　挺好的剧情小说，人物角色多面性，而不是单的纯谁善谁恶，刻画出人性的复杂多面。<br>　　１１《少年的你，如此美丽》<br>　　玖月晞写的一本青春言情小说吧，剧情上感觉有一些地方有点雷同《白夜行》，但这部小说还是很大胆的刻画了青少年女生的校园欺凌事件，反映了弱势群体如何自保以及法律相关的问题。<br>　　１２《妻妾成群》<br>　　《妻妾成群》是作家苏童创作的一部中篇小说。这部作品通过描写一个“受过新时代教育”的女学生颂莲，自愿嫁入到高墙深院秩序井然的封建家族陈府，最终又在“妻妾成群”明争暗斗中走向精神崩溃的悲惨命运，艺术化地再现了中国封建礼教吞噬人性的恐怖景象。<br>　　１３《老婆，跟我回家吧》<br>　　酒小七写的网络言情小说，还算有点幽默吧<br>　　１４《魔道祖师》<br>　　这部小说是因为先看了动漫，好奇剧情发展而去看的。我是挺喜欢的，故事线完整，人物性格分明。最开始夷陵老祖魏无羡复活，我以为受尽冤屈与不公的他会走浩浩荡荡的复仇路线，但却并没有，内心依旧洒脱，和蓝忘机一同维护心中的正义。<br>　　１５《窦娥冤》<br>　　窦娥冤的冤情今天动地，但我一直不清楚窦娥冤在何处，但现在总算明白了。<br>　　１６《莺莺传》<br>　　读了西厢记，就顺便把元稹的莺莺传也读了<br>　　１７《斗破苍穹》<br>　　玄幻小说<br>　　１８《基都山伯爵》<br>　　复仇曲。我爱爱我的人，我很恨我的人。<br>　　１９《人间失格》太宰治<br>　　２０《我的晃荡的青春》<br>　　东野圭吾的故事<br>　　２１《富爸爸，穷爸爸》<br>　　这本书倒是略为提到了理财的方面，钱的重要性在现今社会不言而喻。<br>　　富爸爸喜欢买入资产，穷爸爸喜欢买入负债。<br>　　２２《堂吉诃德》<br>　　骑士小说<br>　　２３《罗生门》<br>　　《罗生门》以风雨不透的布局将人推向生死抉择的极限，从而展示了“恶”的无可回避，第一次传递出作者对人的理解，对人的无奈与绝望。<br>　　２４《爱情和其他魔鬼》<br>　　加西亚马尔克斯眼中魔鬼般的爱情。<br>　　２５《红顶商人胡雪岩》<br>　　商圣的传奇人生<br>　　２６《韩寒的ｏｎｅ系列》<br>　　２７《半小时漫画中国史》<br>　　有意思的漫画历史作品<br>　　２８《死刑今夜执行》<br>　　思婷写的一部推理小说<br>　　２９《革命时期的爱情》<br>　　３０《杨绛传》</p><p>　　３１《蒋勋说红楼梦》</p><pre><code>也算是一个理解红楼梦的视角吧，只是蒋勋眼中的红楼梦我不能全都苟同，有些地方我怀疑作者的想法如你所说吗，我无从得知，但是蒋勋明显读的比我细比我深，还是学到了很多。</code></pre><p>   ３２《理想国》</p><p>　　３３《婉约词》<br>　　一本词集，只有词，没有注释解释啥的，你可以把自己想象成古人，嘻嘻，陶冶一番。<br>　　３４《小王子的领悟》<br>    周保松理解的小王子，可以帮助理解。<br>　　３５《邻人之妻》<br>　　由两性视角，诸多人物实例，反映美国社会这些年的发展。<br>　　３６古典四大名剧《西厢记》《牡丹亭》《桃花扇》《长生殿》<br>　　３７《战国策》<br>　　３８《资治通鉴》原著<br>　　３９《红手指》<br>　　东野圭吾较早的一部推理小说，但是也反映了家庭关系之间出现的一些问题<br>　　４０《聊斋志异》<br>以上主要是上半年看的一些书，其他的还有一些是关于编程的专业技能书，以及修仙玄幻言情等等网络小说，说白了，很多时候也就是为了消磨消磨时间，阅读就是挺能满足我的方式之一，嘻嘻。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书单 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>154. 寻找旋转排序数组中的最小值 II</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-II/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-II/</url>
      
        <content type="html"><![CDATA[<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,2,0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></p><p>分析：查找旋转了的排序数组，数组里允许存在重复元素，我们知道在一个数组里求最小元素，遍历整个数组肯定能求出，但一般时间复杂度都不是最优的，所以采用二分查找，当然对于这道题，如果数组里重复元素过多，二分的优势也并不明显。<br>分以下三种情况遍历：</p><ul><li>nums[mid] &gt; nums[left],查找右半区间</li><li>nums[mid] &lt; nums[left],查找左半区间</li><li>nums[mid] = nums[left] ，left++，跳过继续查找</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(size == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(size == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> min(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt; nums[right]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[left]) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[left]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(nums[left], nums[right]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>18. 四数之和</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>注意：</p><p>答案中不可以包含重复的四元组。</p><p>示例：</p><p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p><p>满足要求的四元组集合为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>分析：这道题和三数之和思路类似，无非是多了一个数，首先对给定数组进行排序，是最后答案数组有序，用两个do while循环去重。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size() - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> l = nums.size() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(k &lt; l) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k] + nums[l];</span><br><span class="line">                    <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">                        curr.push_back(nums[i]);</span><br><span class="line">                        curr.push_back(nums[j]);</span><br><span class="line">                        curr.push_back(nums[k]);</span><br><span class="line">                        curr.push_back(nums[l]);</span><br><span class="line">                        res.push_back(curr);</span><br><span class="line">                        <span class="keyword">do</span>&#123;++k;&#125;</span><br><span class="line">                        <span class="keyword">while</span>(k &lt; l &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]);</span><br><span class="line">                        <span class="keyword">do</span>&#123;--l;&#125;</span><br><span class="line">                        <span class="keyword">while</span>(k &lt; l &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                        ++k;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        --l;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>16. 最接近的三数之和</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p><p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p><p>分析：还是双指针思想，类似之前的三数之和解法，设定3个指针，固定两个，根据和的大小移动另一个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> distance = INT_MAX;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> k = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; k) &#123;</span><br><span class="line">                <span class="keyword">int</span> tempVal = nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">int</span> tempDis;</span><br><span class="line">                <span class="keyword">if</span>(tempVal &lt; target) &#123;</span><br><span class="line">                    tempDis = target - tempVal;</span><br><span class="line">                    <span class="keyword">if</span>(tempDis &lt; distance) &#123;</span><br><span class="line">                        distance = tempDis;</span><br><span class="line">                        res = nums[i] + nums[j] + nums[k];</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tempVal &gt; target) &#123;</span><br><span class="line">                    tempDis = tempVal - target;</span><br><span class="line">                    <span class="keyword">if</span>(tempDis &lt; distance) &#123;</span><br><span class="line">                        distance = tempDis;</span><br><span class="line">                        res = nums[i] + nums[j] + nums[k];</span><br><span class="line">                    &#125;</span><br><span class="line">                    --k;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res = nums[i] + nums[j] + nums[k];</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>15. 三数之和</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>分析：双指针思想，定位其中两个指针，根据和的大小来移动第三个指针。由于要求每个答案数组中的元素是升序排列的，所以在开始要对原数组进行排序，另外题目要求不能包含重复的答案数组，所以要有相应的去重操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> k = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; k) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                    curr.push_back(nums[i]);</span><br><span class="line">                    curr.push_back(nums[j]);</span><br><span class="line">                    curr.push_back(nums[k]);</span><br><span class="line">                    res.push_back(curr);</span><br><span class="line">                    ++j;</span><br><span class="line">                    --k;</span><br><span class="line">                    <span class="keyword">while</span>(j &lt; k &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;</span><br><span class="line">                        ++j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(j &lt; k &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                        --k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    --k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; nums.size() - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1057 Stack（30 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1057-Stack%EF%BC%8830-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1057-Stack%EF%BC%8830-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1057 Stack（30 分）<br>Stack is one of the most fundamental data structures, which is based on the principle of Last In First Out (LIFO). The basic operations include Push (inserting an element onto the top position) and Pop (deleting the top element). Now you are supposed to implement a stack with an extra operation: PeekMedian – return the median value of all the elements in the stack. With N elements, the median value is defined to be the (N/2)-th smallest element if N is even, or ((N+1)/2)-th if N is odd.</p><p>Input Specification:<br>Each input file contains one test case. For each case, the first line contains a positive integer N (≤10<br>​5<br>​​ ). Then N lines follow, each contains a command in one of the following 3 formats:</p><p>Push key<br>Pop<br>PeekMedian<br>where key is a positive integer no more than 10<br>​5<br>​​ .</p><p>Output Specification:<br>For each Push command, insert key into the stack and output nothing. For each Pop or PeekMedian command, print in a line the corresponding returned value. If the command is invalid, print Invalid instead.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">17</span><br><span class="line">Pop</span><br><span class="line">PeekMedian</span><br><span class="line">Push 3</span><br><span class="line">PeekMedian</span><br><span class="line">Push 2</span><br><span class="line">PeekMedian</span><br><span class="line">Push 1</span><br><span class="line">PeekMedian</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 5</span><br><span class="line">Push 4</span><br><span class="line">PeekMedian</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Invalid</span><br><span class="line">Invalid</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">Invalid</span><br></pre></td></tr></table></figure></p><p>分析：这道题除了要求实现栈的弹入和弹出操作，还要求查询栈内元素第k大（k是中位数），为了缩减时间复杂度，可以考虑分快思想，或者直接用树状数组<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sqrn = <span class="number">316</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">int</span> block[sqrn];</span><br><span class="line"><span class="keyword">int</span> table[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">peekMedian</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sum + block[idx] &lt; k) &#123;</span><br><span class="line">        sum += block[idx++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = idx * sqrn;</span><br><span class="line">    <span class="keyword">while</span>(sum + table[num] &lt; k) &#123;</span><br><span class="line">        sum += table[num++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    st.push(x);</span><br><span class="line">    block[x / sqrn]++;</span><br><span class="line">    table[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = st.top();</span><br><span class="line">    st.pop();</span><br><span class="line">    block[x / sqrn]--;</span><br><span class="line">    table[x]--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, query;</span><br><span class="line">    <span class="built_in">memset</span>(block, <span class="number">0</span>, <span class="keyword">sizeof</span>(block));</span><br><span class="line">    <span class="built_in">memset</span>(table, <span class="number">0</span>, <span class="keyword">sizeof</span>(table));</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;query);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; query; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd, <span class="string">"Push"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            Push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd, <span class="string">"Pop"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.empty() == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Invalid\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.empty() == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Invalid\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> k = st.size();</span><br><span class="line">                <span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    k = (k + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    k = k / <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                peekMedian(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1068 Find More Coins（30 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1068-Find-More-Coins%EF%BC%8830-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1068-Find-More-Coins%EF%BC%8830-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1068 Find More Coins（30 分）<br>Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she must pay the exact amount. Since she has as many as 10<br>​4<br>​​  coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find some coins to pay for it.</p><p>Input Specification:<br>Each input file contains one test case. For each case, the first line contains 2 positive numbers: N (≤10<br>​4<br>​​ , the total number of coins) and M (≤10<br>​2<br>​​ , the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers. All the numbers in a line are separated by a space.</p><p>Output Specification:<br>For each test case, print in one line the face values V<br>​1<br>​​ ≤V<br>​2<br>​​ ≤⋯≤V<br>​k<br>​​  such that V<br>​1<br>​​ +V<br>​2<br>​​ +⋯+V<br>​k<br>​​ =M. All the numbers must be separated by a space, and there must be no extra space at the end of the line. If such a solution is not unique, output the smallest sequence. If there is no solution, output “No Solution” instead.</p><p>Note: sequence {A[1], A[2], …} is said to be “smaller” than sequence {B[1], B[2], …} if there exists k≥1 such that A[i]=B[i] for all i&lt;k, and A[k] &lt; B[k].</p><p>Sample Input 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 9</span><br><span class="line">5 9 8 7 2 3 4 1</span><br></pre></td></tr></table></figure></p><p>Sample Output 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 5</span><br></pre></td></tr></table></figure></p><p>Sample Input 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 8</span><br><span class="line">7 2 4 3</span><br></pre></td></tr></table></figure></p><p>Sample Output 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No Solution</span><br></pre></td></tr></table></figure></p><p>题目大意：背包问题，有n枚硬币，给出每枚硬币的价值，现在要用这些硬币去支付价值为m的东西，问是否存在这样的方案使选择用来支付的硬币价值之和恰好为m，如果存在从小到大输出硬币的价值，如果有多种方案，则输出“字典序“”最小的</p><p>01背包问题：<br>状态转移方程：dp[i][v] = max{dp[i - 1][v], dp[i - 1][v - w[i] + c[i]}<br>开一个bool型二维数组choice[i][v]用来记录是选择了哪个策略，即是放第i件物品还是不放第i件物品。<br>无解条件为dp[m] != m<br>求解dp数组时，如果两种策略的大小相等，选择放第i件物品的策略。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> w[maxn], dp[maxv] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> choice[maxn][maxv], flag[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(w + <span class="number">1</span>, w + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = m; v &gt;= w[i]; v--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[v] &lt;= dp[v - w[i]] + w[i]) &#123;</span><br><span class="line">                dp[v] = dp[v - w[i]] + w[i];</span><br><span class="line">                choice[i][v] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                choice[i][v] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[m] != m) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No Solution"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> k = n, num = <span class="number">0</span>, v = m;</span><br><span class="line">        <span class="keyword">while</span>(k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(choice[k][v] == <span class="number">1</span>) &#123;</span><br><span class="line">                flag[k] = <span class="literal">true</span>;</span><br><span class="line">                v -= w[k];</span><br><span class="line">                num++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag[k] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i] == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, w[i]);</span><br><span class="line">                num--;</span><br><span class="line">                <span class="keyword">if</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1021 Deepest Root（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1021-Deepest-Root%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1021-Deepest-Root%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1021 Deepest Root（25 分）<br>A graph which is connected and acyclic can be considered a tree. The hight of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called the deepest root.</p><p>Input Specification:<br>Each input file contains one test case. For each case, the first line contains a positive integer N (≤10<br>​4<br>​​ ) which is the number of nodes, and hence the nodes are numbered from 1 to N. Then N−1 lines follow, each describes an edge by given the two adjacent nodes’ numbers.</p><p>Output Specification:<br>For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print Error: K components where K is the number of connected components in the graph.</p><p>Sample Input 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure></p><p>Sample Output 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p><p>Sample Input 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure></p><p>Sample Output 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: 2 components</span><br></pre></td></tr></table></figure></p><p>题目大意：给出n个结点和n-1条边，问它们能否形成一棵n个结点的树，如果能，从中选出结点作为树根，使整棵树的高度最大。输出所有满足要求的可以作为树根的结点。<br>思路：<br>1 由于连通、边数为n-1的图一定是一棵树，因此需要判断给定数据是否能使图连通。使用并查集判断方法：<br>每读入一条边的两个端点，判断这两个端点是否属于相同的集合，如果不同，则将它们合并到一个集合中，当处理完所有边后根据最终产生的集合个数是否为1来判断给定的图是否连通。<br>2 确定图连通后，则确定了树，选择合适根结点使树高最大的做法为：<br>先任意选择一个结点，从该节点开始遍历整棵树，获取能达到的最深的结点，记为集合A；然后从集合A中任意一个结点出发遍历整棵树，获取能达到的最深顶点，记为结点集合B。集合A与B的并集就是所求结果。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">bool</span> isRoot[maxn];</span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = x;</span><br><span class="line">    <span class="keyword">while</span>(x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a != father[a]) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = a;</span><br><span class="line">        a = father[a];</span><br><span class="line">        father[z] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span>(faA != faB) &#123;</span><br><span class="line">        father[faA] = faB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">blockCnt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        isRoot[findFather(i)] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cnt += isRoot[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxH = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp, ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> height, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height &gt; maxH) &#123;</span><br><span class="line">        temp.clear();</span><br><span class="line">        temp.push_back(u);</span><br><span class="line">        maxH = height;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(height == maxH) &#123;</span><br><span class="line">        temp.push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(G[u][i] == pre) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(G[u][i], height + <span class="number">1</span>, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">        Union(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> block = blockCnt(n);</span><br><span class="line">    <span class="keyword">if</span>(block != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: %d components\n"</span>, block);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        ans = temp;</span><br><span class="line">        dfs(ans[<span class="number">0</span>], <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.size(); i++) &#123;</span><br><span class="line">            ans.push_back(temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ans.begin(), ans.end());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i] != ans[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1007 Maximum Subsequence Sum (25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1007-Maximum-Subsequence-Sum-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1007-Maximum-Subsequence-Sum-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1007 Maximum Subsequence Sum (25)（25 分）<br>Given a sequence of K integers { N~1~, N~2~, …, N~K~ }. A continuous subsequence is defined to be { N~i~, N~i+1~, …, N~j~ } where 1 &lt;= i &lt;= j &lt;= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p><p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p><p>Input Specification:</p><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (&lt;= 10000). The second line contains K numbers, separated by a space.</p><p>Output Specification:</p><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">-10 1 2 3 4 -5 -23 3 7 -21</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 4</span><br></pre></td></tr></table></figure></p><p>求解最大连续子序列和，并且要求输出首尾元素，<br>边界dp[0] = a[0]<br>转移方程：if(dp[i - 1] + a[i]) &gt; a[i] : dp[i] = dp[i - 1] + a[i]<br>                 else  dp[i] = a[i]<br>用s[i]表示以a[i]作为结尾的最大连续子序列是从哪个元素开始的<br>两种情况<br>1 只有一个元素，这个最大连续子序列就是从a[i]开始，s[i] = a[i]<br>2 s[i] = s[i - 1]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], dp[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 %d %d\n"</span>, a[<span class="number">0</span>], a[n - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i - <span class="number">1</span>] + a[i] &gt; a[i]) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + a[i];</span><br><span class="line">            s[i] = s[i - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = a[i];</span><br><span class="line">            s[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt; dp[k]) &#123;</span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, dp[k], a[s[k]], a[k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1013 Battle Over Cities (25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1013-Battle-Over-Cities-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1013-Battle-Over-Cities-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1013 Battle Over Cities (25)（25 分）<br>It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from/toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly.</p><p>For example, if we have 3 cities and 2 highways connecting city~1~-city~2~ and city~1~-city~3~. Then if city~1~ is occupied by the enemy, we must have 1 highway repaired, that is the highway city~2~-city~3~.</p><p>Input</p><p>Each input file contains one test case. Each case starts with a line containing 3 numbers N (&amp;lt1000), M and K, which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then M lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to N. Finally there is a line containing K numbers, which represent the cities we concern.</p><p>Output</p><p>For each of the K cities, output in a line the number of highways need to be repaired if that city is lost.</p><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 2 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure></p><p>Sample Output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>题目大意：<br>给定一个无向图并规定：当删除图中某个顶点时，将会同时把与之连接的边一起删除，接下来给出k个查询，每个查询给出一个欲删除的顶点编号，求删除该顶点后需要增加多少边，才能使图连通。</p><p>分析：给定一个无向图，如何计算需要增加的边，使得整个图连通。<br>显然需要增加的边数等于连通块个数减1<br>求解一个无向图的连通块个数一般有两种方法：</p><ol><li>图的遍历：在遍历图的过程中总是每次访问单个连通块，并将该连通块内的所有顶点都标记为已访问，然后去访问下个连通块，在访问过程中同时计数遍历的连通快数</li><li>并查集：判断无向图每条边的两个顶点是否在一个集合内，如果在同一个集合内，则不作处理；否则将这两个顶点加入同一个集合。最后统计集合个数<br>关于删除顶点，当访问回到该顶点时返回即可。<br>1 遍历图计算连通块<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1111</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> currentPoint;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v == currentPoint) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[G[v][i]] == <span class="literal">false</span>) &#123;</span><br><span class="line">            dfs(G[v][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> query = <span class="number">0</span>; query &lt; k; query++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;currentPoint);</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">int</span> block = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != currentPoint &amp;&amp; vis[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">                block++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, block - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>2 并查集求连通块</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1111</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = x;</span><br><span class="line">    <span class="keyword">while</span>(x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a != father[a]) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = a;</span><br><span class="line">        a = father[a];</span><br><span class="line">        father[z] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span>(faA != faB) &#123;</span><br><span class="line">        father[faA] = father[faB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> currentPoint;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> query = <span class="number">0</span>; query &lt; k; query++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;currentPoint);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = i, v = G[i][j];</span><br><span class="line">                <span class="keyword">if</span>(u == currentPoint || v == currentPoint) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Union(u, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> block = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == currentPoint) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> fai = findFather(i);</span><br><span class="line">            <span class="keyword">if</span>(vis[fai] == <span class="literal">false</span>) &#123;</span><br><span class="line">                block++;</span><br><span class="line">                vis[fai] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, block - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>707. 设计链表</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。<br>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyLinkedList linkedList = new MyLinkedList();</span><br><span class="line">linkedList.addAtHead(1);</span><br><span class="line">linkedList.addAtTail(3);</span><br><span class="line">linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3</span><br><span class="line">linkedList.get(1);            //返回2</span><br><span class="line">linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3</span><br><span class="line">linkedList.get(1);            //返回3</span><br></pre></td></tr></table></figure></p><p>提示：</p><p>所有值都在 [1, 1000] 之内。<br>操作次数将在  [1, 1000] 之内。<br>请不要使用内置的 LinkedList 库。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        LinkedList = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* LinkedList;</span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        ListNode* head = LinkedList;</span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; i &lt; index) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head &amp;&amp; i == index) &#123;</span><br><span class="line">            <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* head = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">        head-&gt;next = LinkedList;</span><br><span class="line">        head-&gt;val = val;</span><br><span class="line">        LinkedList = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* head = LinkedList;</span><br><span class="line">        ListNode* temp = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">        temp-&gt;next = <span class="number">0</span>;</span><br><span class="line">        temp-&gt;val = val;</span><br><span class="line">        <span class="keyword">if</span>(!head) &#123;</span><br><span class="line">            LinkedList = temp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        ListNode* head = LinkedList;</span><br><span class="line">        <span class="keyword">if</span>(!head &amp;&amp; index == <span class="number">0</span>) &#123;</span><br><span class="line">            ListNode* temp = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">            temp-&gt;val = val;</span><br><span class="line">            temp-&gt;next = <span class="number">0</span>;</span><br><span class="line">            LinkedList = temp;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; i &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head &amp;&amp; head-&gt;next == <span class="number">0</span>) &#123;</span><br><span class="line">            ListNode* temp = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">            temp-&gt;val = val;</span><br><span class="line">            temp-&gt;next = <span class="number">0</span>;</span><br><span class="line">            head-&gt;next = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == index - <span class="number">1</span> &amp;&amp; head &amp;&amp; head-&gt;next) &#123;</span><br><span class="line">            ListNode* temp = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">            temp-&gt;val = val;</span><br><span class="line">            temp-&gt;next = head-&gt;next;</span><br><span class="line">            head-&gt;next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        ListNode* head = LinkedList;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; i &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next == <span class="number">0</span> &amp;&amp; index == <span class="number">0</span>) &#123;</span><br><span class="line">            LinkedList = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next) &#123;</span><br><span class="line">            ListNode* temp = head-&gt;next;</span><br><span class="line">            head-&gt;next = temp-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>687. 最长同值路径</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/687-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/687-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p><p>注意：两个节点之间的路径长度由它们之间的边数表示。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">              5</span><br><span class="line">             / \</span><br><span class="line">            4   5</span><br><span class="line">           / \   \</span><br><span class="line">          1   1   5</span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">              1</span><br><span class="line">             / \</span><br><span class="line">            4   5</span><br><span class="line">           / \   \</span><br><span class="line">          4   4   5</span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p>注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。</p><p>分析：考察二叉树的递归<br>首先判断二叉树root是否为空，如果是直接返回0，之后对左右子结点分别调用当前函数，取其中较大值保存到临时变量，表示左右子树中最长的同值路径，然后跟当前树的最长同值路径进行比较，对左右子结点调用dfs函数，并传入当前结点值，将返回值与临时变量比较取较大值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sub = max(longestUnivaluePath(root-&gt;left), longestUnivaluePath(root-&gt;right));</span><br><span class="line">        <span class="keyword">return</span> max(sub, dfs(root-&gt;left, root-&gt;val) + dfs(root-&gt;right, root-&gt;val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node || node-&gt;val != parent) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(dfs(node-&gt;left, node-&gt;val), dfs(node-&gt;right, node-&gt;val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>686. 重复叠加字符串匹配</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/686-%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/686-%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>给定两个字符串 A 和 B, 寻找重复叠加字符串A的最小次数，使得字符串B成为叠加后的字符串A的子串，如果不存在则返回 -1。</p><p>举个例子，A = “abcd”，B = “cdabcdab”。</p><p>答案为 3， 因为 A 重复叠加三遍后为 “abcdabcdabcd”，此时 B 是其子串；A 重复叠加两遍后为”abcdabcd”，B 并不是其子串。</p><p>注意:</p><p> A 与 B 字符串的长度在1和10000区间范围内。</p><p>在字符串b的长度范围内循环累加a并且判断是否存在子串，但要注意边界，所以循环结束后如果不存在，需要在累加一次并进行判断。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenb = B.length();</span><br><span class="line">        String res = A;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(res.length() &lt; lenb) &#123;</span><br><span class="line">            res += A;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.contains(B)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        res += A;</span><br><span class="line">        <span class="keyword">if</span>(res.contains(B)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cnt + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>690. 员工的重要性</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/690-%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/690-%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。</p><p>比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。</p><p>现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1</span><br><span class="line">输出: 11</span><br></pre></td></tr></table></figure></p><p>解释:<br>员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 = 11。<br>注意:</p><p>一个员工最多有一个直系领导，但是可以有多个直系下属<br>员工数量不超过2000。</p><p>思路：这题本质还是二叉树的遍历，所以用dfs或bfs都能做。<br>首先把 employees 存入 HashMap， id 为 key， Employee 为value。</p><p>　　然后建立一个 dfs function：</p><p>　　　　当员工的 subordinates 的 size  等于 0 的时候， 说明没有必要继续递归了，返回员工的重要值；</p><p>　　　　如果 size 大于0，那么遍历 subordinates，把每一个 员工id 递归，累加重要值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Employee info</span></span><br><span class="line"><span class="comment">class Employee &#123;</span></span><br><span class="line"><span class="comment">    // It's the unique id of each node;</span></span><br><span class="line"><span class="comment">    // unique id of this employee</span></span><br><span class="line"><span class="comment">    public int id;</span></span><br><span class="line"><span class="comment">    // the importance value of this employee</span></span><br><span class="line"><span class="comment">    public int importance;</span></span><br><span class="line"><span class="comment">    // the id of direct subordinates</span></span><br><span class="line"><span class="comment">    public List&lt;Integer&gt; subordinates;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(List&lt;Employee&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Employee&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Employee e : employees) &#123;</span><br><span class="line">            map.put(e.id, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(id, map);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id, HashMap&lt;Integer, Employee&gt; map)</span> </span>&#123;</span><br><span class="line">        Employee e = map.get(id);</span><br><span class="line">        <span class="keyword">if</span>(e.subordinates.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.importance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = e.importance;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sub : e.subordinates) &#123;</span><br><span class="line">            res += dfs(sub, map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>665. 非递减数列</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/665-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/665-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。</p><p>我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，满足 array[i] &lt;= array[i + 1]。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,2,3]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure></p><p>解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。<br>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,2,1]</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure></p><p>解释: 你不能在只改变一个元素的情况下将其变为非递减数列。<br>说明:  n 的范围为 [1, 10,000]。<br>分析：要求最多改变一个元素问能否使给定序列成为非递减序列。遍历给定数组，计数递增节点个数。<br>假设有一个数列a1a2a3a4a5,在a3之前一切正常，但是a4 &lt; a3，这时候有两种解决方案：一种是抬高a4，一种是降低a3，判断的依据就看a4和a2的关系，若a4 &lt; a2,则最好的解决方案就是抬高a4,抬高到a3的值刚好，反之亦然。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size(), needChange = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i + <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">                needChange++;</span><br><span class="line">                <span class="keyword">if</span>(needChange &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i + <span class="number">1</span>] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    nums[i + <span class="number">1</span>] = nums[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nums[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1107 Social Clusters（30 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1107-Social-Clusters%EF%BC%8830-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1107-Social-Clusters%EF%BC%8830-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1107 Social Clusters（30 分）<br>When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. A social cluster is a set of people who have some of their hobbies in common. You are supposed to find all the clusters.</p><p>Input Specification:<br>Each input file contains one test case. For each test case, the first line contains a positive integer N (≤1000), the total number of people in a social network. Hence the people are numbered from 1 to N. Then N lines follow, each gives the hobby list of a person in the format:</p><p>K<br>​i<br>​​ : h<br>​i<br>​​ [1] h<br>​i<br>​​ [2] … h<br>​i<br>​​ [K<br>​i<br>​​ ]</p><p>where K<br>​i<br>​​  (&gt;0) is the number of hobbies, and h<br>​i<br>​​ [j] is the index of the j-th hobby, which is an integer in [1, 1000].</p><p>Output Specification:<br>For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">3: 2 7 10</span><br><span class="line">1: 4</span><br><span class="line">2: 5 3</span><br><span class="line">1: 4</span><br><span class="line">1: 3</span><br><span class="line">1: 4</span><br><span class="line">4: 6 8 1 5</span><br><span class="line">1: 4</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4 3 1</span><br></pre></td></tr></table></figure></p><p>题目大意：如果有两个人有任意一个活动相同，那么救称他们处于同一个社交网络，给定n个人，求n个人形成了多少社交网络。<br>用course[h]记录喜欢活动h的人的编号，那么findFather(course[h])就是这个人所在的社交网络的根结点，合并当前读入的编号i与findFather(course[h])<br>集合计数可以开一个isRoot数组表示x号人作为根结点的社交网络中有多少人<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="keyword">int</span> isRoot[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> course[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = x;</span><br><span class="line">    <span class="keyword">while</span>(x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a != father[a]) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = a;</span><br><span class="line">        a = father[a];</span><br><span class="line">        father[z] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span>(faA != faB) &#123;</span><br><span class="line">        father[faA] = faB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">        isRoot[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, h;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h);</span><br><span class="line">            <span class="keyword">if</span>(course[h] == <span class="number">0</span>) &#123;</span><br><span class="line">                course[h] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            Union(i, findFather(course[h]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        isRoot[findFather(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isRoot[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    sort(isRoot + <span class="number">1</span>, isRoot + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ans; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, isRoot[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; ans) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1066 Root of AVL Tree (25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1066-Root-of-AVL-Tree-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1066-Root-of-AVL-Tree-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1066 Root of AVL Tree (25)（25 分）<br>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p><p>Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p><p>Output Specification:</p><p>For each test case, print the root of the resulting AVL tree in one line.</p><p>Sample Input 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">88 70 61 96 120</span><br></pre></td></tr></table></figure></p><p>Sample Output 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">70</span><br></pre></td></tr></table></figure></p><p>Sample Input 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">88 70 61 96 120 90 65</span><br></pre></td></tr></table></figure></p><p>Sample Output 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">88</span><br></pre></td></tr></table></figure></p><p>题目大意：给出n个整数，将他们依次插入一棵初始为空的AVL树上，求插入后根结点的值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, height;</span><br><span class="line">    node *lchild, *rchild;</span><br><span class="line">&#125;*root;</span><br><span class="line"><span class="function">node* <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    node* Node = <span class="keyword">new</span> node;</span><br><span class="line">    Node-&gt;v = v;</span><br><span class="line">    Node-&gt;height = <span class="number">1</span>;</span><br><span class="line">    Node-&gt;lchild = Node-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updatahegiht</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    root-&gt;height = max(getHeight(root-&gt;lchild), getHeight(root-&gt;rchild)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getbalancefac</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getHeight(root-&gt;lchild) - getHeight(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(node* &amp;root)</span> </span>&#123;</span><br><span class="line">    node* temp = root-&gt;rchild;</span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild = root;</span><br><span class="line">    updatahegiht(root);</span><br><span class="line">    updatahegiht(temp);</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(node* &amp;root)</span> </span>&#123;</span><br><span class="line">    node* temp = root-&gt;lchild;</span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild = root;</span><br><span class="line">    updatahegiht(root);</span><br><span class="line">    updatahegiht(temp);</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = newnode(v);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v &lt; root-&gt;v) &#123;</span><br><span class="line">        insert(root-&gt;lchild, v);</span><br><span class="line">        updatahegiht(root);</span><br><span class="line">        <span class="keyword">if</span>(getbalancefac(root) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(getbalancefac(root-&gt;lchild) == <span class="number">1</span>) &#123;</span><br><span class="line">                R(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(getbalancefac(root-&gt;lchild) == <span class="number">-1</span>) &#123;</span><br><span class="line">                L(root-&gt;lchild);</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(root-&gt;rchild, v);</span><br><span class="line">        updatahegiht(root);</span><br><span class="line">        <span class="keyword">if</span>(getbalancefac(root) == <span class="number">-2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(getbalancefac(root-&gt;rchild) == <span class="number">-1</span>) &#123;</span><br><span class="line">                L(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(getbalancefac(root-&gt;rchild) == <span class="number">1</span>) &#123;</span><br><span class="line">                R(root-&gt;rchild);</span><br><span class="line">                L(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    node* root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        insert(root, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">        insert(root, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, root-&gt;v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1099 Build A Binary Search Tree（30 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1099-Build-A-Binary-Search-Tree%EF%BC%8830-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1099-Build-A-Binary-Search-Tree%EF%BC%8830-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1099 Build A Binary Search Tree（30 分）<br>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2.</p><p><img src="https://images.ptausercontent.com/24c2521f-aaed-4ef4-bac8-3ff562d80a1b.jpg" alt="alt"></p><p>Input Specification:<br>Each input file contains one test case. For each case, the first line gives a positive integer N (≤100) which is the total number of nodes in the tree. The next N lines each contains the left and the right children of a node in the format left_index right_index, provided that the nodes are numbered from 0 to N−1, and 0 is always the root. If one child is missing, then −1 will represent the NULL child pointer. Finally N distinct integer keys are given in the last line.</p><p>Output Specification:<br>For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">1 6</span><br><span class="line">2 3</span><br><span class="line">-1 -1</span><br><span class="line">-1 4</span><br><span class="line">5 -1</span><br><span class="line">-1 -1</span><br><span class="line">7 -1</span><br><span class="line">-1 8</span><br><span class="line">-1 -1</span><br><span class="line">73 45 11 58 82 25 67 38 42</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">58 25 82 11 38 67 45 73 42</span><br></pre></td></tr></table></figure></p><p>题目大意：给出n个结点的二叉树的每个结点的左右孩子的编号，-1表示不存在，接着给出一个n个整数的序列，需要将这n个整数填入二叉树的结点中，使得二叉树成为一颗二叉查找树，输出这棵二叉查找树的层序遍历序列。</p><p>分析：采用二叉树的静态写法比较适合表示结点的编号关系，<br>对一颗二叉查找树来说，中序遍历序列是递增的，所以要把给定n个整数从小到大排序，然后对給定的二叉树进行中序遍历，同时将排序后的数字填入二叉树，最后层序遍历输出。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> lchild, rchild;</span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="keyword">int</span> n, in[maxn], num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(Node[root].lchild);</span><br><span class="line">    Node[root].data = in[num++];</span><br><span class="line">    inorder(Node[root].rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, Node[now].data);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; n) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Node[now].lchild != <span class="number">-1</span>) &#123;</span><br><span class="line">            q.push(Node[now].lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Node[now].rchild != <span class="number">-1</span>) &#123;</span><br><span class="line">            q.push(Node[now].rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lchild, rchild;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;lchild, &amp;rchild);</span><br><span class="line">        Node[i].lchild = lchild;</span><br><span class="line">        Node[i].rchild = rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(in, in + n);</span><br><span class="line">    inorder(<span class="number">0</span>);</span><br><span class="line">    bfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1064 Complete Binary Search Tree (30)（30 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1064-Complete-Binary-Search-Tree-30-%EF%BC%8830-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1064-Complete-Binary-Search-Tree-30-%EF%BC%8830-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1064 Complete Binary Search Tree (30)（30 分）<br>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</p><p>Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=1000). Then N distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p><p>Output Specification:</p><p>For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 0</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 3 8 1 5 7 9 0 2 4</span><br></pre></td></tr></table></figure></p><p>题目大意：给出n个非负整数，用他们构建一棵完全二叉排序树，输出这棵树的层序遍历序列。<br>分析：用数组在存放完全二叉树，对完全二叉树中的任意一个节点x，其左孩子结点的编号为2x，右孩子编号为2x+1<br>对一颗二叉排序树来说，其中序遍历序列是递增的，所以先将给定数字从小到大排序，然后对cbt数组表示的二叉树进行中序遍历，并再遍历过程中将数字从小到大填入数组<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, number[maxn], cbt[maxn], index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root &gt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root * <span class="number">2</span>);</span><br><span class="line">    cbt[root] = number[index++];</span><br><span class="line">    inorder(root * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(number, number + n);</span><br><span class="line">    inorder(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, cbt[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1004 Counting Leaves (30)（30 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1004-Counting-Leaves-30-%EF%BC%8830-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1004-Counting-Leaves-30-%EF%BC%8830-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1004 Counting Leaves (30)（30 分）<br>A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child.</p><p>Input</p><p>Each input file contains one test case. Each case starts with a line containing 0 &lt; N &lt; 100, the number of nodes in a tree, and M (&lt; N), the number of non-leaf nodes. Then M lines follow, each in the format:</p><p>ID K ID[1] ID[2] … ID[K]<br>where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 01.</p><p>Output</p><p>For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.</p><p>The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output “0 1” in a line.</p><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">01 1 02</span><br></pre></td></tr></table></figure></p><p>Sample Output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1</span><br></pre></td></tr></table></figure></p><p>题目大意：给出一棵二叉树，遍历该树，问该树的每一层有多少叶子结点。<br>1深度优先搜索<br>用邻接表来存储树，用一个leaf数组存放每层的叶子结点个数，用maxh记录树的深度。<br>dfs函数里先更新深度maxh，再判断当前结点是否为叶子结点，以此来决定是否要对leaf数组进行自增，在枚举完所有子结点后进入下一层</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> leaf[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> maxh = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    maxh = max(h, maxh);</span><br><span class="line">    <span class="keyword">if</span>(G[index].size() == <span class="number">0</span>) &#123;</span><br><span class="line">        leaf[h]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[index].size(); i++) &#123;</span><br><span class="line">        dfs(G[index][i], h + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, parent, child, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;parent, &amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;child);</span><br><span class="line">            G[parent].push_back(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, leaf[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxh; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, leaf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 广度优先搜索<br>bfs前要先将根结点压入队列q，然后再开始bfs。开始bfs时，先把队首元素弹出，同时更新最大深度maxh，之后判断当前访问节点是否为叶子结点，最后将所有子结点压入队列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> h[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> leaf[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> maxh = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        maxh = max(maxh, h[id]);</span><br><span class="line">        <span class="keyword">if</span>(G[id].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            leaf[h[id]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[id].size(); i++) &#123;</span><br><span class="line">            h[G[id][i]] = h[id] + <span class="number">1</span>;</span><br><span class="line">            q.push(G[id][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, parent, child, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;parent, &amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;child);</span><br><span class="line">            G[parent].push_back(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    h[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxh; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, leaf[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, leaf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>830. 较大分组的位置</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>在一个由小写字母构成的字符串 S 中，包含由一些连续的相同字符所构成的分组。</p><p>例如，在字符串 S = “abbxxxxzyy” 中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。</p><p>我们称所有包含大于或等于三个连续字符的分组为较大分组。找到每一个较大分组的起始和终止位置。</p><p>最终结果按照字典顺序输出。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abbxxxxzzy&quot;</span><br><span class="line">输出: [[3,6]]</span><br><span class="line">解释: &quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abc&quot;</span><br><span class="line">输出: []</span><br><span class="line">解释: &quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcdddeeeeaabbbcd&quot;</span><br><span class="line">输出: [[3,5],[6,9],[12,14]]</span><br></pre></td></tr></table></figure></p><p>说明:  1 &lt;= S.length &lt;= 1000<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; largeGroupPositions(<span class="built_in">string</span> S) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; S.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i] == S[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(right - left &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    res.push_back(&#123;left, right&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                right = right + <span class="number">1</span>;</span><br><span class="line">                left = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right - left &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    res.push_back(&#123;left, right&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1094 The Largest Generation (25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1094-The-Largest-Generation-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1094-The-Largest-Generation-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1094 The Largest Generation (25)（25 分）<br>A family hierarchy is usually presented by a pedigree tree where all the nodes on the same level belong to the same generation. Your task is to find the generation with the largest population.</p><p>Input Specification:</p><p>Each input file contains one test case. Each case starts with two positive integers N (&amp;lt100) which is the total number of family members in the tree (and hence assume that all the members are numbered from 01 to N), and M (&amp;ltN) which is the number of family members who have children. Then M lines follow, each contains the information of a family member in the following format:</p><p>ID K ID[1] ID[2] … ID[K]</p><p>where ID is a two-digit number representing a family member, K (&amp;gt0) is the number of his/her children, followed by a sequence of two-digit ID’s of his/her children. For the sake of simplicity, let us fix the root ID to be 01. All the numbers in a line are separated by a space.</p><p>Output Specification:</p><p>For each test case, print in one line the largest population number and the level of the corresponding generation. It is assumed that such a generation is unique, and the root level is defined to be 1.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">23 13</span><br><span class="line">21 1 23</span><br><span class="line">01 4 03 02 04 05</span><br><span class="line">03 3 06 07 08</span><br><span class="line">06 2 12 13</span><br><span class="line">13 1 21</span><br><span class="line">08 2 15 16</span><br><span class="line">02 2 09 10</span><br><span class="line">11 2 19 20</span><br><span class="line">17 1 22</span><br><span class="line">05 1 11</span><br><span class="line">07 1 14</span><br><span class="line">09 1 17</span><br><span class="line">10 1 18</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 4</span><br></pre></td></tr></table></figure></p><p>题目大意：给定树的结点个数n，非叶子节点个数m，然后输入m个非叶子结点各自的孩子结点编号，输出结点个数最多的一层的结点个数以及层号</p><p>思路：定义一个hashTable数组用来记录每一层的结点个数<br>写一个dfs函数，用来记录当前访问的结点编号index与该结点的层号level，进入函数，先令hashTable[level]加1，之后遍历结点index的所有孩子结点，对每个孩子结点进行递归，递归时level+1<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; node[maxn];</span><br><span class="line"><span class="keyword">int</span> hashTable[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    hashTable[level]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; node[index].size(); j++) &#123;</span><br><span class="line">        dfs(node[index][j], level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, parent, k, child;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;parent, &amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;child);</span><br><span class="line">            node[parent].push_back(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> maxLevel = <span class="number">-1</span>, maxValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable[i] &gt; maxValue) &#123;</span><br><span class="line">            maxValue = hashTable[i];</span><br><span class="line">            maxLevel = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, maxValue, maxLevel);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1090 Highest Price in Supply Chain (25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1090-Highest-Price-in-Supply-Chain-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1090-Highest-Price-in-Supply-Chain-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1090 Highest Price in Supply Chain (25)（25 分）<br>A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）– everyone involved in moving a product from supplier to customer.</p><p>Starting from one root supplier, everyone on the chain buys products from one’s supplier in a price P and sell or distribute them in a price that is r% higher than P. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.</p><p>Now given a supply chain, you are supposed to tell the highest price we can expect from some retailers.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, The first line contains three positive numbers: N (&lt;=10^5^), the total number of the members in the supply chain (and hence they are numbered from 0 to N-1); P, the price given by the root supplier; and r, the percentage rate of price increment for each distributor or retailer. Then the next line contains N numbers, each number S~i~ is the index of the supplier for the i-th member. S~root~ for the root supplier is defined to be -1. All the numbers in a line are separated by a space.</p><p>Output Specification:</p><p>For each test case, print in one line the highest price we can expect from some retailers, accurate up to 2 decimal places, and the number of retailers that sell at the highest price. There must be one space between the two numbers. It is guaranteed that the price will not exceed 10^10^.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9 1.80 1.00</span><br><span class="line">1 5 4 4 -1 4 5 3 6</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.85 2</span><br></pre></td></tr></table></figure></p><p>与1079相类似，要求所有叶结点中的最高价格以及这个价格的叶结点个数。<br>由于不需要考虑点权，所以可以直接用vector数组来存放树，树的最大深度可通过dfs或bfs获得。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child[maxn];</span><br><span class="line"><span class="keyword">double</span> p, r;</span><br><span class="line"><span class="keyword">int</span> n, maxDepth = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(child[index].size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth &gt; maxDepth) &#123;</span><br><span class="line">            maxDepth = depth;</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(depth == maxDepth) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; child[index].size(); i++) &#123;</span><br><span class="line">        dfs(child[index][i], depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa, root;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lf%lf"</span>, &amp;n, &amp;p, &amp;r);</span><br><span class="line">    r /= <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;fa);</span><br><span class="line">        <span class="keyword">if</span>(fa != <span class="number">-1</span>) &#123;</span><br><span class="line">            child[fa].push_back(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f %d\n"</span>, p * <span class="built_in">pow</span>(<span class="number">1</span> + r, maxDepth), num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1079 Total Sales of Supply Chain (25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1079-Total-Sales-of-Supply-Chain-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1079-Total-Sales-of-Supply-Chain-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1079 Total Sales of Supply Chain (25)（25 分）<br>A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）– everyone involved in moving a product from supplier to customer.</p><p>Starting from one root supplier, everyone on the chain buys products from one’s supplier in a price P and sell or distribute them in a price that is r% higher than P. Only the retailers will face the customers. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.</p><p>Now given a supply chain, you are supposed to tell the total sales from all the retailers.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line contains three positive numbers: N (&lt;=10^5^), the total number of the members in the supply chain (and hence their ID’s are numbered from 0 to N-1, and the root supplier’s ID is 0); P, the unit price given by the root supplier; and r, the percentage rate of price increment for each distributor or retailer. Then N lines follow, each describes a distributor or retailer in the following format:</p><p>K~i~ ID[1] ID[2] … ID[K~i~]</p><p>where in the i-th line, K~i~ is the total number of distributors or retailers who receive products from supplier i, and is then followed by the ID’s of these distributors or retailers. K~j~ being 0 means that the j-th member is a retailer, then instead the total amount of the product will be given after K~j~. All the numbers in a line are separated by a space.</p><p>Output Specification:</p><p>For each test case, print in one line the total sales we can expect from all the retailers, accurate up to 1 decimal place. It is guaranteed that the number will not exceed 10^10^.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 1.80 1.00</span><br><span class="line">3 2 3 5</span><br><span class="line">1 9</span><br><span class="line">1 4</span><br><span class="line">1 7</span><br><span class="line">0 7</span><br><span class="line">2 6 1</span><br><span class="line">1 8</span><br><span class="line">0 9</span><br><span class="line">0 4</span><br><span class="line">0 3</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">42.4</span><br></pre></td></tr></table></figure></p><p>题目大意：给出一棵树根唯一的销售供应的树，在树根处货物的价格为p，然后从根节点每往子结点走一层，盖层的货物价格会在父亲结点的价格上上涨r%。给出每个叶结点的货物量，求出价格之和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> data;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> p, r, ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Node[index].child.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        ans += Node[index].data * <span class="built_in">pow</span>(<span class="number">1</span> + r, depth);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Node[index].child.size(); i++) &#123;</span><br><span class="line">        dfs(Node[index].child[i], depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, child;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lf%lf"</span>, &amp;n, &amp;p, &amp;r);</span><br><span class="line">    r /= <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;Node[i].data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;child);</span><br><span class="line">                Node[i].child.push_back(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1f\n"</span>, p * ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1102 Invert a Binary Tree（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1102-Invert-a-Binary-Tree%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1102-Invert-a-Binary-Tree%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1102 Invert a Binary Tree（25 分）<br>The following is from Max Howell @twitter:</p><p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.<br>Now it’s your turn to prove that YOU CAN invert a binary tree!</p><p>Input Specification:<br>Each input file contains one test case. For each case, the first line gives a positive integer N (≤10) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to N−1. Then N lines follow, each corresponds to a node from 0 to N−1, and gives the indices of the left and right children of the node. If the child does not exist, a - will be put at the position. Any pair of children are separated by a space.</p><p>Output Specification:<br>For each test case, print in the first line the level-order, and then in the second line the in-order traversal sequences of the inverted tree. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">1 -</span><br><span class="line">- -</span><br><span class="line">0 -</span><br><span class="line">2 7</span><br><span class="line">- -</span><br><span class="line">- -</span><br><span class="line">5 -</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 7 2 6 4 0 5 1</span><br><span class="line">6 5 7 4 3 2 0 1</span><br></pre></td></tr></table></figure></p><p>题目大意：二叉树有n个结点，给出每个结点的左右孩子的节点编号，把该二叉树反转，输出反转后二叉树的层序遍历序列和中序遍历序列。</p><p>思路：进行后序遍历反转二叉树，在访问根结点时转换lchild和rchild</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> lchild, rchild;</span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="keyword">bool</span> notRoot[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n, num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, id);</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(Node[root].lchild);</span><br><span class="line">    print(root);</span><br><span class="line">    inorder(Node[root].rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        print(now);</span><br><span class="line">        <span class="keyword">if</span>(Node[now].lchild != <span class="number">-1</span>) &#123;</span><br><span class="line">            q.push(Node[now].lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Node[now].rchild != <span class="number">-1</span>) &#123;</span><br><span class="line">            q.push(Node[now].rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(Node[root].lchild);</span><br><span class="line">    postorder(Node[root].rchild);</span><br><span class="line">    swap(Node[root].lchild, Node[root].rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strTonum</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">'-'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        notRoot[c - <span class="string">'0'</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(notRoot[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> lchild, rchild;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            getchar();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c %c"</span>, &amp;lchild, &amp;rchild);</span><br><span class="line">        Node[i].lchild = strTonum(lchild);</span><br><span class="line">        Node[i].rchild = strTonum(rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = findRoot();</span><br><span class="line">    postorder(root);</span><br><span class="line">    bfs(root);</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>706. 设计哈希映射</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/706-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/706-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>不使用任何内建的哈希表库设计一个哈希映射</p><p>具体地说，你的设计应该包含以下的功能</p><p>put(key, value)：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。<br>get(key)：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。<br>remove(key)：如果映射中存在这个键，删除这个数值对。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyHashMap hashMap = new MyHashMap();</span><br><span class="line">hashMap.put(1, 1);          </span><br><span class="line">hashMap.put(2, 2);         </span><br><span class="line">hashMap.get(1);            // 返回 1</span><br><span class="line">hashMap.get(3);            // 返回 -1 (未找到)</span><br><span class="line">hashMap.put(2, 1);         // 更新已有的值</span><br><span class="line">hashMap.get(2);            // 返回 1 </span><br><span class="line">hashMap.remove(2);         // 删除键为2的数据</span><br><span class="line">hashMap.get(2);            // 返回 -1 (未找到)</span><br></pre></td></tr></table></figure></p><p>注意：</p><p>所有的值都在 [1, 1000000]的范围内。<br>操作的总数目在[1, 10000]范围内。<br>不要使用内建的哈希库。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashMap() &#123;</span><br><span class="line">        HashMap = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (<span class="number">1000001</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** value will always be positive. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        HashMap[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HashMap[key];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        HashMap[key] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; HashMap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashMap obj = new MyHashMap();</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.remove(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>705. 设计哈希集合</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/705-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/705-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>不使用任何内建的哈希表库设计一个哈希集合</p><p>具体地说，你的设计应该包含以下的功能</p><p>add(value)：向哈希集合中插入一个值。<br>contains(value) ：返回哈希集合中是否存在这个值。<br>remove(value)：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyHashSet hashSet = new MyHashSet();</span><br><span class="line">hashSet.add(1);         </span><br><span class="line">hashSet.add(2);         </span><br><span class="line">hashSet.contains(1);    // 返回 true</span><br><span class="line">hashSet.contains(3);    // 返回 false (未找到)</span><br><span class="line">hashSet.add(2);          </span><br><span class="line">hashSet.contains(2);    // 返回 true</span><br><span class="line">hashSet.remove(2);          </span><br><span class="line">hashSet.contains(2);    // 返回  false (已经被删除)</span><br></pre></td></tr></table></figure></p><p>注意：</p><p>所有的值都在 [1, 1000000]的范围内。<br>操作的总数目在[1, 10000]范围内。<br>不要使用内建的哈希集合库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashSet() &#123;</span><br><span class="line">        hashSet = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; (<span class="number">1000001</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        hashSet[key] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashSet[key]) &#123;</span><br><span class="line">            hashSet[key] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set did not already contain the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hashSet[key];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; hashSet;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashSet obj = new MyHashSet();</span></span><br><span class="line"><span class="comment"> * obj.add(key);</span></span><br><span class="line"><span class="comment"> * obj.remove(key);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj.contains(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1086 Tree Traversals Again (25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1086-Tree-Traversals-Again-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1086-Tree-Traversals-Again-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1086 Tree Traversals Again (25)（25 分）<br>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p><p>\ Figure 1</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to N). Then 2N lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p><p>Output Specification:</p><p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">Push 1</span><br><span class="line">Push 2</span><br><span class="line">Push 3</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 4</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 5</span><br><span class="line">Push 6</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 2 6 5 1</span><br></pre></td></tr></table></figure></p><p>题目大意：用栈来模拟一棵二叉树的先序和中序遍历，求这棵二叉树的后序遍历序列，<br>思路：<br>每次访问一个结点就把它入栈，类似先序遍历先访问根结点，所以push的次序就是先序遍历序列中元素的顺序，pop是按照左子树，根结点，右子树的顺序进行，所以pop的次序就是中序遍历序列中的元素顺序。<br>所以就是要根据二叉树的先序遍历序列和中序遍历序列，重构二叉树然后进行后序遍历<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node* lchild;</span><br><span class="line">    node* rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> pre[maxn], in[maxn], post[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preL &gt; preR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* root = <span class="keyword">new</span> node;</span><br><span class="line">    root-&gt;data = pre[preL];</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k = inL; k &lt;= inR; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[k] == pre[preL]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numLeft = k - inL;</span><br><span class="line">    root-&gt;lchild = create(preL + <span class="number">1</span>, preL + numLeft, inL, k - <span class="number">1</span>);</span><br><span class="line">    root-&gt;rchild = create(preL + numLeft + <span class="number">1</span>, preR, k + <span class="number">1</span>, inR);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(root-&gt;lchild);</span><br><span class="line">    postorder(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, root-&gt;data);</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">int</span> x, preIndex = <span class="number">0</span>, inIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(str, <span class="string">"Push"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            pre[preIndex++] = x;</span><br><span class="line">            st.push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            in[inIndex++] = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node* root = create(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    postorder(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1091 Acute Stroke (30)（30 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1091-Acute-Stroke-30-%EF%BC%8830-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1091-Acute-Stroke-30-%EF%BC%8830-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1091 Acute Stroke (30)（30 分）<br>One important factor to identify acute stroke (急性脑卒中) is the volume of the stroke core. Given the results of image analysis in which the core regions are identified in each MRI slice, your job is to calculate the volume of the stroke core.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line contains 4 positive integers: M, N, L and T, where M and N are the sizes of each slice (i.e. pixels of a slice are in an M by N matrix, and the maximum resolution is 1286 by 128); L (&lt;=60) is the number of slices of a brain; and T is the integer threshold (i.e. if the volume of a connected core is less than T, then that core must not be counted).</p><p>Then L slices are given. Each slice is represented by an M by N matrix of 0’s and 1’s, where 1 represents a pixel of stroke, and 0 means normal. Since the thickness of a slice is a constant, we only have to count the number of 1’s to obtain the volume. However, there might be several separated core regions in a brain, and only those with their volumes no less than T are counted. Two pixels are “connected” and hence belong to the same region if they share a common side, as shown by Figure 1 where all the 6 red pixels are connected to the blue one.</p><p>\ Figure 1</p><p>Output Specification:</p><p>For each case, output in a line the total volume of the stroke core.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">3 4 5 2</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">1 0 1 1</span><br><span class="line">0 1 0 0</span><br><span class="line">0 0 0 0</span><br><span class="line">1 0 1 1</span><br><span class="line">0 0 0 0</span><br><span class="line">0 0 0 0</span><br><span class="line">0 0 0 1</span><br><span class="line">0 0 0 1</span><br><span class="line">1 0 0 0</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">26</span><br></pre></td></tr></table></figure></p><p>题目大意：<br>给出一个三维数组，数组元素的取值为0或1。与某一个元素相邻的元素为其上下左右前后6个方向的邻接元素。若干个相邻元素的1称为一个块，如果块中1的个数不小于t，则称这个块为卒中核心区。要求所有卒中核心区中1的个数之和。</p><p>基本思路：三维广度优先搜索。枚举三维数组的每一个位置，如果为0，则跳过；如果为1，则使用bfs查询与该位置相邻的6个位置，递归判断他们是否为1。为了防止重复判断，用一个inq数组标记每个位置是否已经入队。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">int</span> n, m, slice, t;</span><br><span class="line"><span class="keyword">int</span> pixel[<span class="number">1290</span>][<span class="number">130</span>][<span class="number">61</span>];</span><br><span class="line"><span class="keyword">bool</span> inq[<span class="number">1290</span>][<span class="number">130</span>][<span class="number">61</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> X[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Y[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Z[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= n || x &lt; <span class="number">0</span> || y &gt;= m || y &lt; <span class="number">0</span> || z &gt;= slice || z &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pixel[x][y][z] == <span class="number">0</span> || inq[x][y][z] == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">    Node.x = x, Node.y = y, Node.z = z;</span><br><span class="line">    q.push(Node);</span><br><span class="line">    inq[x][y][z] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        node top = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        tot++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> newx = top.x + X[i];</span><br><span class="line">            <span class="keyword">int</span> newy = top.y + Y[i];</span><br><span class="line">            <span class="keyword">int</span> newz = top.z + Z[i];</span><br><span class="line">            <span class="keyword">if</span>(judge(newx, newy, newz)) &#123;</span><br><span class="line">                Node.x = newx;</span><br><span class="line">                Node.y = newy;</span><br><span class="line">                Node.z = newz;</span><br><span class="line">                q.push(Node);</span><br><span class="line">                inq[newx][newy][newz] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot &gt;= t) &#123;</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;slice, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> z = <span class="number">0</span>; z &lt; slice; z++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; m; y++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pixel[x][y][z]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> z = <span class="number">0</span>; z &lt; slice; z++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; m; y++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(pixel[x][y][z] == <span class="number">1</span> &amp;&amp; inq[x][y][z] == <span class="literal">false</span>) &#123;</span><br><span class="line">                    ans += bfs(x, y, z);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>680. 验证回文字符串 Ⅱ</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/680-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2-%E2%85%A1/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/680-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2-%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aba&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abca&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure></p><p>解释: 你可以删除c字符。<br>注意:</p><p>字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。</p><p>考虑双指针，从两段向中间进行比较，如果发现不匹配，因为只能删除一个字符，所以只有两种情况，即左指针后移或右指针前移。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left] != s[right]) &#123;</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(s, left + <span class="number">1</span>, right) || isPalindrome(s, left, right - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left] != s[right]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>674. 最长连续递增序列</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>给定一个未经排序的整数数组，找到最长且连续的的递增序列。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure></p><p>解释: 最长连续递增序列是 [1,3,5], 长度为3。<br>尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。<br>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,2,2,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure></p><p>解释: 最长连续递增序列是 [2], 长度为1。<br>注意：数组长度不会超过10000。</p><p>思路：遍历数组的时候用一个临时变量记录连续递增序列的长度，对每次的结果去最大值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxm = <span class="number">-1</span>, temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                temp += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxm = max(maxm, temp);</span><br><span class="line">                temp = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(maxm, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>661. 图片平滑器</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/661-%E5%9B%BE%E7%89%87%E5%B9%B3%E6%BB%91%E5%99%A8/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/661-%E5%9B%BE%E7%89%87%E5%B9%B3%E6%BB%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[1,1,1],</span><br><span class="line"> [1,0,1],</span><br><span class="line"> [1,1,1]]</span><br><span class="line">输出:</span><br><span class="line">[[0, 0, 0],</span><br><span class="line"> [0, 0, 0],</span><br><span class="line"> [0, 0, 0]]</span><br><span class="line">解释:</span><br><span class="line">对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0</span><br><span class="line">对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0</span><br><span class="line">对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0</span><br></pre></td></tr></table></figure></p><p>注意:</p><p>给定矩阵中的整数范围为 [0, 255]。<br>矩阵的长和宽的范围均为 [1, 150]。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; imageSmoother(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M) &#123;</span><br><span class="line">        <span class="keyword">int</span> rows = M.size();</span><br><span class="line">        <span class="keyword">int</span> cols = M[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res = M;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// sum 3x3 area and take care of the boundary</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=max(<span class="number">0</span>,i<span class="number">-1</span>); x&lt;=min(rows<span class="number">-1</span>, i+<span class="number">1</span>); x++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> y=max(<span class="number">0</span>, j<span class="number">-1</span>); y&lt;=min(cols<span class="number">-1</span>, j+<span class="number">1</span>); y++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sum += M[x][y]; <span class="comment">// sum up cells value</span></span><br><span class="line">                        count++; <span class="comment">// count cells number</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res[i][j] = sum / count; <span class="comment">// get average value</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>836. 矩形重叠</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/</url>
      
        <content type="html"><![CDATA[<p>矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。</p><p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p><p>给出两个矩形，判断它们是否重叠并返回结果。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure></p><p>说明：</p><p>两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。<br>矩形中的所有坐标都处于 -10^9 和 10^9 之间。</p><p>考虑重叠部分矩形的左下角坐标和右上角坐标<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = max(rec1[<span class="number">0</span>], rec2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> x2 = min(rec1[<span class="number">2</span>], rec2[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">int</span> y1 = max(rec1[<span class="number">1</span>], rec2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> y2 = min(rec1[<span class="number">3</span>], rec2[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">return</span> x1 &lt; x2 &amp;&amp; y1 &lt; y2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>695. 岛屿的最大面积</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<p>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line">对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">[[0,0,0,0,0,0,0,0]]</span><br><span class="line">对于上面这个给定的矩阵, 返回 0。</span><br></pre></td></tr></table></figure></p><p>注意: 给定的矩阵grid 的长度和宽度都不超过 50。</p><p>用dfs或bfs搜索遍历二维数组。</p><p>深度优先搜索借助递归，沿着某找路径往下直到结束。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; mark(grid.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(grid[<span class="number">0</span>].size(), <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> deep = grid.size();</span><br><span class="line">        <span class="keyword">int</span> len = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deep; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mark[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> temp = dfs(grid, i, j, mark);</span><br><span class="line">                res = max(res, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; mark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= grid.size() || y &gt;= grid[<span class="number">0</span>].size() || x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mark[x][y]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        mark[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(grid, x + <span class="number">1</span>, y, mark) + dfs(grid, x - <span class="number">1</span>, y, mark) + dfs(grid, x, y + <span class="number">1</span>, mark) + dfs(grid, x, y - <span class="number">1</span>, mark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>bfs需要借助栈进行一层层遍历搜索。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; mark(grid.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(grid[<span class="number">0</span>].size(), <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> deep = grid.size();</span><br><span class="line">        <span class="keyword">int</span> len = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deep; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mark[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">                st.push(make_pair(i, j));</span><br><span class="line">                mark[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(!st.empty()) &#123;</span><br><span class="line">                    temp++;</span><br><span class="line">                    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cur = st.top();</span><br><span class="line">                    st.pop();</span><br><span class="line">                    <span class="keyword">int</span> x = cur.first;</span><br><span class="line">                    <span class="keyword">int</span> y = cur.second;</span><br><span class="line">                    <span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x - <span class="number">1</span>][y] == <span class="number">1</span> &amp;&amp; mark[x - <span class="number">1</span>][y] == <span class="literal">false</span>) &#123;</span><br><span class="line">                        st.push(make_pair(x - <span class="number">1</span>, y));</span><br><span class="line">                        mark[x - <span class="number">1</span>][y] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(x + <span class="number">1</span> &lt; deep &amp;&amp; grid[x + <span class="number">1</span>][y] == <span class="number">1</span> &amp;&amp; mark[x + <span class="number">1</span>][y] == <span class="literal">false</span>) &#123;</span><br><span class="line">                        st.push(make_pair(x + <span class="number">1</span>, y));</span><br><span class="line">                        mark[x + <span class="number">1</span>][y] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x][y - <span class="number">1</span>] == <span class="number">1</span> &amp;&amp; mark[x][y - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                        st.push(make_pair(x, y - <span class="number">1</span>));</span><br><span class="line">                        mark[x][y - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(y + <span class="number">1</span> &lt; len &amp;&amp; grid[x][y + <span class="number">1</span>] == <span class="number">1</span> &amp;&amp; mark[x][y + <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                        st.push(make_pair(x, y + <span class="number">1</span>));</span><br><span class="line">                        mark[x][y + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>849. 到最近的人的最大距离</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/849-%E5%88%B0%E6%9C%80%E8%BF%91%E7%9A%84%E4%BA%BA%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/849-%E5%88%B0%E6%9C%80%E8%BF%91%E7%9A%84%E4%BA%BA%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p>在一排座位（ seats）中，1 代表有人坐在座位上，0 代表座位上是空的。</p><p>至少有一个空座位，且至少有一人坐在座位上。</p><p>亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。</p><p>返回他到离他最近的人的最大距离。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,0,0,0,1,0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。</span><br><span class="line">如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。</span><br><span class="line">因此，他到离他最近的人的最大距离是 2 。 </span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[1,0,0,0]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure></p><p>解释：<br>如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。<br>这是可能的最大距离，所以答案是 3 。<br>提示：</p><p>1 &lt;= seats.length &lt;= 20000<br>seats 中只含有 0 和 1，至少有一个 0，且至少有一个 1。</p><p>考虑三种情况，根据0的个数来计算，最左边或最右边有最多的连续0，那么结果就是相应0的个数，如果连续0在中间，连续0位为偶数个，那么个数/2就行，否则还要加上1。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistToClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; seats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, res = <span class="number">0</span>, n = seats.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(seats[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(cnt, res);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(seats[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(cnt, res);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(seats[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                res = max(res, cnt / <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = max(res, cnt / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>821. 字符的最短距离</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: S = &quot;loveleetcode&quot;, C = &apos;e&apos;</span><br><span class="line">输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>字符串 S 的长度范围为 [1, 10000]。<br>C 是一个单字符，且保证是字符串 S 里的字符。<br>S 和 C 中的所有字母均为小写字母。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shortestToChar(<span class="built_in">string</span> S, <span class="keyword">char</span> C) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i] == C) &#123;</span><br><span class="line">                ans[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = min(ans[i], ans[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans[i] = min(ans[i], ans[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>724. 寻找数组的中心索引</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。</p><p>我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。</span><br><span class="line">同时, 3 也是第一个符合要求的中心索引。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">nums = [1, 2, 3]</span><br><span class="line">输出: -1</span><br><span class="line">解释: </span><br><span class="line">数组中不存在满足此条件的中心索引。</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>nums 的长度范围为 [0, 10000]。<br>任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。</p><p>思路：先求出数组总和，然后遍历数组，判断左侧和与右侧和是否相等，右侧和可以用总和减去左侧和减去nums[i]表示<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, leftsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(leftsum == sum - leftsum - nums[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            leftsum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>700. 二叉搜索树中的搜索</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>例如，</p><p>给定二叉搜索树:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   7</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure></p><p>和值: 2<br>你应该返回如下子树:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      2     </span><br><span class="line">     / \   </span><br><span class="line">    1   3</span><br><span class="line">在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root-&gt;left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>783. 二叉搜索树结点最小距离</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/783-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%BB%93%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/783-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%BB%93%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉搜索树的根结点 root, 返回树中任意两节点的差的最小值。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [4,2,6,1,3,null,null]</span><br><span class="line">输出: 1</span><br><span class="line">解释:</span><br><span class="line">注意，root是树结点对象(TreeNode object)，而不是数组。</span><br><span class="line"></span><br><span class="line">给定的树 [4,2,6,1,3,null,null] 可表示为下图:</span><br><span class="line"></span><br><span class="line">          4</span><br><span class="line">        /   \</span><br><span class="line">      2      6</span><br><span class="line">     / \    </span><br><span class="line">    1   3</span><br></pre></td></tr></table></figure></p><p>最小的差值是 1, 它是节点1和节点2的差值, 也是节点3和节点2的差值。<br>注意：</p><p>二叉树的大小范围在 2 到 100。<br>二叉树总是有效的，每个节点的值都是整数，且不重复。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX, pre = INT_MAX;</span><br><span class="line">        getres(root, pre, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getres</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; pre, <span class="keyword">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getres(root-&gt;left, pre, res);</span><br><span class="line">        <span class="keyword">if</span>(pre != INT_MAX) &#123;</span><br><span class="line">            res = min(res, <span class="built_in">abs</span>(pre - root-&gt;val));</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        getres(root-&gt;right, pre, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>671. 二叉树中第二小的节点</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/671-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/671-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 </p><p>给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line">     / \</span><br><span class="line">    5   7</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line">说明: 最小的值是 2 ，第二小的值是 5 。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"></span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure></p><p>说明: 最小的值是 2, 但是不存在第二小的值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode* &gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">            TreeNode* node = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            res.insert(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">                s.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">                s.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = res.begin();</span><br><span class="line">        <span class="keyword">if</span>(res.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> *(++it);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>669. 修剪二叉搜索树</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  0   2</span><br><span class="line"></span><br><span class="line">  L = 1</span><br><span class="line">  R = 2</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">    1</span><br><span class="line">      \</span><br><span class="line">       2</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  0   4</span><br><span class="line">   \</span><br><span class="line">    2</span><br><span class="line">   /</span><br><span class="line">  1</span><br><span class="line"></span><br><span class="line">  L = 1</span><br><span class="line">  R = 3</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">      3</span><br><span class="line">     / </span><br><span class="line">   2   </span><br><span class="line">  /</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure></p><p> 先看根节点：<br>如果节点值比L还小，说明根节点和左子树都需要被剪掉，继续对右子树进行修剪。<br>如果节点值比R还大，说明根节点和右子树都需要被剪掉。继续对左子树进行修剪。<br>如果节点值在区间内:则对左子树和右子树再进行修剪。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; L) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root-&gt;right, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; R) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root-&gt;left, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = trimBST(root-&gt;left, L, R);</span><br><span class="line">        root-&gt;right = trimBST(root-&gt;right, L, R);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>479. 最大回文数乘积</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/479-%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E6%95%B0%E4%B9%98%E7%A7%AF/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/479-%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E6%95%B0%E4%B9%98%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<p>你需要找到由两个 n 位数的乘积组成的最大回文数。</p><p>由于结果会很大，你只需返回最大回文数 mod 1337得到的结果。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line"></span><br><span class="line">输出: 987</span><br><span class="line"></span><br><span class="line">解释: 99 x 91 = 9009, 9009 % 1337 = 987</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>n 的取值范围为 [1,8]。<br>分析：直接暴力搜索是要超时的。<br>先确定n位数的范围，然后遍历这个区间的数字。<br>当n&gt;1时，两个n位数乘积的最大回文数一定是2n位的。<br>所以将当前数字的前半段反转后拼接到后面，组成一个回文数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestPalindrome</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> upper = <span class="built_in">pow</span>(<span class="number">10</span>, n) - <span class="number">1</span>, lower = upper / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = upper; i &gt; lower; i--) &#123;</span><br><span class="line">            <span class="built_in">string</span> t = to_string(i);</span><br><span class="line">            <span class="keyword">long</span> p = stol(t + <span class="built_in">string</span>(t.rbegin(), t.rend()));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> j = upper; j * j &gt; p; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> p % <span class="number">1337</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>475. 供暖器</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/475-%E4%BE%9B%E6%9A%96%E5%99%A8/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/475-%E4%BE%9B%E6%9A%96%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。</p><p>现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。</p><p>所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。</p><p>说明:</p><p>给出的房屋和供暖器的数目是非负数且不会超过 25000。<br>给出的房屋和供暖器的位置均是非负数且不会超过10^9。<br>只要房屋位于供暖器的半径内(包括在边缘上)，它就可以得到供暖。<br>所有供暖器都遵循你的半径标准，加热的半径也一样。<br>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3],[2]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4],[1,4]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。</span><br></pre></td></tr></table></figure></p><p>二分解法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heaters)</span> </span>&#123;</span><br><span class="line">        sort(heaters.begin(), heaters.end());</span><br><span class="line">        <span class="keyword">int</span> radius = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> h : houses) &#123;</span><br><span class="line">            radius = max(radius, binarySearch(h, heaters));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> val, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heaters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = heaters.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> diff = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; heaters[mid]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            diff = min(<span class="built_in">abs</span>(val - heaters[left]), <span class="built_in">abs</span>(val - heaters[left - <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; heaters.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            diff = min(diff, <span class="built_in">abs</span>(val - heaters[left + <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        diff = min(diff, <span class="built_in">abs</span>(val - heaters[left]));</span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>双指针法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heaters)</span> </span>&#123;</span><br><span class="line">        sort(houses.begin(), houses.end());</span><br><span class="line">        sort(heaters.begin(), heaters.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> house : houses) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; heaters.size() - <span class="number">1</span> &amp;&amp; heaters[i] + heaters[i + <span class="number">1</span>] &lt;= house * <span class="number">2</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, <span class="built_in">abs</span>(heaters[i] - house));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>482. 密钥格式化</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/482-%E5%AF%86%E9%92%A5%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/482-%E5%AF%86%E9%92%A5%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>给定一个密钥字符串S，只包含字母，数字以及 ‘-‘（破折号）。N 个 ‘-‘ 将字符串分成了 N+1 组。给定一个数字 K，重新格式化字符串，除了第一个分组以外，每个分组要包含 K 个字符，第一个分组至少要包含 1 个字符。两个分组之间用 ‘-‘（破折号）隔开，并且将所有的小写字母转换为大写字母。</p><p>给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S = &quot;5F3Z-2e-9-w&quot;, K = 4</span><br><span class="line"></span><br><span class="line">输出：&quot;5F3Z-2E9W&quot;</span><br></pre></td></tr></table></figure></p><p>解释：字符串 S 被分成了两个部分，每部分 4 个字符；<br>     注意，两个额外的破折号需要删掉。<br>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S = &quot;2-5g-3-J&quot;, K = 2</span><br><span class="line"></span><br><span class="line">输出：&quot;2-5G-3J&quot;</span><br></pre></td></tr></table></figure></p><p>解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。</p><p>提示:</p><p>S 的长度不超过 12,000，K 为正整数<br>S 只包含字母数字（a-z，A-Z，0-9）以及破折号’-‘<br>S 非空<br>思路：忽略原字符串的连接号从后往前遍历。当字符个数整除k的时候要把多余的-pop掉<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">licenseKeyFormatting</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> countk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = S.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">char</span> letter = S[i];</span><br><span class="line">            <span class="keyword">if</span>(letter != <span class="string">'-'</span>) &#123;</span><br><span class="line">                res += <span class="built_in">toupper</span>(letter);</span><br><span class="line">                countk++;</span><br><span class="line">                <span class="keyword">if</span>(countk == K) &#123;</span><br><span class="line">                    res += <span class="string">'-'</span>;</span><br><span class="line">                    countk = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size() != <span class="number">0</span> &amp;&amp; res[res.size() - <span class="number">1</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            res.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1024 Palindromic Number (25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1024-Palindromic-Number-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1024-Palindromic-Number-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>A number that will be the same when it is written forwards or backwards is known as a Palindromic Number. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers.</p><p>Non-palindromic numbers can be paired with palindromic ones via a series of operations. First, the non-palindromic number is reversed and the result is added to the original number. If the result is not a palindromic number, this is repeated until it gives a palindromic number. For example, if we start from 67, we can obtain a palindromic number in 2 steps: 67 + 76 = 143, and 143 + 341 = 484.</p><p>Given any positive integer N, you are supposed to find its paired palindromic number and the number of steps taken to find it.</p><p>Input Specification:</p><p>Each input file contains one test case. Each case consists of two positive numbers N and K, where N (&lt;= 10^10^) is the initial numer and K (&lt;= 100) is the maximum number of steps. The numbers are separated by a space.</p><p>Output Specification:</p><p>For each test case, output two numbers, one in each line. The first number is the paired palindromic number of N, and the second number is the number of steps taken to find the palindromic number. If the palindromic number is not found after K steps, just output the number obtained at the Kth step and K instead.</p><p>Sample Input 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">67 3</span><br></pre></td></tr></table></figure></p><p>Sample Output 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">484</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p>Sample Input 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">69 3</span><br></pre></td></tr></table></figure></p><p>Sample Output 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1353</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>题目大意：给定一个正整数和操作次数限制，问在给定限制内能否得到回文数。该操作为让一个整数加上这个整数首尾颠倒的数字。<br>思路：<br>讲几个主要步骤写成分个函数<br>1 将字符串转化为相应结构的大整数<br>2 实现高精度的a + b，可以直接用模板<br>3 判断是否回文<br>4 输出函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bign</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    bign() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">bign <span class="title">change</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    bign a;</span><br><span class="line">    a.len = str.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len; i++) &#123;</span><br><span class="line">        a.d[i] = str[a.len - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">bign <span class="title">add</span><span class="params">(bign a, bign b)</span> </span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len || i &lt; b.len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a.d[i] + b.d[i] + carry;</span><br><span class="line">        c.d[c.len++] = temp % <span class="number">10</span>;</span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry != <span class="number">0</span>) &#123;</span><br><span class="line">        c.d[c.len++] = carry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(bign a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a.len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.d[i] != a.d[a.len - i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(bign a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,a.d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> t, k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str&gt;&gt;t;</span><br><span class="line">    bign a = change(str);</span><br><span class="line">    <span class="keyword">while</span>(k &lt; t &amp;&amp; judge(a) == <span class="literal">false</span>) &#123;</span><br><span class="line">        bign b = a;</span><br><span class="line">        reverse(b.d, b.d + b.len);</span><br><span class="line">        a = add(a, b);</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    print(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>599. 两个列表的最小索引总和</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/599-%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E6%80%BB%E5%92%8C/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/599-%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。</p><p>你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]</span><br><span class="line">[&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]</span><br><span class="line">输出: [&quot;Shogun&quot;]</span><br><span class="line">解释: 他们唯一共同喜爱的餐厅是“Shogun”。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]</span><br><span class="line">[&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]</span><br><span class="line">输出: [&quot;Shogun&quot;]</span><br><span class="line">解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。</span><br></pre></td></tr></table></figure></p><p>提示:</p><p>两个列表的长度范围都在 [1, 1000]内。<br>两个列表中的字符串的长度将在[1，30]的范围内。<br>下标从0开始，到列表的长度减1。<br>两个列表都没有重复的元素。</p><p>思路：考察哈希表，用空间换时间，用map建立第一个列表字符串和索引的映射，然后在第二个列表里面遍历查找最小索引。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRestaurant(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; data;</span><br><span class="line">        <span class="keyword">int</span> minVal = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;list1.size(); i++) &#123;</span><br><span class="line">            data.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(list1[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list2.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data.find(list2[i]) != data.end()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(data[list2[i]] + i &lt; minVal) &#123;</span><br><span class="line">                    minVal = data[list2[i]] + i;</span><br><span class="line">                    res.clear();</span><br><span class="line">                    res.push_back(list2[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[list2[i]] + i == minVal) &#123;</span><br><span class="line">                    res.push_back(list2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>598. 范围求和 II</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/598-%E8%8C%83%E5%9B%B4%E6%B1%82%E5%92%8C-II/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/598-%E8%8C%83%E5%9B%B4%E6%B1%82%E5%92%8C-II/</url>
      
        <content type="html"><![CDATA[<p>给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。</p><p>操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，含义是将所有符合 0 &lt;= i &lt; a 以及 0 &lt;= j &lt; b 的元素 M[i][j] 的值都增加 1。</p><p>在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">m = 3, n = 3</span><br><span class="line">operations = [[2,2],[3,3]]</span><br><span class="line">输出: 4</span><br><span class="line">解释: </span><br><span class="line">初始状态, M = </span><br><span class="line">[[0, 0, 0],</span><br><span class="line"> [0, 0, 0],</span><br><span class="line"> [0, 0, 0]]</span><br><span class="line"></span><br><span class="line">执行完操作 [2,2] 后, M = </span><br><span class="line">[[1, 1, 0],</span><br><span class="line"> [1, 1, 0],</span><br><span class="line"> [0, 0, 0]]</span><br><span class="line">执行完操作 [3,3] 后, M = </span><br><span class="line">[[2, 2, 1],</span><br><span class="line"> [2, 2, 1],</span><br><span class="line"> [1, 1, 1]]</span><br></pre></td></tr></table></figure></p><p>M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。<br>注意:</p><p>m 和 n 的范围是 [1,40000]。<br>a 的范围是 [1,m]，b 的范围是 [1,n]。<br>操作数目不超过 10000。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ops)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> op : ops) &#123;</span><br><span class="line">            m = min(m, op[<span class="number">0</span>]);</span><br><span class="line">            n = min(n, op[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>594. 最长和谐子序列</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/594-%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/594-%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。</p><p>现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,2,2,5,2,3,7]</span><br><span class="line">输出: 5</span><br><span class="line">原因: 最长的和谐数组是：[3,2,2,2,3].</span><br></pre></td></tr></table></figure></p><p>说明: 输入的数组长度最大不超过20,000.</p><p>思路：<br>题目要求最长和谐子序列的长度，实际上就是让你求数组里面大小相差为1，并且个数最多的那两个数的数量。考察了哈希表的思想。可以直接利用map的映射特性和自动排序特性，建立一个数和该数个数的映射，然后遍历map，求值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(), pre;</span><br><span class="line">        <span class="keyword">for</span>(;it != m.end(); it++) &#123;</span><br><span class="line">            pre = prev(it);</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;first == pre-&gt;first + <span class="number">1</span>) &#123;</span><br><span class="line">                res = max(res, it-&gt;second + pre-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>581. 最短无序连续子数组</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>你找到的子数组应是最短的，请输出它的长度。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure></p><p>说明 :</p><p>输入的数组长度范围在 [1, 10,000]。<br>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</p><p>法一：我觉得简单的写法还是用个辅助数组，也就是一个对原数组已进行排序的数组，然后分别从头尾往中间遍历找到第一个不匹配的位置<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; help = nums;</span><br><span class="line">        sort(help.begin(), help.end());</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.size() &amp;&amp; help[i] == nums[i]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; i &amp;&amp; help[j] == nums[j]) &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j - i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>法二：</p><p>要求无序连续子数组的长度，那么就需要确定该无序连续子数组的起始和结尾位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums[j], nums[j - <span class="number">1</span>]);</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(start == <span class="number">-1</span> || start &gt; j) &#123;</span><br><span class="line">                    start = j;</span><br><span class="line">                &#125;</span><br><span class="line">                 res = max(res, i - start + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>876. 链表的中间结点</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><p>给定链表的结点数介于 1 和 100 之间。</p><p>分析，求给定单链表的中间节点，用双指针思想，定义两个指针都指向头结点，一个指针每次走两步，一个每次走一步，当快指针到达最后结点，慢指针指向的就是中间结点<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* pa = head;</span><br><span class="line">        ListNode* pb = head;</span><br><span class="line">        <span class="keyword">while</span>(pa-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(pa-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                pa = pa-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>501. 二叉搜索树中的众数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p>假定 BST 有如下定义：</p><p>结点左子树中所含结点的值小于等于当前结点的值<br>结点右子树中所含结点的值大于等于当前结点的值<br>左子树和右子树都是二叉搜索树<br>例如：<br>给定 BST [1,null,2,2],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   2</span><br><span class="line">返回[2].</span><br></pre></td></tr></table></figure></p><p>提示：如果众数超过1个，不需考虑输出顺序</p><p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><p>思路：常规解法是直接遍历二叉树，用哈希表来计数，但是空间复杂度就要求O(n)<br>或者利用二叉搜索树的性质，进行中序遍历后的序列是有序序列，因此可以在中序遍历时求众数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMode(TreeNode* root) &#123;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        inorder(root, pre);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* node, TreeNode*&amp; pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(node-&gt;left, pre);</span><br><span class="line">        <span class="keyword">if</span>(pre) &#123;</span><br><span class="line">            cnt = (node-&gt;val == pre-&gt;val) ? cnt + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= mx) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; mx) &#123;</span><br><span class="line">                res.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            mx = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">        inorder(node-&gt;right, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>563. 二叉树的坡度</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/563-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/563-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树，计算整个树的坡度。</p><p>一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。</p><p>整个树的坡度就是其所有节点的坡度之和。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">         1</span><br><span class="line">       /   \</span><br><span class="line">      2     3</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">结点的坡度 2 : 0</span><br><span class="line">结点的坡度 3 : 0</span><br><span class="line">结点的坡度 1 : |2-3| = 1</span><br><span class="line">树的坡度 : 0 + 0 + 1 = 1</span><br></pre></td></tr></table></figure></p><p>注意:</p><p>任何子树的结点的和不会超过32位整数的范围。<br>坡度的值不会超过32位整数的范围。</p><p>用后序遍历，直接从叶结点开始计算左右子树和，直接进行坡度计算<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sumLeft = helper(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> sumRight = helper(root-&gt;right);</span><br><span class="line">        res += <span class="built_in">abs</span>(sumLeft - sumRight);</span><br><span class="line">        <span class="keyword">return</span> sumLeft + sumRight + root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>606. 根据二叉树创建字符串</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/606-%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/606-%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p><p>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: 二叉树: [1,2,3,4]</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">   /    </span><br><span class="line">  4     </span><br><span class="line"></span><br><span class="line">输出: &quot;1(2(4))(3)&quot;</span><br></pre></td></tr></table></figure></p><p>解释: 原本将是“1(2(4)())(3())”，<br>在你省略所有不必要的空括号对之后，<br>它将是“1(2(4))(3)”。<br>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: 二叉树: [1,2,3,null,4]</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">     \  </span><br><span class="line">      4 </span><br><span class="line"></span><br><span class="line">输出: &quot;1(2()(4))(3)&quot;</span><br></pre></td></tr></table></figure></p><p>解释: 和第一个示例相似，<br>除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。</p><p>思路：按照先序遍历根结点-左子树-右子树的顺序递归，在左子结点为空但右子结点不为空的时候递归加上”()”<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(t, res);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(res.begin() + <span class="number">1</span>, res.end() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* t, <span class="built_in">string</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="string">"("</span> + to_string(t-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;left == <span class="literal">NULL</span> &amp;&amp; t-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            res += <span class="string">"()"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(t-&gt;left, res);</span><br><span class="line">        helper(t-&gt;right, res);</span><br><span class="line">        res += <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1023 Have Fun with Numbers (20)（20 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1023-Have-Fun-with-Numbers-20-%EF%BC%8820-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1023-Have-Fun-with-Numbers-20-%EF%BC%8820-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again!</p><p>Now you are suppose to check if there are more numbers with this property. That is, double a given number with k digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.</p><p>Input Specification:</p><p>Each input file contains one test case. Each case contains one positive integer with no more than 20 digits.</p><p>Output Specification:</p><p>For each test case, first print in a line “Yes” if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or “No” if not. Then in the next line, print the doubled number.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1234567899</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">2469135798</span><br></pre></td></tr></table></figure></p><p>题目大意：<br>给一个长度不超过20位的整数，问这个整数的两倍后的数位是不是原整数数位的一个排列。</p><p>判断是不是原整数数位的一个排列可以开一个count数组，用来存放0~9中每个数字出现次数，对新整数中出现的每个数字都在相应位置减1，最后判断coun数组中元素的值是不是都是0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bign</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">21</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    bign() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span> ,<span class="keyword">sizeof</span>(d));</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">bign <span class="title">change</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    bign a;</span><br><span class="line">    a.len = str.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len; i++) &#123;</span><br><span class="line">        a.d[i] = str[a.len - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">bign <span class="title">multi</span><span class="params">(bign a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a.d[i] * b + carry;</span><br><span class="line">        c.d[c.len++] = temp % <span class="number">10</span>;</span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(carry != <span class="number">0</span>) &#123;</span><br><span class="line">        c.d[c.len++] = carry % <span class="number">10</span>;</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(bign a, bign b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.len != b.len) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len; i++) &#123;</span><br><span class="line">        count[a.d[i]]++;</span><br><span class="line">        count[b.d[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(count[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(bign a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, a.d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    getline(<span class="built_in">cin</span>, str);</span><br><span class="line">    bign a = change(str);</span><br><span class="line">    bign mul = multi(a, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(judge(a, mul)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print(mul);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1096 Consecutive Factors (20)（20 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1096-Consecutive-Factors-20-%EF%BC%8820-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1096-Consecutive-Factors-20-%EF%BC%8820-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Among all the factors of a positive integer N, there may exist several consecutive numbers. For example, 630 can be factored as 3<em>5</em>6*7, where 5, 6, and 7 are the three consecutive numbers. Now given any positive N, you are supposed to find the maximum number of consecutive factors, and list the smallest sequence of the consecutive factors.</p><p>Input Specification:</p><p>Each input file contains one test case, which gives the integer N (1&lt;N&lt;2^31^).</p><p>Output Specification:</p><p>For each test case, print in the first line the maximum number of consecutive factors. Then in the second line, print the smallest sequence of the consecutive factors in the format “factor[1]<em> factor[2]</em> …* factor[k]”, where the factors are listed in increasing order, and 1 is NOT included.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">630</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5*6*7</span><br></pre></td></tr></table></figure></p><p>题目大意：<br>给出一个正整数n，求一段连续的整数，使n能被这段连续整数的乘积整除，如果有多个方案，输出连续整数个数最多的方案；如果还有多种方案，输出第一个数最小的方案。<br>步骤：<br>1 由于n不会被除自己以外的大于根号n的整数整除，所以只需从2~根号n遍历连续整数的第一个，求此时n能被最多多少个连续整数的乘积整除，同时记录对应连续整数的第一个数和最多个数<br>2 如果遍历结束最长长度为0，那么答案就是n本身，否则输出相应结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    LL sqr = (LL)<span class="built_in">sqrt</span>(<span class="number">1.0</span> * n), first = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">2</span>; i &lt;= sqr; i++) &#123;</span><br><span class="line">        LL temp = <span class="number">1</span>, j = i;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            temp *= j;</span><br><span class="line">            <span class="keyword">if</span>(n % temp != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                first = i;</span><br><span class="line">                maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n%lld"</span>, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, maxLen);</span><br><span class="line">        <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; maxLen; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld"</span>, first + i);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; maxLen - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1015 Reversible Primes (20)（20 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1015-Reversible-Primes-20-%EF%BC%8820-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1015-Reversible-Primes-20-%EF%BC%8820-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>A reversible prime in any number system is a prime whose “reverse” in that number system is also a prime. For example in the decimal system 73 is a reversible prime because its reverse 37 is also a prime.</p><p>Now given any two positive integers N (&lt; 10^5^) and D (1 &lt; D &lt;= 10), you are supposed to tell if N is a reversible prime with radix D.</p><p>Input Specification:</p><p>The input file consists of several test cases. Each case occupies a line which contains two integers N and D. The input is finished by a negative N.</p><p>Output Specification:</p><p>For each test case, print in one line “Yes” if N is a reversible prime with radix D, or “No” if not.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">73 10</span><br><span class="line">23 2</span><br><span class="line">23 10</span><br><span class="line">-2</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure></p><p>题目大意：给出正整数n和进制radix，如果n是素数，且n在radix进制下反转后得到的整数也是素数，则输出Yes，否则，输出No</p><p>分析：<br>1先判断n是否为素数，不是素数直接输出No<br>2如果n是素数，将n转换为radix进制，判断该数是否素数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">111</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, radix;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;radix);</span><br><span class="line">        <span class="keyword">if</span>(isPrime(n) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">               d[len++] = n % radix;</span><br><span class="line">               n /= radix;</span><br><span class="line">            &#125; <span class="keyword">while</span>(n != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                n = n * radix + d[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isPrime(n) == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1049 Counting Ones (30)（30 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1049-Counting-Ones-30-%EF%BC%8830-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1049-Counting-Ones-30-%EF%BC%8830-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>The task is simple: given any positive integer N, you are supposed to count the total number of 1’s in the decimal form of the integers from 1 to N. For example, given N being 12, there are five 1’s in 1, 10, 11, and 12.</p><p>Input Specification:</p><p>Each input file contains one test case which gives the positive N (&lt;=2^30^).</p><p>Output Specification:</p><p>For each test case, print the number of 1’s in one line.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure></p><p>题目大意：<br>给出一个数字n，求1~n的所有数字里面出现1的个数</p><p>分析：一个个枚举计算肯定是超时的，这是个数学问题，需要寻找规律从特殊扩展到一般。<br>设当前处理至第k位，那么记left为第k位的高位所表示的数，now为第k位数，right为第k位的低位表示的数，分三种情况：</p><ul><li>若now == 0， ans += left * a;</li><li>now == 1 , ans += left * a + right + 1;</li><li>now == 2 , ans += (left + 1) * a;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, a = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left, right, now;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n / a != <span class="number">0</span>) &#123;</span><br><span class="line">        left = n / (a * <span class="number">10</span>);</span><br><span class="line">        now = n / a % <span class="number">10</span>;</span><br><span class="line">        right = n % a;</span><br><span class="line">        <span class="keyword">if</span>(now == <span class="number">0</span>) &#123;</span><br><span class="line">            ans += left * a;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(now == <span class="number">1</span>) &#123;</span><br><span class="line">            ans += left * a + right + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += (left + <span class="number">1</span>) * a;</span><br><span class="line">        &#125;</span><br><span class="line">        a *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1044 Shopping in Mars (25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1044-Shopping-in-Mars-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1044-Shopping-in-Mars-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Shopping in Mars is quite a different experience. The Mars people pay by chained diamonds. Each diamond has a value (in Mars dollars M\$). When making the payment, the chain can be cut at any position for only once and some of the diamonds are taken off the chain one by one. Once a diamond is off the chain, it cannot be taken back. For example, if we have a chain of 8 diamonds with values M\$3, 2, 1, 5, 4, 6, 8, 7, and we must pay M\$15. We may have 3 options:</p><ol><li>Cut the chain between 4 and 6, and take off the diamonds from the position 1 to 5 (with values 3+2+1+5+4=15).\</li></ol><p>Cut before 5 or after 6, and take off the diamonds from the position 4 to 6 (with values 5+4+6=15).\<br>Cut before 8, and take off the diamonds from the position 7 to 8 (with values 8+7=15).\<br>Now given the chain of diamond values and the amount that a customer has to pay, you are supposed to list all the paying options for the customer.</p><p>If it is impossible to pay the exact amount, you must suggest solutions with minimum lost.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line contains 2 numbers: N (&lt;=10^5^), the total number of diamonds on the chain, and M (&lt;=10^8^), the amount that the customer has to pay. Then the next line contains N positive numbers D~1~ … D~N~ (D~i~&lt;=10^3^ for all i=1, …, N) which are the values of the diamonds. All the numbers in a line are separated by a space.</p><p>Output Specification:</p><p>For each test case, print “i-j” in a line for each pair of i &lt;= j such that D~i~ + … + D~j~ = M. Note that if there are more than one solution, all the solutions must be printed in increasing order of i.</p><p>If there is no solution, output “i-j” for pairs of i &lt;= j such that D~i~ + … + D~j~ &gt; M with (D~i~ + … + D~j~ - M) minimized. Again all the solutions must be printed in increasing order of i.</p><p>It is guaranteed that the total value of diamonds is sufficient to pay the given amount.</p><p>Sample Input 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">16 15</span><br><span class="line">3 2 1 5 4 6 8 7 16 10 15 11 9 12 14 13</span><br></pre></td></tr></table></figure></p><p>Sample Output 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1-5</span><br><span class="line">4-6</span><br><span class="line">7-8</span><br><span class="line">11-11</span><br></pre></td></tr></table></figure></p><p>Sample Input 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 13</span><br><span class="line">2 4 5 7 9</span><br></pre></td></tr></table></figure></p><p>Sample Output 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2-4</span><br><span class="line">4-5</span><br></pre></td></tr></table></figure></p><p>题目大意：给出一个数字序列和一个数s，在数字序列里求出所有和值为s的连续子序列。如果没有，就输出所有和值大于s的子序列里面和值最接近s的子序列。<br>分析：用sum[i]表示a[1]到a[i]的和值，那么a[i]到a[j]的和值就是sum[j] - sum[i - 1].<br>因为给出的数均为正数，所以sum数组严格单调递增，所以可以二分。<br>根据sum[j] - sum[i - 1] = s，在sum数组的[i,n]范围内查找值为sum[i-1] + s的元素是否存在，若果存在，则对应的下标记为右端点j，如果不存在，找到第一个使和值超过s的右端点j</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="keyword">int</span> n, s, nears = <span class="number">100000010</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int upper_bound(int&amp; l, int&amp; r, int x) &#123;</span></span><br><span class="line"><span class="comment">    int mid;</span></span><br><span class="line"><span class="comment">    int left = l, right = r;</span></span><br><span class="line"><span class="comment">    while(left &lt; right) &#123;</span></span><br><span class="line"><span class="comment">        mid = (left + right) / 2;</span></span><br><span class="line"><span class="comment">        if(sum[mid] &gt; x) &#123;</span></span><br><span class="line"><span class="comment">            right = mid;</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            left = mid + 1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return left;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;s);</span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;sum[i]);</span><br><span class="line">        sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = upper_bound(sum + i, sum + n + <span class="number">1</span>, sum[i - <span class="number">1</span>] + s) - sum;</span><br><span class="line">        <span class="keyword">if</span>(sum[j - <span class="number">1</span>] - sum[i - <span class="number">1</span>] == s) &#123;</span><br><span class="line">            nears = s;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j &lt;= n &amp;&amp; sum[j] - sum[i - <span class="number">1</span>] &lt; nears) &#123;</span><br><span class="line">            nears = sum[j] - sum[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = upper_bound(sum + i, sum + n + <span class="number">1</span>, sum[i - <span class="number">1</span>] + nears) - sum;</span><br><span class="line">        <span class="keyword">if</span>(sum[j - <span class="number">1</span>] - sum[i - <span class="number">1</span>] == nears) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d-%d\n"</span>, i, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1010 Radix (25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1010-Radix-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1010-Radix-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is “yes”, if 6 is a decimal number and 110 is a binary number.</p><p>Now for any pair of positive integers N1 and N2, your task is to find the radix of one number while that of the other is given.</p><p>Input Specification:</p><p>Each input file contains one test case. Each case occupies a line which contains 4 positive integers:\ N1 N2 tag radix\ Here N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set {0-9, a-z} where 0-9 represent the decimal numbers 0-9, and a-z represent the decimal numbers 10-35. The last number “radix” is the radix of N1 if “tag” is 1, or of N2 if “tag” is 2.</p><p>Output Specification:</p><p>For each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print “Impossible”. If the solution is not unique, output the smallest possible radix.</p><p>Sample Input 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 110 1 10</span><br></pre></td></tr></table></figure></p><p>Sample Output 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p><p>Sample Input 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 ab 1 2</span><br></pre></td></tr></table></figure></p><p>Sample Output 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure></p><p>题目大意：输入4个整数n1，n2，tag，radix，tag为1表示n1为radix进制数，tag为2表示n2为radix进制数。求n1和n2中未知进制的那个数是否存在，并满足某个进制时和另一个数在10进制下相等。若存在，输出满足条件的最小进制；否则，输出Impossible</p><p>分析<br>1：将已确定进制的数放在n1，未确定进制的数放在n2</p><p>2：二分查找，二分n2的进制，将n2从该进制转化为10进制，令其与n1的10进制比较：如果大于n1的十进制，则往左子区间二分；如果小于n2的十进制，则往右子区间二分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL inf = (<span class="number">1L</span>L &lt;&lt; <span class="number">63</span>) - <span class="number">1</span>;</span><br><span class="line">LL m[<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'0'</span>; c &lt;= <span class="string">'9'</span>; c++) &#123;</span><br><span class="line">        m[c] = c - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">        m[c] = c - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">convertTo10</span><span class="params">(<span class="keyword">char</span> a[], LL radix, LL t)</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ans = ans * radix + m[a[i]];</span><br><span class="line">        <span class="keyword">if</span>(ans &lt; <span class="number">0</span> || ans &gt; t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">char</span> n2[], LL radix, LL t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(n2);</span><br><span class="line">    LL num = convertTo10(n2, radix, t);</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t &gt; num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(t == num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">binarySearch</span><span class="params">(<span class="keyword">char</span> n2[], LL left, LL right, LL t)</span> </span>&#123;</span><br><span class="line">    LL mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = cmp(n2, mid, t);</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">-1</span>) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLargest</span><span class="params">(<span class="keyword">char</span> n2[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(n2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m[n2[i]] &gt; ans) &#123;</span><br><span class="line">            ans = m[n2[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> n1[<span class="number">20</span>], n2[<span class="number">20</span>], temp[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> tag, radix;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s %s %d %d"</span>, n1, n2, &amp;tag, &amp;radix);</span><br><span class="line">    <span class="keyword">if</span>(tag == <span class="number">2</span>) &#123;</span><br><span class="line">        swap(n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">    LL t = convertTo10(n1, radix, inf);</span><br><span class="line">    LL low = findLargest(n2);</span><br><span class="line">    LL high = max(low, t) + <span class="number">1</span>;</span><br><span class="line">    LL ans = binarySearch(n2, low, high, t);</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1038 Recover the Smallest Number (30)（30 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1038-Recover-the-Smallest-Number-30-%EF%BC%8830-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1038-Recover-the-Smallest-Number-30-%EF%BC%8830-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Given a collection of number segments, you are supposed to recover the smallest number from them. For example, given {32, 321, 3214, 0229, 87}, we can recover many numbers such like 32-321-3214-0229-87 or 0229-32-87-321-3214 with respect to different orders of combinations of these segments, and the smallest number is 0229-321-3214-32-87.</p><p>Input Specification:</p><p>Each input file contains one test case. Each case gives a positive integer N (&lt;=10000) followed by N number segments. Each segment contains a non-negative integer of no more than 8 digits. All the numbers in a line are separated by a space.</p><p>Output Specification:</p><p>For each test case, print the smallest number in one line. Do not output leading zeros.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 32 321 3214 0229 87</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22932132143287</span><br></pre></td></tr></table></figure></p><p>题目大意：给出若干数字串，将它们按某个顺序拼接后输出，要求生成的数最小。</p><p>贪心策略：<br>对数字串s1和s2，如果s1+s2 &lt; s2+s1,那么把s1放在s2的前面，否则，把s2放在s1的前面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="built_in">string</span> str[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(str, str + n, cmp);</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans += str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ans.size() != <span class="number">0</span> &amp;&amp; ans[<span class="number">0</span>] == <span class="string">'0'</span>) &#123;</span><br><span class="line">        ans.erase(ans.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1067 Sort with Swap(0,*) (25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1067-Sort-with-Swap-0-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1067-Sort-with-Swap-0-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Given any permutation of the numbers {0, 1, 2,…, N-1}, it is easy to sort them in increasing order. But what if Swap(0, * ) is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way:</p><p>Swap(0, 1) =&gt; {4, 1, 2, 0, 3}\ Swap(0, 3) =&gt; {4, 1, 2, 3, 0}\ Swap(0, 4) =&gt; {0, 1, 2, 3, 4}</p><p>Now you are asked to find the minimum number of swaps need to sort the given permutation of the first N nonnegative integers.</p><p>Input Specification:</p><p>Each input file contains one test case, which gives a positive N (&lt;=10^5^) followed by a permutation sequence of {0, 1, …, N-1}. All the numbers in a line are separated by a space.</p><p>Output Specification:</p><p>For each case, simply print in a line the minimum number of swaps need to sort the given permutation.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 3 5 7 2 6 4 9 0 8 1</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure></p><p>题目大意：给出一个0~n-1的序列，要求通过两两交换的方式将其变为递增序列，且只能是0与其他数字交换，求最小交换次数</p><p>贪心策略：<br>如果0在本位上就先寻找一个当前不在本位上的数字与0交换，只要0不在本位，就将0所在位置的数的当前位置和0的位置交换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> pos[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> left = n - <span class="number">1</span>, num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">        pos[num] = i;</span><br><span class="line">        <span class="keyword">if</span>(num == i &amp;&amp; num != <span class="number">0</span>) &#123;</span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pos[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(k &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span>(pos[k] != k) &#123;</span><br><span class="line">                    swap(pos[<span class="number">0</span>], pos[k]);</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(pos[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        swap(pos[<span class="number">0</span>], pos[pos[<span class="number">0</span>]]);</span><br><span class="line">        ans++;</span><br><span class="line">        left--;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1033 To Fill or Not to Fill (25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1033-To-Fill-or-Not-to-Fill-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1033-To-Fill-or-Not-to-Fill-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line contains 4 positive numbers: C~max~ (&lt;= 100), the maximum capacity of the tank; D (&lt;=30000), the distance between Hangzhou and the destination city; D~avg~ (&lt;=20), the average distance per unit gas that the car can run; and N (&lt;= 500), the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: P~i~, the unit gas price, and D~i~ (&lt;=D), the distance between this station and Hangzhou, for i=1,…N. All the numbers in a line are separated by a space.</p><p>Output Specification:</p><p>For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print “The maximum travel distance = X” where X is the maximum possible distance the car can run, accurate up to 2 decimal places.</p><p>Sample Input 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">50 1300 12 8</span><br><span class="line">6.00 1250</span><br><span class="line">7.00 600</span><br><span class="line">7.00 150</span><br><span class="line">7.10 0</span><br><span class="line">7.20 200</span><br><span class="line">7.50 400</span><br><span class="line">7.30 1000</span><br><span class="line">6.85 300</span><br></pre></td></tr></table></figure></p><p>Sample Output 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">749.17</span><br></pre></td></tr></table></figure></p><p>Sample Input 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">50 1300 12 2</span><br><span class="line">7.10 0</span><br><span class="line">7.00 600</span><br></pre></td></tr></table></figure></p><p>Sample Output 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The maximum travel distance = 1200.00</span><br></pre></td></tr></table></figure></p><p>题目大意：给定n个加油站的单位油价和离起点的距离，汽车初始时刻处于起点位置，油箱为空，在不超过油箱容量的前提下可以在任意加油站购买任意量的汽油，求从起点到终点的最小花费。如果到不了终点，输出最终的行驶距离。</p><p>分析：<br>1将终点视为单位油价为0，离起点距离为d的加油站，然后将所有加油站按离起点的距离从小到大排序。排序后，如果如果离起点最近的加油站距离不是0，则汽车无法出发，直接输出结果<br>2如何选择下一个车站的策略：</p><ul><li>优先前往更低油价的加油站</li><li>在没有更低油价的加油站时前往油价尽可能低的加油站</li><li>在没有加油站能够到达时结束</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">station</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> price, dis;</span><br><span class="line">&#125;st[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(station a, station b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dis &lt; b.dis;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> maxc, d, davg;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%d"</span>, &amp;maxc, &amp;d, &amp;davg, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;st[i].price, &amp;st[i].dis);</span><br><span class="line">    &#125;</span><br><span class="line">    st[n].price = <span class="number">0</span>;</span><br><span class="line">    st[n].dis = d;</span><br><span class="line">    sort(st, st + n, cmp);</span><br><span class="line">    <span class="keyword">if</span>(st[<span class="number">0</span>].dis != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The maximum travel distance = 0.00\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>, nowTank = <span class="number">0</span>, maxm = maxc * davg;</span><br><span class="line">        <span class="keyword">while</span>(now &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">double</span> minPrice = inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = now + <span class="number">1</span>; i &lt;= n &amp;&amp; st[i].dis - st[now].dis &lt;= maxm; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(st[i].price &lt; minPrice) &#123;</span><br><span class="line">                    minPrice = st[i].price;</span><br><span class="line">                    k = i;</span><br><span class="line">                    <span class="keyword">if</span>(minPrice &lt; st[now].price) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">double</span> need = (st[k].dis - st[now].dis) / davg;</span><br><span class="line">            <span class="keyword">if</span>(minPrice &lt; st[now].price) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nowTank &lt; need) &#123;</span><br><span class="line">                    ans += (need - nowTank) * st[now].price;</span><br><span class="line">                    nowTank = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nowTank -= need;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += (maxc - nowTank) * st[now].price;</span><br><span class="line">                nowTank = maxc - need;</span><br><span class="line">            &#125;</span><br><span class="line">            now = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now == n) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, ans);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"The maximum travel distance = %.2f\n"</span>, st[now].dis + maxm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>543. 二叉树的直径</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p><p>示例 :<br>给定二叉树<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br><span class="line">       / \     </span><br><span class="line">      4   5    </span><br><span class="line">返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</span><br></pre></td></tr></table></figure></p><p>注意：两结点之间的路径长度是以它们之间边的数目表示。<br>给定一个二叉树，求该二叉树中两点之间的最远距离，这个最远距离就是根结点的左右两个子树的的深度之和再加上1。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        maxDepth(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* node, <span class="keyword">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = maxDepth(node-&gt;left, res);</span><br><span class="line">        <span class="keyword">int</span> right = maxDepth(node-&gt;right, res);</span><br><span class="line">        res = max(res, left + right);</span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>641. Design Circular Deque</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/641-Design-Circular-Deque/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/641-Design-Circular-Deque/</url>
      
        <content type="html"><![CDATA[<p>Design your implementation of the circular double-ended queue (deque).<br>Your implementation should support following operations:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MyCircularDeque(k): Constructor, set the size of the deque to be k.</span><br><span class="line">insertFront(): Adds an item at the front of Deque. Return true if the operation is successful.</span><br><span class="line">insertLast(): Adds an item at the rear of Deque. Return true if the operation is successful.</span><br><span class="line">deleteFront(): Deletes an item from the front of Deque. Return true if the operation is successful.</span><br><span class="line">deleteLast(): Deletes an item from the rear of Deque. Return true if the operation is successful.</span><br><span class="line">getFront(): Gets the front item from the Deque. If the deque is empty, return -1.</span><br><span class="line">getRear(): Gets the last item from Deque. If the deque is empty, return -1.</span><br><span class="line">isEmpty(): Checks whether Deque is empty or not. </span><br><span class="line">isFull(): Checks whether Deque is full or not.</span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3</span><br><span class="line">circularDeque.insertLast(1);// return true</span><br><span class="line">circularDeque.insertLast(2);// return true</span><br><span class="line">circularDeque.insertFront(3);// return true</span><br><span class="line">circularDeque.insertFront(4);// return false, the queue is full</span><br><span class="line">circularDeque.getRear();  // return 32</span><br><span class="line">circularDeque.isFull();// return true</span><br><span class="line">circularDeque.deleteLast();// return true</span><br><span class="line">circularDeque.insertFront(4);// return true</span><br><span class="line">circularDeque.getFront();// return 4</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>All values will be in the range of [1, 1000].<br>The number of operations will be in the range of [1, 1000].<br>Please do not use the built-in Deque library.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularDeque</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line">    MyCircularDeque(<span class="keyword">int</span> k) &#123;</span><br><span class="line">        size = k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insertFront</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.insert(q.begin(), value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insertLast</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.push_back(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deleteFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.erase(q.begin());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deleteLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.size() == size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularDeque object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularDeque obj = new MyCircularDeque(k);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj.insertFront(value);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.insertLast(value);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj.deleteFront();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj.deleteLast();</span></span><br><span class="line"><span class="comment"> * int param_5 = obj.getFront();</span></span><br><span class="line"><span class="comment"> * int param_6 = obj.getRear();</span></span><br><span class="line"><span class="comment"> * bool param_7 = obj.isEmpty();</span></span><br><span class="line"><span class="comment"> * bool param_8 = obj.isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>622. 设计循环队列</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/622-%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/622-%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。<br>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。<br>你的实现应该支持如下操作：</p><p>MyCircularQueue(k): 构造器，设置队列长度为 k 。<br>Front: 从队首获取元素。如果队列为空，返回 -1 。<br>Rear: 获取队尾元素。如果队列为空，返回 -1 。<br>enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。<br>deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。<br>isEmpty(): 检查循环队列是否为空。<br>isFull(): 检查循环队列是否已满。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MyCircularQueue circularQueue = new MycircularQueue(3); // 设置长度为3</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(1);  // 返回true</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(2);  // 返回true</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(3);  // 返回true</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(4);  // 返回false,队列已满</span><br><span class="line"></span><br><span class="line">circularQueue.Rear();  // 返回3</span><br><span class="line"></span><br><span class="line">circularQueue.isFull();  // 返回true</span><br><span class="line"></span><br><span class="line">circularQueue.deQueue();  // 返回true</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(4);  // 返回true</span><br><span class="line"></span><br><span class="line">circularQueue.Rear();  // 返回4</span><br></pre></td></tr></table></figure></p><p>提示：</p><p>所有的值都在 1 至 1000 的范围内；<br>操作数将在 1 至 1000 的范围内；<br>请不要使用内置的队列库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">    MyCircularQueue(<span class="keyword">int</span> k) &#123;</span><br><span class="line">        size = k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.push_back(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.erase(q.begin());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q.front();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q.back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.size() == size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularQueue obj = new MyCircularQueue(k);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj.enQueue(value);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.deQueue();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.Front();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.Rear();</span></span><br><span class="line"><span class="comment"> * bool param_5 = obj.isEmpty();</span></span><br><span class="line"><span class="comment"> * bool param_6 = obj.isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>559. N叉树的最大深度</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/559-N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/559-N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>给定一个N叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>例如，给定一个 3叉树 :</p><p><img src="https://leetcode-cn.com/static/images/problemset/NaryTreeExample.png" alt="alt"></p><p>我们应返回其最大深度，3。</p><p>说明:</p><p>树的深度不会超过 1000。<br>树的节点总不会超过 5000。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> child : root-&gt;children) &#123;</span><br><span class="line">            depth = max(depth, maxDepth(child));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>590. N叉树的后序遍历</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>给定一个N叉树，返回其节点值的后序遍历。</p><p>例如，给定一个 3叉树 :</p><p><img src="https://leetcode-cn.com/static/images/problemset/NaryTreeExample.png" alt="alt"></p><p>返回其后序遍历: [5,6,3,2,4,1].</p><p>说明: 递归法很简单，你可以使用迭代法完成此题吗?</p><p>递归法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder(Node* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : root-&gt;children)</span><br><span class="line">        postorder(n);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>迭代法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder(Node* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">            Node* node = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> n : node-&gt;children) &#123;</span><br><span class="line">                s.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>589. N叉树的前序遍历</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>给定一个N叉树，返回其节点值的前序遍历。</p><p>例如，给定一个 3叉树 :</p><p> <img src="https://leetcode-cn.com/static/images/problemset/NaryTreeExample.png" alt="alt"></p><p>返回其前序遍历: [1,3,5,6,2,4]。</p><p>说明: 递归法很简单，你可以使用迭代法完成此题吗?</p><p>递归法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorder(Node* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        preorder(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">private: </span><br><span class="line">    void preorder(Node* root, vector&lt;int&gt;&amp; res) &#123;</span><br><span class="line">        if(root == NULL) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        for(const auto&amp; n : root-&gt;children)</span><br><span class="line">        preorder(n, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>迭代法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorder(Node* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if(root == NULL) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;Node*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        while(!s.empty()) &#123;</span><br><span class="line">            Node* node = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            for(auto it = node-&gt;children.rbegin(); it != node-&gt;children.rend(); it++) &#123;</span><br><span class="line">                s.push(*it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>429. N叉树的层序遍历</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>给定一个N叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。</p><p>例如，给定一个 3叉树 :</p><p><img src="https://leetcode-cn.com/static/images/problemset/NaryTreeExample.png" alt="alt"></p><p>返回其层序遍历:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">     [3,2,4],</span><br><span class="line">     [5,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>树的深度不会超过 1000。<br>树的节点总数不会超过 5000。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val = NULL;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node* &gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                Node* t = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                temp.push_back(t-&gt;val);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t-&gt;children.size(); j++) &#123;</span><br><span class="line">                    q.push(t-&gt;children[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1048 Find Coins (25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1048-Find-Coins-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1048-Find-Coins-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she could only use exactly two coins to pay the exact amount. Since she has as many as 10^5^ coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find two coins to pay for it.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line contains 2 positive numbers: N (&lt;=10^5^, the total number of coins) and M(&lt;=10^3^, the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers no more than 500. All the numbers in a line are separated by a space.</p><p>Output Specification:</p><p>For each test case, print in one line the two face values V~1~ and V~2~ (separated by a space) such that V~1~ + V~2~ = M and V~1~ &lt;= V~2~. If such a solution is not unique, output the one with the smallest V~1~. If there is no solution, output “No Solution” instead.</p><p>Sample Input 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 15</span><br><span class="line">1 2 8 7 2 4 11 15</span><br></pre></td></tr></table></figure></p><p>Sample Output 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 11</span><br></pre></td></tr></table></figure></p><p>Sample Input 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7 14</span><br><span class="line">1 8 7 2 4 11 15</span><br></pre></td></tr></table></figure></p><p>Sample Output 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No Solution</span><br></pre></td></tr></table></figure></p><p>题目大意：给出n个正整数和一个正整数m，问n个数字里面是否存在一堆数字a和b（a&lt;=b）,使得a+b = m。如果有多对，输出a最小的那一对。<br>分析：两数之和的问题，考虑哈希思想，当然也可以用二分查找或two pointers做<br>哈希解法：<br>1 用int型的哈希数组存放每个数字出现的个数<br>2 枚举1~m，如果i和m-i都在散列数组里面，并且i == m - i时数字i的个数大于等于2，那么就表示找到了符合的一对数字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> HashTable[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">        HashTable[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(HashTable[i] &amp;&amp; HashTable[m - i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == m - i &amp;&amp; HashTable[i] &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, m - i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No Solution\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1095 Cars on Campus (30)（30 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1095-Cars-on-Campus-30-%EF%BC%8830-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1095-Cars-on-Campus-30-%EF%BC%8830-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Zhejiang University has 6 campuses and a lot of gates. From each gate we can collect the in/out times and the plate numbers of the cars crossing the gate. Now with all the information available, you are supposed to tell, at any specific time point, the number of cars parking on campus, and at the end of the day find the cars that have parked for the longest time period.</p><p>Input Specification:</p><p>Each input file contains one test case. Each case starts with two positive integers N (&lt;= 10000), the number of records, and K (&lt;= 80000) the number of queries. Then N lines follow, each gives a record in the format</p><p>plate_number hh:mm:ss status</p><p>where plate_number is a string of 7 English capital letters or 1-digit numbers; hh:mm:ss represents the time point in a day by hour:minute:second, with the earliest time being 00:00:00 and the latest 23:59:59; and status is either in or out.</p><p>Note that all times will be within a single day. Each “in” record is paired with the chronologically next record for the same car provided it is an “out” record. Any “in” records that are not paired with an “out” record are ignored, as are “out” records not paired with an “in” record. It is guaranteed that at least one car is well paired in the input, and no car is both “in” and “out” at the same moment. Times are recorded using a 24-hour clock.</p><p>Then K lines of queries follow, each gives a time point in the format hh:mm:ss. Note: the queries are given in ascending order of the times.</p><p>Output Specification:</p><p>For each query, output in a line the total number of cars parking on campus. The last line of output is supposed to give the plate number of the car that has parked for the longest time period, and the corresponding time length. If such a car is not unique, then output all of their plate numbers in a line in alphabetical order, separated by a space.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">16 7</span><br><span class="line">JH007BD 18:00:01 in</span><br><span class="line">ZD00001 11:30:08 out</span><br><span class="line">DB8888A 13:00:00 out</span><br><span class="line">ZA3Q625 23:59:50 out</span><br><span class="line">ZA133CH 10:23:00 in</span><br><span class="line">ZD00001 04:09:59 in</span><br><span class="line">JH007BD 05:09:59 in</span><br><span class="line">ZA3Q625 11:42:01 out</span><br><span class="line">JH007BD 05:10:33 in</span><br><span class="line">ZA3Q625 06:30:50 in</span><br><span class="line">JH007BD 12:23:42 out</span><br><span class="line">ZA3Q625 23:55:00 in</span><br><span class="line">JH007BD 12:24:23 out</span><br><span class="line">ZA133CH 17:11:22 out</span><br><span class="line">JH007BD 18:07:01 out</span><br><span class="line">DB8888A 06:30:50 in</span><br><span class="line">05:10:00</span><br><span class="line">06:30:50</span><br><span class="line">11:00:00</span><br><span class="line">12:23:42</span><br><span class="line">14:00:00</span><br><span class="line">18:00:00</span><br><span class="line">23:59:00</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">JH007BD ZD00001 07:20:09</span><br></pre></td></tr></table></figure></p><p>题目大意：给出n条记录，每条记录给出一辆车的车牌号，当前时刻，出入校门情况。然后给出k个查询，每个查询给出一个时刻，输出在这个时刻校园内的车辆数。<br>查询完毕后输出在学校里停留时间最长的车牌号，可以有多个。</p><p>思路：</p><ol><li>定义车辆结构体，记录单条记录的信息。定义<br>map&lt; string,int&gt; parkTime ,记录每辆车在校园内停留总时长</li><li>将所有记录存放到数组里，并先按车牌号从小到大排序，若车牌号相同，按时间值从小到大排序</li><li>遍历所有记录，查找有效值存入valid数组</li><li>将valid数组按时间从小到大排序，并进行查询</li><li>遍历parkTime，输出停留时间最长的车牌号</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">char</span> status[<span class="number">4</span>];</span><br><span class="line">&#125;all[maxn], valid[maxn];</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; parkTime;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timeToint</span><span class="params">(<span class="keyword">int</span> hh, <span class="keyword">int</span> mm, <span class="keyword">int</span> ss)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hh * <span class="number">3600</span> + mm * <span class="number">60</span> + ss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpByIdandTime</span><span class="params">(Car a, Car b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a.id, b.id)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.id, b.id) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.time &lt; b.time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpByTime</span><span class="params">(Car a, Car b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.time &lt; b.time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, hh, mm, ss;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %d:%d:%d %s"</span>, all[i].id, &amp;hh, &amp;mm, &amp;ss, all[i].status);</span><br><span class="line">        all[i].time = timeToint(hh, mm, ss);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(all, all + n, cmpByIdandTime);</span><br><span class="line">    <span class="keyword">int</span> maxTime = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(all[i].id, all[i+<span class="number">1</span>].id) &amp;&amp; !<span class="built_in">strcmp</span>(all[i].status, <span class="string">"in"</span>) &amp;&amp; !<span class="built_in">strcmp</span>(all[i + <span class="number">1</span>].status, <span class="string">"out"</span>)) &#123;</span><br><span class="line">            valid[num++] = all[i];</span><br><span class="line">            valid[num++] = all[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> inTime = all[i + <span class="number">1</span>].time - all[i].time;</span><br><span class="line">            <span class="keyword">if</span>(parkTime.count(all[i].id) == <span class="number">0</span>) &#123;</span><br><span class="line">                parkTime[all[i].id] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            parkTime[all[i].id] += inTime;</span><br><span class="line">            maxTime = max(maxTime, parkTime[all[i].id]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(valid, valid + num, cmpByTime);</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>, numCar = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d"</span>, &amp;hh, &amp;mm, &amp;ss);</span><br><span class="line">        <span class="keyword">int</span> time = timeToint(hh, mm, ss);</span><br><span class="line">        <span class="keyword">while</span>(now &lt; num &amp;&amp; valid[now].time &lt;= time) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(valid[now].status, <span class="string">"in"</span>)) &#123;</span><br><span class="line">                numCar++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                numCar--;</span><br><span class="line">            &#125;</span><br><span class="line">            now++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,numCar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it = parkTime.begin(); it != parkTime.end(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;second == maxTime) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s "</span>, it-&gt;first.c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d\n"</span>,maxTime / <span class="number">3600</span>, maxTime % <span class="number">3600</span> / <span class="number">60</span>, maxTime % <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1080 Graduate Admission (30)（30 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1080-Graduate-Admission-30-%EF%BC%8830-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1080-Graduate-Admission-30-%EF%BC%8830-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>It is said that in 2013, there were about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure.</p><p>Each applicant will have to provide two grades: the national entrance exam grade G~E~, and the interview grade G~I~. The final grade of an applicant is (G~E~ + G~I~) / 2. The admission rules are:</p><p>The applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list.<br>If there is a tied final grade, the applicants will be ranked according to their national entrance exam grade G~E~. If still tied, their ranks must be the same.<br>Each applicant may have K choices and the admission will be done according to his/her choices: if according to the rank list, it is one’s turn to be admitted; and if the quota of one’s most preferred shcool is not exceeded, then one will be admitted to this school, or one’s other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected.<br>If there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, even if its quota will be exceeded.<br>Input Specification:</p><p>Each input file contains one test case. Each case starts with a line containing three positive integers: N (&lt;=40,000), the total number of applicants; M (&lt;=100), the total number of graduate schools; and K (&lt;=5), the number of choices an applicant may have.</p><p>In the next line, separated by a space, there are M positive integers. The i-th integer is the quota of the i-th graduate school respectively.</p><p>Then N lines follow, each contains 2+K integers separated by a space. The first 2 integers are the applicant’s G~E~ and G~I~, respectively. The next K integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to M-1, and the applicants are numbered from 0 to N-1.</p><p>Output Specification:</p><p>For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants’ numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">11 6 3</span><br><span class="line">2 1 2 2 2 3</span><br><span class="line">100 100 0 1 2</span><br><span class="line">60 60 2 3 5</span><br><span class="line">100 90 0 3 4</span><br><span class="line">90 100 1 2 0</span><br><span class="line">90 90 5 1 3</span><br><span class="line">80 90 1 0 2</span><br><span class="line">80 80 0 1 2</span><br><span class="line">80 80 0 1 2</span><br><span class="line">80 70 1 3 2</span><br><span class="line">70 80 1 2 3</span><br><span class="line">100 100 0 2 4</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 10</span><br><span class="line">3</span><br><span class="line">5 6 7</span><br><span class="line">2 8</span><br><span class="line"></span><br><span class="line">1 4</span><br></pre></td></tr></table></figure></p><p>题目大意：要求模拟学校录取招生的过程，按从小到大输出每个学校录取的考生编号</p><p>思路：</p><ol><li>分别定义学生和学校结构体存放对应信息</li><li>对读入的所有考生进行排序，并按规则计算出各考生的排名</li><li>对每个考生的每个志愿学校，如果当前志愿学校的招生人数未达到该校招生人数总额度或该校上一个录取考生的排名与该考生排名相同，则照样可以被录取。</li><li>对每个学校将其按考生编号从小到大排序，并按顺序输出录取考生的编号。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">40010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> GE, GI, sum;</span><br><span class="line">    <span class="keyword">int</span> r, stuID;</span><br><span class="line">    <span class="keyword">int</span> cho[<span class="number">6</span>];</span><br><span class="line">&#125;stu[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">School</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> quota;</span><br><span class="line">    <span class="keyword">int</span> stuNum;</span><br><span class="line">    <span class="keyword">int</span> id[maxn];</span><br><span class="line">    <span class="keyword">int</span> lastAdmit;</span><br><span class="line">&#125;sch[<span class="number">111</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpStu</span><span class="params">(Student a, Student b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.sum != b.sum) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.sum &gt; b.sum;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> a.GE &gt; b.GE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpId</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stu[a].stuID &lt; stu[b].stuID;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;sch[i].quota);</span><br><span class="line">        sch[i].stuNum = <span class="number">0</span>;</span><br><span class="line">        sch[i].lastAdmit = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        stu[i].stuID = i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;stu[i].GE, &amp;stu[i].GI);</span><br><span class="line">        stu[i].sum = stu[i].GE + stu[i].GI;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;stu[i].cho[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(stu, stu + n, cmpStu);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; stu[i].sum == stu[i - <span class="number">1</span>].sum &amp;&amp; stu[i].GE == stu[i - <span class="number">1</span>].GE) &#123;</span><br><span class="line">            stu[i].r = stu[i - <span class="number">1</span>].r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stu[i].r = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> choice = stu[i].cho[j];</span><br><span class="line">            <span class="keyword">int</span> num = sch[choice].stuNum;</span><br><span class="line">            <span class="keyword">int</span> last = sch[choice].lastAdmit;</span><br><span class="line">            <span class="keyword">if</span>(num &lt; sch[choice].quota || (last != <span class="number">-1</span> &amp;&amp; stu[i].r == stu[last].r)) &#123;</span><br><span class="line">                sch[choice].id[num] = i;</span><br><span class="line">                sch[choice].lastAdmit = i;</span><br><span class="line">                sch[choice].stuNum++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sch[i].stuNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sort(sch[i].id, sch[i].id + sch[i].stuNum, cmpId);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sch[i].stuNum; j++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, stu[sch[i].id[j]].stuID);</span><br><span class="line">                <span class="keyword">if</span>(j &lt; sch[i].stuNum - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>872. 叶子相似的树</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/872-%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/872-%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>考虑一个二叉树的所有叶子。这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。</p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png" alt="alt"></p><p>举个例子，给定一个如上图所示的树，其叶值序列为 (6, 7, 4, 9, 8) 。</p><p>如果两个二叉树的叶值序列相同，我们就认为它们是 叶相似的。</p><p>如果给定的两个头结点分别为 root1 和 root2 的树是叶相似的，返回 true；否则返回 false 。</p><p>提示：</p><p>给定的两个树会有 1 到 100 个结点。</p><p>分析，直接递归遍历，将两颗二叉树的叶结点序列分别存放在两个数组，然后比较两个数组是否相等即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getChildTree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            v.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            getChildTree(v, root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            getChildTree(v, root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">leafSimilar</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a,b;</span><br><span class="line">        a = getChildTree(a, root1);</span><br><span class="line">        b = getChildTree(b, root2);</span><br><span class="line">        <span class="keyword">if</span>(a.size() != b.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i] != b[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>541. 反转字符串 II</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-II/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-II/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure></p><p>要求:</p><p>该字符串只包含小写的英文字母。<br>给定字符串的长度和 k 在[1, 10000]范围内。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseStr</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> cnt = n / k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i * k + k &lt; n) &#123;</span><br><span class="line">                    reverse(s.begin() + i * k, s.begin() + i * k + k);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reverse(s.begin() + i * k, s.end());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>538. 把二叉搜索树转换为累加树</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: 二叉搜索树:</span><br><span class="line">              5</span><br><span class="line">            /   \</span><br><span class="line">           2     13</span><br><span class="line"></span><br><span class="line">输出: 转换为累加树:</span><br><span class="line">             18</span><br><span class="line">            /   \</span><br><span class="line">          20     13</span><br></pre></td></tr></table></figure></p><p>分析：利用二叉搜索树的性质直接进行后序遍历累加<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        convert(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        convert(cur-&gt;right);</span><br><span class="line">        cur-&gt;val += sum;</span><br><span class="line">        sum = cur-&gt;val;</span><br><span class="line">        convert(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>530. 二叉搜索树的最小绝对差</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</url>
      
        <content type="html"><![CDATA[<p>给定一个所有节点为非负值的二叉搜索树，求树中任意两节点的差的绝对值的最小值。</p><p>示例 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    /</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p>解释:<br>最小绝对差为1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。<br>注意: 树中至少有2个节点。</p><p>分析：二叉搜索树的中序遍历为升序序列，因此问题就转化为这个生序序列相邻两个值的差的最小值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX, pre = <span class="number">-1</span>;</span><br><span class="line">        inorder(root, res, pre);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; res, <span class="keyword">int</span>&amp; pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root-&gt;left, res, pre);</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="number">-1</span>) &#123;</span><br><span class="line">        res = min(res, root-&gt;val - pre);</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root-&gt;val;</span><br><span class="line">    inorder(root-&gt;right, res, pre);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>521. 最长特殊序列 Ⅰ</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/521-%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97-%E2%85%A0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/521-%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97-%E2%85%A0/</url>
      
        <content type="html"><![CDATA[<p>给定两个字符串，你需要从这两个字符串中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。</p><p>子序列可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。</p><p>输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。</p><p>示例 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aba&quot;, &quot;cdc&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解析: 最长特殊序列可为 &quot;aba&quot; (或 &quot;cdc&quot;)</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>两个字符串长度均小于100。<br>字符串中的字符仅含有 ‘a’~’z’。</p><p>这道题不能想的太复杂，只需要按3种情况讨论下就行。</p><ol><li>两个字符串相等，显然不存在，返回-1</li><li>两个字符串长度相同但不相等，直接返回其长度就行</li><li>两个字符串长度不相等，那么返回更长的那个。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLUSlength</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lena = a.size();</span><br><span class="line">        <span class="keyword">int</span> lenb = b.size();</span><br><span class="line">        <span class="keyword">if</span>(lena == lenb) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; lena &amp;&amp; j &lt; lenb &amp;&amp; a[i] == b[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; lena || j &lt; lenb) &#123;</span><br><span class="line">                <span class="keyword">return</span> lena;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> max(lena, lenb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>506. 相对名次</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/506-%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/506-%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<p>给出 N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”（”Gold Medal”, “Silver Medal”, “Bronze Medal”）。</p><p>(注：分数越高的选手，排名越靠前。)</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [5, 4, 3, 2, 1]</span><br><span class="line">输出: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]</span><br></pre></td></tr></table></figure></p><p>解释: 前三名运动员的成绩为前三高的，因此将会分别被授予 “金牌”，“银牌”和“铜牌” (“Gold Medal”, “Silver Medal” and “Bronze Medal”).<br>余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。<br>提示:</p><p>N 是一个正整数并且不会超过 10000。<br>所有运动员的成绩都不相同。</p><p>可以利用map数据结构来存放名次和成绩，并利用其自动排序的特性。由于成绩高的名词在前面，而map默认升序，所以需要倒着往前遍历，因此定义迭代器的时候为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int, int&gt;::reverse_iterator it;</span><br></pre></td></tr></table></figure></p><p>并且map迭代器用it-&gt;first来访问键，it-&gt;second来访问值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRelativeRanks(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res(nums.size(), <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::reverse_iterator it;</span><br><span class="line">        <span class="keyword">for</span>(it = m.rbegin(); it != m.rend(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">1</span>) &#123;</span><br><span class="line">                res[it-&gt;second] = <span class="string">"Gold Medal"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">2</span>) &#123;</span><br><span class="line">                res[it-&gt;second] = <span class="string">"Silver Medal"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">3</span>) &#123;</span><br><span class="line">                res[it-&gt;second] = <span class="string">"Bronze Medal"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[it-&gt;second] = to_string(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>463. 岛屿的周长</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</url>
      
        <content type="html"><![CDATA[<p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><p>示例 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[0,1,0,0],</span><br><span class="line"> [1,1,1,0],</span><br><span class="line"> [0,1,0,0],</span><br><span class="line"> [1,1,0,0]]</span><br><span class="line"></span><br><span class="line">答案: 16</span><br><span class="line">解释: 它的周长是下面图片中的 16 个黄色的边：</span><br></pre></td></tr></table></figure></p><p><img src="https://leetcode-cn.com/static/images/problemset/island.png" alt="alt"><br>分析，计算方格为1的周长，可以先将为1的方格都加上4，然后检查左边和上方是否为1，为1的话就减去2。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res += <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    res -= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                    res -= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1016 Phone Bills (25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1016-Phone-Bills-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1016-Phone-Bills-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1016 Phone Bills (25)（25 分）<br>A long-distance telephone company charges its customers by the following rules:</p><p>Making a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records.</p><p>Input Specification:</p><p>Each input file contains one test case. Each case has two parts: the rate structure, and the phone call records.</p><p>The rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from 00:00 - 01:00, the toll from 01:00</p><p>02:00, and so on for each hour in the day.<br>The next line contains a positive number N (&lt;= 1000), followed by N lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date (mm:dd:hh:mm), and the word “on-line” or “off-line”.</p><p>For each test case, all dates will be within a single month. Each “on-line” record is paired with the chronologically next record for the same customer provided it is an “off-line” record. Any “on-line” records that are not paired with an “off-line” record are ignored, as are “off-line” records not paired with an “on-line” record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock.</p><p>Output Specification:</p><p>For each test case, you must print a phone bill for each customer.</p><p>Bills must be printed in alphabetical order of customers’ names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date (dd:hh:mm), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">10 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 10</span><br><span class="line">10</span><br><span class="line">CYLL 01:01:06:01 on-line</span><br><span class="line">CYLL 01:28:16:05 off-line</span><br><span class="line">CYJJ 01:01:07:00 off-line</span><br><span class="line">CYLL 01:01:08:03 off-line</span><br><span class="line">CYJJ 01:01:05:59 on-line</span><br><span class="line">aaa 01:01:01:03 on-line</span><br><span class="line">aaa 01:02:00:01 on-line</span><br><span class="line">CYLL 01:28:15:41 on-line</span><br><span class="line">aaa 01:05:02:24 on-line</span><br><span class="line">aaa 01:04:23:59 off-line</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CYJJ 01</span><br><span class="line">01:05:59 01:07:00 61 $12.10</span><br><span class="line">Total amount: $12.10</span><br><span class="line">CYLL 01</span><br><span class="line">01:06:01 01:08:03 122 $24.40</span><br><span class="line">28:15:41 28:16:05 24 $3.85</span><br><span class="line">Total amount: $28.25</span><br><span class="line">aaa 01</span><br><span class="line">02:00:01 04:23:59 4318 $638.80</span><br><span class="line">Total amount: $638.80</span><br></pre></td></tr></table></figure></p><p>题目大意:给出24h中每个小时内的资费，并给出n个通话记录点。要求对每个人的有效通话记录进行资费计算。</p><p>第一步：对所有记录进行排序<br>第二步：对每个用户判断其是否存在有效通话记录<br>第三步：如果存在有效通话记录，则输出有效通话记录并计费。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> toll[<span class="number">25</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Record</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">25</span>];</span><br><span class="line">    <span class="keyword">int</span> month, dd, hh, mm;</span><br><span class="line">    <span class="keyword">bool</span> statu;</span><br><span class="line">&#125; rec[maxn], temp;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Record a, Record b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="built_in">strcmp</span>(a.name, b.name);</span><br><span class="line">    <span class="keyword">if</span>(s != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s &lt; <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a.month != b.month) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.month &lt; b.month;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a.dd != b.dd) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.dd &lt; b.dd;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a.hh != b.hh) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.hh &lt; b.hh;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.mm &lt; b.mm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAns</span><span class="params">(<span class="keyword">int</span> on, <span class="keyword">int</span> off, <span class="keyword">int</span>&amp; time, <span class="keyword">int</span>&amp; money)</span> </span>&#123;</span><br><span class="line">    temp = rec[on];</span><br><span class="line">    <span class="keyword">while</span>(temp.dd &lt; rec[off].dd || temp.hh &lt; rec[off].hh || temp.mm &lt; rec[off].mm) &#123;</span><br><span class="line">        time++;</span><br><span class="line">        money += toll[temp.hh];</span><br><span class="line">        temp.mm++;</span><br><span class="line">        <span class="keyword">if</span>(temp.mm &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            temp.mm = <span class="number">0</span>;</span><br><span class="line">            temp.hh++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.hh &gt;= <span class="number">24</span>) &#123;</span><br><span class="line">            temp.hh = <span class="number">0</span>;</span><br><span class="line">            temp.dd++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;toll[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, rec[i].name);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d:%d"</span>, &amp;rec[i].month, &amp;rec[i].dd, &amp;rec[i].hh, &amp;rec[i].mm);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, line);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(line, <span class="string">"on-line"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            rec[i].statu = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rec[i].statu = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(rec, rec + n, cmp);</span><br><span class="line">    <span class="keyword">int</span> on = <span class="number">0</span>, off, next;</span><br><span class="line">    <span class="keyword">while</span>(on &lt; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> needPrint = <span class="number">0</span>;</span><br><span class="line">        next = on;</span><br><span class="line">        <span class="keyword">while</span>(next &lt; n &amp;&amp; <span class="built_in">strcmp</span>(rec[next].name, rec[on].name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(needPrint == <span class="number">0</span> &amp;&amp; rec[next].statu) &#123;</span><br><span class="line">                needPrint = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(needPrint == <span class="number">1</span> &amp;&amp; rec[next].statu == <span class="literal">false</span>) &#123;</span><br><span class="line">                needPrint = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(needPrint &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            on = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> allMoney = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %02d\n"</span>, rec[on].name, rec[on].month);</span><br><span class="line">        <span class="keyword">while</span>(on &lt; next) &#123;</span><br><span class="line">            <span class="keyword">while</span>(on &lt; next - <span class="number">1</span> &amp;&amp; !(rec[on].statu &amp;&amp; rec[on + <span class="number">1</span>].statu == <span class="literal">false</span>)) &#123;</span><br><span class="line">                on++;</span><br><span class="line">            &#125;</span><br><span class="line">        off = on + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(off == next) &#123;</span><br><span class="line">            on = next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d "</span>, rec[on].dd, rec[on].hh, rec[on].mm);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d "</span>, rec[off].dd, rec[off].hh, rec[off].mm);</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>, money = <span class="number">0</span>;</span><br><span class="line">        getAns(on, off, time, money);</span><br><span class="line">        allMoney += money;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d $%.2f\n"</span>, time, money / <span class="number">100.0</span>);</span><br><span class="line">        on = off + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Total amount: $%.2f\n"</span>, allMoney / <span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1012 The Best Rank (25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1012-The-Best-Rank-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1012-The-Best-Rank-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1012 The Best Rank (25)（25 分）<br>To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: C - C Programming Language, M - Mathematics (Calculus or Linear Algebra), and E - English. At the mean time, we encourage students by emphasizing on their best ranks – that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student.</p><p>For example, The grades of C, M, E and A - Average of 4 students are given as the following:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StudentID  C  M  E  A</span><br><span class="line">310101     98 85 88 90</span><br><span class="line">310102     70 95 88 84</span><br><span class="line">310103     82 87 94 88</span><br><span class="line">310104     91 91 91 91</span><br></pre></td></tr></table></figure></p><p>Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average.</p><p>Input</p><p>Each input file contains one test case. Each case starts with a line containing 2 numbers N and M (&lt;=2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then N lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of C, M and E. Then there are M lines, each containing a student ID.</p><p>Output</p><p>For each of the M students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space.</p><p>The priorities of the ranking methods are ordered as A &gt; C &gt; M &gt; E. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority.</p><p>If a student is not on the grading list, simply output “N/A”.</p><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5 6</span><br><span class="line">310101 98 85 88</span><br><span class="line">310102 70 95 88</span><br><span class="line">310103 82 87 94</span><br><span class="line">310104 91 91 91</span><br><span class="line">310105 85 90 90</span><br><span class="line">310101</span><br><span class="line">310102</span><br><span class="line">310103</span><br><span class="line">310104</span><br><span class="line">310105</span><br><span class="line">999999</span><br></pre></td></tr></table></figure></p><p>Sample Output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 C</span><br><span class="line">1 M</span><br><span class="line">1 E</span><br><span class="line">1 A</span><br><span class="line">3 A</span><br><span class="line">N/A</span><br></pre></td></tr></table></figure></p><p>题目大意：已知n个学生的3门课分数C、M、E，以及这三门课的平均分A。<br>现在分别按这四个分数对n个考生从高到低排序，这样每个考生就有4个排名且每个分数都有一个排名。接下来有m个查询，输出该考生4个排名中最高的那个排名及对应的分数是哪个。如果不同课程有相同排名，则按优先级A&gt;C&gt;M&gt;E输出，如果查询的考生id不存在，输出N/A</p><ul><li>排名时注意相同的分数排名相同的。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> grade[<span class="number">4</span>];</span><br><span class="line">&#125;stu[<span class="number">2001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> course[<span class="number">4</span>] = &#123;<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'M'</span>, <span class="string">'E'</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Rank[<span class="number">1000000</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> now;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Student a, Student b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.grade[now] &gt; b.grade[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;stu[i].id, &amp;stu[i].grade[<span class="number">1</span>], &amp;stu[i].grade[<span class="number">2</span>], &amp;stu[i].grade[<span class="number">3</span>]);</span><br><span class="line">        stu[i].grade[<span class="number">0</span>] = round((stu[i].grade[<span class="number">1</span>] + stu[i].grade[<span class="number">2</span>] + stu[i].grade[<span class="number">3</span>]) / <span class="number">3.0</span>) + <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(now = <span class="number">0</span>; now &lt; <span class="number">4</span>; now++) &#123;</span><br><span class="line">        sort(stu, stu + n, cmp);</span><br><span class="line">        Rank[stu[<span class="number">0</span>].id][now] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(stu[i].grade[now] == stu[i - <span class="number">1</span>].grade[now]) &#123;</span><br><span class="line">                Rank[stu[i].id][now] = Rank[stu[i - <span class="number">1</span>].id][now];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Rank[stu[i].id][now] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> query;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;query);</span><br><span class="line">        <span class="keyword">if</span>(Rank[query][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"N/A\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(Rank[query][j] &lt; Rank[query][k]) &#123;</span><br><span class="line">                    k = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %c\n"</span>, Rank[query][k], course[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>458. 可怜的小猪</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/458-%E5%8F%AF%E6%80%9C%E7%9A%84%E5%B0%8F%E7%8C%AA/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/458-%E5%8F%AF%E6%80%9C%E7%9A%84%E5%B0%8F%E7%8C%AA/</url>
      
        <content type="html"><![CDATA[<p>有1000只水桶，其中有且只有一桶装的含有毒药，其余装的都是水。它们从外观看起来都一样。如果小猪喝了毒药，它会在15分钟内死去。</p><p>问题来了，如果需要你在一小时内，弄清楚哪只水桶含有毒药，你最少需要多少只猪？</p><p>回答这个问题，并为下列的进阶问题编写一个通用算法。</p><p>进阶:</p><p>假设有 n 只水桶，猪饮水中毒后会在 m 分钟内死亡，你需要多少猪（x）就能在 p 分钟内找出“有毒”水桶？n只水桶里有且仅有一只有毒的桶。<br>参考：<a href="http://www.voidcn.com/article/p-vrqdyaov-bpd.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-vrqdyaov-bpd.html</a><br>分析：拿到题目乍一看  ~~不知<br>所云，我擦，不是easy类的题吗，怀疑了一波自己的智商然后去Google了。<br>一头猪有五个状态，15min,30,45,60,die or alive.<br>一头猪不光是死活两种状态，而是具有五种状态，所以应该采用五进制进行编码；<br>用这种编码方式去唯一对应一个水桶，当五个回合结束之后通过两头猪在五个状态的状态判断哪一个桶水有毒。<br>所以n个猪能确定的编码数量是5的n次方<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">poorPigs</span><span class="params">(<span class="keyword">int</span> buckets, <span class="keyword">int</span> minutesToDie, <span class="keyword">int</span> minutesToTest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ceil</span>(<span class="built_in">log</span>(buckets) / <span class="built_in">log</span>(minutesToTest / minutesToDie + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>438. 找到字符串中所有字母异位词</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><p>说明：</p><p>字母异位词指字母相同，但排列不同的字符串。<br>不考虑答案输出的顺序。<br>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 6]</span><br></pre></td></tr></table></figure></p><p>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的字母异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的字母异位词。<br> 示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 1, 2]</span><br></pre></td></tr></table></figure></p><p>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的字母异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的字母异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的字母异位词。</p><p>分析：给一个非空字符串p，找到字符串s中所有p的重组字符串的起始下标。</p><p>定义a[26]数组存放字母出现的次数。为了节省时间，每一次循环时，加入新的字符，减去原先的第一个字符。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAnagrams(<span class="built_in">string</span> s, <span class="built_in">string</span> p) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> lens = s.size();</span><br><span class="line">        <span class="keyword">int</span> lenp = p.size();</span><br><span class="line">        <span class="keyword">if</span>(lens == <span class="number">0</span> || lenp == <span class="number">0</span> || lens &lt; lenp) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenp; i++) &#123;</span><br><span class="line">            a[p[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenp - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            a[s[i] - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lens - lenp + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            a[s[i + lenp - <span class="number">1</span>] - <span class="string">'a'</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(isZero(a)) &#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            a[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isZero</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>447. 回旋镖的数量</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/447-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/447-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。</p><p>找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[0,0],[1,0],[2,0]]</span><br></pre></td></tr></table></figure></p><p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]</span><br></pre></td></tr></table></figure></p><p>分析：因为要考虑元组间的顺序关系，所以如果有n个点与点a距离相等，那么排列方式一共有n(n-1)种，利用哈希表来记录与某个点相同距离的个数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfBoomerangs</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = points.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = points[i].first - points[j].first;</span><br><span class="line">                <span class="keyword">int</span> y = points[i].second - points[j].second;</span><br><span class="line">                m[x * x + y * y]++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; :: iterator it;</span><br><span class="line">        <span class="keyword">for</span>(it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = it-&gt;second;</span><br><span class="line">            res += temp * (temp - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            m.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>437. 路径总和 III</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树，它的每个结点都存放着一个整数值。</p><p>找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">返回 3。和等于 8 的路径有:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3.  -3 -&gt; 11</span><br></pre></td></tr></table></figure></p><p>分析：题目要求在以root为根结点的二叉树中，寻找和为sum的路径，返回这样的路径个数。<br>我们可以分两种情况进行递归遍历，</p><ul><li>第一种sum包含当前结点，在他的左右子树里面寻找和为sum的路径数量。递归调用dfs</li><li>第二种，当前结点不包含在sum里面，直接调用pathSum递归</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        res += dfs(root, sum);</span><br><span class="line">        res += pathSum(root-&gt;left, sum);</span><br><span class="line">        res += pathSum(root-&gt;right, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == num) &#123;</span><br><span class="line">            res += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += dfs(root-&gt;left, num - root-&gt;val);</span><br><span class="line">        res += dfs(root-&gt;right, num - root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>74. 搜索二维矩阵</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。<br>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 13</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>分析：二维矩阵中的查找，采用嵌套循环是可以做出判断的，但这样算法不够高效，也没有利用到题中给出的矩阵特征，我们可以固定右上角的元素，根据每行每列递增的规律优化写法，这题剑指offer里面也有说明<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(matrix[<span class="number">0</span>].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rowNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> colNum = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(rowNum &lt; matrix.size() &amp;&amp; colNum &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; matrix[rowNum][colNum]) &#123;</span><br><span class="line">                --colNum;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[rowNum][colNum]) &#123;</span><br><span class="line">                ++rowNum;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>832. 翻转图像</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/832-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/832-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p>给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。</p><p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。</p><p>反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,1,0],[1,0,1],[0,0,0]]</span><br><span class="line">输出: [[1,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；</span><br><span class="line">     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</span><br><span class="line">输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br><span class="line">解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；</span><br><span class="line">     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>1 &lt;= A.length = A[0].length &lt;= 20<br>0 &lt;= A[i][j] &lt;= 1<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; flipAndInvertImage(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            reverse(A[i].begin(), A[i].end());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A[i].size(); j++) &#123;</span><br><span class="line">                A[i][j] ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>696. 计数二进制子串</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/696-%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/696-%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p><p>重复出现的子串要计算它们出现的次数。</p><p>示例 1 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;00110011&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。</span><br><span class="line"></span><br><span class="line">请注意，一些重复出现的子串要计算它们出现的次数。</span><br></pre></td></tr></table></figure></p><p>另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。<br>示例 2 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;10101&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。</span><br><span class="line">注意：</span><br></pre></td></tr></table></figure></p><p>s.length 在1到50,000之间。<br>s 只包含“0”或“1”字符。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                curLen++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                preLen = curLen;</span><br><span class="line">                curLen = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(preLen &gt;= curLen) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>704. Binary Search</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/704-Binary-Search/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/704-Binary-Search/</url>
      
        <content type="html"><![CDATA[<p>Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: 9 exists in nums and its index is 4</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: 2 does not exist in nums so return -1</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>You may assume that all elements in nums are unique.<br>n will be in the range [1, 10000].<br>The value of each element in nums will be in the range [-9999, 9999].</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>868. 二进制间距</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/868-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%97%B4%E8%B7%9D/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/868-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%97%B4%E8%B7%9D/</url>
      
        <content type="html"><![CDATA[<p>给定一个正整数 N，找到并返回 N 的二进制表示中两个连续的 1 之间的最长距离。 </p><p>如果没有两个连续的 1，返回 0 。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：22</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">22 的二进制是 0b10110 。</span><br><span class="line">在 22 的二进制表示中，有三个 1，组成两对连续的 1 。</span><br><span class="line">第一对连续的 1 中，两个 1 之间的距离为 2 。</span><br><span class="line">第二对连续的 1 中，两个 1 之间的距离为 1 。</span><br><span class="line">答案取两个距离之中最大的，也就是 2 。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：5</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">5 的二进制是 0b101 。</span><br></pre></td></tr></table></figure></p><p>示例 3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：6</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">6 的二进制是 0b110 。</span><br></pre></td></tr></table></figure></p><p>示例 4：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：8</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">8 的二进制是 0b1000 。</span><br><span class="line">在 8 的二进制表示中没有连续的 1，所以返回 0 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= N &lt;= 10^9<br>方法一：记录索引，对给定的二进制数的每一位进行与运算，将为1的那一位的索引记录的a数组中，然后计算a数组相邻元素最大的差值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binaryGap</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(((N&gt;&gt;i) &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                a[t++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            ans = max(ans, a[i+<span class="number">1</span>] - a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>方法二：一次遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binaryGap</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(((N&gt;&gt;i) &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(last &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    ans = max(ans, i - last);</span><br><span class="line">                &#125;</span><br><span class="line">                last = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1046 Shortest Distance (20)（20 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1046-Shortest-Distance-20-%EF%BC%8820-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1046-Shortest-Distance-20-%EF%BC%8820-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1046 Shortest Distance (20)（20 分）<br>The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line contains an integer N (in [3, 10^5^]), followed by N integer distances D~1~ D~2~ … D~N~, where D~i~ is the distance between the i-th and the (i+1)-st exits, and D~N~ is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (&lt;=10^4^), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 10^7^.</p><p>Output Specification:</p><p>For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 1 2 4 14 9</span><br><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">2 5</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">10</span><br><span class="line">7</span><br></pre></td></tr></table></figure></p><p>题目大意：有n个结点围成一个圈，相邻两个结点之间的距离已知，且每次只能移动到相邻点。给出m次询问，每次给出两个编号a，b，问从a到b的最短距离是多少。</p><p>分析：用dis[i]表示1号结点按顺时针方向到达i号节点顺时针方向下一个节点的距离，sum表示一圈的总距离，a[i]表示i号与i+1号顶点的距离。对于每次询问，结果其实就是dis(left,right)和sum-dis(left,right)中的较小值。<br>dis数组和sum在读入数据时就可进行预处理来得到，以此来降低时间复杂度，对于每次询问dis(left,right) = dis[right-1] - dis[left-1].<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> dis[maxn], a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, query, n, left, right;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        sum += a[i];</span><br><span class="line">        dis[i] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;query);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; query; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;left, &amp;right);</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) &#123;</span><br><span class="line">            swap(left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = dis[right - <span class="number">1</span>] - dis[left - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min(temp, sum - temp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>572. 另一个树的子树</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p><p>示例 1:<br>给定的树 s:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \</span><br><span class="line"> 1   2</span><br><span class="line">给定的树 t：</span><br><span class="line"></span><br><span class="line">   4 </span><br><span class="line">  / \</span><br><span class="line"> 1   2</span><br><span class="line">返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定的树 s：</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \</span><br><span class="line"> 1   2</span><br><span class="line">    /</span><br><span class="line">   0</span><br><span class="line">给定的树 t：</span><br><span class="line"></span><br><span class="line">   4</span><br><span class="line">  / \</span><br><span class="line"> 1   2</span><br><span class="line">返回 false。</span><br></pre></td></tr></table></figure></p><p>分析：题目指出s的一个子树包括s的一个节点和该结点的所有子孙，因此子树是在叶结点往上某个与t相同的树，因此可以将问题转化为两棵树是否相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSame(s, t)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSubtree(s-&gt;left, t)||isSubtree(s-&gt;right, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s &amp;&amp; !t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s || !t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val != t-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSame(s-&gt;left, t-&gt;left)&amp;&amp;isSame(s-&gt;right, t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>709. 转换成小写字母</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/709-%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/709-%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;Hello&quot;</span><br><span class="line">输出: &quot;hello&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;here&quot;</span><br><span class="line">输出: &quot;here&quot;</span><br></pre></td></tr></table></figure></p><p>示例 3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LOVELY&quot;</span><br><span class="line">输出: &quot;lovely&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toLowerCase</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] &gt;= <span class="string">'A'</span> &amp;&amp; str[i] &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">                str[i] = str[i] + <span class="number">32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>653. 两数之和 IV - 输入 BST</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/653-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-IV-%E8%BE%93%E5%85%A5-BST/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/653-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-IV-%E8%BE%93%E5%85%A5-BST/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p><p>案例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target = 9</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">案例 2:</span><br></pre></td></tr></table></figure></p><p>输入:<br>    5<br>   / \<br>  3   6<br> / \   \<br>2   4   7</p><p>Target = 28</p><p>输出: False<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">分析：又是两数之和的问题，可以借助set进行判断，还是哈希思想，遍历整个树，查找是否有符合条件的值。</span><br><span class="line"></span><br><span class="line">递归写法：</span><br><span class="line">递归写法要主要set的定义不能在函数内部进行。</span><br><span class="line">```cpp</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     unordered_set&lt;int&gt; s;</span><br><span class="line">    bool findTarget(TreeNode* root, int k) &#123;</span><br><span class="line">        if(root == NULL) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s.count(k - root-&gt;val) != 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        s.insert(root-&gt;val);</span><br><span class="line">        return findTarget(root-&gt;left, k) || findTarget(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>迭代写法：<br>迭代写法怎么写其实就看你准备怎么遍历二叉树了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode* &gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            TreeNode* t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(s.count(k - t-&gt;val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.insert(t-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) &#123;</span><br><span class="line">                q.push(t-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) &#123;</span><br><span class="line">                q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode* &gt; st;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty() || root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.count(root-&gt;val)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.insert(k - root-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode *node = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                root = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>804. 唯一摩尔斯密码词</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/804-%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/804-%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: “a” 对应 “.-“, “b” 对应 “-…”, “c” 对应 “-.-.”, 等等。</p><p>为了方便，所有26个英文字母对应摩尔斯密码表如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</span><br></pre></td></tr></table></figure></p><p>给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-.-….-“，(即 “-.-.” + “-…” + “.-“字符串的结合)。我们将这样一个连接过程称作单词翻译。</p><p>返回我们可以获得所有词不同单词翻译的数量。</p><p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">各单词翻译如下:</span><br><span class="line">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br></pre></td></tr></table></figure></p><p>共有 2 种不同翻译, “–…-.” 和 “–…–.”.</p><p>注意:</p><p>单词列表words 的长度不会超过 100。<br>每个单词 words[i]的长度范围为 [1, 12]。<br>每个单词 words[i]只包含小写字母。</p><p>分析：这道题还是比较好想的，用字符串数组建立一个字母与摩尔斯密码的映射，遍历给定字符串数组，将每个单词的对应密码存入set字符串集合，输出集合大小即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniqueMorseRepresentations(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        string a[26] = &#123;&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;&#125;;</span><br><span class="line">        set&lt;string&gt; res;</span><br><span class="line">        for(int i = 0; i &lt; words.size(); i++) &#123;</span><br><span class="line">            string s = &quot;&quot;;</span><br><span class="line">            for(int j = 0; j &lt; words[i].size(); j++) &#123;</span><br><span class="line">                s += a[words[i][j]-&apos;a&apos;];</span><br><span class="line">            &#125;</span><br><span class="line">            res.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return res.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>L2-023 图着色问题（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-023-%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-023-%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>L2-023 图着色问题（25 分）<br>图着色问题是一个著名的NP完全问题。给定无向图 G = (V, E)，问可否用K种颜色为V中的每一个顶点分配一种颜色，使得不会有两个相邻顶点具有同一种颜色？</p><p>但本题并不是要你解决这个着色问题，而是对给定的一种颜色分配，请你判断这是否是图着色问题的一个解。</p><p>输入格式：</p><p>输入在第一行给出3个整数V（0 &lt; V &lt;= 500）、E（&gt;= 0）和K（0 &lt; K &lt;= V），分别是无向图的顶点数、边数、以及颜色数。顶点和颜色都从1到V编号。随后E行，每行给出一条边的两个端点的编号。在图的信息给出之后，给出了一个正整数N（&lt;= 20），是待检查的颜色分配方案的个数。随后N行，每行顺次给出V个顶点的颜色（第i个数字表示第i个顶点的颜色），数字间以空格分隔。题目保证给定的无向图是合法的（即不存在自回路和重边）。</p><p>输出格式：</p><p>对每种颜色分配方案，如果是图着色问题的一个解则输出“Yes”，否则输出“No”，每句占一行。</p><p>输入样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">6 8 3</span><br><span class="line">2 1</span><br><span class="line">1 3</span><br><span class="line">4 6</span><br><span class="line">2 5</span><br><span class="line">2 4</span><br><span class="line">5 4</span><br><span class="line">5 6</span><br><span class="line">3 6</span><br><span class="line">4</span><br><span class="line">1 2 3 3 1 2</span><br><span class="line">4 5 6 6 4 5</span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">2 3 4 2 3 4</span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure></p><p>分析：这题主要考察对图的遍历，题目要求你判断給定的颜色分配是不是图着色问题的一个解，而图着色问题的要求是用k种颜色为图G中的每个顶点分配一种颜色，并且不会有相邻两个顶点具有同一种颜色。可以枚举所有相连的点，看颜色是否相同。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">11</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">11</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vet[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> color[N];</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vet[i].size(); j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = vet[i][j];</span><br><span class="line">            <span class="keyword">if</span>(color[i] == color[v]) &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line">        vet[a].push_back(b);</span><br><span class="line">        vet[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;color[i]);</span><br><span class="line">        mp[color[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mp.size() != k)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        solve();</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>L2-024 部落（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-024-%E9%83%A8%E8%90%BD%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-024-%E9%83%A8%E8%90%BD%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>L2-024 部落（25 分）<br>在一个社区里，每个人都有自己的小圈子，还可能同时属于很多不同的朋友圈。我们认为朋友的朋友都算在一个部落里，于是要请你统计一下，在一个给定社区中，到底有多少个互不相交的部落？并且检查任意两个人是否属于同一个部落。</p><p>输入格式：</p><p>输入在第一行给出一个正整数N（&lt;= 10^4^），是已知小圈子的个数。随后N行，每行按下列格式给出一个小圈子里的人：</p><p>K P[1] P[2] … P[K]</p><p>其中K是小圈子里的人数，P[i]（i=1, .., K）是小圈子里每个人的编号。这里所有人的编号从1开始连续编号，最大编号不会超过10^4^。</p><p>之后一行给出一个非负整数Q（&lt;= 10^4^），是查询次数。随后Q行，每行给出一对被查询的人的编号。</p><p>输出格式：</p><p>首先在一行中输出这个社区的总人数、以及互不相交的部落的个数。随后对每一次查询，如果他们属于同一个部落，则在一行中输出“Y”，否则输出“N”。</p><p>输入样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3 10 1 2</span><br><span class="line">2 3 4</span><br><span class="line">4 1 5 7 8</span><br><span class="line">3 9 6 4</span><br><span class="line">2</span><br><span class="line">10 5</span><br><span class="line">3 7</span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 2</span><br><span class="line">Y</span><br><span class="line">N</span><br></pre></td></tr></table></figure></p><p>分析：并查集问题。根据set大小来输出社区总人数，遍历集合，根据F[i]是否等于i来计算互不相交的部落个数。判断两人是否属于同一部落用并查集里的find函数即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> F[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = x;</span><br><span class="line">    <span class="keyword">while</span>(r != F[r]) &#123;</span><br><span class="line">        r = F[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = x, j;</span><br><span class="line">    <span class="keyword">while</span>(i != r) &#123;</span><br><span class="line">        j = F[i];</span><br><span class="line">        F[i] = r;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = Find(x);</span><br><span class="line">    <span class="keyword">int</span> fb = Find(y);</span><br><span class="line">    <span class="keyword">if</span>(fa != fb) &#123;</span><br><span class="line">        F[fa] = fb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        F[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> m,k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        <span class="keyword">int</span> pre;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>) &#123;</span><br><span class="line">                pre = k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Union(pre,k);</span><br><span class="line">                pre = k;</span><br><span class="line">            &#125;</span><br><span class="line">            s.insert(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(F[i] == i) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,s.size(),sum);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(Find(x) == Find(y)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Y\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"N\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>682. 棒球比赛</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/682-%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/682-%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>你现在是棒球比赛记录员。<br>给定一个字符串列表，每个字符串可以是以下四种类型之一：<br>1.整数（一轮的得分）：直接表示您在本轮中获得的积分数。</p><ol start="2"><li>“+”（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。</li><li>“D”（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。</li><li>“C”（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效 回合的分数是无效的，应该被移除。</li></ol><p>每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。<br>你需要返回你在所有回合中得分的总和。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]</span><br><span class="line">输出: 30</span><br><span class="line">解释: </span><br><span class="line">第1轮：你可以得到5分。总和是：5。</span><br><span class="line">第2轮：你可以得到2分。总和是：7。</span><br><span class="line">操作1：第2轮的数据无效。总和是：5。</span><br><span class="line">第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。</span><br><span class="line">第4轮：你可以得到5 + 10 = 15分。总数是：30。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]</span><br><span class="line">输出: 27</span><br><span class="line">解释: </span><br><span class="line">第1轮：你可以得到5分。总和是：5。</span><br><span class="line">第2轮：你可以得到-2分。总数是：3。</span><br><span class="line">第3轮：你可以得到4分。总和是：7。</span><br><span class="line">操作1：第3轮的数据无效。总数是：3。</span><br><span class="line">第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。</span><br><span class="line">第5轮：你可以得到9分。总数是：8。</span><br><span class="line">第6轮：你可以得到-4 + 9 = 5分。总数是13。</span><br><span class="line">第7轮：你可以得到9 + 5 = 14分。总数是27。</span><br></pre></td></tr></table></figure></p><p>注意：</p><p>输入列表的大小将介于1和1000之间。<br>列表中的每个整数都将介于-30000和30000之间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len = res.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ops.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ops[i].compare(<span class="string">"+"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                res.push_back(res[res.size()<span class="number">-1</span>]+res[res.size()<span class="number">-2</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ops[i].compare(<span class="string">"D"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                res.push_back(res[res.size()<span class="number">-1</span>]*<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ops[i].compare(<span class="string">"C"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                res.pop_back();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(stoi(ops[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.size();i++)&#123;</span><br><span class="line">            sum += res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>605. 种花问题</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/605-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/605-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: flowerbed = [1,0,0,0,1], n = 1</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: flowerbed = [1,0,0,0,1], n = 2</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure></p><p>注意:</p><p>数组内已种好的花不会违反种植规则。<br>输入的数组长度范围为 [1, 20000]。<br>n 是非负整数，且不会超过输入数组的大小。</p><p>要想根据连续0的个数来计算能种多少花，需要考虑边界的问题，为了解决边界问题，可以采取补0的方法，如果第一个元素为0，就在最前面再补一个0，如果最后一个元素为0，就在最后面再补一个0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flowerbed.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flowerbed[<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">            flowerbed.insert(flowerbed.begin(),<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flowerbed.back()==<span class="number">0</span>)&#123;</span><br><span class="line">            flowerbed.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=flowerbed.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;flowerbed.size()&amp;&amp;flowerbed[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum += (cnt<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &gt;= n;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>844. 比较含退格的字符串</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S = &quot;ab#c&quot;, T = &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S = &quot;ab##&quot;, T = &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “”。</span><br></pre></td></tr></table></figure></p><p>示例 3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S = &quot;a##c&quot;, T = &quot;#a#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “c”。</span><br></pre></td></tr></table></figure></p><p>示例 4：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">输入：S = &quot;a#c&quot;, T = &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：S 会变成 “c”，但 T 仍然是 “b”。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= S.length &lt;= 200</span><br><span class="line">1 &lt;= T.length &lt;= 200</span><br><span class="line">S 和 T 只含有小写字母以及字符 &apos;#&apos;。</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool backspaceCompare(string S, string T) &#123;</span><br><span class="line">         return deal(S)==deal(T);</span><br><span class="line">    &#125;</span><br><span class="line">    string deal(string x)&#123;</span><br><span class="line">        string res;</span><br><span class="line">        for(int i=0;i&lt;x.size();i++)&#123;</span><br><span class="line">            if(x[i]==&apos;#&apos;)&#123;</span><br><span class="line">                if(!res.empty())&#123;</span><br><span class="line">                res.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res.push_back(x[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>401. 二进制手表</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/401-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/401-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。</p><p>每个 LED 代表一个 0 或 1，最低位在右侧。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg" alt="alt"></p><p>例如，上面的二进制手表读取 “3:25”。</p><p>给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。</p><p>案例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 1</span><br><span class="line">返回: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]</span><br></pre></td></tr></table></figure></p><p>注意事项:</p><p>输出的顺序没有要求。<br>小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。<br>分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。</p><p>根据二进制中1的个数来计算<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; readBinaryWatch(<span class="keyword">int</span> num) &#123;</span><br><span class="line">         List&lt;String&gt; times = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">12</span>; h++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">60</span>; m++)</span><br><span class="line">                <span class="keyword">if</span> (Integer.bitCount(h) + Integer.bitCount(m) == num)</span><br><span class="line">                    times.add(String.format(<span class="string">"%d:%02d"</span>, h, m));</span><br><span class="line">        <span class="keyword">return</span> times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>717. 1比特与2比特字符</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/717-1%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/717-1%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。</p><p>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits = [1, 0, 0]</span><br><span class="line">输出: True</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits = [1, 1, 1, 0]</span><br><span class="line">输出: False</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。</span><br></pre></td></tr></table></figure></p><p>注意:</p><p>1 &lt;= len(bits) &lt;= 1000.<br>bits[i] 总是0 或 1.</p><p>利用i作为增量指针，碰到0，增1，碰到1，增2，最后判断i的大小与bits剩余长度是否相等。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = bits.size();</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">       <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(bits[i]==<span class="number">1</span>)&#123;</span><br><span class="line">               i += <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> i==len<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>566. 重塑矩阵</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/566-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/566-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<p>在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。</p><p>给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。</p><p>重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。</p><p>如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 1, c = 4</span><br><span class="line">输出: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">解释:</span><br><span class="line">行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 2, c = 4</span><br><span class="line">输出: </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">解释:</span><br><span class="line">没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。</span><br></pre></td></tr></table></figure></p><p>注意：</p><p>给定矩阵的宽和高范围在 [1, 100]。<br>给定的 r 和 c 都是正数。<br>常规思路，首先根据两个矩阵的长乘宽是否相等来判断能否转化，如果能够转化，那么再用一个双重循环，将原矩阵的值按照一行行赋给结果矩阵<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixReshape(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(r,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c));</span><br><span class="line">        <span class="keyword">int</span> row = nums.size();</span><br><span class="line">        <span class="keyword">int</span> col = nums[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> indx1 = <span class="number">0</span>,indx2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( row*col!=r*c )&#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                    res[indx1][indx2++] = nums[i][j];</span><br><span class="line">                    <span class="keyword">if</span>( indx2==c)&#123;</span><br><span class="line">                        indx2 = <span class="number">0</span>;</span><br><span class="line">                        indx1++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>精简写法，用一个循环搞定<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixReshape(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = nums.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span> (m * n &lt; r * c) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; newNums(r, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r * c; i++) &#123;</span><br><span class="line">            newNums[i / c][i % c] = nums[i / n][i % n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>637. 二叉树的层平均值</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组.</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">输出: [3, 14.5, 11]</span><br><span class="line">解释:</span><br><span class="line">第0层的平均值是 3,  第1层是 14.5, 第2层是 11. 因此返回 [3, 14.5, 11].</span><br></pre></td></tr></table></figure></p><p>注意：</p><p>节点值的范围在32位有符号整数范围内。<br>分析：题目给定一棵二叉树，要求求出该二叉树每层节点值的平均值。</p><ul><li>1，先将根结点push进一个队列 ，然后去掉该队列最前面的结点</li><li>2，将每个从队列去掉的结点，将他们所有的孩子结点push进一个临时队列</li><li>3，继续从这个队列pop结点和add这个结点的孩子结点到临时队列直到队列为空</li><li>4，每次队列为空就表示这一层的所有结点都已被访问</li><li>5，当push结点到临时队列的时候，保持求和sum，并且求出每层的平均值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; averageOfLevels(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode*&gt; temp;</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                TreeNode* n = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                sum += n-&gt;val;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(n-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    temp.push(n-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(n-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    temp.push(n-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q = temp;</span><br><span class="line">            res.push_back((sum*<span class="number">1.0</span>/count));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>812. 最大三角形面积</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/812-%E6%9C%80%E5%A4%A7%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/812-%E6%9C%80%E5%A4%A7%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<p>给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">这五个点如下图所示。组成的橙色三角形是最大的，面积为2。</span><br></pre></td></tr></table></figure></p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/04/1027.png" alt="alt"></p><p>注意:</p><p>3 &lt;= points.length &lt;= 50.<br>不存在重复的点。<br> -50 &lt;= points[i][j] &lt;= 50.<br>结果误差值在 10^-6 以内都认为是正确答案。</p><p>三角形面积公式：<strong>A= 1/2 * [ x1(y2-y3) + x2(y3-y1) + x3(y1-y2) ]</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">largestTriangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = points.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;len;k++)&#123;</span><br><span class="line">                    res = max(res,<span class="number">0.5</span>*<span class="built_in">abs</span>(points[i][<span class="number">0</span>]*(points[j][<span class="number">1</span>]-points[k][<span class="number">1</span>])+points[j][<span class="number">0</span>]*(points[k][<span class="number">1</span>]-points[i][<span class="number">1</span>])+points[k][<span class="number">0</span>]*(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>])));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>693. 交替位二进制数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/693-%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/693-%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">5的二进制数是: 101</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 7</span><br><span class="line">输出: False</span><br><span class="line">解释:</span><br><span class="line">7的二进制数是: 111</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 11</span><br><span class="line">输出: False</span><br><span class="line">解释:</span><br><span class="line">11的二进制数是: 1011</span><br></pre></td></tr></table></figure></p><p> 示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">10的二进制数是: 1010</span><br></pre></td></tr></table></figure></p><p>方法一：将给定数值的二进制数转化为对应的字符串，只要该字符串不存在两个相邻的字符相等，那么就满足条件。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>( n )&#123;</span><br><span class="line">            <span class="built_in">string</span> a = to_string(n%<span class="number">2</span>);</span><br><span class="line">            s = a + s;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( s[i] == s[i+<span class="number">1</span>] )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>方法二：除以二，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = n%<span class="number">2</span>;</span><br><span class="line">            n = n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>( cur == n%<span class="number">2</span> )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = n%<span class="number">2</span>;</span><br><span class="line">            n = n/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>338. Bit位计数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/338-Bit%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/338-Bit%E4%BD%8D%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定一个非负整数 num。 对于范围 0 ≤ i ≤ num 中的每个数字 i ，计算其二进制数中的1的数目并将它们作为数组返回。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如给定 num = 5 ，应该返回 [0,1,1,2,1,2].</span><br></pre></td></tr></table></figure></p><p>进阶：</p><ul><li>给出时间复杂度为O(n * sizeof(integer)) 的解答非常容易。 但是你可以在线性时间O(n)内用一次遍历做到吗？</li><li>要求算法的空间复杂度为O(n)。</li><li>你能进一步完善解法吗？ 在c ++或任何其他语言中不使用任何内置函数（如c++里的 __builtin_popcount）来执行此操作。</li></ul><p>方法一：一位一位计算，但是这是完全不符合题目要求的，题目中希望你给出更优化的算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=num;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = count(i);</span><br><span class="line">                res.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( n )&#123;</span><br><span class="line">            <span class="keyword">if</span>( n%<span class="number">2</span> == <span class="number">1</span> )&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：找规律，<strong>规律是，从1开始，遇到偶数时，其1的个数和该偶数除以2得到的数字的1的个数相同，遇到奇数时，其1的个数等于该奇数除以2得到的数字的1的个数再加1</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= num; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( i%<span class="number">2</span> == <span class="number">0</span> )&#123;</span><br><span class="line">                    res.push_back(res[i/<span class="number">2</span>]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back( res[i/<span class="number">2</span>] + <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法三：利用i&amp;(i-1),i&amp;(i-1)一方面可以用来判断一个数是否为2的指数，放在这里的规律是，针对结果数组，每个下标i = i&amp;(i-1)+1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(num+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= num; i++)&#123;</span><br><span class="line">                res[i] = res[i&amp;(i<span class="number">-1</span>)]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>617. 合并二叉树</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \   \ </span><br><span class="line"> 5   4   7</span><br><span class="line">注意: 合并必须从两个树的根节点开始。</span><br></pre></td></tr></table></figure></p><p>首先判断t1和t2是否为空，如果t1为空，那么返回t2，如果t2为空，那么返回t1</p><p>新建一个结点t，参数为两个结点值的和，然后分别调用merge函数向左向右递归。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!t1)&#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!t2)&#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* t = <span class="keyword">new</span> TreeNode(t1-&gt;val+t2-&gt;val);</span><br><span class="line">        t-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class="line">        t-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>46. 全排列</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>法一：偷懒的写法，直接调用求下一个排列的库函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(next_permutation(nums.begin(),nums.end()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>法二：递归枚举</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( cur == nums.size() - <span class="number">1</span> )&#123;</span><br><span class="line">            ans.push_back(nums);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            swap( nums[cur], nums[i] );</span><br><span class="line">            dfs( cur + <span class="number">1</span>,nums, ans );</span><br><span class="line">            swap( nums[cur], nums[i] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        dfs( <span class="number">0</span>, nums, res );</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>31. 下一个排列</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</span><br><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure></p><p>法一：C++有直接求下一个排列的库函数，但这题用库函数就没意义了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        next_permutation(nums.begin(),nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>法二：<br>算法过程如图<br><img src="http://4.bp.blogspot.com/-4zN0u5JG0vs/UN0xPEkP5yI/AAAAAAAAG9Q/O48ZfwB1i_c/s640/Picture4.png" alt="alt"></p><p>图片来源：<a href="http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html" target="_blank" rel="noopener">http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swapWith</span><span class="params">(<span class="keyword">int</span> num,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = nums[i];</span><br><span class="line">        <span class="keyword">int</span> j = i,index = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i;j&lt;nums.size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( min &gt; nums[j] &amp;&amp; nums[j] &gt; nums[num] )&#123;</span><br><span class="line">                index = j;</span><br><span class="line">                min = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[index],nums[num]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size()<span class="number">-1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                swapWith(i<span class="number">-1</span>, nums, i);</span><br><span class="line">                sort(nums.begin()+i,nums.end());</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( flag == <span class="number">0</span> )&#123;</span><br><span class="line">            sort(nums.begin(),nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>868. 转置矩阵</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/868-%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/868-%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<p>给定一个矩阵 A， 返回 A 的转置矩阵。</p><p>矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6]]</span><br><span class="line">输出：[[1,4],[2,5],[3,6]]</span><br></pre></td></tr></table></figure></p><p>提示：</p><p>1 &lt;= A.length &lt;= 1000<br>1 &lt;= A[0].length &lt;= 1000</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; transpose(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = A.size();</span><br><span class="line">        <span class="keyword">int</span> col = A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B(row,<span class="number">0</span>);</span><br><span class="line">         <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(col,B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                res[j][i] = A[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>504. 七进制数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/504-%E4%B8%83%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/504-%E4%B8%83%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数，将其转化为7进制，并以字符串形式输出。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 100</span><br><span class="line">输出: &quot;202&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -7</span><br><span class="line">输出: &quot;-10&quot;</span><br></pre></td></tr></table></figure></p><p>注意: 输入范围是 [-1e7, 1e7] 。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( num == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            res = to_string(<span class="built_in">abs</span>(num%<span class="number">7</span>)) + res;</span><br><span class="line">            num /= <span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            res = <span class="string">"-"</span> + res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>500. 键盘行</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/500-%E9%94%AE%E7%9B%98%E8%A1%8C/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/500-%E9%94%AE%E7%9B%98%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所<br><img src="https://leetcode-cn.com/static/images/problemset/keyboard.png" alt="img"></p><p>示例1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</span><br><span class="line">输出: [&quot;Alaska&quot;, &quot;Dad&quot;]</span><br></pre></td></tr></table></figure></p><p>注意:</p><p>你可以重复使用键盘上同一字符。<br>你可以假设输入的字符串将只包含字母。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findWords(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">          <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; row1 &#123;<span class="string">'q'</span>,<span class="string">'w'</span>,<span class="string">'e'</span>,<span class="string">'r'</span>,<span class="string">'t'</span>,<span class="string">'y'</span>,<span class="string">'u'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'p'</span>,<span class="string">'Q'</span>,<span class="string">'W'</span>,<span class="string">'E'</span>,<span class="string">'R'</span>,<span class="string">'T'</span>,<span class="string">'Y'</span>,<span class="string">'U'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'P'</span>&#125;;</span><br><span class="line">          <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; row2&#123;<span class="string">'a'</span>,<span class="string">'s'</span>,<span class="string">'d'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>,<span class="string">'A'</span>,<span class="string">'S'</span>,<span class="string">'D'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>,<span class="string">'H'</span>,<span class="string">'J'</span>,<span class="string">'K'</span>,<span class="string">'L'</span>&#125;;</span><br><span class="line">          <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; row3&#123;<span class="string">'z'</span>,<span class="string">'x'</span>,<span class="string">'c'</span>,<span class="string">'v'</span>,<span class="string">'b'</span>,<span class="string">'n'</span>,<span class="string">'m'</span>,<span class="string">'Z'</span>,<span class="string">'X'</span>,<span class="string">'C'</span>,<span class="string">'V'</span>,<span class="string">'B'</span>,<span class="string">'N'</span>,<span class="string">'M'</span>&#125;;</span><br><span class="line">          <span class="keyword">for</span>(<span class="built_in">string</span> word : words) &#123;</span><br><span class="line">              <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">char</span> ch : word) &#123;</span><br><span class="line">                 <span class="keyword">if</span>(row1.count(ch)) a = <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span>(row2.count(ch)) b = <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span>(row3.count(ch)) c = <span class="number">1</span>;</span><br><span class="line">                 </span><br><span class="line">                 <span class="keyword">if</span>(a + b + c &gt; <span class="number">1</span>) <span class="keyword">break</span>;    </span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(a + b + c == <span class="number">1</span>) res.push_back(word);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>496. 下一个更大元素 I</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/</url>
      
        <content type="html"><![CDATA[<p>给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。</span><br><span class="line">    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。</span><br><span class="line">    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字2，第二个数组中的下一个较大数字是3。</span><br><span class="line">    对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。</span><br><span class="line">注意:</span><br></pre></td></tr></table></figure></p><p>nums1和nums2中所有元素是唯一的。<br>nums1和nums2 的数组大小都不超过1000。</p><p>暴力解法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; findNums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;findNums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.size();j++)&#123;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span>(findNums[i]==nums[j])&#123;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;nums.size();k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(nums[k]&gt;findNums[i])&#123;</span><br><span class="line">                            res.push_back(nums[k]);</span><br><span class="line">                            flag =<span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    res.push_back(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>用栈做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; findNums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s.size()&amp;&amp;s.top()&lt;nums[i])&#123;</span><br><span class="line">                m[s.top()] = nums[i];</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;findNums.size();i++)&#123;</span><br><span class="line">            res.push_back(m.count(findNums[i])?m[findNums[i]]:<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>492. 构造矩形</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/492-%E6%9E%84%E9%80%A0%E7%9F%A9%E5%BD%A2/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/492-%E6%9E%84%E9%80%A0%E7%9F%A9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p>作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：</p><ol><li><p>你设计的矩形页面必须等于给定的目标面积。</p></li><li><p>宽度 W 不应大于长度 L，换言之，要求 L &gt;= W 。</p></li><li><p>长度 L 和宽度 W 之间的差距应当尽可能小。<br>你需要按顺序输出你设计的页面的长度 L 和宽度 W。</p></li></ol><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: [2, 2]</span><br><span class="line">解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。</span><br><span class="line">但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>给定的面积不大于 10,000,000 且为正整数。<br>你设计的页面的长度和宽度必须都是正整数。<br>分析：题目要求还是很明确的，求出一组满足要求的长和宽，要求L&gt;=W,所以对area开根号，并且从中间开始遍历，只要满足L&gt;=W，就可以加入结果数组并输出、</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; constructRectangle(<span class="keyword">int</span> area) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">sqrt</span>(area);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=area;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(area%i==<span class="number">0</span>&amp;&amp;i&gt;=area/i)&#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">                res.push_back(area/i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>476. 数字的补数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。</p><p>注意:</p><p>给定的整数保证在32位带符号整数的范围内。<br>你可以假定二进制数不包含前导零位。<br>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 2</span><br><span class="line">解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: 0</span><br><span class="line">解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。</span><br></pre></td></tr></table></figure></p><p>这题其实已经将问题简化了，由于限定给出的为正整数，那么也就不需要考虑负数的情况了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(sum&lt;num)&#123;</span><br><span class="line">            sum += <span class="built_in">pow</span>(<span class="number">2</span>,i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum-num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>645. 错误的集合</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/645-%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/645-%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。</p><p>给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,2,4]</span><br><span class="line">输出: [2,3]</span><br><span class="line">注意:</span><br></pre></td></tr></table></figure></p><p>给定数组的长度范围是 [2, 10000]。<br>给定的数组是无序的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findErrorNums(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">10001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            a[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="number">2</span>)&#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>643. 子数组最大平均数 I</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0-I/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0-I/</url>
      
        <content type="html"><![CDATA[<p>给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,12,-5,-6,50,3], k = 4</span><br><span class="line">输出: 12.75</span><br><span class="line">解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75</span><br></pre></td></tr></table></figure></p><p>注意:</p><p>1 &lt;= k &lt;= n &lt;= 30,000。<br>所给数据范围 [-10,000，10,000]。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> avg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> max = <span class="number">-10001</span>,sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">double</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">while</span>(k+j&lt;=nums.size())&#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=j;i&lt;k+j;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        avg = sum/k;</span><br><span class="line">        <span class="keyword">if</span>(avg&gt;max)&#123;</span><br><span class="line">            max = avg;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>507. 完美数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/507-%E5%AE%8C%E7%BE%8E%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/507-%E5%AE%8C%E7%BE%8E%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。</p><p>给定一个 正整数 n， 如果他是完美数，返回 True，否则返回 False</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 28</span><br><span class="line">输出: True</span><br><span class="line">解释: 28 = 1 + 2 + 4 + 7 + 14</span><br></pre></td></tr></table></figure></p><p>注意:</p><p>输入的数字 n 不会超过 100,000,000. (1e8)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPerfectNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="built_in">sqrt</span>(num);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num%i==<span class="number">0</span>)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">                sum += num/i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>409. 最长回文串</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p><p>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p><p>注意:<br>假设字符串的长度不会超过 1010。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure></p><p>分析：这题其实比求最长回文子串要简单，我的思路就是对給定字符串的每个字符进行哈希映射来计数，然后分情况讨论求和，首先偶数个的字符肯定能组成回文串，奇数个的字符如果大于2，则求和时要减去1，但最后总的要加1或者有某个字符个数为1，最后总的也是要加1<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            a[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==s.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;=<span class="number">2</span>&amp;&amp;a[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=a[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;<span class="number">2</span>&amp;&amp;a[i]%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=(a[i]<span class="number">-1</span>);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>459. 重复的子字符串</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abab&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure></p><p>解释: 可由子字符串 “ab” 重复两次构成。<br>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aba&quot;</span><br><span class="line"></span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcabcabc&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure></p><p>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。)</p><p>分析：判断一个字符串是否可以有多个子字符串构成，则该子字符串的长度不能大于该字符串长度的一半，所以可以从0到n/2进行遍历，如果i能被n整除，则进行验证。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">string</span> s2 = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> c = n/i;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++)&#123;</span><br><span class="line">                s2 += s.substr(<span class="number">0</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(s==s2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>443. 压缩字符串</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/443-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/443-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定一组字符，使用原地算法将其压缩。</p><p>压缩后的长度必须始终小于或等于原数组长度。</p><p>数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。</p><p>在完成原地修改输入数组后，返回数组的新长度。</p><p>进阶：<br>你能否仅使用O(1) 空间解决问题？</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">返回6，输入数组的前6个字符应该是：[&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]</span><br></pre></td></tr></table></figure></p><p>说明：<br>“aa”被”a2”替代。”bb”被”b2”替代。”ccc”被”c3”替代。<br>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;a&quot;]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">返回1，输入数组的前1个字符应该是：[&quot;a&quot;]</span><br></pre></td></tr></table></figure></p><p>说明：<br>没有任何字符串被替代。<br>示例 3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">返回4，输入数组的前4个字符应该是：[&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;]。</span><br></pre></td></tr></table></figure></p><p>说明：<br>由于字符”a”不重复，所以不会被压缩。”bbbbbbbbbbbb”被“b12”替代。<br>注意每个数字在数组中都有它自己的位置。<br>注意：</p><p>所有字符都有一个ASCII值在[35, 126]区间内。<br>1 &lt;= len(chars) &lt;= 1000。</p><p>分析，压缩字符串，我的代码跑是能跑通过了，但是写法不咋好看，不符合简介美观要求了。<br>思路就不提了，基本就是按题目意思直接模拟，新开了个数组存放结果字符集，然后将其赋给chars数组<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; chars)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; cur;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((chars[i]==chars[i+<span class="number">1</span>])&amp;&amp;((i+<span class="number">1</span>)&lt;chars.size()))&#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((chars[i]!=chars[i+<span class="number">1</span>])||((i+<span class="number">1</span>)==chars.size()))&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp==<span class="number">1</span>)&#123;</span><br><span class="line">                    res.push_back(chars[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.push_back(chars[i]);</span><br><span class="line">                    <span class="keyword">while</span>(temp!=<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = temp%<span class="number">10</span>;</span><br><span class="line">                        <span class="keyword">char</span> y = x+<span class="string">'0'</span>;</span><br><span class="line">                        temp /= <span class="number">10</span>;</span><br><span class="line">                        cur.push_back(y);</span><br><span class="line">                    &#125;</span><br><span class="line">                    reverse(cur.begin(),cur.end());</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cur.size();j++)&#123;</span><br><span class="line">                        res.push_back(cur[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur.clear();</span><br><span class="line">                     </span><br><span class="line">                &#125;</span><br><span class="line">                temp = <span class="number">1</span>;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> len = chars.size();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;res.size())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            chars[i] = res[i];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=len;j&lt;res.size();j++)&#123;</span><br><span class="line">                chars.push_back(res[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len==res.size())&#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.size();i++)&#123;</span><br><span class="line">                chars[i] = res[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.size();i++)&#123;</span><br><span class="line">                chars[i] = res[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t =len-res.size();</span><br><span class="line">            <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">                chars.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chars.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>319. 灯泡开关</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/319-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/319-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 1 </span><br><span class="line">解释: </span><br><span class="line">初始时, 灯泡状态 [关闭, 关闭, 关闭].</span><br><span class="line">第一轮后, 灯泡状态 [开启, 开启, 开启].</span><br><span class="line">第二轮后, 灯泡状态 [开启, 关闭, 开启].</span><br><span class="line">第三轮后, 灯泡状态 [开启, 关闭, 关闭].</span><br></pre></td></tr></table></figure></p><p>你应该返回 1，因为只有一个灯泡还亮着。<br>一般都是想着直接暴力模拟，不明白为什么开个平方就行了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>129. 求根到叶子节点数字之和</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p><p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p><p>计算从根到叶子节点生成的所有数字之和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">输出: 25</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12.</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13.</span><br><span class="line">因此，数字总和 = 12 + 13 = 25.</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  9   0</span><br><span class="line"> / \</span><br><span class="line">5   1</span><br><span class="line">输出: 1026</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.</span><br><span class="line">从根到叶子节点路径 4-&gt;0 代表数字 40.</span><br><span class="line">因此，数字总和 = 495 + 491 + 40 = 1026.</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum*<span class="number">10</span>+root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(root-&gt;left,sum*<span class="number">10</span>+root-&gt;val)+dfs(root-&gt;right,sum*<span class="number">10</span>+root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>113. 路径总和 II</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定如下二叉树，以及目标和 sum = 22，</span><br><span class="line"></span><br><span class="line">              5</span><br><span class="line">             / \</span><br><span class="line">            4   8</span><br><span class="line">           /   / \</span><br><span class="line">          11  13  4</span><br><span class="line">         /  \    / \</span><br><span class="line">        7    2  5   1</span><br><span class="line">返回:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>题目要求很清楚了，要求路径之和与给定值相等的所有路径，<br>分别往左子树，右子树递归遍历所有路径，每次递归就减去相应的节点值，到了叶子结点如果剩余值与叶子结点值相等，则该条路径符合要求，记录下该条路径，不符合的中间结果就pop掉<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">        pathSum(root,sum,cur,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(TreeNode *root,<span class="keyword">int</span> gap,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;cur,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.push_back(root-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(gap==root-&gt;val)&#123;</span><br><span class="line">                    res.push_back(cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pathSum(root-&gt;left,gap-root-&gt;val,cur,res);</span><br><span class="line">            pathSum(root-&gt;right,gap-root-&gt;val,cur,res);</span><br><span class="line">            cur.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>102. 二叉树的层次遍历</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>层序遍历指按层次的顺序从根结点向下逐层进行遍历，且对同一层的节点为从左到右遍历。<br>基本思路：从根结点开始广度优先搜索</p><ul><li>将根结点root加入队列</li><li>取出队首结点，访问它</li><li>如果该结点有左孩子，将左孩子入队。</li><li>如果该结点有右孩子，将右孩子入队</li><li>返回第二步，直到队列为空</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode*&gt; qt;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode* now = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            v.push_back(now-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                qt.push(now-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                qt.push(now-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">              res.push_back(v);</span><br><span class="line">            q = qt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>145. 二叉树的后序遍历</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树，返回它的 后序 遍历。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure></p><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？<br>先遍历左子树，再遍历右子树，最后输出根结点<br>递归法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        postorder(res,root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res,TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(res,root-&gt;left);</span><br><span class="line">        postorder(res,root-&gt;right);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>迭代法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            TreeNode *temp = s.top();</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)&#123;</span><br><span class="line">                s.push(temp-&gt;left);</span><br><span class="line">                temp-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp-&gt;right)&#123;</span><br><span class="line">                s.push(temp-&gt;right);</span><br><span class="line">                temp-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(temp-&gt;val);</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>144. 二叉树的前序遍历</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树，返回它的 前序 遍历。</p><p> 示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure></p><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><p>递归法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        preorder(res,root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res,TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        preorder(res,root-&gt;left);</span><br><span class="line">        preorder(res,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>迭代法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            TreeNode *p = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            res.push_back(p-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                s.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                s.push(p-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>94. 二叉树的中序遍历</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树，返回它的中序 遍历。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure></p><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><p>遍历顺序：左子树-&gt;根结点-&gt;右子树</p><p>递归法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        inorder(res,root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res,TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            inorder(res,root-&gt;left);</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            inorder(res,root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>迭代法：<br>用栈来模拟中序遍历<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* p = root;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty()||p!=<span class="literal">NULL</span>)&#123;<span class="comment">//当栈s为空或p指针不空进行迭代</span></span><br><span class="line">            <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;<span class="comment">//当p不空，将其压入栈，并且指针指向左孩子</span></span><br><span class="line">                s.push(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//p为空指针，将栈顶元素赋给p，并弹出栈顶元素，将p push进结果数组，然后p指针指向右孩子</span></span><br><span class="line">                p = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                res.push_back(p-&gt;val);</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>766. 托普利茨矩阵</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/766-%E6%89%98%E6%99%AE%E5%88%A9%E8%8C%A8%E7%9F%A9%E9%98%B5/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/766-%E6%89%98%E6%99%AE%E5%88%A9%E8%8C%A8%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<p>如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。</p><p>给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">matrix = [</span><br><span class="line">  [1,2,3,4],</span><br><span class="line">  [5,1,2,3],</span><br><span class="line">  [9,5,1,2]</span><br><span class="line">]</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">在上述矩阵中, 其对角线为:</span><br><span class="line">&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;。</span><br><span class="line">各条对角线上的所有元素均相同, 因此答案是True。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,2],</span><br><span class="line">  [2,2]</span><br><span class="line">]</span><br><span class="line">输出: False</span><br><span class="line">解释: </span><br><span class="line">对角线&quot;[1, 2]&quot;上的元素不同。</span><br></pre></td></tr></table></figure></p><p>说明:</p><p> matrix 是一个包含整数的二维数组。<br>matrix 的行数和列数均在 [1, 20]范围内。<br>matrix[i][j] 包含的整数在 [0, 99]范围内。<br>进阶:</p><p>如果矩阵存储在磁盘上，并且磁盘内存是有限的，因此一次最多只能将一行矩阵加载到内存中，该怎么办？<br>如果矩阵太大以至于只能一次将部分行加载到内存中，该怎么办？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.size(); ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; matrix[<span class="number">0</span>].size(); ++j)</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] != matrix[i - <span class="number">1</span>][j - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>746. 使用最小花费爬楼梯</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<p>数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost<a href="索引从0开始">i</a>。</p><p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p><p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: cost = [10, 15, 20]</span><br><span class="line">输出: 15</span><br><span class="line">解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。</span><br></pre></td></tr></table></figure></p><p> 示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</span><br></pre></td></tr></table></figure></p><p>注意：</p><p>cost 的长度将会在 [2, 1000]。<br>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。</p><p>求爬楼梯的最小花费，考虑动态规划解法，因为每爬上一个楼梯后你可以选择爬一级或两级楼梯，因此每次都是从前面一级或者是前面两级的位置过来的，因此得出dp转移方程，用dp[i]表示爬到第i层的最小花费<br><strong>dp[i] = min(dp[i-2]+cost[i-2],dp[i-1]+cost[i-1])</strong><br>但是下面的代码测试时显示超时的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i] = min(dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>],dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>L2-020 功夫传人（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-020-%E5%8A%9F%E5%A4%AB%E4%BC%A0%E4%BA%BA%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-020-%E5%8A%9F%E5%A4%AB%E4%BC%A0%E4%BA%BA%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>L2-020 功夫传人（25 分）<br>一门武功能否传承久远并被发扬光大，是要看缘分的。一般来说，师傅传授给徒弟的武功总要打个折扣，于是越往后传，弟子们的功夫就越弱…… 直到某一支的某一代突然出现一个天分特别高的弟子（或者是吃到了灵丹、挖到了特别的秘笈），会将功夫的威力一下子放大N倍 —— 我们称这种弟子为“得道者”。</p><p>这里我们来考察某一位祖师爷门下的徒子徒孙家谱：假设家谱中的每个人只有1位师傅（除了祖师爷没有师傅）；每位师傅可以带很多徒弟；并且假设辈分严格有序，即祖师爷这门武功的每个第i代传人只能在第i-1代传人中拜1个师傅。我们假设已知祖师爷的功力值为Z，每向下传承一代，就会减弱r%，除非某一代弟子得道。现给出师门谱系关系，要求你算出所有得道者的功力总值。</p><p>输入格式：</p><p>输入在第一行给出3个正整数，分别是：N（&lt;=10^5^）——整个师门的总人数（于是每个人从0到N-1编号，祖师爷的编号为0）；Z——祖师爷的功力值（不一定是整数，但起码是正数）；r ——每传一代功夫所打的折扣百分比值（不超过100的正数）。接下来有N行，第i行（i=0, …, N-1）描述编号为i的人所传的徒弟，格式为：</p><p>K~i~ ID[1] ID[2] … ID[K~i~]</p><p>其中K~i~是徒弟的个数，后面跟的是各位徒弟的编号，数字间以空格间隔。K~i~为零表示这是一位得道者，这时后面跟的一个数字表示其武功被放大的倍数。</p><p>输出格式：</p><p>在一行中输出所有得道者的功力总值，只保留其整数部分。题目保证输入和正确的输出都不超过10^10^。</p><p>输入样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 18.0 1.00</span><br><span class="line">3 2 3 5</span><br><span class="line">1 9</span><br><span class="line">1 4</span><br><span class="line">1 7</span><br><span class="line">0 7</span><br><span class="line">2 6 1</span><br><span class="line">1 8</span><br><span class="line">0 9</span><br><span class="line">0 4</span><br><span class="line">0 3</span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">404</span><br></pre></td></tr></table></figure></p><p>题目要求计算所有得道者功力总和，祖师爷功力为z，每下降一代传授的功力要减r%，根据一代代递归得出每代徒弟的功力，如果是得道者，就将相应功力加起来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">100005</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child[maxm];</span><br><span class="line"><span class="keyword">double</span> val[maxm],z,r,sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">double</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val[id])&#123;</span><br><span class="line">        sum = sum+w*val[id];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;child[id].size();i++)&#123;</span><br><span class="line">            dfs(child[id][i],w*r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="keyword">sizeof</span>(val));</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %lf %lf"</span>,&amp;n,&amp;z,&amp;r);</span><br><span class="line">    r = (<span class="number">100</span>-r)/<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">if</span>(!m)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;val[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">                child[i].push_back(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>,z);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(<span class="keyword">int</span>)sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>L2-012 关于堆的判断（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-012-%E5%85%B3%E4%BA%8E%E5%A0%86%E7%9A%84%E5%88%A4%E6%96%AD%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-012-%E5%85%B3%E4%BA%8E%E5%A0%86%E7%9A%84%E5%88%A4%E6%96%AD%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>L2-012 关于堆的判断（25 分）<br>将一系列给定数字顺序插入一个初始为空的小顶堆H[]。随后判断一系列相关命题是否为真。命题分下列几种：</p><ul><li>“x is the root”：x是根结点；</li><li>“x and y are siblings”：x和y是兄弟结点；</li><li>“x is the parent of y”：x是y的父结点；</li><li>“x is a child of y”：x是y的一个子结点。<br>输入格式：</li></ul><p>每组测试第1行包含2个正整数N（&lt;= 1000）和M（&lt;= 20），分别是插入元素的个数、以及需要判断的命题数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。之后M行，每行给出一个命题。题目保证命题中的结点键值都是存在的。</p><p>输出格式：</p><p>对输入的每个命题，如果其为真，则在一行中输出“T”，否则输出“F”。</p><p>输入样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">46 23 26 24 10</span><br><span class="line">24 is the root</span><br><span class="line">26 and 23 are siblings</span><br><span class="line">46 is the parent of 23</span><br><span class="line">23 is a child of 10</span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F</span><br><span class="line">T</span><br><span class="line">F</span><br><span class="line">T</span><br></pre></td></tr></table></figure></p><p>首先提一下概念：堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子结点的值。<br>小顶堆是指每个父亲结点的值小于等于孩子结点的值，每个结点的值都是以它为根结点的子树的最小值。</p><p>题目要求根据给出的数值建立小顶堆，然后根据建立的小顶堆判断相应结点关系是否正确</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">99999999</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxm],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    a[++cnt] = x;</span><br><span class="line">    <span class="keyword">int</span> t = cnt;</span><br><span class="line">    <span class="keyword">while</span>(t&gt;<span class="number">1</span>&amp;&amp;(a[t/<span class="number">2</span>]&gt;a[t]))&#123;</span><br><span class="line">        a[t] = a[t/<span class="number">2</span>];</span><br><span class="line">        a[t/<span class="number">2</span>] = x;</span><br><span class="line">        t /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[t] = x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,x,y;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        creat(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        p[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'a'</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;y);</span><br><span class="line">            getline(<span class="built_in">cin</span>,s);</span><br><span class="line">            <span class="keyword">if</span>(p[x]/<span class="number">2</span>==p[y]/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"F\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'r'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[x]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"F\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'p'</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;y;</span><br><span class="line">            <span class="keyword">if</span>(p[x]==p[y]/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"F\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;y;</span><br><span class="line">            <span class="keyword">if</span>(p[x]/<span class="number">2</span>==p[y])&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"T\n"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"F\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>153. 寻找旋转排序数组中的最小值</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></p><p>这道题乍一看很纳闷，求最小元素不是一个sort就能搞定的吗？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后来看下标签，考点是二分查找<br>我们需要知道，对于一个区间A，如果A[start]    &lt;    A[stop]，那么该区间一定是有 序的了。<br>另外，由于不含重复元素，需要分两种情况。<br>对于一个轮转了的排序了的数组，<br>如果nums[mid]&gt;nums[left]，最小值一定在右半区间<br>如果nums[mid]&lt;nums[left]，最小值一定在左半区间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(size==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(size==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> min(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = size<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]&lt;nums[right])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;nums[left])&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;nums[left])&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(nums[left],nums[right]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>红顶商人胡雪岩</title>
      <link href="/%E9%98%85%E8%AF%BB/%E7%BA%A2%E9%A1%B6%E5%95%86%E4%BA%BA%E8%83%A1%E9%9B%AA%E5%B2%A9/"/>
      <url>/%E9%98%85%E8%AF%BB/%E7%BA%A2%E9%A1%B6%E5%95%86%E4%BA%BA%E8%83%A1%E9%9B%AA%E5%B2%A9/</url>
      
        <content type="html"><![CDATA[<p>　　期末考试最后一考完，吃完午饭，我便急匆匆出了校门，来到学校边上的新生公交站，冒着烈日等公交，当时太阳倒不算狠毒，但着实闷热得很。上午考的概率论很不理想，一道分值最高的计算题明明是送分题却让我看走眼，死心眼的以为老师出错题了，我已经不止一次考完交了卷才发觉自己犯了傻，但事后纠结自知已无用，也就将其抛之脑后罢了。额头上汗一滴滴的往下流，但也只能忍一忍了，因为早就计划好去一个地方参观参观－－胡雪岩故居。<br>　　以前一直没有意识到胡雪岩故居就在河坊街边上，因此即使路过怕是也没怎么在意，但这次想到要专门去访一访也并不是没有缘由的。我大学过的平平淡淡，唯一做的一件事就是养成了读书的习惯，纸质书也好，ｋｉｎｄｌｅ也好，一天不去读个及章节反倒不舒服了。最近一直在读的就是高阳写的《胡雪岩全传》，但有一点我也清楚，这毕竟只是小说，不可能与历史完全相合，因为关于胡雪岩的很多事迹其实本也就无法考证了，因此我也就只谈谈小说里的胡雪岩好了。说起来，读这种小说会让我有一种亲切感，一方面根据真人真事改编，另一方面，故事背景就发生在杭州，浙江一带，作为一个杭州人，哪怕读到一些地名倒也不会陌生。从书中的描述上来看，我对胡雪岩的佩服还是多过反感的，他身上有很多我所极欠缺的品质，总之作为一个商人，他几乎具备了商人所需的大部分优秀品质，被世人尊为商圣也不是毫无来由的。智商极高，于是不慌不乱，脑袋转动极快，一有了思路便快准狠的下手，不光快，而且严峻形势下还能考虑到方方面面，极为严谨不苟。<br>　　<img src="/img/胡雪岩2.jpg" alt="img"><br>　　另一方面，牛逼的就是他的为人处世实在是老到精炼，无论官场，商场，帮派各种地方都混得开，交际甚广。朋友不光多，而且重情重义，绝不都是一帮狗肉朋友！他对自己到算是有很清楚的认识，对做官没兴趣，知道自己生来就是做生意的，不做生意皮就痒痒。关于他做人打交道的漂亮之处，我就举一个例子好了。那是在红顶商人那部里面张太太说的一件事，这位张太太也就是那位钱庄的伙计张胖子的夫人，张胖子后来由于自己的雇主翻脸不认人，到上海开了家杂货店，与红红火火的胡雪岩比起来了算是落魄了，但胡雪岩还是想拉他一把，与他合伙开钱庄，这时张太太透露了多年前的一件事，那时胡雪岩被赶出钱庄，正是穷困潦倒之际，有一天竟跑来找张太太借钱，一问不为别的，还是为了朋友，当时胡雪岩一位朋友重病，急需买药治疗，穷的叮当响的胡雪岩依旧想办法为其筹钱，当时拿了自己的一枚戒指作抵押问张太太借了5两银子，说道“这枚戒指市面上也就值1两，但是我母亲留给我的，所以也看的比较贵重”，后来钱当然退了，但胡雪岩并没有把戒指收回去，因为“今日的5两与当时的5两怎可同日而语”。一件小事，或者一次小小的谈话，可以看出他做人的漂亮之处，因此交际圈拉得开也不是完全没道理的。<br>　　<img src="/img/胡雪岩3.jpg" alt="img"><br>　　当然，他的有些做法在很多人眼中倒并不算光彩，但他经商的能力确实是黑不掉的。从一个一穷二白的小伙计，到王有龄的知遇之恩，30年间平步青云，扶摇直上，甚至到了富可敌国，但悲剧性的一幕确实无法善终，最后一切在眨眼间竟就烟雾般消散，自己一生的经营毁于一旦，几日后抑郁而终，实在凄凉。这道又让我想起来了红楼梦里的贾府，繁华到幻灭，也就是一瞬间的事，简直让人分不清真假。他在元宝街的旧居总体还算方正，在我看来是挺大的了，正门进去假山林立，内湖内桥搭配得当，溶洞内也可方便出入，有许多珍贵的植物，谷物，包括厨房的摆设，都一点点映射出当日清末大户人家的生活景象，几圈逛下来累了，边找了个阴凉处木凳下坐了坐，闲暇之余顺便又看了一章节的小说，总体还算惬意。这里插一句，读书的时候出去逛逛真的不错，至少带着学生证门票可以半价。出了旧居，我便不行来到了另一处与胡雪岩有关的地方，想必你也已经猜到了，胡庆余堂，“大善人胡雪岩”开药店的初心就是想在后世留个好名，这点想必他倒可以知足了，当年威风江浙的胡道台，给人留下的胡庆余堂着实是一笔珍贵的财富。胡庆余堂至今在杭州还有多家门店，每天来看病的人络绎不绝，今天还碰巧有位带着几个老外在胡庆余堂博物馆做介绍的。百年过去，关于这位胡老爷的故事也都成了历史，就让我对这位杭州的实干家表示一份敬意吧，至少一生短暂，他没有稀里糊涂的就浪费过去了。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>80. 删除排序数组中的重复项 II</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II/</url>
      
        <content type="html"><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [1,1,1,2,2,3],</span><br><span class="line"></span><br><span class="line">函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,1,2,3,3],</span><br><span class="line"></span><br><span class="line">函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line">说明:</span><br></pre></td></tr></table></figure></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p><strong>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</strong></p><p>你可以想象内部操作如下:</p><p>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br>int len = removeDuplicates(nums);</p><p>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p><p>分析：要求删除一个排序数组中的中的重复项，每个元素要求最多出现两次。<br>首先，数组为空的时候特殊判断一下。然后用一个num计数标记，如果相邻两个数相等并且num小于2的时候直接后移，如果相邻两个数不相等，则后移完成后将num置为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]==nums[i])&#123;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">if</span>(num&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                    nums[++j] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[++j] = nums[i];</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>860. 柠檬水找零</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。</p><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[5,5,5,10,20]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure></p><p>解释：<br>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。<br>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。<br>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。<br>由于所有客户都得到了正确的找零，所以我们输出 true。<br>示例 2：</p><p>输入：[5,5,10]<br>输出：true<br>示例 3：</p><p>输入：[10,10]<br>输出：false<br>示例 4：</p><p>输入：[5,5,10,10,20]<br>输出：false<br>解释：<br>前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。<br>对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。<br>对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。<br>由于不是每位顾客都得到了正确的找零，所以答案是 false。</p><p>提示：</p><p>0 &lt;= bills.length &lt;= 10000<br>bills[i] 不是 5 就是 10 或是 20</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lemonadeChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt1 = <span class="number">0</span>,cnt2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bills.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bills[i]==<span class="number">5</span>)&#123;</span><br><span class="line">                cnt1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bills[i]==<span class="number">10</span>)&#123;</span><br><span class="line">                cnt2++;</span><br><span class="line">                cnt1--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bills[i]==<span class="number">20</span>)&#123;</span><br><span class="line">                cnt1--;</span><br><span class="line">                <span class="keyword">if</span>(cnt2==<span class="number">0</span>)&#123;</span><br><span class="line">                    cnt1 -=<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt2--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">if</span>(cnt1&lt;<span class="number">0</span>||cnt2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>441. 排列硬币</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/441-%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/441-%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81/</url>
      
        <content type="html"><![CDATA[<p>你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。</p><p>给定一个数字 n，找出可形成完整阶梯行的总行数。</p><p>n 是一个非负整数，并且在32位有符号整型的范围内。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = 5</span><br><span class="line"></span><br><span class="line">硬币可排列成以下几行:</span><br><span class="line">¤</span><br><span class="line">¤ ¤</span><br><span class="line">¤ ¤</span><br></pre></td></tr></table></figure></p><p>因为第三行不完整，所以返回2.<br>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = 8</span><br><span class="line"></span><br><span class="line">硬币可排列成以下几行:</span><br><span class="line">¤</span><br><span class="line">¤ ¤</span><br><span class="line">¤ ¤ ¤</span><br><span class="line">¤ ¤</span><br></pre></td></tr></table></figure></p><p>因为第四行不完整，所以返回3.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right =n;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> sum = mid*(mid+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;n)&#123;</span><br><span class="line">                 right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>744. 寻找比目标字母大的最小字母</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/744-%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/744-%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。</p><p>数组里字母的顺序是循环的。举个例子，如果目标字母target = ‘z’ 并且有序数组为 letters = [‘a’, ‘b’]，则答案返回 ‘a’。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;a&quot;</span><br><span class="line">输出: &quot;c&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;c&quot;</span><br><span class="line">输出: &quot;f&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;d&quot;</span><br><span class="line">输出: &quot;f&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;g&quot;</span><br><span class="line">输出: &quot;j&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;j&quot;</span><br><span class="line">输出: &quot;c&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;k&quot;</span><br><span class="line">输出: &quot;c&quot;</span><br></pre></td></tr></table></figure></p><p>注:</p><p>letters长度范围在[2, 10000]区间内。<br>letters 仅由小写字母组成，最少包含两个不同的字母。<br>目标字母target 是一个小写字母。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(letters.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letters.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(letters[i] &gt; target)</span><br><span class="line">                <span class="keyword">return</span> letters[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> letters[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这题其实是考察二分查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = letters.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = n;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid]&gt;target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> letters[left%n];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>747. 至少是其他数字两倍的最大数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/747-%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/747-%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在一个给定的数组nums中，总是存在一个最大元素 。</p><p>查找数组中的最大元素是否至少是数组中每个其他数字的两倍。</p><p>如果是，则返回最大元素的索引，否则返回-1。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [3, 6, 1, 0]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 6是最大的整数, 对于数组中的其他整数,</span><br><span class="line">6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1.</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1, 2, 3, 4]</span><br><span class="line">输出: -1</span><br><span class="line">解释: 4没有超过3的两倍大, 所以我们返回 -1.</span><br></pre></td></tr></table></figure></p><p>提示:</p><p>nums 的长度范围在[1, 50].<br>每个 nums[i] 的整数范围在 [0, 99].</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxm =<span class="number">0</span>,x = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        maxm = nums[x<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(maxm&gt;=nums[x<span class="number">-2</span>]*<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> m[maxm];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>561. 数组拆分 I</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/561-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86-I/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/561-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86-I/</url>
      
        <content type="html"><![CDATA[<p>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,4,3,2]</span><br><span class="line"></span><br><span class="line">输出: 4</span><br><span class="line">解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure></p><p>提示:</p><p>n 是正整数,范围在 [1, 10000].<br>数组中的元素范围在 [-10000, 10000].</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i+=<span class="number">2</span>)&#123;</span><br><span class="line">            res += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>532. 数组中的K-diff数对</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/532-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84K-diff%E6%95%B0%E5%AF%B9/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/532-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84K-diff%E6%95%B0%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [3, 1, 4, 1, 5], k = 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。</span><br></pre></td></tr></table></figure></p><p>尽管数组中有两个1，但我们只应返回不同的数对的数量。<br>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:[1, 2, 3, 4, 5], k = 1</span><br><span class="line">输出: 4</span><br><span class="line">解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 3, 1, 5, 4], k = 0</span><br><span class="line">输出: 1</span><br><span class="line">解释: 数组中只有一个 0-diff 数对，(1, 1)。</span><br></pre></td></tr></table></figure></p><p>注意:</p><p>数对 (i, j) 和数对 (j, i) 被算作同一数对。<br>数组的长度不超过10,000。<br>所有输入的整数的范围在 [-1e7, 1e7]。<br>分析，题目要求差为k的数对有多少对，这里当k为0时，数组里某个数出现大于2都算做1个数对，当k大于0，也需要去重，所以我用了两个容器，map用来映射计数，set用来结果去重。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>||k&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m ;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">if</span>(m[nums[i]]&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                   s.insert(nums[i]); </span><br><span class="line">                &#125;</span><br><span class="line">                    count = s.size();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(m[nums[i]+k]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    s.insert(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                count = s.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>455. 分发饼干</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</url>
      
        <content type="html"><![CDATA[<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>注意：</p><p>你可以假设胃口值为正。<br>一个小朋友最多只能拥有一块饼干。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3], [1,1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2], [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br></pre></td></tr></table></figure></p><p>分析：给定一个关于饼干的数组和一个关于胃口的数组，要求尽可能满足多的孩子，那么需要先对连个数组进行排序，尽可能让小饼干满足小胃口的，而不是那一块大饼干满足小胃口的，以此进行遍历计数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,index = <span class="number">0</span>;</span><br><span class="line">        sort(g.begin(),g.end());</span><br><span class="line">        sort(s.begin(),s.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=g[index])&#123;</span><br><span class="line">                res++;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">if</span>(index&gt;=g.size())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>453. 最小移动次数使数组元素相等</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/453-%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/453-%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动可以使 n - 1 个元素增加 1。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[1,2,3]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">只需要3次移动（注意每次移动会增加两个元素的值）：</span><br><span class="line"></span><br><span class="line">[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</span><br></pre></td></tr></table></figure></p><p>分析：逆向思考，每次移动让剩余的n-1个数加1，相当于每次移动让选定的那个数减1，<br>所以最少移动次数其实就是所有元素减去最小元素的和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX,sum = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;min)&#123;</span><br><span class="line">                min = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum-min*nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>L2-013 红色警报（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-013-%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%8A%A5%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-013-%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%8A%A5%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>L2-013 红色警报（25 分）<br>战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。</p><p>输入格式：</p><p>输入在第一行给出两个整数N（0 &lt; N &lt;=500）和M（&lt;=5000），分别为城市个数（于是默认城市从0到N-1编号）和连接两城市的通路条数。随后M行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数K和随后的K个被攻占的城市的编号。</p><p>注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。</p><p>输出格式：</p><p>对每个被攻占的城市，如果它会改变整个国家的连通性，则输出“Red Alert: City k is lost!”，其中k是该城市的编号；否则只输出“City k is lost.”即可。如果该国失去了最后一个城市，则增加一行输出“Game Over.”。</p><p>输入样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">0 1</span><br><span class="line">1 3</span><br><span class="line">3 0</span><br><span class="line">0 4</span><br><span class="line">5</span><br><span class="line">1 2 0 4 3</span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">City 1 is lost.</span><br><span class="line">City 2 is lost.</span><br><span class="line">Red Alert: City 0 is lost!</span><br><span class="line">City 4 is lost.</span><br><span class="line">City 3 is lost.</span><br><span class="line">Game Over.</span><br></pre></td></tr></table></figure></p><p>方法一：用dfs判断是否连通并且计算连通数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">550</span>;</span><br><span class="line"><span class="keyword">int</span> edge[maxm][maxm];</span><br><span class="line"><span class="keyword">int</span> visit[maxm],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    visit[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[i]&amp;&amp;edge[x][i])&#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Calcnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[i])&#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="keyword">sizeof</span>(edge));</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        edge[a][b] = <span class="number">1</span>;</span><br><span class="line">        edge[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cntt = Calcnt();</span><br><span class="line">    <span class="keyword">int</span> k,city;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;city);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[city][j])&#123;</span><br><span class="line">                edge[city][j] = <span class="number">0</span>;</span><br><span class="line">                edge[j][city] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">        <span class="keyword">int</span> temp = Calcnt();</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;cntt+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Red Alert: City %d is lost!\n"</span>,city);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"City %d is lost.\n"</span>,city);</span><br><span class="line">        &#125;</span><br><span class="line">        cntt = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Game Over.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：并查集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">550</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">&#125;edge[<span class="number">5005</span>];</span><br><span class="line"><span class="keyword">int</span> visit[maxm],fa[maxm];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x])&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Find(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xc = Find(x);</span><br><span class="line">    <span class="keyword">int</span> yc = Find(y);</span><br><span class="line">    <span class="keyword">if</span>(xc!=yc)&#123;</span><br><span class="line">        fa[xc] = yc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k,u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        edge[i].u = u;</span><br><span class="line">        edge[i].v = v;</span><br><span class="line">        Union(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">0</span>,num2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[i]==i)&#123;</span><br><span class="line">            num1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">        num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> city;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;city);</span><br><span class="line">        visit[city] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[edge[i].u]==<span class="number">1</span>||visit[edge[i].v]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Union(edge[i].u,edge[i].v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[i]==i)&#123;</span><br><span class="line">                num2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num1==num2||num1+<span class="number">1</span>==num2)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"City %d is lost.\n"</span>,city);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Red Alert: City %d is lost!\n"</span>,city);</span><br><span class="line">        &#125;</span><br><span class="line">        num1 = num2;</span><br><span class="line">    &#125;</span><br><span class="line">    num1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            num1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num1==n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Game Over.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>L2-014 列车调度（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-014-%E5%88%97%E8%BD%A6%E8%B0%83%E5%BA%A6%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-014-%E5%88%97%E8%BD%A6%E8%B0%83%E5%BA%A6%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>L2-014 列车调度（25 分）<br>火车站的列车调度铁轨的结构如下图所示。</p><p>\ Figure</p><p>两端分别是一条入口（Entrance）轨道和一条出口（Exit）轨道，它们之间有N条平行的轨道。每趟列车从入口可以选择任意一条轨道进入，最后从出口离开。在图中有9趟列车，在入口处按照{8，4，2，5，3，9，1，6，7}的顺序排队等待进入。如果要求它们必须按序号递减的顺序从出口离开，则至少需要多少条平行铁轨用于调度？</p><p>输入格式：</p><p>输入第一行给出一个整数N (2 &lt;= N &lt;= 10^5^)，下一行给出从1到N的整数序号的一个重排列。数字间以空格分隔。</p><p>输出格式：</p><p>在一行中输出可以将输入的列车按序号递减的顺序调离所需要的最少的铁轨条数。</p><p>输入样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">8 4 2 5 3 9 1 6 7</span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p><p>分析：求最少下降子序列数，即求最长上升子序列长度<br>关于 Dilworth定理：<br>Dilworth定理根据序列划分的最小数量的链描述了任何有限偏序集的宽度。<br>定理内容：<br>反链是一种偏序集，其任意两个元素不可比；而链则是一种任意两个元素可比的偏序集。Dilworth定理说明，存在一个反链A与一个将序列划分为链族P的划分，使得划分中链的数量等于集合A的基数。当存在这种情况时，对任何至多能包含来自P中每一个成员一个元素的反链，A一定是此序列中的最大反链。同样地，对于任何最少包含A中的每一个元素的一个链的划分，P也一定是序列可以划分出的最小链族。偏序集的宽度被定义为A与P的共同大小。<br>另一种Dilworth定理的等价表述是：在有穷偏序集中，任何反链最大元素数目等于任何将集合到链的划分中链的最小数目。一个关于无限偏序集的理论指出，在此种情况下，一个偏序集具有有限的宽度w，当且仅当它可以划分为最少w条链。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> n,d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;d);</span><br><span class="line">        <span class="keyword">if</span>(s.empty())&#123;</span><br><span class="line">            s.insert(d);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">            it = s.lower_bound(d);</span><br><span class="line">            <span class="keyword">if</span>(it==s.end())&#123;</span><br><span class="line">                s.insert(d);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s.erase(it);</span><br><span class="line">                s.insert(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,s.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>771. 宝石与石头</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/771-%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/771-%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<p>给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J = &quot;z&quot;, S = &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></p><p>注意:</p><p>S 和 J 最多含有50个字母。<br> J 中的字符不重复。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;J.size();i++)&#123;</span><br><span class="line">            hash[J[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;S.size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[S[j]])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>728. 自除数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/728-%E8%87%AA%E9%99%A4%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/728-%E8%87%AA%E9%99%A4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>自除数 是指可以被它包含的每一位数除尽的数。</p><p>例如，128 是一个自除数，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。</p><p>还有，自除数不允许包含 0 。</p><p>给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">上边界left = 1, 下边界right = 22</span><br><span class="line">输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]</span><br></pre></td></tr></table></figure></p><p>注意：</p><p>每个输入参数的边界满足 1 &lt;= left &lt;= right &lt;= 10000。</p><p>题目要求求出某个区间内的自除数，直接遍历整个区间就可以，并根据定义写一个判断是否为自除数的函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; selfDividingNumbers(<span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = left;n &lt;= right;n++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(selfDividing(n))&#123;</span><br><span class="line">                res.push_back(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">bool</span> <span class="title">selfDividing</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>||(n%(s[i]-<span class="string">'0'</span>)&gt;<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>852. 山脉数组的峰顶索引</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/852-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/852-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>我们把符合下列属性的数组 A 称作山脉：</p><p>A.length &gt;= 3<br>存在 0 &lt; i &lt; A.length - 1 使得A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]<br>给定一个确定为山脉的数组，返回任何满足 A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 的 i 的值。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[0,1,0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[0,2,1,0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></p><p>提示：</p><p>3 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt;= 10^6<br>A 是如上定义的山脉</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;A[i+<span class="number">1</span>])&#123;</span><br><span class="line">                 temp = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>L2-021 点赞狂魔（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-021-%E7%82%B9%E8%B5%9E%E7%8B%82%E9%AD%94%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-021-%E7%82%B9%E8%B5%9E%E7%8B%82%E9%AD%94%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>L2-021 点赞狂魔（25 分）<br>微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。然而有这么一种人，他们会通过给自己看到的一切内容点赞来狂刷存在感，这种人就被称为“点赞狂魔”。他们点赞的标签非常分散，无法体现出明显的特性。本题就要求你写个程序，通过统计每个人点赞的不同标签的数量，找出前3名点赞狂魔。</p><p>输入格式：</p><p>输入在第一行给出一个正整数N（&lt;=100），是待统计的用户数。随后N行，每行列出一位用户的点赞标签。格式为“Name K F~1~ … F~K~”，其中 Name 是不超过8个英文小写字母的非空用户名，1&lt;=K&lt;=1000，F~i~（i=1, …, K）是特性标签的编号，我们将所有特性标签从1到10^7^编号。数字间以空格分隔。</p><p>输出格式：</p><p>统计每个人点赞的不同标签的数量，找出数量最大的前3名，在一行中顺序输出他们的用户名,其间以1个空格分隔,且行末不得有多余空格。如果有并列，则输出标签出现次数平均值最小的那个，题目保证这样的用户没有并列。若不足3人，则用“-”补齐缺失，例如“mike jenny -”就表示只有2人。</p><p>输入样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">bob 11 101 102 103 104 105 106 107 108 108 107 107</span><br><span class="line">peter 8 1 2 3 4 3 2 5 1</span><br><span class="line">chris 12 1 2 3 4 5 6 7 8 9 1 2 3</span><br><span class="line">john 10 8 7 6 5 4 3 2 1 7 5</span><br><span class="line">jack 9 6 7 8 9 10 11 12 13 14</span><br></pre></td></tr></table></figure></p><p>输出样例：</p><p>jack chris john<br>分析：创建一个关于点赞人的结构体，然后对其根据不同标签数和出现次数平均值最小进行排序，不同标签数可以用set计算，出现次数平均最小即每次k最小。排序后根据是否满足3人分类输出。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">people</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">11</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt,num;</span><br><span class="line">&#125;a[<span class="number">1111</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(people a,people b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.cnt!=b.cnt)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.cnt&gt;b.cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.num&lt;b.num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k,n,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i].name);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        s.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            s.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        a[i].cnt = s.size();</span><br><span class="line">        a[i].num = k;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+n,cmp);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;min(n,<span class="number">3</span>);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,a[i].name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>657. 判断路线成圈</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/657-%E5%88%A4%E6%96%AD%E8%B7%AF%E7%BA%BF%E6%88%90%E5%9C%88/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/657-%E5%88%A4%E6%96%AD%E8%B7%AF%E7%BA%BF%E6%88%90%E5%9C%88/</url>
      
        <content type="html"><![CDATA[<p>初始位置 (0, 0) 处有一个机器人。给出它的一系列动作，判断这个机器人的移动路线是否形成一个圆圈，换言之就是判断它是否会移回到原来的位置。</p><p>移动顺序由一个字符串表示。每一个动作都是由一个字符来表示的。机器人有效的动作有 R（右），L（左），U（上）和 D（下）。输出应为 true 或 false，表示机器人移动路线是否成圈。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;UD&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LL&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>分析：要求能回到原位置，那么左右 和上下所移动的步数必须对应相等。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L=<span class="number">0</span>,R=<span class="number">0</span>,U=<span class="number">0</span>,D=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;moves.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(moves[i]==<span class="string">'L'</span>)&#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(moves[i]==<span class="string">'R'</span>)&#123;</span><br><span class="line">                R++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(moves[i]==<span class="string">'U'</span>)&#123;</span><br><span class="line">                U++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(moves[i]==<span class="string">'D'</span>)&#123;</span><br><span class="line">                D++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L==R&amp;&amp;U==D)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>633. 平方数之和</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/633-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/633-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。</p><p>示例1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: True</span><br><span class="line">解释: 1 * 1 + 2 * 2 = 5</span><br></pre></td></tr></table></figure></p><p>示例2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i*i&lt;=c;i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> x = <span class="built_in">sqrt</span>(c-i*i);</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="keyword">int</span>(x))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>628. 三个数的最大乘积</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: 24</span><br></pre></td></tr></table></figure></p><p>注意:</p><p>给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。<br>输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。</p><p>分析：主要就是考虑负数的情况，<br>第一种：给定的数全是负数，<br>第二种：负数和正数都有<br>第三种：全是正数<br>首先对数组排序，答案不外乎是后三个数相乘或者前两个数乘以最后一个数，两种<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> a = nums[n<span class="number">-1</span>]*nums[n<span class="number">-2</span>]*nums[n<span class="number">-3</span>];</span><br><span class="line">        <span class="keyword">int</span> b = nums[<span class="number">0</span>]*nums[<span class="number">1</span>]*nums[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b||nums[n<span class="number">-1</span>]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>575. 分糖果</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/575-%E5%88%86%E7%B3%96%E6%9E%9C/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/575-%E5%88%86%E7%B3%96%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<p>给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candies = [1,1,2,2,3,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure></p><p>解析: 一共有三种种类的糖果，每一种都有两个。<br>     最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。<br>示例 2 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candies = [1,1,2,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。<br>注意:</p><p>数组的长度为[2, 10,000]，并且确定为偶数。<br>数组中数字的大小在范围[-100,000, 100,000]内。</p><p>分析：题目给定偶数n个种类不确定的糖果，要求平均分给弟弟和妹妹，并且妹妹分得的糖果种类要求尽可能多。首先因为给定的是偶数个，所以两人分得的糖果数必然相等，都为n/2,我们只需考虑原先糖果总的种类数，显然如果总的种类大于等于n/2,那么妹妹最大种类便是n/2，否则妹妹的最大种类数就是原先糖果的最大种类总数。而获取原先糖果的最大种类，利用set的去重就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; sum;</span><br><span class="line">        <span class="keyword">int</span> n = candies.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum.insert(candies[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = sum.size();</span><br><span class="line">        <span class="keyword">if</span>(m&gt;=n/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《追随》</title>
      <link href="/%E5%BD%B1%E9%9F%B3/%E3%80%8A%E8%BF%BD%E9%9A%8F%E3%80%8B/"/>
      <url>/%E5%BD%B1%E9%9F%B3/%E3%80%8A%E8%BF%BD%E9%9A%8F%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>　　我之前一直没有写影评的习惯，看完电影，好就是好，烂就是烂，或喜、或悲、或震撼、或沉思，总之看完也就过去了，也不敢妄加品论，以免误导他人。但最近慢慢开始养成了写观后感的习惯，针对自己喜欢的，格调比较高的，或多或少结合自己的理解想写点感受。包括阅读也是，读书笔记是我向来忽略的一点，但这其实相当重要，倘若你想加深理解的话。<br>　　我平时看电影，很少会关注导演的信息，但这次确实不得不提一下这部《追随》的导演－－克里斯托弗·诺兰。网上一搜，才发现他的电影我都已经看过不下１０部，其中有很多都是被我奉为经典的作品。</p><ul><li><p>《追随》<br>1996年，诺兰拍了首部故事片《跟踪》。电影描述了一位作家逐渐成为一个跟踪癖的故事。电影完全不按事件发生顺序呈现，观众不得不随主角一起拼接情节碎片以了解当时究竟发生了什么。</p></li><li><p>《记忆碎片》<br>2000年电影《记忆碎片》票房仍属上乘，并被称为邪典之作，获金球奖和奥斯卡奖的最佳编剧奖提名。</p></li><li><p>《蝙蝠侠》三部曲</p></li><li><p>《致命魔术》</p></li></ul><p>2006年10月20日发行的《致命魔术》改编自克里斯托弗·普雷斯特（Christopher Priest）的同名小说，是关于19世纪两个互为对手的魔术师的故事。</p><ul><li><p>《盗梦空间》<br>一部科幻悬疑片，片中梦中梦的剧情着实很吸引人。</p></li><li><p>《星际穿越》</p></li></ul><p>2014年的《星际穿越》讲述一队探险者根据当代重力及天体权威物理学家基普·索恩的理论，突破科学极限、穿越“虫洞”来寻找适合人类生存的星球的冒险故事。</p><ul><li>《敦刻尔克》<br>故事改编自著名的二战军事事件“敦克尔克大撤退”。二战初期，40万的英法盟军被敌军围困于敦刻尔克的海滩之上，面对敌军步步逼近的绝境，他们不得不为自己的命运背水一战，才有可能活着回家。</li></ul><p>　　以上列举了几部我看过的诺兰的作品，基本符合时间线，看过的人想必也就可以想象诺兰一步步的封神之路是怎么走过来的。<br>　　《追随》是诺兰的导演处女作。由诺兰自编自导，杰里米·西奥伯德、亚历克斯·霍、露西·拉塞尔等人主演的惊悚片。<br>　　剧情梗概－－女主角是一个黑帮老大的情妇 。此黑帮老大某天在情妇家中杀掉了一个人，情妇家中的地毯上留下了血迹，情妇把地毯藏了起来，并且以此勒索黑帮老大。这是整个事情的起因。老大无法忍受情妇的勒索，派出假名叫柯布的杀手去解决这个麻烦，并且要求了杀人手法和地点（用锤子，在情妇家）。<br>　　“在很长时间里，我都是一个人生活。这种生活变得越来越孤单，并且乏味。一整天无事可做，就那么呆着。从那时起，我开始尾随别人”，影片以此开头，引入了男主，一个无业游民，一个幻想成为作家的作家，一个孤独的男人。诺兰着眼于剧情的连环与绕圈，他希望给观众一种走入迷宫的感觉，他曾说：“我决定以这种方式来组织我的故事，将重点放在观众对每一个新的场景不可能有完全的理解上，就像它是第一次被人们看到一样。”要做到这一点，影片的布局就不能简单处理，不能让观众在几分钟内看破剧情，然后感叹一波无趣。<br>　　说实话，我有点难以理解比尔的做法，或许是因为我没亲眼见过生活中真正由于这种原因尾随他人的人吧。孤独人我见过不少，迷茫的人，事业不顺的人身边一抓一大把，但是像比尔这样的，据他自己说尾随他人是为了寻找发现写作的素材，多么冠冕堂皇的一个理由，事实真的如此吗，对于他的追随动机也是我很好奇的一点。试想一下，一个极端孤独的年轻人，一个缺乏社交的可怜虫，心理扭曲而萌生了尾随陌生人的想法，甚至为自己的尾随做出了规范，要求随机性等等，这里其实涉及到了人性的方面，心理学的方面，我相信他和有些孤独的人不同，他是否是自己内心主动排斥社交？还是真正的社交无能？同时他又有着极强的好奇心，好奇他人的生活。他的行为毫无以为已然涉及到了犯罪，尽管他并无恶意，并无功利之心。<br>　　在剧情方面，电影围绕骗中骗，连环展开。之前提到了比尔，一个心理怪异的尾随狂，原本一切都没什么异常，他继续他的尾随就行了，但有一天，他对柯布发生了兴趣，也就是从那一刻起他已然落入陷阱，柯布是一位反侦察高手，一番观察与交谈，便已将比尔当做自己的棋子，为自己的任务开路。两人仿佛志同道合，开始一同作案，一起入室行窃，目的却不是钱，而是“人”，同时柯布开始传授比尔作案技巧，让比尔一步步模仿自己，然后成为自己的替罪羊。行窃过程中柯布有些偷窃心得倒是挺有意思的。第一个，盒子，他发现很多屋主都会有一个小盒子，里面不会放什么值钱的物品，但往往都是些私人物品，但却能折射出关于主人的真实世界。盒子一般是个鞋盒，放着自己私密的小东西。偷盗的哲学在于，丢了东西，才意识到拥有过。还有一个，当比尔被值钱行窃过的主人对视时，慌张不已的样子，柯布却来了句“虽然你行的是鸡鸣狗盗之事，但也不用摆出一副鸡鸣狗盗之相”．．．<br>　　慢慢慢慢，比尔在柯布的诱导下开始接触了金发女郎，当然也对她的房间行窃过。金发女郎是一位黑道大佬的情人，但比尔却一步步爱上了他，因为爱上，导致最后完全深陷泥潭而无法逃脱。他不知道，金发女郎和柯布其实暗中早已认识，沟通，此二人希望设局，找一位替罪羊，为自己脱罪，而这只可怜的替罪羊自然就是比尔，没有比他更好的选择了。而金发女郎自以为自己也是设局者，却不知其实自己也是一只可怜的羔羊。也是从一开始，金发女郎便已经是柯布的目标了，只是未能察觉。诺兰就是围绕这样一个剧情展开环式叙述，加深悬疑层次，用故事吸引了一大波影迷。只是这样的一个连环计在我看来似乎还是牵强了点，在逻辑上的严密感不是足够的强大，我只能默认是剧情需要了。当然了，对内容与真实的要求我想应该也不是诺兰最看重的，诺兰介绍自己时也曾提到“我不仅是一名导演，更是一个拥有奇想的人”。想来也是，如若没有一个奇思妙想，脑洞打开的头脑，怎么能编出令人赞叹不已的一部部神作。</p>]]></content>
      
      
      <categories>
          
          <category> 影音 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>557. 反转字符串中的单词 III</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-III/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-III/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;Let&apos;s take LeetCode contest&quot;</span><br><span class="line">输出: &quot;s&apos;teL ekat edoCteeL tsetnoc&quot;</span><br><span class="line">注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == s.length() || s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">        reverse(s.begin() + index, s.begin() + i);</span><br><span class="line">        index = i + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>551. 学生出勤纪录 I</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/551-%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E7%BA%AA%E5%BD%95-I/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/551-%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E7%BA%AA%E5%BD%95-I/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串来代表一个学生的出勤纪录，这个纪录仅包含以下三个字符：</p><p>‘A’ : Absent，缺勤<br>‘L’ : Late，迟到<br>‘P’ : Present，到场<br>如果一个学生的出勤纪录中不超过一个’A’(缺勤)并且不超过两个连续的’L’(迟到),那么这个学生会被奖赏。</p><p>你需要根据这个学生的出勤纪录判断他是否会被奖赏。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;PPALLP&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;PPALLL&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkRecord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>,num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'A'</span>)&#123;</span><br><span class="line">                num1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'L'</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">'L'</span>&amp;&amp;s[i+<span class="number">2</span>]==<span class="string">'L'</span>)&#123;</span><br><span class="line">                num2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num1&lt;=<span class="number">1</span>&amp;&amp;num2==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>485. 最大连续1的个数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定一个二进制数组， 计算其中最大连续1的个数。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,0,1,1,1]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.</span><br></pre></td></tr></table></figure></p><p>注意：</p><p>输入的数组只包含 0 和1。<br>输入数组的长度是正整数，且不超过 10,000。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxm = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;maxm)&#123;</span><br><span class="line">                    maxm = cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxm = max(maxm,cnt);</span><br><span class="line">        <span class="keyword">return</span> maxm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>448. 找到所有数组中消失的数字</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure></p><p>我的思路：利用set的唯一性和自动排序，将原数组中的元素插入set，然后从1到n进行遍历，找到不存在的数字<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDisappearedNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">       <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; nums2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            nums2.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=nums2.begin();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=*it)&#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(it==nums2.end())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             it++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>434. 字符串中的单词数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p><p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;Hello, my name is John&quot;</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">' '</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;n&amp;&amp;s[i]!=<span class="string">' '</span>)&#123;i++;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>415. 字符串相加</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/415-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/415-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p><p>注意：</p><p>num1 和num2 的长度都小于 5100.<br>num1 和num2 都只包含数字 0-9.<br>num1 和num2 都不包含任何前导零。<br>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</p><p>字符串相加，类似二进制链表的相加，一位一位计算，然后逐为求和求进位，根据进位判断是否需要补高位、<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> m = num1.size(),n = num2.size(),i=m<span class="number">-1</span>,j = n<span class="number">-1</span>,carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a , b;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                a = num1[i--]-<span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                a = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                b = num2[j--]-<span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sum = a+b+carry;</span><br><span class="line">            res.insert(res.begin(),sum%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">            carry = sum/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"1"</span>+res;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>400. 第N个数字</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/400-%E7%AC%ACN%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/400-%E7%AC%ACN%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n 个数字。</p><p>注意:<br>n 是正数且在32为整形范围内 ( n &lt; 231)。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>说明:<br>第11个数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … 里是0，它是10的一部分。</p><p>将整数序列划分为下列区间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1   1-9</span><br><span class="line">2   10-99</span><br><span class="line">3   100-999</span><br><span class="line">4   1000-9999</span><br><span class="line">5   10000-99999</span><br><span class="line">6   100000-999999</span><br><span class="line">7   1000000-9999999</span><br><span class="line">8   10000000-99999999</span><br><span class="line">9   100000000-99999999</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>, base = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">9L</span>*base*len)&#123;</span><br><span class="line">            n -= <span class="number">9</span>*base*len;</span><br><span class="line">            len++;</span><br><span class="line">            base *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> curNum = (n<span class="number">-1</span>)/len + base, digit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(n<span class="number">-1</span>)%len;i&lt;len;++i)&#123;</span><br><span class="line">            digit = curNum%<span class="number">10</span>;</span><br><span class="line">            curNum /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>405. 数字转换为十六进制数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/405-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/405-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。</p><p>注意:</p><p>十六进制中所有字母(a-f)都必须是小写。<br>十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符’0’来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。<br>给定的数确保在32位有符号整数范围内。<br>不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。<br>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">26</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">&quot;1a&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">&quot;ffffffff&quot;</span><br></pre></td></tr></table></figure></p><p>要将一个十进制数转换为十六进制数，不管其是正数还是负数，都只需要将其二进制表示每四位分成一个单元，将其取出后计算这四位二进制数代表的十进制数，与0~f之间的数字做一个映射即可。要把每四位取出也很简单，与0xf进行AND运算即可。<br>在C++中，左移是逻辑移位，也就是说在数字后面补0，右移运算符是算术移位，也就是在左侧补符号位(正数补0，负数补1<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>,high=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">16</span>]=&#123;<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(num&amp;&amp;res.size()&lt;<span class="number">8</span>)&#123;</span><br><span class="line">            res=<span class="built_in">map</span>[(num&amp;<span class="number">0xf</span>)]+res;</span><br><span class="line">            num=num&gt;&gt;<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>404. 左叶子之和</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>计算给定二叉树的所有左叶子之和。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p><p>递归写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>&amp;&amp;root-&gt;left-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;left-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            sum += root-&gt;left-&gt;val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum += sumOfLeftLeaves(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        sum += sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>迭代写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode* temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)&#123;</span><br><span class="line">                q.push(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left-&gt;left==<span class="literal">NULL</span>&amp;&amp;temp-&gt;left-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    sum += temp-&gt;left-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right)&#123;</span><br><span class="line">                q.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>387. 字符串中的第一个唯一字符</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p>案例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;leetcode&quot;</span><br><span class="line">返回 0.</span><br><span class="line"></span><br><span class="line">s = &quot;loveleetcode&quot;,</span><br><span class="line">返回 2.</span><br></pre></td></tr></table></figure></p><p>注意事项：您可以假定该字符串只包含小写字母。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">300</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            a[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[s[i]]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>303. 区域和检索 - 数组不可变</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>你可以假设数组不可变。<br>会多次调用 sumRange 方法。</p><p>新建一个dp数组，用来保存相应前个数的和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums) &#123;</span><br><span class="line">        dp.resize(nums.size()+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums.size();++i)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[j+<span class="number">1</span>]-dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>290. 单词模式</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/290-%E5%8D%95%E8%AF%8D%E6%A8%A1%E5%BC%8F/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/290-%E5%8D%95%E8%AF%8D%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>给定一种 pattern(模式) 和一个字符串 str ，判断 str 是否遵循相同的模式。</p><p>这里的遵循指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应模式。</p><p>示例1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>说明:<br>你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; m1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m2;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(str)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> word;in&gt;&gt;word;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m1.find(pattern[i])!=m1.end()||m2.find(word)!=m2.end())&#123;</span><br><span class="line">                <span class="keyword">if</span>(m1[pattern[i]]!=m2[word])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m1[pattern[i]] = m2[word] = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i==pattern.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>278. 第一个错误的版本</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 n = 5，并且 version = 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br></pre></td></tr></table></figure></p><p>所以，4 是第一个错误的版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of isBadVersion API.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBadVersion</span><span class="params">(<span class="keyword">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> high = n;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = isBadVersion(mid);</span><br><span class="line">            <span class="keyword">if</span>(temp)&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《无题》北岛</title>
      <link href="/%E9%98%85%E8%AF%BB/%E3%80%8A%E6%97%A0%E9%A2%98%E3%80%8B%E5%8C%97%E5%B2%9B/"/>
      <url>/%E9%98%85%E8%AF%BB/%E3%80%8A%E6%97%A0%E9%A2%98%E3%80%8B%E5%8C%97%E5%B2%9B/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>对于世界</p><p>我永远是个陌生人</p><p>我不懂它的言语</p><p>他不懂我的沉默</p><p>我们交换的</p><p>只是一点轻蔑</p><p>如同相逢在镜子里</p><p>对于自己</p><p>我永远是个陌生人</p><p>我畏惧黑暗</p><p>却用身体挡住了</p><p>那唯一的灯</p><p>我的影子是我的情人</p><p>心是仇敌</p></blockquote><p>北岛的诗集里面，这首是我蛮喜欢的一首。</p><p>我爱诗愛词，爱李白的浪漫豪放，爱杜甫的忧国忧民，我爱古典诗，我也爱现代诗。</p><p>我遗憾，我遗憾自己的无才无能，遗憾自己不能像诗人般脱口成诗，吟唱古今。</p><p>“对于世界，我永远是个陌生人”，难道不是吗，地球没了我照样转，世界没了我，并不会就此停滞。我只是个路人，和所有人一样，来这世上走一遭，来看看这世界，尽管世界不会记得我来过。</p><p>“我们交换的，只是一点轻蔑，如同相逢在镜子里”<br>我无法容忍这狭隘、势利的世界，世界眼中又何曾有过我，互相的轻蔑吧。</p><p>“我畏惧黑暗，却用身体挡住了，那唯一的灯”<br>我的矛盾，我的孤独，哎，我不愿与这世界妥协，不愿与自己妥协，让我独自挣扎吧，让我独自探索吧。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>414. 第三大的数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/414-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/414-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [3, 2, 1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure></p><p>解释: 第三大的数是 1.<br>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>解释: 第三大的数不存在, 所以返回最大的数 2 .<br>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2, 2, 3, 1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure></p><p>解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。<br>存在两个值为2的数，它们都排第二。</p><p>返回第三大且又是唯一出现的数，这里涉及到了排序和去重，所以想到用set来做，因为set是自动去重并升序的容器，但有一点，访问set集合里的元素只能通过迭代器的形式进行访问，而不能通过下标。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            res.insert(nums[i]);</span><br><span class="line">            <span class="keyword">int</span> len = res.size();</span><br><span class="line">        <span class="keyword">if</span>(len&gt;<span class="number">3</span>)&#123;</span><br><span class="line">            res.erase(res.begin());</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size()==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> *res.begin();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *res.rbegin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>389. 找不同</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/389-%E6%89%BE%E4%B8%8D%E5%90%8C/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/389-%E6%89%BE%E4%B8%8D%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<p>给定两个字符串 s 和 t，它们只包含小写字母。</p><p>字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 t 中被添加的字母。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">s = &quot;abcd&quot;</span><br><span class="line">t = &quot;abcde&quot;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">e</span><br></pre></td></tr></table></figure></p><p>解释：<br>‘e’ 是那个被添加的字母。</p><p>分析：可以求出两个字符串的ASCII总和的差值，而这个差值就对应着被添加的字母的ASCII数值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>,sum2 = <span class="number">0</span>,dif = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            sum1 += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.size();i++)&#123;</span><br><span class="line">            sum2 += t[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dif = sum2-sum1;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">char</span>)dif;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>374. 猜数字大小</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/374-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/374-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<p>我们正在玩一个猜数字游戏。 游戏规则如下：<br>我从 1 到 n 选择一个数字。 你需要猜我选择了哪个数字。<br>每次你猜错了，我会告诉你这个数字是大了还是小了。<br>你调用一个预先定义好的接口 guess(int num)，它会返回 3 个可能的结果（-1，1 或 0）：</p><p>-1 : 我的数字比较小<br> 1 : 我的数字比较大<br> 0 : 恭喜！你猜对了！<br>示例:</p><p>n = 10, 我选择 6.</p><p>返回 6.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of guess API.</span></span><br><span class="line"><span class="comment">// @param num, your guess</span></span><br><span class="line"><span class="comment">// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">guess</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = guess(n);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>,right = n;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> x = guess(mid);</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">-1</span>)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>链表常见题型整理</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B%E6%95%B4%E7%90%86/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-将链表进行翻转"><a href="#1-将链表进行翻转" class="headerlink" title="1. 将链表进行翻转"></a>1. 将链表进行翻转</h1><p>从头到尾遍历原链表，每遍历有关结点，将其摘下放在新链表的最前端。注意链表为空和只有一个结点的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode * <span class="title">ReverseList</span><span class="params">(ListNode * pHead)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 如果链表为空或只有一个结点，无需反转，直接返回原链表头指针</span></span><br><span class="line">  <span class="keyword">if</span>(pHead == <span class="literal">NULL</span> || pHead-&gt;m_pNext == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">  ListNode * pReversedHead = <span class="literal">NULL</span>; <span class="comment">// 反转后的新链表头指针，初始为NULL</span></span><br><span class="line">  ListNode * pCurrent = pHead;</span><br><span class="line">  <span class="keyword">while</span>(pCurrent != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    ListNode * pTemp = pCurrent;</span><br><span class="line">    pCurrent = pCurrent-&gt;m_pNext;</span><br><span class="line">    pTemp-&gt;m_pNext = pReversedHead; <span class="comment">// 将当前结点摘下，插入新链表的最前端</span></span><br><span class="line">    pReversedHead = pTemp;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> pReversedHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-查找链表的中间结点"><a href="#2-查找链表的中间结点" class="headerlink" title="2. 查找链表的中间结点"></a>2. 查找链表的中间结点</h1><p>设置两个指针，两个指针同时向前走，前面的指针每次走两步，后面的指针每次走一步，前面的指针走到最后一个结点时，后面的指针所指的结点就是中间结点，即第 (n / 2 + 1) 个结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode * <span class="title">GetMiddleNode</span><span class="params">(ListNode * pHead)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链表为空或只有一个结点，返回头指针</span></span><br><span class="line">  <span class="keyword">if</span>(pHead == <span class="literal">NULL</span> || pHead-&gt;m_pNext == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line"></span><br><span class="line">  ListNode * pAhead = pHead;</span><br><span class="line">  ListNode * pBehind = pHead;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前面指针每次走两步，直到指向最后一个结点，后面指针每次走一步</span></span><br><span class="line">  <span class="keyword">while</span>(pAhead-&gt;m_pNext != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    pAhead = pAhead-&gt;m_pNext;</span><br><span class="line">    pBehind = pBehind-&gt;m_pNext;</span><br><span class="line">    <span class="keyword">if</span>(pAhead-&gt;m_pNext != <span class="literal">NULL</span>)</span><br><span class="line">      pAhead = pAhead-&gt;m_pNext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后面的指针所指结点即为中间结点</span></span><br><span class="line">  <span class="keyword">return</span> pBehind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-查找链表倒数第-k-个结点"><a href="#3-查找链表倒数第-k-个结点" class="headerlink" title="3. 查找链表倒数第 k 个结点"></a>3. 查找链表倒数第 k 个结点</h1><p>使用两个指针，先让前面的指针走到正向的第k个结点，这样前后两个指针的距离差是k-1，之后前后两个指针一起向前走，前面的指针走到最后一个结点时，后面指针所指的结点就是倒数第k个结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数名前面的R代表反向</span></span><br><span class="line"><span class="function">ListNode * <span class="title">RGetKthNode</span><span class="params">(ListNode * pHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 这里k的计数是从1开始的，若k为0或链表为空返回NULL</span></span><br><span class="line">  <span class="keyword">if</span>(k == <span class="number">0</span> || pHead == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  ListNode * pAhead = pHead;</span><br><span class="line">  ListNode * pBehind = pHead;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前面的指针先走到正向第k个结点</span></span><br><span class="line">  <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; pAhead != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    pAhead = pAhead-&gt;m_pNext;</span><br><span class="line">    k--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 结点个数小于k，返回NULL</span></span><br><span class="line">  <span class="keyword">if</span>(k &gt; <span class="number">1</span> || pAhead == <span class="literal">NULL</span>)    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前后两个指针一起向前走，直到前面的指针指向最后一个结点</span></span><br><span class="line">  <span class="keyword">while</span>(pAhead-&gt;m_pNext != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    pBehind = pBehind-&gt;m_pNext;</span><br><span class="line">    pAhead = pAhead-&gt;m_pNext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后面的指针所指结点就是倒数第k个结点</span></span><br><span class="line">  <span class="keyword">return</span> pBehind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-逆序打印链表"><a href="#4-逆序打印链表" class="headerlink" title="4. 逆序打印链表"></a>4. 逆序打印链表</h1><p>对于这种颠倒顺序的问题，要不使用栈，要不使用递归解决。</p><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPrintList</span><span class="params">(ListNode * pHead)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    RPrintList(pHead-&gt;m_pNext);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pHead-&gt;m_nKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPrintList</span><span class="params">(ListNode * pHead)</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ListNode *&gt; s;</span><br><span class="line">  ListNode * pNode = pHead;</span><br><span class="line">  <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    s.push(pNode);</span><br><span class="line">    pNode = pNode-&gt;m_pNext;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">    pNode = s.top();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pNode-&gt;m_nKey);</span><br><span class="line">    s.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-判断一个链表是否有环"><a href="#5-判断一个链表是否有环" class="headerlink" title="5. 判断一个链表是否有环"></a>5. 判断一个链表是否有环</h1><p>这里也使用两个指针。如果一个链表中有环，也就是说用一个指针去遍历，是永远走不到头的。因此，我们可以用两个指针去遍历，一个指针一次走两步，另一个指针一次走一步，如果有环，两个指针肯定会在环中相遇。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasCircle</span><span class="params">(ListNode * pHead)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 快指针每次前进两步</span></span><br><span class="line">  ListNode * pFast = pHead;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 慢指针每次前进一步</span></span><br><span class="line">  ListNode * pSlow = pHead;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(pFast != <span class="literal">NULL</span> &amp;&amp; pFast-&gt;m_pNext != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    pFast = pFast-&gt;m_pNext-&gt;m_pNext;</span><br><span class="line">    pSlow = pSlow-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 相遇，存在环</span></span><br><span class="line">  <span class="keyword">if</span>(pSlow == pFast)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-判断两个链表是否相交"><a href="#6-判断两个链表是否相交" class="headerlink" title="6. 判断两个链表是否相交"></a>6. 判断两个链表是否相交</h1><p>如果两个链表相交于某一节点，那么在这个相交节点之后的所有节点都是两个链表所共有的。也就是说，如果两个链表相交，那么最后一个节点肯定是共有的。先遍历第一个链表，记住最后一个节点，然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点作比较，如果相同，则相交，否则不相交。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsIntersected</span><span class="params">(ListNode * pHead1, ListNode * pHead2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span> || pHead2 == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  ListNode * pTail1 = pHead1;</span><br><span class="line">  <span class="keyword">while</span>(pTail1-&gt;m_pNext != <span class="literal">NULL</span>)</span><br><span class="line">    pTail1 = pTail1-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">  ListNode * pTail2 = pHead2;</span><br><span class="line">  <span class="keyword">while</span>(pTail2-&gt;m_pNext != <span class="literal">NULL</span>)</span><br><span class="line">    pTail2 = pTail2-&gt;m_pNext;</span><br><span class="line">  <span class="keyword">return</span> pTail1 == pTail2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-求两个链表相交的第一个节点"><a href="#7-求两个链表相交的第一个节点" class="headerlink" title="7. 求两个链表相交的第一个节点"></a>7. 求两个链表相交的第一个节点</h1><p>对第一个链表遍历，计算长度 len1，同时保存最后一个节点的地址。<br>对第二个链表遍历，计算长度 len2，同时检查最后一个节点是否和第一个链表的最后一个节点相同，若不相同，不相交，结束。<br>两个链表均从头节点开始，假设 len1 大于 len2，那么将第一个链表先遍历 len1 ~ len2 个节点，此时两个链表当前节点到第一个相交节点的距离就相等了，然后一起向后遍历，知道两个节点的地址相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">GetFirstCommonNode</span><span class="params">(ListNode * pHead1, ListNode * pHead2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span> || pHead2 == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> len1 = <span class="number">1</span>;</span><br><span class="line">  ListNode * pTail1 = pHead1;</span><br><span class="line">  <span class="keyword">while</span>(pTail1-&gt;m_pNext != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    pTail1 = pTail1-&gt;m_pNext;</span><br><span class="line">    len1++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> len2 = <span class="number">1</span>;</span><br><span class="line">  ListNode * pTail2 = pHead2;</span><br><span class="line">  <span class="keyword">while</span>(pTail2-&gt;m_pNext != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    pTail2 = pTail2-&gt;m_pNext;</span><br><span class="line">    len2++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不相交直接返回NULL</span></span><br><span class="line">  <span class="keyword">if</span>(pTail1 != pTail2)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  ListNode * pNode1 = pHead1;</span><br><span class="line">  ListNode * pNode2 = pHead2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先对齐两个链表的当前结点，使之到尾节点的距离相等</span></span><br><span class="line">  <span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line">    <span class="keyword">int</span> k = len1 - len2;</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">      pNode1 = pNode1-&gt;m_pNext;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> k = len2 - len1;</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">      pNode2 = pNode2-&gt;m_pNext;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(pNode1 != pNode2)&#123;</span><br><span class="line">    pNode1 = pNode1-&gt;m_pNext;</span><br><span class="line">    pNode2 = pNode2-&gt;m_pNext;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pNode1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-判断一个链表是否存在环，如果存在求进入环中的第一个节点"><a href="#8-判断一个链表是否存在环，如果存在求进入环中的第一个节点" class="headerlink" title="8. 判断一个链表是否存在环，如果存在求进入环中的第一个节点"></a>8. 判断一个链表是否存在环，如果存在求进入环中的第一个节点</h1><p>首先判断是否存在环，若不存在结束。在环中的一个节点处断开（当然函数结束时不能破坏原链表），这样就形成了两个相交的单链表，求进入环中的第一个节点也就转换成了求两个单链表相交的第一个节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">GetFirstNodeInCircle</span><span class="params">(ListNode * pHead)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(pHead == <span class="literal">NULL</span> || pHead-&gt;m_pNext == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  ListNode * pFast = pHead;</span><br><span class="line">  ListNode * pSlow = pHead;</span><br><span class="line">  <span class="keyword">while</span>(pFast != <span class="literal">NULL</span> &amp;&amp; pFast-&gt;m_pNext != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    pSlow = pSlow-&gt;m_pNext;</span><br><span class="line">    pFast = pFast-&gt;m_pNext-&gt;m_pNext;</span><br><span class="line">    <span class="keyword">if</span>(pSlow == pFast)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pFast == <span class="literal">NULL</span> || pFast-&gt;m_pNext == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将环中的此节点作为假设的尾节点，将它变成两个单链表相交问题</span></span><br><span class="line">  ListNode * pAssumedTail = pSlow;</span><br><span class="line">  ListNode * pHead1 = pHead;</span><br><span class="line">  ListNode * pHead2 = pAssumedTail-&gt;m_pNext;</span><br><span class="line"></span><br><span class="line">  ListNode * pNode1, * pNode2;</span><br><span class="line">  <span class="keyword">int</span> len1 = <span class="number">1</span>;</span><br><span class="line">  ListNode * pNode1 = pHead1;</span><br><span class="line">  <span class="keyword">while</span>(pNode1 != pAssumedTail)&#123;</span><br><span class="line">    pNode1 = pNode1-&gt;m_pNext;</span><br><span class="line">    len1++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> len2 = <span class="number">1</span>;</span><br><span class="line">  ListNode * pNode2 = pHead2;</span><br><span class="line">  <span class="keyword">while</span>(pNode2 != pAssumedTail)&#123;</span><br><span class="line">    pNode2 = pNode2-&gt;m_pNext;</span><br><span class="line">    len2++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pNode1 = pHead1;</span><br><span class="line">  pNode2 = pHead2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先对齐两个链表的当前结点，使之到尾节点的距离相等</span></span><br><span class="line">  <span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line">    <span class="keyword">int</span> k = len1 - len2;</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">      pNode1 = pNode1-&gt;m_pNext;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> k = len2 - len1;</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">      pNode2 = pNode2-&gt;m_pNext;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(pNode1 != pNode2)&#123;</span><br><span class="line">    pNode1 = pNode1-&gt;m_pNext;</span><br><span class="line">    pNode2 = pNode2-&gt;m_pNext;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pNode1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-给出一个链表头指针-pHead-和一节点指针-pToBeDeleted，O-1-时间复杂度删除节点-pToBeDeleted"><a href="#9-给出一个链表头指针-pHead-和一节点指针-pToBeDeleted，O-1-时间复杂度删除节点-pToBeDeleted" class="headerlink" title="9. 给出一个链表头指针 pHead 和一节点指针 pToBeDeleted，O(1) 时间复杂度删除节点 pToBeDeleted"></a>9. 给出一个链表头指针 pHead 和一节点指针 pToBeDeleted，O(1) 时间复杂度删除节点 pToBeDeleted</h1><p>对于删除节点，我们普通的思路就是让该节点的前一个节点指向该节点的下一个节点，这种情况需要遍历找到该节点的前一个节点，时间复杂度为 O(n)。对于链表，链表中的每个节点结构都是一样的，所以我们可以把该节点的下一个节点的数据复制到该节点，然后删除下一个节点即可。要注意最后一个节点的情况，这个时候只能用常见的方法来操作，先找到前一个节点，但总体的平均时间复杂度还是 O(1)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(ListNode * pHead, ListNode * pToBeDeleted)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(pToBeDeleted == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pToBeDeleted-&gt;m_pNext != <span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将下一个节点的数据复制到本节点，然后删除下一个节点</span></span><br><span class="line">    pToBeDeleted-&gt;m_nKey = pToBeDeleted-&gt;m_pNext-&gt;m_nKey;</span><br><span class="line">    ListNode * temp = pToBeDeleted-&gt;m_pNext;</span><br><span class="line">    pToBeDeleted-&gt;m_pNext = pToBeDeleted-&gt;m_pNext-&gt;m_pNext;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 要删除的是最后一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表中只有一个节点的情况  </span></span><br><span class="line">    <span class="keyword">if</span>(pHead == pToBeDeleted)&#123;</span><br><span class="line">      pHead = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ListNode * pNode = pHead;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到倒数第二个节点</span></span><br><span class="line">      <span class="keyword">while</span>(pNode-&gt;m_pNext != pToBeDeleted)</span><br><span class="line">        pNode = pNode-&gt;m_pNext;</span><br><span class="line">      pNode-&gt;m_pNext = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-合并两个有序链表"><a href="#10-合并两个有序链表" class="headerlink" title="10.合并两个有序链表"></a>10.合并两个有序链表</h1><p>定义val1和val2分别指向两个有序链表的第一个结点，只要两个有序链表有一个遍历到了尾结点就结束比较，如果val1&lt; val2，则让p指向l1，并将l1的指针后移，反之，让p指向l2，并将l2指针后移.最后补足剩余多出来的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* p = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> val1 = l1-&gt;val;</span><br><span class="line">            <span class="keyword">int</span> val2 = l2-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(val1&lt;val2)&#123;</span><br><span class="line">                p-&gt;next = l1;</span><br><span class="line">                p = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">                p = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="11-请判断一个链表是否为回文链表。"><a href="#11-请判断一个链表是否为回文链表。" class="headerlink" title="11.请判断一个链表是否为回文链表。"></a>11.请判断一个链表是否为回文链表。</h1><p>第一步：两个指针都从头出发，快指针每次两步，慢指针每次一步，这样快指针的下一个或下下个为空时，慢指针就在链表正中间那个节点了（如果链表有偶数个节点则在靠近头那侧的）。<br>第二步：从慢指针的下一个开始，把后面的链表都反转（Reverse Linked List），<br>第三步：然后我们再从头和从尾同时向中间前进，就可以判断该链表是不是回文了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = findMid(head);</span><br><span class="line">        mid-&gt;next = reverse(mid-&gt;next);</span><br><span class="line">        mid = mid-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>&amp;&amp;mid!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val!=mid-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            mid = mid-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">findMid</span><span class="params">(ListNode* now)</span></span>&#123;</span><br><span class="line">        ListNode* slow = now;</span><br><span class="line">        ListNode* fast = now-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* now)</span></span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode* temp = now-&gt;next;</span><br><span class="line">            now-&gt;next = pre;</span><br><span class="line">            pre = now;</span><br><span class="line">            now = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="12-删除排序链表中的重复元素"><a href="#12-删除排序链表中的重复元素" class="headerlink" title="12.删除排序链表中的重复元素"></a>12.删除排序链表中的重复元素</h1><p>直接从第一个结点开始遍历整个链表，若当前p所指元素与下一个元素相等，则直接后移指针p=p-&gt;next-next,让p指向下下一个元素，如果不相等，则记录下当前结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       &#125;<span class="comment">//真正写的时候，链表为空一定不能漏了</span></span><br><span class="line">       <span class="keyword">int</span> val = head-&gt;val;</span><br><span class="line">       ListNode* p = head;</span><br><span class="line">       <span class="keyword">while</span>(p&amp;&amp;p-&gt;next)&#123;</span><br><span class="line">           <span class="keyword">if</span>(p-&gt;next-&gt;val!=val)&#123;</span><br><span class="line">               val = p-&gt;next-&gt;val;</span><br><span class="line">               p = p-&gt;next;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               ListNode* n = p-&gt;next-&gt;next;</span><br><span class="line">               p-&gt;next = n;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>371. 两整数之和</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/371-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/371-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>不使用运算符 + 和-，计算两整数a 、b之和。</p><p>示例：<br>若 a = 1 ，b = 2，返回 3。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; <span class="number">32</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a1 = a &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> b1 = b &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> val = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">if</span>(a1 == <span class="number">0</span> &amp;&amp; b1 == <span class="number">0</span> &amp;&amp; carry == <span class="number">0</span>)&#123;</span><br><span class="line">                val = <span class="number">0</span>;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a1 == <span class="number">1</span> &amp;&amp; b1 == <span class="number">1</span> &amp;&amp; carry == <span class="number">1</span>)&#123;</span><br><span class="line">                val = <span class="number">1</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a1==<span class="number">0</span> &amp;&amp; b1 ==<span class="number">0</span> || a1 ==<span class="number">0</span> &amp;&amp; carry ==<span class="number">0</span> || b1 ==<span class="number">0</span> &amp;&amp; carry ==<span class="number">0</span>)&#123;</span><br><span class="line">                val = <span class="number">1</span>;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                val = <span class="number">0</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            val = val &lt;&lt; i;</span><br><span class="line">            sum = sum | val;</span><br><span class="line">            a = a &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            b = b &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>345. 反转字符串中的元音字母</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">给定 s = &quot;hello&quot;, 返回 &quot;holle&quot;.</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 s = &quot;leetcode&quot;, 返回 &quot;leotcede&quot;.</span><br></pre></td></tr></table></figure></p><p>注意:<br>元音字母不包括 “y”.</p><p>思路分析：<br>如果考虑一个更简单的问题：如何反转一个字符串，相信大家都能马上想到算法，因为我们知道每个位置的字符在反转后会出现在什么位置。<br>方法一：翻转ID<br>本题中只需要反转元音字母，同样的，我们希望知道每个元音字母在反转后应该出现在什么位置。因此我们用一个position数组记录元音字母的位置，然后进行反转即可。算法复杂度为O(N)，N是字符串长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseVowels</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos(s.size());</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; vowel;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        vowel.insert(<span class="string">'a'</span>);</span><br><span class="line">        vowel.insert(<span class="string">'e'</span>);</span><br><span class="line">        vowel.insert(<span class="string">'i'</span>);</span><br><span class="line">        vowel.insert(<span class="string">'o'</span>);</span><br><span class="line">        vowel.insert(<span class="string">'u'</span>);</span><br><span class="line">        vowel.insert(<span class="string">'A'</span>);</span><br><span class="line">        vowel.insert(<span class="string">'E'</span>);</span><br><span class="line">        vowel.insert(<span class="string">'I'</span>);</span><br><span class="line">        vowel.insert(<span class="string">'O'</span>);</span><br><span class="line">        vowel.insert(<span class="string">'U'</span>);</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vowel.count(s[i]))&#123;</span><br><span class="line">                pos[cnt] = i;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += s[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            ans[pos[i]] = s[pos[cnt-i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二： 双指针法</p><p>本题还有另外一种思路，那就是two pointer。一个指针从前往后扫描，一个指针从后往前扫描，遇到元音字母是进行交换，直到两个指针相遇，算法终止。算法复杂度同样是O(N)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseVowels</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> left = <span class="number">0</span>, right= s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isVowel(s[left]) &amp;&amp; isVowel(s[right]))</span><br><span class="line">            &#123;</span><br><span class="line">                swap(s[left++], s[right--]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isVowel(s[left]))</span><br><span class="line">            &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c == <span class="string">'a'</span> || c == <span class="string">'e'</span> || c == <span class="string">'i'</span> || c == <span class="string">'o'</span> || c == <span class="string">'u'</span> || c == <span class="string">'A'</span> || c == <span class="string">'E'</span> || c == <span class="string">'I'</span> || c == <span class="string">'O'</span> || c == <span class="string">'U'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>350. 两个数组的交集 II</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-II/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-II/</url>
      
        <content type="html"><![CDATA[<p>给定两个数组，写一个方法来计算它们的交集。</p><p>例如:<br>给定 nums1 = [1, 2, 2, 1], nums2 = [2, 2], 返回 [2, 2].</p><p>注意：</p><p>   输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。<br>   我们可以不考虑输出结果的顺序。<br>跟进:</p><p>如果给定的数组已经排好序呢？你将如何优化你的算法？<br>如果 nums1 的大小比 nums2 小很多，哪种方法更优？<br>如果nums2的元素存储在磁盘上，内存是有限的，你不能一次加载所有的元素到内存中，你该怎么办？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        sort(nums1.begin(),nums1.end());</span><br><span class="line">        sort(nums2.begin(),nums2.end());</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len1&amp;&amp;j&lt;len2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i]&lt;nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i]&gt;nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>349. 两个数组的交集</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>给定两个数组，写一个函数来计算它们的交集。</p><p>例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 num1= [1, 2, 2, 1], nums2 = [2, 2], 返回 [2].</span><br></pre></td></tr></table></figure></p><p>提示:</p><p>每个在结果中的元素必定是唯一的。<br>我们可以不考虑输出结果的顺序。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s,res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.size();i++)&#123;</span><br><span class="line">            s.insert(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums2.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.count(nums2[i]))&#123;</span><br><span class="line">                res.insert(nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(res.begin(),res.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>367. 有效的完全平方数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。</p><p>注意：不要使用任何内置的库函数，如  sqrt。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： 16</span><br><span class="line"></span><br><span class="line">输出： True</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： 14</span><br><span class="line"></span><br><span class="line">输出： False</span><br></pre></td></tr></table></figure></p><p>法一：二分<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> left = <span class="number">0</span>,right = num;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = left+(right-left)/<span class="number">2</span>,t=mid*mid;</span><br><span class="line">            <span class="keyword">if</span>(t==num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t&lt;num)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>法二：<br>任意完全平方数都可以表示成连续的奇数和<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            num -= i;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>342. 4的幂</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/342-4%E7%9A%84%E5%B9%82/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/342-4%E7%9A%84%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数 (32位有符整数型)，请写出一个函数来检验它是否是4的幂。</p><p>示例:<br>当 num = 16 时 ，返回 true 。 当 num = 5时，返回 false。</p><p>问题进阶：你能不使用循环/递归来解决这个问题吗？</p><p>循环写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(num&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num%<span class="number">4</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num/=<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>递归写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (num%<span class="number">4</span>==<span class="number">0</span>)&amp;&amp;isPowerOfFour(num/<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>对数写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">double</span> result = <span class="built_in">log10</span>(num)/<span class="built_in">log10</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> (result==<span class="keyword">int</span>(result))?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>326. 3的幂</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/326-3%E7%9A%84%E5%B9%82/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/326-3%E7%9A%84%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 27</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 45</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>进阶：<br>你能不使用循环或者递归来完成本题吗？</p><p>循环写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">3</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n/=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>递归写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (n%<span class="number">3</span>==<span class="number">0</span>)&amp;&amp;isPowerOfThree(n/<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可以采用取对数求解，如果一个数是3的幂，那么以3为底取对数结果必然是一个整数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="built_in">log10</span>(n)/<span class="built_in">log10</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> (result==<span class="keyword">int</span>(result))?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>不错的几部传记</title>
      <link href="/%E9%98%85%E8%AF%BB/%E4%B8%8D%E9%94%99%E7%9A%84%E5%87%A0%E9%83%A8%E4%BC%A0%E8%AE%B0/"/>
      <url>/%E9%98%85%E8%AF%BB/%E4%B8%8D%E9%94%99%E7%9A%84%E5%87%A0%E9%83%A8%E4%BC%A0%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>今天想理一理近期看过的私以为还不错的关于人物传记的书籍，我相信有很多人对传记类作品并不是很感冒，因为哪怕看再多的传记，那也终究都是别人的故事，别人的人生，你并不会成为书中的那位传奇人物，不否认确实有不少人会带有一些趋利的想法去看一些传记作品，比如有人想着看了《乔布斯传》，自己就能成为下一个乔布斯了。然而明眼人都知道这是不可能的，传记类作品不同于小说，名著等，可能没有足够吸引你的故事情节，没有令你眼前一亮的神来之笔，也不同于一些学术作品，干货满满，让你学到一项项高超的技能，那么我们为什么还是值得去读一读优秀的传记书呢。其实在我看来读传记和读其他书并没有太大区别，无非也是了解下作者的一生是怎么走过来的，也不过就是以书会友，目的并不是要向书中的人物一样，照搬照学，模仿他人的人生，而是感受作者遇到种种遭遇时的内心活动，或许你也遇到过类似的抉择与无奈，或许你也对作者的遭遇满怀同情，因为你也一样。</p><h1 id="《活着为了讲述》"><a href="#《活着为了讲述》" class="headerlink" title="《活着为了讲述》"></a>《活着为了讲述》</h1><p>★《百年孤独》作者马尔克斯唯一自传</p><p>生活不是我们活过的日子，而是我们记住的日子，我们为了讲述而在记忆中重现的日子。</p><p>★就算走到绝境，失去耐心，也要永远保有幽默感，热爱生活，这是我们人生最大的财富。</p><p>给所有在梦想的路上走得磕磕绊绊的人</p><p>★ “我年轻过，落魄过，幸福过，我对生活一往情深。”——加西亚•马尔克斯</p><p>诺奖得主、纯文学畅销奇迹创造者马尔克斯的成长故事：充满魔幻色彩的真实人生。</p><p>其实马尔克斯的作品我读的并不多，只读过几部他享誉盛名的作品：《百年孤独》、《霍乱时期的爱情》、《爱情和其他魔鬼》、《苦妓回忆录》，总之是我很喜欢的一位作家，这是一位完全为写作而生的作家，对他来说，“要么写作，要么死去”，就是这么简单。</p><h1 id="《我的职业是小说家》"><a href="#《我的职业是小说家》" class="headerlink" title="《我的职业是小说家》"></a>《我的职业是小说家》</h1><p>《我的职业是小说家》是村上春树首部自传性作品，历时六年完成。</p><p>小说家看似风光，却是份孤独的职业。三十五年来，村上春树在孤独中编织着美妙动人的故事。他以十二章肺腑之言，真挚诚恳又不失幽默地讲述自己写作道路上的故事，和追逐梦想与幸福的人生往事。</p><p>不论是作为声名显赫的作家，还是认真生活的普通人，他的故事都为人们带来信心和勇气。《我的职业是小说家》就是村上春树热爱生活、追求梦想的真实写照。</p><h1 id="《生命的烤火者：杨绛传》"><a href="#《生命的烤火者：杨绛传》" class="headerlink" title="《生命的烤火者：杨绛传》"></a>《生命的烤火者：杨绛传》</h1><p>其实关于杨绛的传记不只这一个版本，包括他的丈夫钱钟书也是，其实我倒觉得想了解这对夫妇，倒是可以更多的去读读他们自己写的作品，毕竟世面上一些关于他们的传记写的其实并不是很到位，但总得来说我认为还是值得一读的，想了解钱钟书是如何成为一代大家的，也可以去读读《钱钟书传》。</p><h1 id="《漫漫自由路》"><a href="#《漫漫自由路》" class="headerlink" title="《漫漫自由路》"></a>《漫漫自由路》</h1><p>本书是前南非总统曼德拉在监狱里写成的一本长篇巨著。它真实地记录了曼德拉和南非人民为反对种族隔离争取自由解放而进行的卓绝斗争。情节曲折，跌宕起伏，引人入胜，为广大读者所喜爱。<br>不得不承认，曼德拉绝对是一位令人敬仰的政界领袖。</p><h1 id="《陈寅恪的最后20年》"><a href="#《陈寅恪的最后20年》" class="headerlink" title="《陈寅恪的最后20年》"></a>《陈寅恪的最后20年》</h1><p>本书为陈寅恪先生后半生（1949-1969年）的传记。 陈先生学贯中西，文史兼通，学术研究有很高的境界。他一生潜心学问，不求显达，深为国内外学人敬重。本书根据大量档案文献和第一手的采访资料，详尽描述了陈先生生命最后二十年的坎坷经历，披露了许多鲜为人知的史实。 本书为读者打开了一段尘封的历史，从陈先生的生存状态和人际关系入手，探索了他的内心世界，并以此分析、诠释了陈先生晚年作品的内涵，提出了不少颇有说服力的见解。</p><h1 id="《红顶商人胡雪岩6》"><a href="#《红顶商人胡雪岩6》" class="headerlink" title="《红顶商人胡雪岩6》"></a>《红顶商人胡雪岩6》</h1><p>《红顶商人胡雪岩6:悲凉醒世大结局》内容简介：大清首富胡雪岩，幼时家贫，替人放牛为生；稍长，入钱庄干杂活，扫地、倒尿壶，得老板赏识，提为跑街；遇贵人王有龄（浙江巡抚），资助其开钱庄，并与官场中人往来，很快成为杭州巨富；王有龄兵败自杀，胡雪岩改投新任闽浙总督左宗棠门下，长袖善舞，眼光独到，囤积居奇，操纵市场，垄断金融，操办洋务，阻击外商，筹措军饷，30年间扶摇直上，直至富甲天下，得慈禧赏黄马褂穿，赐紫禁城骑马，授二品官衔，大富大贵，无人能比；更乐善好施，赢得“胡大善人”的美名。</p><p>一夜之间风云突变，慈禧下令革职抄家，积攒多年的隐患全面爆发，三天之内一贫如洗，成为政治斗争的牺牲品，两年后郁郁终老，埋骨乱石丛中。</p><h1 id="《黄河青山–黄仁宇回忆录》"><a href="#《黄河青山–黄仁宇回忆录》" class="headerlink" title="《黄河青山–黄仁宇回忆录》"></a>《黄河青山–黄仁宇回忆录》</h1><p>其实我和大多数一样，最初了解到黄仁宇，完全是因为读了《万历十五年》，这本书是黄仁宇生平的回忆录，共有36万字，自述生平经历与学术研究经验。书中虽是历数作者的种种经历，但不乏设问，留给后人很多作者未解之谜。</p><h1 id="《慈禧全传》"><a href="#《慈禧全传》" class="headerlink" title="《慈禧全传》"></a>《慈禧全传》</h1><p>《慈禧全传》是高阳以小说形式全景式描绘晚清社会的一部皇皇巨著，共十册。全书以主要人物慈禧的活动为主线，从咸丰皇帝驾崩热河，慈禧联合恭王，自肃顺为首的顾命大臣手中夺取大权，垂帘听政，写到慈禧去世，溥仪继位，前后跨越四十多年。高阳熟知清朝历史掌故，凡笔记、野史、杂著、诗文及民间传说都烂熟于心，信手拈来，很自然地融入到小说的情境当中。作为小说家，高阳又是个讲故事的高手，他将头绪纷繁、变幻莫测的一段晚清历史，写得跌宕起伏，生动还原了一个有血有肉的“东方的维多利亚女王”——慈禧！</p><h1 id="《梵高传》"><a href="#《梵高传》" class="headerlink" title="《梵高传》"></a>《梵高传》</h1><p>这是一幅关于梵高的巨细靡遗、令人心碎的肖像画。两位作者以精致的细节、畅达的文字为我们描绘出梵高充满英雄主义的传奇一生。与阿姆斯特丹梵高博物馆的倾力合作下，以往从未触碰过的素材浮出水面，让我们更加接近这位伟大而又神秘的艺术家：早年渴望在世界立足；与弟弟提奥激烈的情感拉扯；来到普罗旺斯后，绘出西方艺术中备受珍爱的画作……梵高的内心世界也展现出异样的光芒：爱情生活的迷乱与癫狂；轮番上阵的抑郁症与心理病痛；三十七岁死亡时的重重疑云……</p><h2 id="另外提到梵高，我想再推荐一部电影《至爱梵高·星空之谜》"><a href="#另外提到梵高，我想再推荐一部电影《至爱梵高·星空之谜》" class="headerlink" title="另外提到梵高，我想再推荐一部电影《至爱梵高·星空之谜》"></a>另外提到梵高，我想再推荐一部电影《至爱梵高·星空之谜》</h2><p>2014年，波兰画家兼导演多洛塔·科别拉（Dorota Kobiela）与奥斯卡获奖制片人休·韦尔什曼（Hugh Welchman）一起在美国网站Kickstarter上发起众筹，为电影《至爱梵高》的画师训练筹集资金。<br>在众筹获得巨大成功之后，一共有125位来自世界各地的画家和动画师在波兰和希腊的工作室中接受绘画训练，最终以65000个画面构成了今天这部代表着梵高的艺术、热情、坎坷的一生和他的神秘死亡的电影。</p><h1 id="《富兰克林自传》"><a href="#《富兰克林自传》" class="headerlink" title="《富兰克林自传》"></a>《富兰克林自传》</h1><p>这本书是小时候我姐送我的生日礼物，可能不知什么时候我姐发现我对人物传记还挺有兴趣的，就买了这本书送我。具体内容我已记不大清了，总之是一位伟人的一生，还是比较励志的。</p><ul><li>不知不觉已经有十本书了，暂且就到这里吧，感兴趣的朋友可以去读读看哦，对我来说，阅读，读着读着，的确比刷手机有诱惑力多了，哈哈^_^。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书单 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>235. Lowest Common Ancestor of a Binary Search Tree</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p><p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p><p>Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______6______</span><br><span class="line">    /              \</span><br><span class="line"> ___2__          ___8__</span><br><span class="line">/      \        /      \</span><br><span class="line">0      _4       7       9</span><br><span class="line">      /  \</span><br><span class="line">      3   5</span><br></pre></td></tr></table></figure></p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The LCA of nodes 2 and 8 is 6.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself</span><br><span class="line">             according to the LCA definition.</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>All of the nodes’ values will be unique.<br>p and q are different and both values will exist in the BST.</p><p>LCA问题，题目要求你求出给定结点的最近公共祖先。<br>我们先来看下维基百科中关于LCA的定义：<br>在图论和计算机科学中，最近公共祖先（英语：lowest common ancestor）是指在一个树或者有向无环图中同时拥有v和w作为后代的最深的节点。在这里，我们定义一个节点也是其自己的后代，因此如果v是w的后代，那么w就是v和w的最近公共祖先。</p><p>最近公共祖先是两个节点所有公共祖先中离根节点最远的，计算最近公共祖先和根节点的长度往往是有用的。比如为了计算树中两个节点v和w之间的距离，可以使用以下方法：分别计算由v到根节点和w到根节点的距离，两者之和减去最近公共祖先到根节点的距离的两倍即可得到v到w的距离。</p><p>我们只需要遍历二叉搜索树，如果结点的值比p和q都要大，那么LCA肯定在该结点的左边，反之，如果结点的值比p和q都要小，那么LCA肯定在该结点的右边，如果都不是，那么root其实就是LCA了。</p><p>递归写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&gt;p-&gt;val&amp;&amp;root-&gt;val&gt;q-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;p-&gt;val&amp;&amp;root-&gt;val&lt;q-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>迭代写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(root-&gt;val&gt;p-&gt;val&amp;&amp;root-&gt;val&gt;q-&gt;val)&#123;</span><br><span class="line">               root=root-&gt;left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&lt;p-&gt;val&amp;&amp;root-&gt;val&lt;q-&gt;val)&#123;</span><br><span class="line">               root=root-&gt;right;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>234. Palindrome Linked List</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/234-Palindrome-Linked-List/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/234-Palindrome-Linked-List/</url>
      
        <content type="html"><![CDATA[<p>Given a singly linked list, determine if it is a palindrome.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br><span class="line">Follow up:</span><br><span class="line">Could you do it in O(n) time and O(1) space?</span><br></pre></td></tr></table></figure></p><p>题目要求就是给定一个单链表，让你判断是不是回文链表，最好时间复杂度控制在O(n),空间复杂度控制在O(1)</p><p>思路：<br>第一步：两个指针都从头出发，快指针每次两步，慢指针每次一步，这样快指针的下一个或下下个为空时，慢指针就在链表正中间那个节点了（如果链表有偶数个节点则在靠近头那侧的）。<br>第二步：从慢指针的下一个开始，把后面的链表都反转（Reverse Linked List），<br>第三步：然后我们再从头和从尾同时向中间前进，就可以判断该链表是不是回文了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = findMid(head);</span><br><span class="line">        mid-&gt;next = reverse(mid-&gt;next);</span><br><span class="line">        mid = mid-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>&amp;&amp;mid!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val!=mid-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            mid = mid-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">findMid</span><span class="params">(ListNode* now)</span></span>&#123;</span><br><span class="line">        ListNode* slow = now;</span><br><span class="line">        ListNode* fast = now-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* now)</span></span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode* temp = now-&gt;next;</span><br><span class="line">            now-&gt;next = pre;</span><br><span class="line">            pre = now;</span><br><span class="line">            now = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>257. Binary Tree Paths</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/257-Binary-Tree-Paths/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/257-Binary-Tree-Paths/</url>
      
        <content type="html"><![CDATA[<p>Given a binary tree, return all root-to-leaf paths.</p><p>Note: A leaf is a node with no children.</p><p>Example:</p><p>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure></p><p>Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3</p><p>题目要求：给定一棵二叉树，返回所有从根结点到叶结点的路径</p><p>分析：采用深度优先搜索，递归访问每个结点的子结点，如果遇到叶结点，则输出所记录的路径。然后返回上一层</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        dfs(root,path,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left==<span class="literal">nullptr</span>&amp;&amp;node-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            result.push_back(generatePath(path));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                dfs(node-&gt;left,path,result);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                dfs(node-&gt;right,path,result);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">generatePath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="built_in">stringstream</span> ss;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;path.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            ss&lt;&lt;path[i]&lt;&lt;<span class="string">"-&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ss&lt;&lt;path[i];</span><br><span class="line">        <span class="keyword">return</span> ss.str();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1045 快速排序(25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1045-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1045-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1045 快速排序(25)（25 分）<br>著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的N个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？</p><p>例如给定N = 5, 排列是1、3、2、4、5。则：</p><p>1的左边没有元素，右边的元素都比它大，所以它可能是主元；\</p><p>尽管3的左边元素都比它小，但是它右边的2它小，所以它不能是主元；\</p><p>尽管2的右边元素都比它大，但其左边的3比它大，所以它不能是主元；\</p><p>类似原因，4和5都可能是主元。</p><p>因此，有3个元素可能是主元。</p><p>输入格式：</p><p>输入在第1行中给出一个正整数N（&lt;= 10^5^）； 第2行是空格分隔的N个不同的正整数，每个数不超过10^9^。</p><p>输出格式：</p><p>在第1行中输出有可能是主元的元素个数；在第2行中按递增顺序输出这些元素，其间以1个空格分隔，行末不得有多余空格。</p><p>输入样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 3 2 4 5</span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 4 5</span><br></pre></td></tr></table></figure></p><p>利用主元位置不变来做</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxm],b[maxm],c[maxm];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>,d = <span class="number">0</span>;</span><br><span class="line">    sort(b,b+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max&lt;a[i])&#123;</span><br><span class="line">            max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==b[i]&amp;&amp;a[i]==max)&#123;</span><br><span class="line">            c[d++] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,c[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>,c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>242. 有效的字母异位词</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br><span class="line">说明:</span><br><span class="line">你可以假设字符串只包含小写字母。</span><br></pre></td></tr></table></figure></p><p>进阶:<br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> counter[<span class="number">27</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            counter[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">            counter[t[i]-<span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(counter[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>283. 移动零</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><p>题目要求将一个数组中所以0元素移到数组末尾。我们可以初始化count为0作为下标，然后遍历数组，将所有不为0的元素放到前面，然后用一个while循环输出剩余的0。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[count++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;nums.size())&#123;</span><br><span class="line">            nums[count++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>461. 汉明距离</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p><p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p><p>注意：<br>0 ≤ x, y &lt; 231.</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: x = 1, y = 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br></pre></td></tr></table></figure></p><p>上面的箭头指出了对应二进制位不同的位置。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = x^y;<span class="comment">//对两个数异或，得到的结果不同的位置处即为1</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(res)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                count++;<span class="comment">//计算1的个数</span></span><br><span class="line">            &#125;</span><br><span class="line">            res/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>L2-011 玩转二叉树（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-011-%E7%8E%A9%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-011-%E7%8E%A9%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>L2-011 玩转二叉树（25 分）<br>给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。</p><p>输入格式：</p><p>输入第一行给出一个正整数N（&lt;=30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。</p><p>输出格式：</p><p>在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。</p><p>输入样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">4 1 3 2 6 5 7</span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 6 1 7 5 3 2</span><br></pre></td></tr></table></figure></p><p>普通的思路就是重建二叉树，然后广搜输出结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">35</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">-1</span>,r=<span class="number">-1</span>;  </span><br><span class="line">&#125;a[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> mid[maxn],first[maxn];  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> la, <span class="keyword">int</span> ra, <span class="keyword">int</span> lb, <span class="keyword">int</span> rb)</span></span>&#123;<span class="comment">///la是中序遍历  </span></span><br><span class="line">    <span class="keyword">if</span>(la &gt; ra) <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    <span class="keyword">int</span> rt = first[lb];  </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(mid[la+i] != rt) i++;  </span><br><span class="line">    a[rt].r = rebuild(la+i+<span class="number">1</span>,ra,lb+i+<span class="number">1</span>,rb);  </span><br><span class="line">    a[rt].l = rebuild(la,la+i<span class="number">-1</span>,lb+<span class="number">1</span>,lb+i);  </span><br><span class="line">    <span class="keyword">return</span> rt;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;  </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;  </span><br><span class="line">    q.push(s);  </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;  </span><br><span class="line">        <span class="keyword">int</span> now = q.front();  </span><br><span class="line">        q.pop();  </span><br><span class="line">        <span class="keyword">if</span>(a[now].r != <span class="number">-1</span>) q.push(a[now].r);  </span><br><span class="line">        <span class="keyword">if</span>(a[now].l != <span class="number">-1</span>) q.push(a[now].l);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,now);  </span><br><span class="line">        <span class="keyword">if</span>(!q.empty()) <span class="built_in">printf</span>(<span class="string">" "</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;mid[i]);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;first[i]);  </span><br><span class="line">    rebuild(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);  </span><br><span class="line">    bfs(first[<span class="number">0</span>]);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>383. 赎金信</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/383-%E8%B5%8E%E9%87%91%E4%BF%A1/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/383-%E8%B5%8E%E9%87%91%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。)</p><p>注意：</p><p>你可以假设两个字符串均只含有小写字母。</p><p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> ransomNote, <span class="built_in">string</span> magazine)</span> </span>&#123;</span><br><span class="line">         <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magazine.size(); ++i)</span><br><span class="line">            ++<span class="built_in">map</span>[magazine[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ransomNote.size(); ++j)</span><br><span class="line">            <span class="keyword">if</span> (--<span class="built_in">map</span>[ransomNote[j]] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1035 插入与归并(25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1035-%E6%8F%92%E5%85%A5%E4%B8%8E%E5%BD%92%E5%B9%B6-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1035-%E6%8F%92%E5%85%A5%E4%B8%8E%E5%BD%92%E5%B9%B6-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1035 插入与归并(25)（25 分）<br>根据维基百科的定义：</p><p>插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。</p><p>归并排序进行如下迭代操作：首先将原始序列看成N个只包含1个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下1个有序的序列。</p><p>现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？</p><p>输入格式：</p><p>输入在第一行给出正整数N (&lt;=100)；随后一行给出原始序列的N个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。</p><p>输出格式：</p><p>首先在第1行中输出“Insertion Sort”表示插入排序、或“Merge Sort”表示归并排序；然后在第2行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行末不得有多余空格。</p><p>输入样例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">3 1 2 8 7 5 9 4 6 0</span><br><span class="line">1 2 3 7 8 5 9 4 6 0</span><br></pre></td></tr></table></figure></p><p>输出样例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Insertion Sort</span><br><span class="line">1 2 3 5 7 8 9 4 6 0</span><br></pre></td></tr></table></figure></p><p>输入样例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">3 1 2 8 7 5 9 4 0 6</span><br><span class="line">1 3 2 8 5 7 4 9 0 6</span><br></pre></td></tr></table></figure></p><p>输出样例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Merge Sort</span><br><span class="line">1 2 3 8 4 5 7 9 0 6</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>&amp;&amp;b[i]&lt;=b[i+<span class="number">1</span>];i++);</span><br><span class="line">    <span class="keyword">for</span>(j=i+<span class="number">1</span>;a[j]==b[j]&amp;&amp;j&lt;n;j++);</span><br><span class="line">    <span class="keyword">if</span>(j==n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Insertion Sort\n"</span>);</span><br><span class="line">        sort(a,a+i+<span class="number">2</span>,cmp);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Merge Sort\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">1</span>,flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]!=b[i])&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k=k*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n/k;i++)</span><br><span class="line">                sort(a+i*k,a+(i+<span class="number">1</span>)*k,cmp);</span><br><span class="line">            sort(a+n/k*k,a+n,cmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[n<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">delete</span> []a;</span><br><span class="line">        <span class="keyword">delete</span> []b;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1034 有理数四则运算(20)（20 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1034-%E6%9C%89%E7%90%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97-20-%EF%BC%8820-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1034-%E6%9C%89%E7%90%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97-20-%EF%BC%8820-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1034 有理数四则运算(20)（20 分）<br>本题要求编写程序，计算2个有理数的和、差、积、商。</p><p>输入格式：</p><p>输入在一行中按照“a1/b1 a2/b2”的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为0。</p><p>输出格式：</p><p>分别在4行中按照“有理数1 运算符 有理数2 = 结果”的格式顺序输出2个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式“k a/b”，其中k是整数部分，a/b是最简分数部分；若为负数，则须加括号；若除法分母为0，则输出“Inf”。题目保证正确的输出中没有超过整型范围的整数。</p><p>输入样例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2/3 -4/2</span><br></pre></td></tr></table></figure></p><p>输出样例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2/3 + (-2) = (-1 1/3)</span><br><span class="line">2/3 - (-2) = 2 2/3</span><br><span class="line">2/3 * (-2) = (-1 1/3)</span><br><span class="line">2/3 / (-2) = (-1/3)</span><br></pre></td></tr></table></figure></p><p>输入样例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5/3 0/6</span><br></pre></td></tr></table></figure></p><p>输出样例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 2/3 + 0 = 1 2/3</span><br><span class="line">1 2/3 - 0 = 1 2/3</span><br><span class="line">1 2/3 * 0 = 0</span><br><span class="line">1 2/3 / 0 = Inf</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辗转相除法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> c = <span class="number">0</span>; <span class="comment">//带分数前面的整数部分，默认是0</span></span><br><span class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span>)&#123; <span class="comment">//正数</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>)&#123; <span class="comment">//形如3/1</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld"</span>, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; b)&#123; <span class="comment">//形如5/3</span></span><br><span class="line">            c = a / b;</span><br><span class="line">            a -= b * c;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld %lld/%lld"</span>, c, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//真分数 形如3/5</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld/%lld"</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">0</span>)&#123; <span class="comment">//形如0/3</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//负数</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>)&#123; <span class="comment">//形如-3/1</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"(%lld)"</span>, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">-1</span> * a &gt; b)&#123; <span class="comment">//形如-5/3</span></span><br><span class="line">            c = a / b;</span><br><span class="line">            a = (<span class="number">-1</span> * a) % b;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"(%lld %lld/%lld)"</span>, c, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//真分数</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"(%lld/%lld)"</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a1, <span class="keyword">long</span> <span class="keyword">long</span> b1, <span class="keyword">long</span> <span class="keyword">long</span> a2, <span class="keyword">long</span> <span class="keyword">long</span> b2)</span></span>&#123;</span><br><span class="line">    print(a1, b1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" + "</span>);</span><br><span class="line">    print(a2, b2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" = "</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a3 = a1 * b2 + a2 * b1;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b3 = b1 * b2;</span><br><span class="line">    <span class="comment">//化简到最简形式，非带分数形式</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> gcd3 = <span class="built_in">abs</span>(gcd(a3, b3));</span><br><span class="line">    a3 /= gcd3;</span><br><span class="line">    b3 /= gcd3;</span><br><span class="line">    print(a3, b3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subtract</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a1, <span class="keyword">long</span> <span class="keyword">long</span> b1, <span class="keyword">long</span> <span class="keyword">long</span> a2, <span class="keyword">long</span> <span class="keyword">long</span> b2)</span></span>&#123;</span><br><span class="line">    print(a1, b1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - "</span>);</span><br><span class="line">    print(a2, b2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" = "</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a3 = a1 * b2 - a2 * b1;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b3 = b1 * b2;</span><br><span class="line">    <span class="comment">//化简到最简形式，非带分数形式</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> gcd3 = <span class="built_in">abs</span>(gcd(a3, b3));</span><br><span class="line">    a3 /= gcd3;</span><br><span class="line">    b3 /= gcd3;</span><br><span class="line">    print(a3, b3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a1, <span class="keyword">long</span> <span class="keyword">long</span> b1, <span class="keyword">long</span> <span class="keyword">long</span> a2, <span class="keyword">long</span> <span class="keyword">long</span> b2)</span></span>&#123;</span><br><span class="line">    print(a1, b1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" * "</span>);</span><br><span class="line">    print(a2, b2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" = "</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a3 = a1 * a2;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b3 = b1 * b2;</span><br><span class="line">    <span class="comment">//化简到最简形式，非带分数形式</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> gcd3 = <span class="built_in">abs</span>(gcd(a3, b3));</span><br><span class="line">    a3 /= gcd3;</span><br><span class="line">    b3 /= gcd3;</span><br><span class="line">    print(a3, b3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a1, <span class="keyword">long</span> <span class="keyword">long</span> b1, <span class="keyword">long</span> <span class="keyword">long</span> a2, <span class="keyword">long</span> <span class="keyword">long</span> b2)</span></span>&#123;</span><br><span class="line">    print(a1, b1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" / "</span>);</span><br><span class="line">    print(a2, b2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" = "</span>);</span><br><span class="line">    <span class="keyword">if</span>(a2 == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Inf"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a2 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a3 = <span class="number">-1</span> * a1 * b2;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> b3 = <span class="number">-1</span> * b1 * a2;</span><br><span class="line">        <span class="comment">//化简到最简形式，非带分数形式</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> gcd3 = <span class="built_in">abs</span>(gcd(a3, b3));</span><br><span class="line">        a3 /= gcd3;</span><br><span class="line">        b3 /= gcd3;</span><br><span class="line">        print(a3, b3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a3 = a1 * b2;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> b3 = b1 * a2;</span><br><span class="line">        <span class="comment">//化简到最简形式，非带分数形式</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> gcd3 = <span class="built_in">abs</span>(gcd(a3, b3));</span><br><span class="line">        a3 /= gcd3;</span><br><span class="line">        b3 /= gcd3;</span><br><span class="line">        print(a3, b3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a1, b1, a2, b2;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> c1 = <span class="number">0</span>, c2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld/%lld %lld/%lld"</span>, &amp;a1, &amp;b1, &amp;a2, &amp;b2);</span><br><span class="line">    <span class="comment">//先化简到最简形式，非带分数形式</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> gcd1 = <span class="built_in">abs</span>(gcd(a1, b1));</span><br><span class="line">    a1 /= gcd1;</span><br><span class="line">    b1 /= gcd1;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> gcd2 = <span class="built_in">abs</span>(gcd(a2, b2));</span><br><span class="line">    a2 /= gcd2;</span><br><span class="line">    b2 /= gcd2;</span><br><span class="line">    <span class="comment">//统一用最简形式参与运算</span></span><br><span class="line">    add(a1, b1, a2, b2);</span><br><span class="line">    subtract(a1, b1, a2, b2);</span><br><span class="line">    multiply(a1, b1, a2, b2);</span><br><span class="line">    divide(a1, b1, a2, b2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>看不见的客人</title>
      <link href="/%E5%BD%B1%E9%9F%B3/%E7%9C%8B%E4%B8%8D%E8%A7%81%E7%9A%84%E5%AE%A2%E4%BA%BA/"/>
      <url>/%E5%BD%B1%E9%9F%B3/%E7%9C%8B%E4%B8%8D%E8%A7%81%E7%9A%84%E5%AE%A2%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p>　　昨晚看的一部电影《看不见的客人》，比我预想中的要好得多。其实和之前看的一部《控方证人》有异曲同工之处，但还是不得不承认这部剧的剧本够精彩。影片的主线围绕着一位律师和男主的谈话展开，一次次叙述的转变，层层反转，层层递进，吸引着观众紧跟节奏，直至结尾，真相揭露，给人豁然一击，人心叵测，人性慎测，莫过于此。<br>　　为什么说情节，布局十分巧妙。暂且撇开律师是死者母亲假扮这一点，说实话，在影片结尾这位母亲摘下假发，取下隐形镜片之前，我并没有看出来这位律师就是由死者母亲假扮的，当然，若是结合之前的一些对话以及言行，确实有很多地方与之相呼应，不然很难理解一位普通的花钱请来办事的普通律师会有很多奇怪的表现。例如，他为何一开始将一枚时钟摆在桌子上，表明只有３个小时的对话时间。另外，提现这部剧不是一部脑残剧的很大一点，便是这部剧剧情能吸引观众一步步深入，而不是一眼就让你看透结局。如何做到这一点的呢？首先影片是以律师和男主两人之间的对话展开的，这场对话实际上在我看来就是一场审判，一场拷问，关乎人性，关乎讽刺。因为对话的一方其实已经知道真相，而另一方却仍旧在重重伪装。而这位律师要做的便是层层诱导，让男主亲口一部部走入律师的陷阱，直至说出全部真相。剧情优秀的电影会让人觉得这是经得住推敲的，而这部电影恰好就是一部逻辑十分严密的电影。男主和律师其实是在进行一场博弈，尽管律师已经得知大部分真相，但她的目的是为了证据，他需要男主亲口说出自己的罪行，但显然，对男主这样一个内心防线严密的人来说这不是一件容易的事，他一次次叙述，一次次被律师推翻，就是想掩盖真相。你会发现，男主的每一次叙述，叙述中加入情节展现，你会发现竟然都是合情合理的，由此可以想象他的心理防线多么巨大，换言之，他的自私自利，泯灭良知已经到了何种程度。<br>　　<img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike272%2C5%2C5%2C272%2C90/sign=835ef35add88d43fe4a499a01c77b97e/43a7d933c895d143d216b00c78f082025aaf07b8.jpg" alt="alt"><br>　　<br>　　接下来来看看男主的叙述，第一步，撇开车祸，撇开一切罪行喊冤，说明了自己在一个酒店莫名被人栽赃了，有人杀人劫财，并且嫁祸给他，一场密室杀人，所有证据都指向他，百口莫辩。然而，这场叙述不到10分钟就结束了，这样的话，律师简直听都不想听，于是让他别再浪费时间了，把该说的说出来才有辩护成功的希望，慢慢，男主有点服软，开始了他的第二个版本的叙述，这一次，他讲矛头指向了他的情人，劳拉。总之，他绝不会轻易说出自己的黑暗面，毕竟，他可是众人眼中的精英，万众瞩目，事业有成的成功企业家。男主将黑暗面加在了自己的情人劳拉身上，表明自己是身不由己，一时糊涂，听了情人劳拉的怂恿犯下大错，包括后面对死于车祸的男孩的陷害。然而律师一直不停的强调，注重细节，细节能救你，同时也能要了你的命。之后，男主一步步走入律师的圈套。最后，男主发现中计的时候，那种表情，绝对是被拷问后的表情，是被人对灵魂深深的拷问！让人难以想象的是男主为了自己所谓的前途竟然可以不择手段到这种程度，后面得知他的情人内心愧疚难安的了焦虑症，希望男主拿钱弥补死去男孩的父母并告知他们男孩尸体的位置，没想到男主一念之下杀了劳拉，更令人难以容忍的是，他在得知出了车祸的男孩还有一口气之时，他不是尽力去挽救，而是用力盖上了后备箱，视而不见，将车沉入湖底，实在难以想象但凡有一点良知的人能做得如此心狠手辣。<br>　　<img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=1f47a808743e6709aa0d4dad5aaef458/0b7b02087bf40ad1da1893cc5c2c11dfa9ecce25.jpg" alt="Alt"><br>　　影片的讽刺方面直指一些现实社会中的“精英”，“名流”，尽管光环四射，衣着光鲜亮丽，成功，优秀都是他们的代名词，然而，有的人却被这些身外之物完全束缚了，私欲无限膨胀，完全以自我为中心，视他人如蝼蚁，视生命如蝼蚁，什么？出事了，我的前途怎么办，我的妻子女儿怎么办，我的事业刚刚达到巅峰，我怎能在这时出问题，一切都得为我开路，不能被这些碍手碍脚的家伙挡住我的美好前程。<br>　　另外，这部电影的正面主角，便是死者父母，用一句话来形容他们的内心“当你失去了至爱之人，便已无所畏惧”。他们为了给自己无辜的儿子，给死去的劳拉讨回一个公道，与男主不断周旋，收集各种资料，以谎言制服谎言，这也成就了这部电影最大的一个反转，长时间与恶龙搏斗，自身也会如同恶龙般强大，无所畏惧。<br>　　人心莫测，莫过于此，对《看不见的客人》而言，电影的画龙点睛之笔并不在于悬疑，更在于它深攫以了谎言这一人类用来满足自我私欲的本质，并在最后用打动人心的情感完成了这一内在的升华。</p>]]></content>
      
      
      <categories>
          
          <category> 影音 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>263. 丑数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/263-%E4%B8%91%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/263-%E4%B8%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>编写一个程序判断给定的数是否为丑数。</p><p>丑数就是只包含质因数 2, 3, 5 的正整数。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 6</span><br><span class="line">输出: true</span><br><span class="line">解释: 6 = 2 × 3</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: true</span><br><span class="line">解释: 8 = 2 × 2 × 2</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 14</span><br><span class="line">输出: false</span><br><span class="line">解释: 14 不是丑数，因为它包含了另外一个质因数 7。</span><br></pre></td></tr></table></figure></p><p>说明：</p><p>1 是丑数。<br>输入不会超过 32 位有符号整数的范围: [−231,  231 − 1]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            num=num/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> isUgly(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            num=num/<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">return</span> isUgly(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            num=num/<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">return</span> isUgly(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>237. 删除链表中的节点</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>请编写一个函数，使其可以删除某个链表中给定的（非末尾的）节点，您将只被给予要求被删除的节点。</p><p>比如：假设该链表为 1 -&gt; 2 -&gt; 3 -&gt; 4  ，给定您的为该链表中值为 3 的第三个节点，那么在调用了您的函数之后，该链表则应变成 1 -&gt; 2 -&gt; 4 。<br>后移指针<br><img src="https://leetcode.com/media/original_images/237_LinkedList.png" alt="img"></p><p><img src="https://leetcode.com/media/original_images/237_LinkedList3.png" alt="img"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>219. 存在重复元素 II</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,1], k = 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,0,1,1], k = 1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,1,2,3], k = 2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; check;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check.find(nums[i])==check.end())&#123;</span><br><span class="line">                check[nums[i]]=i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果这个值在之前出现过，则检查差值</span></span><br><span class="line">                <span class="keyword">if</span>(i-check[nums[i]]&lt;=k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                check[nums[i]]=i;<span class="comment">//更新下标的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>226. 翻转二叉树</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>翻转一棵二叉树。</p><p>示例：</p><p>输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure></p><p>备注:<br>这个问题是受到 Max Howell 的 原问题 启发的 ：</p><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p><p>递归写法：</p><p>翻转一棵空树结果还是一棵空树，但必须判断。之后递归交换左右结点。<br>时间复杂度O(n)<br>空间复杂度O(n)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* right = invertTree(root-&gt;right);</span><br><span class="line">        TreeNode* left = invertTree(root-&gt;left);</span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>迭代写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode* &gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode *current = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            TreeNode *temp = current-&gt;left;</span><br><span class="line">            current-&gt;left = current-&gt;right;</span><br><span class="line">            current-&gt;right = temp;</span><br><span class="line">            <span class="keyword">if</span>(current-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                q.push(current-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(current-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                q.push(current-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1030 完美数列(25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1030-%E5%AE%8C%E7%BE%8E%E6%95%B0%E5%88%97-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1030-%E5%AE%8C%E7%BE%8E%E6%95%B0%E5%88%97-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1030 完美数列(25)（25 分）<br>给定一个正整数数列，和正整数p，设这个数列中的最大值是M，最小值是m，如果M &lt;= m * p，则称这个数列是完美数列。</p><p>现在给定参数p和一些正整数，请你从中选择尽可能多的数构成一个完美数列。</p><p>输入格式：</p><p>输入第一行给出两个正整数N和p，其中N（&lt;= 10^5^）是输入的正整数的个数，p（&lt;= 10^9^）是给定的参数。第二行给出N个正整数，每个数不超过10^9^。</p><p>输出格式：</p><p>在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。</p><p>输入样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 8</span><br><span class="line">2 3 20 4 5 1 6 7 8 9</span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure></p><p>思路：对一个已经排序好的数列，找出这个数列小于等于这个数列最小元素*p的元素个数<br>p与最小数相乘会超出int范围，所以不能用int定义数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">100100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i,j,maxm = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    <span class="keyword">double</span> temp;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        temp = a[i]*p;<span class="comment">//遍历，将a[i]作为最小数</span></span><br><span class="line">        <span class="keyword">for</span>( j=cnt;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;temp)&#123;<span class="comment">//如果不满足条件了，则将下一个元素最为最小值</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j-i&gt;=maxm)&#123;<span class="comment">//如果此次的长度大于上一次，更新数列长度</span></span><br><span class="line">        maxm = j-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,maxm);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>232. 用栈实现队列</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>使用栈实现队列的下列操作：</p><p>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。<br>示例:</p><p>MyQueue queue = new MyQueue();</p><p>queue.push(1);<br>queue.push(2);<br>queue.peek();  // 返回 1<br>queue.pop();   // 返回 1<br>queue.empty(); // 返回 false<br>说明:</p><p>你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st,temp;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        st.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">if</span>(temp.empty())&#123;</span><br><span class="line">         <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            val = st.top();</span><br><span class="line">            temp.push(val);</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = temp.top();</span><br><span class="line">        temp.pop();</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> val = st.top();</span><br><span class="line">            temp.push(val);</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = temp.top();</span><br><span class="line">        <span class="keyword">while</span>(!temp.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> val = temp.top();</span><br><span class="line">            st.push(val);</span><br><span class="line">            temp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.empty()&amp;&amp;temp.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>225. 用队列实现栈</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>使用队列实现栈的下列操作：</p><p>push(x) – 元素 x 入栈<br>pop() – 移除栈顶元素<br>top() – 获取栈顶元素<br>empty() – 返回栈是否为空<br>注意:</p><p>你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。<br>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。<br>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; st,st2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        st.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> result = top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">"stack is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.empty())&#123;</span><br><span class="line">            swap(st,st2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(st.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            st2.push(st.front());</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.empty()&amp;&amp;st2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1025 反转链表 (25)（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-25-%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>1025 反转链表 (25)（25 分）<br>给定一个常数K以及一个单链表L，请编写程序将L中每K个结点反转。例如：给定L为1→2→3→4→5→6，K为3，则输出应该为3→2→1→6→5→4；如果K为4，则输出应该为4→3→2→1→5→6，即最后不到K个元素不反转。</p><p>输入格式：</p><p>每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址、结点总个数正整数N(&lt;= 10^5^)、以及正整数K(&lt;=N)，即要求反转的子链结点的个数。结点的地址是5位非负整数，NULL地址用-1表示。</p><p>接下来有N行，每行格式为：</p><p>Address Data Next</p><p>其中Address是结点地址，Data是该结点保存的整数数据，Next是下一结点的地址。</p><p>输出格式：</p><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p><p>输入样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00100 6 4</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000 4 33218</span><br><span class="line">33218 3 12309</span><br><span class="line">12309 2 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 -1</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> data[maxn];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">list</span>[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next[maxn];</span><br><span class="line">    <span class="keyword">int</span> first,k,n,temp,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;first,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;data[temp],&amp;next[temp]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(first!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">list</span>[sum++] = first;</span><br><span class="line">        first = next[first];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(sum-sum%k);i+=k)&#123;</span><br><span class="line">      reverse(begin(<span class="built_in">list</span>) + i, begin(<span class="built_in">list</span>) + i + k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>,<span class="built_in">list</span>[i],data[<span class="built_in">list</span>[i]],<span class="built_in">list</span>[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%05d %d -1"</span>,<span class="built_in">list</span>[sum<span class="number">-1</span>],data[<span class="built_in">list</span>[sum<span class="number">-1</span>]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>206. 反转链表</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>反转一个单链表。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure></p><p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p>迭代法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode *temp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        head = prev;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>递归法：</p><p>递归的终止步分三种情况讨论：</p><ol><li>原链表为空，直接返回空链表即可。</li><li>原链表仅有一个元素，返回该元素。</li><li>原链表有两个以上元素，由于是单链表，故翻转需要自尾部向首部逆推。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *newHead = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>190. 颠倒二进制位</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<p>颠倒给定的 32 位无符号整数的二进制位。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 43261596</span><br><span class="line">输出: 964176192</span><br><span class="line">解释: 43261596 的二进制表示形式为 00000010100101000001111010011100 ，</span><br><span class="line">     返回 964176192，其二进制表示形式为 00111001011110000010100101000000 。</span><br></pre></td></tr></table></figure></p><p>进阶:<br>如果多次调用这个函数，你将如何优化你的算法？</p><p>方法一：<br>遍历整数的所有位。 如果第i个位置的一个位置在I / P编号中。<br>然后将该位设置为（NO_OF_BITS - 1） - i in o / p。 NO_OF_BITS是给定数字中存在的位数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>  NO_OF_BITS = <span class="keyword">sizeof</span>(n) * <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> reverse_num = <span class="number">0</span>, i, temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NO_OF_BITS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = (n &amp; (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">        <span class="keyword">if</span>(temp)</span><br><span class="line">            reverse_num |= (<span class="number">1</span> &lt;&lt; ((NO_OF_BITS - <span class="number">1</span>) - i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reverse_num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>时间复杂度：O(logn)<br>空间复杂度：O(1)<br>方法二：<br>保持reversenum每一位与给定num相等直到num变成0，之后反向移动剩余的位<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="keyword">sizeof</span>(n) * <span class="number">8</span> - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> reverse_num = n;</span><br><span class="line"></span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">       reverse_num &lt;&lt;= <span class="number">1</span>;       </span><br><span class="line">       reverse_num |= n &amp; <span class="number">1</span>;</span><br><span class="line">       n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">       count--;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse_num &lt;&lt;= count;</span><br><span class="line">    <span class="keyword">return</span> reverse_num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>160. 相交链表</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>编写一个程序，找到两个单链表相交的起始节点。</p><p>例如，下面的两个链表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure></p><p>在节点 c1 开始相交。</p><p>注意：</p><ul><li>如果两个链表没有交点，返回 null.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li></ul><p>用环的思想来做，我们让两条链表分别从各自的开头开始往后遍历，当其中一条遍历到末尾时，我们跳到另一个条链表的开头继续遍历。两个指针最终会相等，<br>而且只有两种情况，一种情况是在交点处相遇，另一种情况是在各自的末尾的空节点处相等。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!headA||!headB) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *a = headA;</span><br><span class="line">        ListNode *b = headB;</span><br><span class="line">        <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">            a = a ? a-&gt;next : headB;</span><br><span class="line">            b = b ? b-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>141. 环形链表</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>给定一个链表，判断链表中是否有环。</p><p>进阶：<br>你能否不使用额外空间解决此题？</p><p>可以用一个哈希表<br>···cpp</p><p>unordered_map&lt; int,bool&gt; visited<br>···<br>来标记每个元素是否被访问过，若某个元素被重复访问，则存在环。</p><p>最好的方法是用快慢指针，快指针每次走两步，慢指针每次走一步，只要快慢指针相遇，则肯定有环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>112. 路径总和</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">              5</span><br><span class="line">             / \</span><br><span class="line">            4   8</span><br><span class="line">           /   / \</span><br><span class="line">          11  13  4</span><br><span class="line">         /  \      \</span><br><span class="line">        7    2      1</span><br><span class="line">返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</span><br></pre></td></tr></table></figure></p><p>直接深搜<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(sum,<span class="number">0</span>,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> target,<span class="keyword">int</span> sum,TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> leftp = dfs(target,sum,root-&gt;left);</span><br><span class="line">        <span class="keyword">bool</span> rightp = dfs(target,sum,root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> leftp||rightp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>卖米</title>
      <link href="/%E9%98%85%E8%AF%BB/%E5%8D%96%E7%B1%B3/"/>
      <url>/%E9%98%85%E8%AF%BB/%E5%8D%96%E7%B1%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="01"><a href="#01" class="headerlink" title="01"></a>01</h1><p><strong>《卖米》作者飞花，原名张培祥，1979年，出生于湖南醴陵一个山区农民家庭。自小于贫寒中刻苦学习，1997年考入北京大学法学院，2001年攻读法学硕士。2003年非典期间，年仅24岁的张培祥就已身患白血病离开了人世。</strong></p><p>天刚蒙蒙亮，母亲就把我叫起来了：“琼宝，明天是这里的场，咱们担点米到场上卖了，好弄点钱给你爹买药。”</p><p>我恍恍惚惚展开双眼，看看窗外，日头还没出来呢。我真实太困，又在床上赖了一会儿。</p><p>近邻传来父亲的咳嗽声，母亲在厨房忙在世，饭菜的喷鼻气夹杂着淡淡的油烟味飘过去，渐渐遣散了我的睡意。我坐起来，穿好衣服，开端铺床。</p><p>“姐，我也跟你们一同去赶场好不好？你买冰棍给我吃！”</p><p>弟弟顶着一头睡得乱蓬蓬的头发跑到我房里来。</p><p>“毅宝，你不要去，你留在家里放水。”近邻传来父亲的声响，同化着几声咳嗽。</p><p>弟弟有些不甘愿地冲近邻说：“爹，天气这么热，你自个昨天才中了暑，今天又叫我去，就不怕我也中暑！”</p><p>“人怕热，庄稼不怕？都不去放水，地都干了，禾都死了，一家人喝东南风去？”父亲一动气，咳嗽得更加凶猛了。</p><p>弟弟冲我吐吐舌头，扮了个鬼脸，就到父亲房里去了。</p><p>只听见父亲开端叮嘱他怎样放水，去哪个塘里引水，先放哪丘田，哪几个中央要特别注意他人来截水，等等。</p><h1 id="02"><a href="#02" class="headerlink" title="02"></a>02</h1><p>吃过饭，弟弟就找着父亲常用的那把锄头出去了。我和母亲开始往谷箩里装米，装完后先称了一下，一担八十多斤，一担六十多斤。</p><p>我说：“妈，我挑重的那担吧。”</p><p>“你学生妹子，肩膀嫩，还是我来。”</p><p>母亲说着，一哈腰，把那担重的挑起来了。</p><p>我挑起那担轻的，跟着母亲出了门。</p><p>“路上当心点！我们家的米好，别廉价卖了！”父亲披着衣服站在门口吩咐道。</p><p>“晓得了。你快回床上躺着吧。”母亲困难地把头从扁担旁边扭过去，吩咐道，“饭菜在锅里，半夜你叫毅宝热一下吃！”</p><p>赶场的中央离我家大约有四里路，我和母亲挑着米，在窄窄的田间巷子上走走停停，足足走了一个钟头才到。场上的人曾经不少了，咱们赶忙找了一块旷地，把担子放上去，把扁担放在地上，两个人坐在扁担上，拿凉帽扇着。</p><p>一大早就这么热，中午就更不得了，我忍不住替弟弟担忧起来。</p><p>他去放水，是要在里头晒上一成天的。</p><p>我往周围看了看，发现场上有很多人卖米，莫非他们都等着用钱？</p><p>场上的人大都眼生，都是附近十里八里的同乡，人家也是耕田的，谁会来买米呢？</p><p>我问母亲，母亲说：“有专门的米商人会来收米的。他们开了车到乡间来赶场，收了米，拉到城里去卖，能挣好些哩。”</p><p>我说：“凭什么都给他们挣？咱们也拉到城里去卖好了！”其实自个也晓得不过是气话。</p><p>果真，母亲说：“我们这么一点米，又没车，真弄到城里去卖，挣的钱还不敷路费呢！早先你爹身体好的时刻，自个挑着一百来斤米进城去卖，隔几天去一趟，倒比较划算一点。”</p><p>我不由心里一紧，疼爱起父亲来。从家里到城里足足有三十多里山路呢，他挑着那么重的担子走着去，该何等辛劳！就为了多挣那几个钱，把人累成这样，多不值啊！但又有什么方法呢？家里除了种地，也没其余收入，不卖米，拿什么钱供我和弟弟上学？</p><p>我想着这些，心里一阵阵忧伤起来。看看旁边的母亲，头发有些花白了，黑黝黝的脸上爬上了好多皱纹，脑门上密密麻麻都是汗珠，眼睛有些红肿。</p><p>“妈，你喝点水。”</p><p>我把水壶递过来，拿凉帽替她扇着。</p><p><img src="http://www.veryok.net/img.php?u=https://mmbiz.qpic.cn/mmbiz_jpg/QFaTfWAr2VvdPbzVKoyIBsBFkyWLaEW0pyKcRjInyVfzGXTia5FZCAM3yaPeof8ZQVQEic7ibOS9zZky3VWcPfzVQ/0?wx_fmt=jpeg" alt="Alt text"></p><h1 id="03"><a href="#03" class="headerlink" title="03"></a>03</h1><p>米商人们终于开着车来了。他们四处看着卖米的人，走过来细心看米的成色，还把手插进米里，抓上一把米细看。</p><p>“一块零五。”</p><p>米商人开价了。</p><p>卖米的似乎嫌太低，想还价讨价。</p><p>“不讨价，一口价，爱卖不卖！”</p><p>米商人立场很强硬，究竟，满场都是卖米的人，只有他们是买家，不趁机压价，更待何时？</p><p>母亲留意着那里的情形说：“一块零五？也太廉价了。上场还卖到一块一呢。”</p><p>正说着，有个米商人朝咱们这边走过来了。</p><p>他把手插进大米里，抓了一把出来，迎着阳光细看着。</p><p>“这米好咧！又白又匀净，又筛得洁净，一点沙子也没有！”母亲堆着笑，语气里有几分骄傲。</p><p>确实，我家的米比场上其他人卖的米都好。</p><p>那人点了摇头，说：“米是好米，不过这几天城里涨价，再好的米也卖不出好价前来。一块零五，卖不卖？”</p><p>母亲摇摇头：“这也太廉价了吧？上场还卖一块一呢。再说，你是识货的，一分钱一分货，我这米一定好过别家的！”</p><p>那人又看了看米，犹疑了一下，说：“原本都是一口价，不许还的，看你们家米好，我加点，一块零八，怎样样？”</p><p>母亲照样摇头：“不可，咱们家这米，少说也要卖到一块一。你再加点？”</p><p>那人冷笑一声，说：“明天一定卖不出一块一的行情，我出一块零八你不卖，等会散场的时刻你一块零五都卖不出去！”</p><p>“卖不出去，我们再担回家！”那人的立场激恼了母亲。</p><p>“那你就等着担回家吧。”那人冷笑着，丢下这句话走了。</p><h1 id="04"><a href="#04" class="headerlink" title="04"></a>04</h1><p>我在旁边听着，心里算着：一块零八到一块一，每斤才差两分钱。</p><p>这里一共150斤米，总共也就三块钱的事情，路这么远，何须再挑回去呢？</p><p>我的肩膀还在痛呢。</p><p>我悄悄对母亲说：“妈，一块零八就一块零八吧，横竖也就三块钱的事。再说，还等着钱给爹买药呢。”</p><p>“那哪行？”母亲似乎有些生气了，“三块钱不是钱？再说了，也不单是几块钱的事，经商也得讲点良知，我们辛辛苦苦种出来的米，质量也好，哪能这么贱卖了？”</p><p>我不敢再说。</p><p>我晓得耕田有何等累。</p><p>光说炎天放水，不就把爹给病倒了？</p><p>弟弟也才十一二岁的毛孩子，还不得找着锄头去放水！</p><p>究竟，这是一家人的生计啊！</p><p>又有几个米商人过去了，他们也都只出一块零五。有一两个出到一块零八，也不愿再加。</p><p>母亲依然不愿卖。</p><p>看看人逐渐少了，我有些焦急了。</p><p>母亲必然也很心急吧，我想。</p><p>“妈，你去那里树下凉爽一下吧！”我说。</p><p>母亲一边擦汗，一边摇头：“不可。我走开了，来人买米怎样办？你又不会讨价！”</p><p>我有些羞愧。</p><p>“百无一用是书生”，固然在学校里功课好，但这些事情上就比母亲差远了。</p><p>又有好些人来买米，由于我家的米实在是好，人人都过去看，但谁也不愿出到一块一。</p><p>看看日头到头顶上了，我感觉肚子饿了，便拿出带来的饭菜和母亲一同吃起来。</p><p>母亲吃了两口就不吃了，我晓得她是担忧米卖不出去，心里焦急。</p><p>母亲叹了口气：“还不晓得卖得掉卖不掉呢。”</p><p>我趁机说：“不然就廉价点卖好了。”</p><p>母亲说：“我心里有数。”</p><h1 id="05"><a href="#05" class="headerlink" title="05"></a>05</h1><p>下午人更少了，日头又毒，谁情愿在场上晒着呢。</p><p>看看母亲，衣服都粘在背上了，乌黑的脸上也显露出晒红的印迹来。</p><p>“妈，我替你看着，你去溪里泡泡去。”</p><p>母亲照样摇头：“不行，我有风湿，不能在凉水里泡。你怕热，去那里树底下躲躲好了。”</p><p>“不必，我不怕晒。”</p><p>“那你去买根冰棍吃好了。”</p><p>母亲说着，从兜里掏出两毛钱零钱来。</p><p>我最喜好吃冰棍了，特别是那种叫“葡萄冰”的最好吃，也不贵，两毛钱一根。</p><p>但我今天忽然不想吃了：“妈，我不吃，喝水就行。”</p><p>最热的时候也过来了，转眼快散场了。</p><p>卖杂货的小贩开始降价甩卖，卖菜，卖西瓜的也都呼喊着：“散场了，廉价卖了！”</p><p>我四处看看，场上已经没有几个卖米的了，大部分人已经卖完回去了。</p><p>母亲也焦急起来，一焦急，汗就出得越多了。</p><p>终于有个米贩子过来了：“这米卖不卖？一块零五，不论价！”</p><p>母亲说：“你看我这米，多好！上场还卖一块一呢……”</p><p>不等母亲说完，那人就不耐性地说：“行情不同了！想卖一块一，你就等着往回担吧！”</p><p>奇怪的是，母亲没有生气，反而堆着笑说：“那，一块零八，你要不要？”</p><p>那人从鼻子里哼了一声，说：“你这个价钱，不是开场的时候也难卖出来，如今都散场了，谁买？做梦吧！”</p><p>母亲的脸一会儿白了，动着嘴唇，但什么也没说。</p><p>一旁的我不由得插嘴了：“不买就不买，谁稀罕？不买你就别站在这里挡道！”</p><p>“哟，大妹子，你别这么大火气。”</p><p>那人冷笑着说，“留着点力气等会把米担回去吧！”</p><p>等那人走了，我不由得抱怨母亲：“开场的时候人家出一块零八你不卖，这会好了，人家还不愿意买了！”</p><p>母亲似乎有些羞愧，但并不愿认错：“本来嘛，一分钱一分货，米是好米，哪能贱卖了？出门的时候你爹不还叮嘱叫卖个好价钱？”</p><p>“你还说爹呢！他病在家里，指着这米换钱买药治病！人要紧还是钱要紧？”</p><p>母亲似乎没有话说了，等了一会儿，低声说：“一会儿人家出一块零五也卖了吧。”</p><p>可是再没有人来买米了，米贩子把买来的米装上车，开走了。</p><h1 id="06"><a href="#06" class="headerlink" title="06"></a>06</h1><p>散场了，我和母亲晒了一天，一颗米也没卖出来。</p><p>“妈，走吧，回去吧，别愣在那儿了。”</p><p>我收拾好毛巾、水壶、饭盒，催促道。</p><p>母亲踌躇着，终于起了身。</p><p>“妈，我来挑重的。”</p><p>“你先生妹子，肩膀嫩……”</p><p>不等母亲说完，我已经把那担重的挑起来了。</p><p>母亲也没有再说什么，挑起那担轻的跟在我后面，踏上了回家的路。</p><p>肩上的担子好沉，我只感觉压着一座山似的。</p><p>忽然脚下一滑，我差点摔倒。</p><p>我赶忙把剩下的力气都用到腿上，好不容易站稳了，但肩上的担子还是倾斜了一下，洒了好多米出来。</p><p>“啊，怎么搞的？”母亲也放下担子走过来，嘴里说，“我叫你不要挑这么重的，你偏不听，这不是洒了。多惋惜！真是败家精！”</p><p>败家精是母亲的口头禅，我和弟弟干了什么坏事她老是这么数落我们。</p><p>但今天我感觉格外委屈，也不晓得为什么。</p><p>“你在这等会儿，我回家去拿个簸箕来把地上的米扫进去。浪费了多可惜！拿回去能够喂鸡呢！”母亲也不问我扭伤没有，只顾心疼洒了的米。</p><p>我晓得母亲的脾性，她素来是“刀子嘴，豆腐心”的，虽然也心疼我，嘴里却非要骂我几句。</p><p>想到这些，我也不委屈了。</p><p>“妈，你回去还要往返走个六七里路呢，时候也不早了。”我说。</p><p>“那地上的米怎样办？”</p><p>我心血来潮，把头上的凉帽摘下来：“装在这里边好了。”</p><p>母亲笑了：“还是你脑子活，学生妹子，机灵。”</p><p>说着，我们便蹲下身子，用手把洒落在地上的米捧起来，放在凉帽里，然后把凉帽顶朝下放在谷箩里，便挑着米持续往家赶。</p><p>回抵家里，弟弟曾经回来了，母亲便忙着做晚饭，我跟父亲申报卖米的经过。</p><p>父亲听了，也没埋怨母亲，只说：“那些米贩子也太黑了，城里都卖一块五呢，把价压这么低！这么挣庄稼人的血汗钱，太没良心了！”</p><p>我说：“爹，也没给你买药，怎样办？”</p><p>父亲说：“我原本就说不用买药的嘛，过两天就好了，花那个冤枉钱做什么！”</p><p>早晨，父亲咳嗽得更凶猛了。</p><p>母亲对我说：“琼宝，今天是转步的场，我们辛劳一点，把米挑到那里场上去卖了，好给你爹买药。”</p><p>“转步？那多远，十几里路呢！”我想到那漫长的山路，不由有些发怵。</p><p>“明天你们少担点米去。每人担50斤就够了。”父亲说。</p><p>“那明天可不要再卖不掉担回来哦！”我说，“十几里山路走个往返，还挑着担子，可不是说着玩的！”</p><p>“不会了不会了。”母亲说，“今天一块零八也好，一块零五也好，总之都卖了！”</p><p>母亲的话里有很多辛酸和无奈的意思，我听得出来，但不晓得怎样抚慰她。</p><p>我自个心里也很忧伤，有点想哭。</p><p>我想，别让母亲看见了，要哭就躲到被子里哭去吧。</p><p>可我真是太累啦，头刚刚挨到枕头就睡着了，睡得又香又甜。</p><p>　</p><p>注：《卖米》曾取得北京大学首届校园原创文学大赛一等奖。然而，在颁奖现场，获奖者并没有出现，而是由她的同窗们在寄予哀思，那氛围已经不是在颁奖，而是在开追悼会了。一时间，缄默掩盖了北大的整个阳光大厅。至此，我才晓得获奖者在一年前就已身患白血病离开了人世。</p><p>我为什么要分享这篇文章：读了后，感动是必然的。我老家在浙江省淳安县，我们县因为上个世纪中后期国家要规划建设新安江水电站来保障长三角地区的用电需求，栏坝蓄水，导致了我们县大面积被淹，当时当地的人民不得不举家移民，移民数达到了30余万，而如今的大坝之西，便是你们耳中时常听到的“千岛湖”。当时我外婆家因为离湖区较远，所以没有移民远处或外省，只是往后在高处退了点，千岛湖形成后，水刚好覆盖到了我外婆家边上，而我自己家则里湖区还有好几里路。很多人因为关注旅游渐渐听说了千岛湖的名字，但却不知淳安县是在哪。记得以前读《明朝那些事》的时候才了解到，大清官海瑞曾在淳安县当过县令。我说了这么多，是因为想要引出淳安为什么经济十分落后，至今，淳安仍旧是一个农业大县。建坝蓄水，可以说让淳安的经济倒退了十年，其中最致命的便是田地和旧城被淹，交通不便。当然，如今的淳安也很注重修路造桥，已经改善了许多。记得当初我若是想去一趟县城，需要先赶小巴车，在弯弯曲曲的满是砂石的泥道上颠簸个半天赶到码头，然后在码头坐船到千岛湖镇，一天只有两班船。坐船可没开车那么快，到达目的地就得花去3到4个小时，基本上就半天过去了。不过现在想起来，我到挺怀恋当年坐车赶船的日子，其实我一点都不嫌弃坐船太慢，恰恰相反，我觉得挺惬意的，有时会在船上和哥哥姐姐一起打扑克牌，有时会跑到船舱外，凉风迎面吹来，看着客船在湖里稳速前进，别提有多舒服了，有时望着湖面，时不时还能看到鱼儿扑通一下跃出水面，激动地我对母亲叫着“妈，有鱼跳出来了！”，现如今，造好了千岛湖大桥，一条条道路接连开通，我已经很多年没坐过船了，当时热闹繁华的客运码头，也被地产商承包了去，盖了一幢幢度假酒店。小时候，我爸在外地打工，母亲则待在家里，不仅种着土地，还要在外面厂里做会临时工，还要照顾我和姐姐读书上学。在我刚上小学时，根本不知道什么是苦，干啥都兴致高昂，虽然要力气没力气，但只要母亲收拾着锄头镰刀要往地里田里去时，我一定也会背着一把迷你小锄头，屁颠屁颠跟在她后面也假装干活去了。街坊邻居见了，一个个都夸的我飞上了天，“毅毅，真是勤快呀，又帮你妈干活去了！”。事实上，多数时候我都是一到田里就把锄头丢在一旁，自个跑去玩了，有时会跑去田边的小溪里抓螃蟹，尤其是大热天的时候，泡在溪水里别提有多舒服了。而母亲本来也就没指望我能帮他干多少活。尽管如此，有时母亲实在忙过来，还是会叫我老老实实待在地里帮忙的，在30多度的太阳底下，你甚至找不到一点遮阴的地方，任由那汗水花花直流，你也得扛着干，这其实也就是很多农民的日子，所以我很清楚干农活是种怎样的苦。</p><p> 说来惭愧，到后面我就越来越懒，起初我还嘲讽我老姐，难得去地里干一次活，看我多勤快。但长大以后，我发现自己也和老姐半斤八两了，母亲喊了半天让我一起去地里帮忙，我总是死赖着不肯，最后我就说我还要学习呢！母亲一听，觉得不能让这种是占据了我的学习时间，就独自一人背着篮筐往庄稼地里走了去。读了《卖米》这篇文章，说实话我更多的是一种忏悔，我发现自己变得不是一点两点，我变得太多了，其实与文中作者描写的家庭相比，我家想必还算不错的了。我自责的也不是因为自己太物质，而是很多时候只想到了“钱”这个字眼，忽略了太多其他的东西。我和我姐一样都是在乡下读的小学初中，然后在县城读的高中，之后我来到杭州上大学，而我姐则是在宁波读的大学，一步步往外走，一步步求学，会发现有些人生来含着金钥匙，有些人活着已是拼尽了全力，但我们实在不能责怪自己的父母没能力，我也知道爸妈供我和我姐上学，甚至一直到大学毕业，他们就已经尽力了，教育资源的差距，社会阶层的差距，甚至是自己与同学的差距都不应怪在辛勤了半辈子的农民父母身上，在中国，可能仅仅一个户口的区别也会给你们带来巨大的差距。无论你是既得利益者还是非既得利益者，你都不得不承认这些事实。《卖米》这篇文章其实用词用句都很朴素，没有堆砌什么华丽的辞藻，但是却十分打动人，文章最后一句，累了整整一天的“我”，倒下就睡着，而且睡得又香又甜，生活不易，但我“安然以对”。文章以卖米这件许多人不以为然的小事展开，展现了底层家庭的生活实景，也许很多人根本无法感同身受，因为过惯了大鱼大肉的日子。但我也相信，大多数人的一生，本质都充满着艰难坎坷。努力并以正面姿态生活着吧，正如海子所说：<br> <strong>你来人间一趟，总要看看太阳。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>红黑树简介</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AE%80%E4%BB%8B/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树简介"><a href="#红黑树简介" class="headerlink" title="红黑树简介"></a>红黑树简介</h1><p>红黑树（Red Black Tree）是一种自平衡的二叉查找树，它是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树。后来，在1978年被Leo J.Guibas和Robert Sedgewick修改为如今的“红黑树”。红黑树应用非常广泛，比如C++ STL库中的map和Java中的TreeMap、HashMap都是基于红黑树红黑树结构实现的。近年来，红黑树也常在面试中被问到。因此，掌握红黑树数据结构是非常必要的。</p><p><img src="/img/红黑树1.jpg" alt="alt text"></p><h1 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h1><p>普通的二叉查找树在极端的情况下可退化成链表，此时的查找效率会比较低下。为了避免这种情况，就出现了一些自平衡的查找树，比如AVL、红黑树等。这些自平衡的查找树通过定义一些性质，将任意结点的左右子树高度差控制在固定范围内，以达到平衡状态。红黑树需要满足如下五条性质：</p><ul><li><p>节点是红色或者黑色<br>在树里面的结点不是红色就是黑色，没有其他颜色，这也就是红黑树的由来</p></li><li><p>根节点是黑色<br>根节点总是黑色的，不能为红。</p></li><li><p>每个叶节点（NULL或空节点）是黑色<br>NULL节点是个空节点，并且是黑色的。</p></li><li><p>每个红色节点的两个子节点都是黑色的<br>连续的两个节点的意思就是父节点与子节点不能是连续的红色</p></li><li><p>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）<br>从根节点到每一个NULL节点的路径中，都包含了相同数量的黑色节点。</p></li></ul><p>这五条性质约束了红黑树，可以通过数学来证明，满足这五条性质的二叉树，就可以保证任意节点到其每个叶子节点路径最长不会超过最短路径的2倍。证明如下：</p><p>当某条路径最短时，这条路径比如都是黑色节点构成。当某条路径长度最长时，这条路径必然是由红色和黑色节点相间构成（性质4限定了不能出现两个连续的红色节点）。而性质5又限定了从任一节点到其每个叶子节点的所有路径必须包含相同数量的黑色节点。此时，在路径最长的情况下，路径上红色节点数量 = 黑色节点数量。该路径长度为黑色节点数量的2倍，也就是最短路径长度的2倍。</p><p><img src="/img/红黑树2.jpg" alt="alt text"></p><h1 id="红黑树的操作"><a href="#红黑树的操作" class="headerlink" title="红黑树的操作"></a>红黑树的操作</h1><p>红黑树的基本操作与其他树的操作一样，有查找、插入和删除等操作。由于查找与其他树的操作一样，比较简单，而插入、删除操作比较复杂，这里主要就是接受插入、删除操作。</p><h2 id="1-旋转操作"><a href="#1-旋转操作" class="headerlink" title="1.旋转操作"></a>1.旋转操作</h2><p>由于插入、删除的过程中都要涉及到旋转，这里首先介绍一下旋转这个基本操作。旋转操作分为左旋转和右旋转</p><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>左旋的过程是将节点x的右子树绕节点x逆时针旋转，使得节点x的右子树成为x的父亲，同时修改修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/img/红黑树3.jpg" alt="alt text"></p><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>右旋的过程是将节点x的左子树绕x顺时针旋转，使得节点x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/img/红黑树4.jpg" alt="alt text"></p><h2 id="2-插入操作"><a href="#2-插入操作" class="headerlink" title="2.插入操作"></a>2.插入操作</h2><p>红黑树的插入过程和二叉查找树的插入过程基本类似，不同的地方在于，红黑树插入新节点后，需要进行调整，以满足红黑树的性质。在讨论红黑树的插入操作之前必须要明白，任何一个即将插入的新节点的初始颜色都为红色。原因很简单，引入插入黑色的节点会增加某条路径上黑节点的数目，从而导致整棵树黑高度的不平衡。但如果插入的节点是红色的，此时所有路径上的黑色节点数量不变，仅可能会出现两个连续的红色节点的情况。这种情况下，通过变色和旋转进行调整即可，比插入黑色的简单多了。</p><p>红黑树的插入可能遇到如下几种情况：</p><ul><li>情况1：当插入的节点是根节点时，直接涂黑即可；</li><li>情况2：当要插入的节点的父节点是黑色的时候，这个时候插入一个红色的节点并没有对这五个性质产生破坏。所以直接插入不用在进行调整操作。</li></ul><p><img src="/img/红黑树5.jpg" alt="alt text"></p><ul><li>情况3：如果要插入的节点的父节点是红色且叔叔节点也是红色。由于父节点和插入的节点都是红色，所以性质4被打破，此时需要进行调整。在这种情况下，先将父节点和叔叔节点的颜色染成黑色，再让祖父结点染成红色。此时经过祖父结点的路径上的黑色节点数量不变，性质5仍然满足。但需要注意的是祖父节点被染成红色后，可能会和它的父节点形成连续的红色节点，此时需要递归向上调整。</li></ul><p><img src="/img/红黑树6.jpg" alt="alt text"></p><ul><li>情况4：当要插入的父节点为红色，叔叔节点为黑色。此时需要对父节点进行左旋，然后按照情况5进行处理（注：这里要插入的节点有可能是调整后的其它节点，这里我们理解父节点为插入节点而转到情况5）。</li></ul><p><img src="/img/红黑树7.jpg" alt="alt text"></p><ul><li>情况5：当要插入的父节点为红色，叔叔节点为黑色。插入节点是父节点的左孩子，且父节点是祖父节点的左孩子。此时对祖父节点进行右旋，并将祖父节点和父节点进行互换颜色。这时候满足了红黑树的全部性质。</li></ul><p><img src="/img/红黑树13.jpg" alt="alt text"></p><h2 id="3-删除操作"><a href="#3-删除操作" class="headerlink" title="3.删除操作"></a>3.删除操作</h2><p>相对于插入操作，红黑树的删除操作更为复杂。同样，这里我们也分为几种情况进行分析：</p><ul><li>情况1：当被删除元素为红时，对五条性质都没有什么影响，直接删除即可。</li><li>情况2：当被删除元素为黑且为根节点时，直接删除。</li><li>情况3：当被删除元素为黑，且有一个右子节点为红时，将右子节点涂黑放到被删除元素的位置，如图：</li></ul><p><img src="/img/红黑树8.jpg" alt="alt text"></p><ul><li>情况4：当被删除元素为黑，且兄弟节点为黑，兄弟节点两个孩子也为黑，父节点为红，此时，交换兄弟节点与父节点的颜色；NULL元素是指每个叶节点都是两个空的元素，颜色为黑的NULL元素，需要他的时候就可以把它看成两个黑元素，不需要的时候就可以忽视它。</li></ul><p><img src="/img/红黑树9.jpg" alt="alt text"></p><ul><li>情况5：当被删除的元素为黑、并且为父节点的左支，且兄弟颜色为黑，兄弟的右支为红色，这个时候需要交换兄弟与父亲的颜色，并把富且涂黑、兄弟的右支涂黑，并以父节点为中心左转。</li></ul><p><img src="/img/红黑树10.jpg" alt="alt text"></p><ul><li>情况6：当被删除元素为黑、并且为父节点的左支，且兄弟颜色为黑，兄弟的左支为红色，这个时候需要先把兄弟与兄弟的左子节点颜色互换，进行右转，然后就变成了情况5一样，在按照情况5进行旋转。</li></ul><p><img src="/img/红黑树11.jpg" alt="alt text"></p><ul><li><p>情况7：当被删除元素为黑且为父元素的右支时，跟情况5、情况6互为镜像。</p></li><li><p>情况8：当被删除的元素为黑，且父父元素的左支，兄弟节点为红色的时候，需要交换兄弟节点与父节点的颜色，以父节点进行左旋，就变成了情况4，再按照情况四进行操作即可。</p></li></ul><p><img src="/img/红黑树12.jpg" alt="alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>107. 二叉树的层次遍历 II</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-II/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-II/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>返回其自底向上的层次遍历为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>题目要求：给定一颗二叉树，    返回一个二维数组，这个二维数组要满足这个条件， 二维数组的第一个一维数组要是这可二叉树的最下面一层，之后以此类推<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">int</span> depth = getHeight(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret(depth);</span><br><span class="line">        <span class="keyword">if</span>(depth==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(ret,ret.size()<span class="number">-1</span>,root);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ret,<span class="keyword">int</span> level,TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        ret[level].push_back(root-&gt;val);</span><br><span class="line">        dfs(ret,level<span class="number">-1</span>,root-&gt;left);</span><br><span class="line">        dfs(ret,level<span class="number">-1</span>,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lside = getHeight(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rside = getHeight(root-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> height = (lside&gt;rside?lside:rside)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>L2-006 树的遍历（25 分）</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-006-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-006-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%8825-%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>L2-006 树的遍历（25 分）<br>给定一棵二叉树的后序遍历和中序遍历，请你输出其层序遍历的序列。这里假设键值都是互不相等的正整数。</p><p>输入格式：</p><p>输入第一行给出一个正整数N（&lt;=30），是二叉树中结点的个数。第二行给出其后序遍历序列。第三行给出其中序遍历序列。数字间以空格分隔。</p><p>输出格式：</p><p>在一行中输出该树的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。</p><p>输入样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">2 3 1 5 7 6 4</span><br><span class="line">1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure></p><p>输出样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 1 6 3 5 7 2</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node* lchild;</span><br><span class="line">    node* rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> pre[maxn],in[maxn],post[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> postl,<span class="keyword">int</span> postr,<span class="keyword">int</span> inl,<span class="keyword">int</span> inr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(postl&gt;postr)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* root = <span class="keyword">new</span> node;</span><br><span class="line">    root-&gt;data=post[postr];</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k=inl;k&lt;=inr;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[k]==post[postr])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numLeft=k-inl;</span><br><span class="line">    root-&gt;lchild=create(postl,postl+numLeft<span class="number">-1</span>,inl,k<span class="number">-1</span>);</span><br><span class="line">    root-&gt;rchild=create(postl+numLeft,postr<span class="number">-1</span>,k+<span class="number">1</span>,inr);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node* now=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,now-&gt;data);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;n) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;lchild!=<span class="literal">NULL</span>) q.push(now-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;rchild!=<span class="literal">NULL</span>) q.push(now-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;post[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    node* root=create(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    bfs(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>110. 平衡二叉树</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p>示例 1:</p><p>给定二叉树 [3,9,20,null,null,15,7]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回 true 。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   2</span><br><span class="line">    / \</span><br><span class="line">   3   3</span><br><span class="line">  / \</span><br><span class="line"> 4   4</span><br><span class="line">返回 false 。</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balanceHeight(root)&gt;=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//假如是平衡二叉树，则返回root的高度，否则返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">balanceHeight</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = balanceHeight(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = balanceHeight(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(left&lt;<span class="number">0</span>||right&lt;<span class="number">0</span>||(<span class="built_in">abs</span>(left-right)&gt;<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>258. 各位相加</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/258-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/258-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 38</span><br><span class="line">输出: 2</span><br><span class="line">解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。</span><br></pre></td></tr></table></figure></p><p>进阶:<br>你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num<span class="number">-9</span>*((num<span class="number">-1</span>)/<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=num%<span class="number">10</span>;</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> addDigits(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>292. Nim游戏</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/292-Nim%E6%B8%B8%E6%88%8F/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/292-Nim%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>你和你的朋友，两个人一起玩Nim游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p><p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；<br>     因为无论你拿走 1块、2块 还是 3块石头，最后一块石头总是会被你的朋友拿走。</p><p><strong>找规律发现，只要是4的倍数就一定会输</strong></p><p>class Solution {<br>public:<br>    bool canWinNim(int n) {<br>       return (n%4!=0);<br>    }<br>};</p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>344. 反转字符串</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>请编写一个函数，其功能是将输入的字符串反转过来。</p><p>示例：</p><p>输入：s = “hello”<br>返回：”olleh”<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        reverse(s.begin(),s.end());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">string</span> res;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nIdx = <span class="number">0</span>; nIdx &lt; s.length(); nIdx++)</span><br><span class="line">&#123;</span><br><span class="line">res += s[s.length() - nIdx - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>268. 缺失数字</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/268-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/268-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure></p><p>说明:<br>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=i)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            j=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>231. 2的幂</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/231-2%E7%9A%84%E5%B9%82/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/231-2%E7%9A%84%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数，写一个函数来判断它是否是 2 的幂次方。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 16</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 218</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>分析：</p><ul><li>负数一定不是2的幂</li><li>2的整数次幂对应的二进制数只含有0个或者1个1</li><li>时间复杂度：O(n)    空间复杂度：O(1)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> hasOne = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hasOne)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    hasOne = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasOne;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>217. 存在重复元素</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>108. 将有序数组转换为二叉搜索树</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><p>给定有序数组: [-10,-3,0,5,9],</p><p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     0</span><br><span class="line">    / \</span><br><span class="line">  -3   9</span><br><span class="line">  /   /</span><br><span class="line">-10  5</span><br></pre></td></tr></table></figure></p><p>因为给出的是有序数组，所以数组的中间元素就是二叉搜索树的根结点，然后分治去递归<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums,<span class="number">0</span>,nums.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (end+start)/<span class="number">2</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root-&gt;left = sortedArrayToBST(nums,start,mid);</span><br><span class="line">        root-&gt;right = sortedArrayToBST(nums,mid+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>101. 对称二叉树</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure></p><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">递归写法：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *p,TreeNode *q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span>&amp;&amp;q==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span>||q==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val==q-&gt;val&amp;&amp;isSymmetric(p-&gt;left,q-&gt;right)&amp;&amp;isSymmetric(p-&gt;right,q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">迭代写法：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root-&gt;left);</span><br><span class="line">        s.push(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">auto</span> q = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(!q&amp;&amp;!p) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p||!q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val!=q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s.push(p-&gt;left);</span><br><span class="line">            s.push(q-&gt;right);</span><br><span class="line">            s.push(p-&gt;right);</span><br><span class="line">            s.push(q-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>198. 打家劫舍</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
      
        <content type="html"><![CDATA[<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。<br>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br></pre></td></tr></table></figure></p><p>解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。<br>考虑动态规划解法，关键在于得到dp转移方程<br><strong>dp[i] = max(dp[i-2]+nums[i],dp[i-1]);</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(nums.size());</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>67. 二进制求和</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p><p>输入为非空字符串且只包含数字 1 和 0。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">输出: &quot;100&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = a.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = b.size();</span><br><span class="line">        <span class="keyword">if</span>(len1==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len2==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index1 = len1<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = len2<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index1&gt;=<span class="number">0</span>&amp;&amp;index2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = (a[index1]-<span class="string">'0'</span>)+(b[index2]-<span class="string">'0'</span>)+carry;</span><br><span class="line">            carry = num/<span class="number">2</span>;</span><br><span class="line">            num = num%<span class="number">2</span>;</span><br><span class="line">            index1--;</span><br><span class="line">            index2--;</span><br><span class="line">            ret.insert(ret.begin(),num+<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index1&lt;<span class="number">0</span>&amp;&amp;index2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(carry==<span class="number">1</span>)&#123;</span><br><span class="line">                ret.insert(ret.begin(),carry+<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(index1&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = (a[index1]-<span class="string">'0'</span>)+carry;</span><br><span class="line">            carry = num/<span class="number">2</span>;</span><br><span class="line">            num = num%<span class="number">2</span>;</span><br><span class="line">            index1--;</span><br><span class="line">            ret.insert(ret.begin(),num+<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(index2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = (b[index2]-<span class="string">'0'</span>)+carry;</span><br><span class="line">            carry = num/<span class="number">2</span>;</span><br><span class="line">            num = num%<span class="number">2</span>;</span><br><span class="line">            index2--;</span><br><span class="line">            ret.insert(ret.begin(),num+<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry==<span class="number">1</span>)&#123;</span><br><span class="line">            ret.insert(ret.begin(),carry+<span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>155. 最小栈</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/155-%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/155-%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。<br>示例:</p><p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minSt;</span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!minSt.empty())&#123;</span><br><span class="line">            minSt.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        st.push(x);</span><br><span class="line">        <span class="keyword">if</span>(minSt.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            minSt.push(x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=minSt.top())&#123;</span><br><span class="line">                minSt.push(x);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                minSt.push(minSt.top());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            st.pop();</span><br><span class="line">            minSt.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minSt.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSt.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>205. 同构字符串</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定两个字符串 s 和 t，判断它们是否是同构的。</p><p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;egg&quot;, t = &quot;add&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;foo&quot;, t = &quot;bar&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;paper&quot;, t = &quot;title&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>说明:<br>你可以假设 s 和 t 具有相同的长度。</p><p>用两个HashMap维护字符的映射关系，时间复杂度O(n)，空间复杂度O(n)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Character,Character&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Character,Character&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span> c1 = s.charAt(i);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span> c2 = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map1.containsKey(c1))&#123;</span><br><span class="line">                <span class="keyword">if</span>(map1.get(c1)!=c2) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map1.put(c1,c2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(map2.containsKey(c2))&#123;</span><br><span class="line">                <span class="keyword">if</span>(map2.get(c2)!=c1) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map2.put(c2,c1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>125. 验证回文串</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>说明：本题中，我们将空字符串定义为有效的回文串。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p><strong>transform函数的作用是：将某操作应用于指定范围的每个元素</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++transform|C++tolower|C++toupper|C++字母转大写|C++字母转小写</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">usingnamespacestd;</span><br><span class="line">voidmain()</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"WelcomeToWebSite!"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;transform(s.begin(),s.end(),s.begin(),::<span class="built_in">tolower</span>);<span class="comment">//字母转小写</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;transform(s.begin(),s.end(),s.begin(),::<span class="built_in">toupper</span>);<span class="comment">//字母转大写</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(s.size()==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>)||(s[i]&gt;=<span class="string">'a'</span>&amp;&amp;s[i]&lt;=<span class="string">'z'</span>)||(s[i]&gt;=<span class="string">'A'</span>&amp;&amp;s[i]&lt;=<span class="string">'Z'</span>))&#123;</span><br><span class="line">                res+=s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        transform(res.begin(),res.end(),res.begin(),::<span class="built_in">tolower</span>);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=res.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i]!=res[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>13. 罗马数字转整数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>罗马数字包含以下七种字符：I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: C = 100, L = 50, XXX = 30, III = 3.</span><br></pre></td></tr></table></figure></p><p>示例 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        ans = toInt(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            ans +=toInt(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(toInt(s[i<span class="number">-1</span>])&lt;toInt(s[i]))&#123;</span><br><span class="line">                ans -=toInt(s[i<span class="number">-1</span>])*<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toInt</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'V'</span>:<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'X'</span>:<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:<span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:<span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>:<span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>:<span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>122. 买卖股票的最佳时机 II</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/</url>
      
        <content type="html"><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br></pre></td></tr></table></figure></p><p>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<br>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br>示例 3:</p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>用贪心的思想，低进高出，只要相邻两天有差价就相加，因为题中没有限制交易次数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-prices[i<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=prices[i]-prices[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>111. 二叉树的最小深度</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最小深度  2.</span><br></pre></td></tr></table></figure></p><p>递归写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minDepth(root,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode *root,<span class="keyword">bool</span> hasbrother)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> hasbrother ? INT_MAX:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+min(minDepth(root-&gt;left,root-&gt;right!=<span class="literal">NULL</span>),minDepth(root-&gt;right,root-&gt;left!=<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>迭代写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">int</span> result = INT_MAX;</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;TreeNode*,<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">        s.push(make_pair(root,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> node = s.top().first;</span><br><span class="line">            <span class="keyword">auto</span> depth = s.top().second;</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left==<span class="literal">nullptr</span>&amp;&amp;node-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                result = min(result,depth);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left&amp;&amp;result&gt;depth)&#123;</span><br><span class="line">                s.push(make_pair(node-&gt;left,depth+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right&amp;&amp;result&gt;depth)&#123;</span><br><span class="line">                s.push(make_pair(node-&gt;right,depth+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>119. 杨辉三角 II</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-II/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-II/</url>
      
        <content type="html"><![CDATA[<p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure></p><p>进阶：</p><p>你可以优化你的算法到 O(k) 空间复杂度吗？</p><p>解法：<strong>滚动数组</strong></p><p>我们知道，帕斯卡三角的计算公式是这样的，A[k][n]    =    A[k-1][n-1] +    A[k-1][n]。<br>假设现在数组存放的第3层的数据，[1,    3,    3,    1]，如果我们需要计算第4层的数据， 如果我们从前往后计算，譬如A[4][2]=    A[3][1]    +    A[3][2]，也就是4，但是因为只有一 个数组，所以需要将4这个值覆盖到2这个位置，那么我们计算A[4][3]的时候就会出 现问题了，因为这时候A[3][2]不是3，而是4了。<br>为了解决这个问题，我们只能从后往前计算，仍然是上面那个例子，我们实现计算 A[4][3]    =    A[3][2]    +    A[3][3]，也就是6，我们将6直接覆盖到3这个位置，但不会影响 我们计算A[4][2]，因为A[4][2]    =    A[3][1]    +    A[3][2]，已经不会涉及到3这个位置了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=rowIndex;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">              <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j - <span class="number">1</span>] + <span class="built_in">array</span>[j];</span><br><span class="line">          &#125;</span><br><span class="line">            <span class="built_in">array</span>.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>189. 旋转数组</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure></p><p>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]<br>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br></pre></td></tr></table></figure></p><p>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]<br>说明:</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的原地算法。</p><p>方法一：<br>最简单的想法，进行k次循环，每次循环转移所有元素<br>时间复杂度O(n*k)<br>空间复杂度O(1)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp,previous;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            previous = nums[nums.size()<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.size();j++)&#123;</span><br><span class="line">                temp = nums[j];</span><br><span class="line">                nums[j] = previous;</span><br><span class="line">                previous = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>方法二：用一个额外的数组Array[Accepted]<br>另开一个数组，将每一个元素按正确的位置赋值给新数组，最后将新数组复制到原数组。<br>时间复杂度为O(n)<br>空间复杂度为O(n)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(nums.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            a[(i+k)%nums.size()] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            nums[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>方法三：Using Cyclic Replacements [Accepted]<br>我们可以直接将阵列的每个数字放置在所需的正确位置。但如果我们这样做，我们将破坏原始元素。因此，我们需要将被替换的数字存储在temptemp变量中。然后，我们可以将替换的数字（temptemp）放在正确的位置<br>Look at the following example to clarify the process: nums: [1, 2, 3, 4, 5, 6] k: 2<br><img src="https://leetcode.com/media/original_images/189_Rotate_Array.png" alt="img"><br>时间复杂度为O(n)<br>空间复杂度为O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       k = k%nums.size();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start=<span class="number">0</span>;count&lt;nums.size();start++)&#123;</span><br><span class="line">            <span class="keyword">int</span> current = start;</span><br><span class="line">            <span class="keyword">int</span> prev = nums[start];</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> next = (current+k)%nums.size();</span><br><span class="line">                <span class="keyword">int</span> temp = nums[next];</span><br><span class="line">                nums[next] = prev;</span><br><span class="line">                prev = temp;</span><br><span class="line">                current = next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">while</span>(start!=current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法四：用reverse函数<br>时间复杂度为O(n)<br>空间复杂度为O(1)<br>例如：<br>Original List                   : 1 2 3 4 5 6 7<br>After reversing all numbers     : 7 6 5 4 3 2 1<br>After reversing first k numbers : 5 6 7 4 3 2 1<br>After revering last n-k numbers : 5 6 7 1 2 3 4 –&gt; Result<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       k = k%nums.size();</span><br><span class="line">       reverse(nums,<span class="number">0</span>,nums.size()<span class="number">-1</span>);</span><br><span class="line">       reverse(nums,<span class="number">0</span>,k<span class="number">-1</span>);</span><br><span class="line">       reverse(nums,k,nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>14. 最长公共前缀</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br><span class="line">说明:</span><br></pre></td></tr></table></figure></p><p><strong>所有输入只包含小写字母 a-z 。</strong></p><p>可以采用纵向扫描或横向扫描<br>纵向扫描，就从位置0开始，对每一个位置比较所有的字符串，直到遇到不匹配的字符为止。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.empty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs[<span class="number">0</span>].size();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;strs.size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[j][i]!=strs[<span class="number">0</span>][i]) <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>202. 快乐数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/202-%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/202-%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>编写一个算法来判断一个数是不是“快乐数”。</p><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 19</span><br><span class="line">输出: true</span><br><span class="line">解释:</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></figure></p><p>我们可以建立一个集合，将循环中计算得到的数组存入集合，如果算得结果为1，则为快乐数，相反如果有某个数重复出现，那么必然不是快乐数</p><p><strong>不是快乐数的数称为不快乐数（unhappy number），所有不快乐数的数位平方和计算，最后都会进入 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环中。</strong><br>维基百科中有关于快乐数比较详细的介绍<br><a href="https://en.wikipedia.org/wiki/Happy_number" target="_blank" rel="noopener">快乐数</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            n = numSquareSum(n);</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(st.find(n)!=st.end())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            st.insert(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> squareSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            squareSum +=(n%<span class="number">10</span>)*(n%<span class="number">10</span>);</span><br><span class="line">            n /=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> squareSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>203. 删除链表中的节点</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/203-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/203-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>删除链表中等于给定值 val 的所有节点。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> head;<span class="comment">//检查链表是否为空</span></span><br><span class="line">        ListNode *p = head,*tmp = head,*dum = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        dum-&gt;next = head;</span><br><span class="line">        p = dum;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;<span class="comment">//遍历整个链表</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val==val)&#123;<span class="comment">//删除与给定值相等的结点</span></span><br><span class="line">                tmp = p-&gt;next;</span><br><span class="line">                p-&gt;next = tmp-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dum-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dum;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>28. 实现strStr()</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/28-%E5%AE%9E%E7%8E%B0strStr/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/28-%E5%AE%9E%E7%8E%B0strStr/</url>
      
        <content type="html"><![CDATA[<p>实现 strStr() 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p><p>一道字符串匹配的问题：<br>方法一：暴力解法，时间复杂度O(m*n)</p><p>方法二：KMP算法</p><p>方法三：Boyer-Mooer算法</p><p>方法四：Rabin-Karp算法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, lenh = haystack.length(), lenn = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (lenn == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= lenh - lenn; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; lenn; j++)</span><br><span class="line">                <span class="keyword">if</span> (haystack[i + j] !=  needle[j]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 匹配成功</span></span><br><span class="line">            <span class="keyword">if</span> (j == lenn)  <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// KMP解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; KMPpreprocessing(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; match(n,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; s[i]!=s[j+<span class="number">1</span>]) j = match[j];</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>]) j++;</span><br><span class="line">            match[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(haystack.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = haystack.size(), n = needle.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; match = KMPpreprocessing(needle);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; haystack[i]!=needle[j+<span class="number">1</span>]) j = match[j];</span><br><span class="line">            <span class="keyword">if</span>(haystack[i]==needle[j+<span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j==n<span class="number">-1</span>) <span class="keyword">return</span> (i-n+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>20. 有效的括号</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> left = <span class="string">"([&#123;"</span>;</span><br><span class="line">        <span class="built_in">string</span> right = <span class="string">")]&#125;"</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.find(c)!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                stk.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stk.empty()||stk.top()!=left[right.find(c)])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>172. 阶乘后的零</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数 n，返回 n! 结果尾数中零的数量。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 0</span><br><span class="line">解释: 3! = 6, 尾数中没有零。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 1</span><br><span class="line">解释: 5! = 120, 尾数中有 1 个零.</span><br></pre></td></tr></table></figure></p><p>说明: 你算法的时间复杂度应为 O(log n) 。</p><p>尾随零通常由素数因子2和5产生。如果我们可以计数5s和2s的数量，我们的任务就完成了<br>Trailing 0s in n! = Count of 5s in prime factors of n!<br>                  = floor(n/5) + floor(n/25) + floor(n/125) + ….<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n=n/<span class="number">5</span>) count+=n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树状数组</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="lowbit运算"><a href="#lowbit运算" class="headerlink" title="lowbit运算"></a>lowbit运算</h1><p>lowbit运算属于二进制的一个经典应用：<br>lowbit(x) = x &amp; (-x)</p><p>整数在计算机中一般采用的是补码存储，而把一个补码表示的整数x变成其相反数-x的过程相当于把x的二进制的每一位<br>都取反，然后末位+1.这又等价于直接把x的二进制最右边的1左边的每一位都取反。</p><p>所以lowbit(x) = x &amp; (-x)其实就是取x的二进制最右边的1和它右边所有0.<br>lowbit(x)也可以理解为能整除x的最大2的幂次。</p><h1 id="树状数组及其应用"><a href="#树状数组及其应用" class="headerlink" title="树状数组及其应用"></a>树状数组及其应用</h1><p>例题导入：给出一个整数序列A，元素个数为N(N&lt;=10^5),接下来查询K次（K&lt;=10^5）,每次查询将给出一个正整数（x）(x&lt;=N)<br>,求前x个整数之和。</p><p>一般做法是开一个sum数组，其中sum[i]表示前i个整数之和（数组下标从1开始），这样sum数组就可以在输入N个整数时<br>就预处理出来。接着每次查询前x个整数之和时，输出sum[x]就行。每次查询复杂度为O(1),查询总复杂度为O(K)</p><p>问题升级：假设在查询的过程中可能随时给第x个整数加上一个整数v，要求在查询中能实时输出前x个整数之和<br>（更新操作和查询操作的次数总和为K次）。若按照原先的思路，操作的总复杂度会达到O(KN).</p><h2 id="BIT树状数组解法"><a href="#BIT树状数组解法" class="headerlink" title="BIT树状数组解法"></a>BIT树状数组解法</h2><p>树状数组其实仍然是一个数组，是一个用来记录和的数组，只不过它存放的不是前i个整数之和，而是在i号位之前<br>（含i号位）lowbit(i)个整数之和。<br>用数组C表示树状数组，其中C[i]存放数组A中i号位之前lowbit(i)个元素之和，C[i]和覆盖长度为lowbit(i)<br>lowbit(i)是2的幂次</p><p><img src="https://github.com/Mrhuangyi/Algorithm-and-data-structure/blob/master/Advanced-Algorithm/BIT1.PNG" alt="Alt"></p><p><strong>树状数组的下标必须从1开始</strong></p><h3 id="设计函数getSum-x-返回前x个数之和A-i-……-A-x"><a href="#设计函数getSum-x-返回前x个数之和A-i-……-A-x" class="headerlink" title="设计函数getSum(x) ,返回前x个数之和A[i]+……+A[x]"></a>设计函数getSum(x) ,返回前x个数之和A[i]+……+A[x]</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i))&#123;</span><br><span class="line">    sum+=c[i];</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设计函数update-x-y-实现将第x个数加上一个数v的功能，即A-x-v"><a href="#设计函数update-x-y-实现将第x个数加上一个数v的功能，即A-x-v" class="headerlink" title="设计函数update(x,y),实现将第x个数加上一个数v的功能，即A[x]+=v."></a>设计函数update(x,y),实现将第x个数加上一个数v的功能，即A[x]+=v.</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=N;i+=lowbit(i))&#123;</span><br><span class="line">        c[i]+=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树状数组经典应用"><a href="#树状数组经典应用" class="headerlink" title="树状数组经典应用"></a>树状数组经典应用</h1><p>统计序列中在元素左边比该元素小的元素个数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(i) ((i)&amp;(-i))</span></span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;maxn;i+=lowbit(i))&#123;</span><br><span class="line">        c[i]+=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i))&#123;</span><br><span class="line">        sum+=c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        update(x,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,getSum(x<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">离散化代码</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(i) ((i)&amp;(-i))</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">&#125;temp[maxn];</span><br><span class="line"><span class="keyword">int</span> A[maxn];</span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;maxn;i+=lowbit(i))&#123;</span><br><span class="line">        c[i]+=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i))&#123;</span><br><span class="line">        sum+=c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp[i].val);</span><br><span class="line">        temp[i].pos=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(temp,temp+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>||temp[i].val!=temp[i<span class="number">-1</span>].val)&#123;</span><br><span class="line">            A[temp[i].pos] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            A[temp[i].pos] = A[temp[i<span class="number">-1</span>].pos];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        update(A[i],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,getSum(A[i]<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>LeetCode191. 位1的个数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><p>示例 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 11</span><br><span class="line">输出: 3</span><br><span class="line">解释: 整数 11 的二进制表示为 00000000000000000000000000001011</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 128</span><br><span class="line">输出: 1</span><br><span class="line">解释: 整数 128 的二进制表示为 00000000000000000000000010000000</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            ans +=n%<span class="number">2</span>;</span><br><span class="line">            n/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode121. 买卖股票的最佳时机</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure></p><p>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure></p><p><strong>分析：</strong><br>考察贪心思想，分别找到价格最高最低和最高的一天，并且保证最低的一天在最高的一天之前<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size()&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minm = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();i++)&#123;</span><br><span class="line">            profit = max(profit,prices[i]-minm);</span><br><span class="line">            minm = min(minm,prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode104. 二叉树的最大深度</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode100. 相同的树</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 递归写法：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p&amp;&amp;!q) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//终止</span></span><br><span class="line">        <span class="keyword">if</span>(!p||!q) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;val==q-&gt;val&amp;&amp;(isSameTree(p-&gt;left,q-&gt;left))&amp;&amp;isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">迭代写法</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(p);</span><br><span class="line">        s.push(q);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            p = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            q = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(!p&amp;&amp;!q) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p||!q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val!=q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s.push(p-&gt;left);</span><br><span class="line">            s.push(q-&gt;left);</span><br><span class="line">            s.push(p-&gt;right);</span><br><span class="line">            s.push(q-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode118. 杨辉三角</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
      
        <content type="html"><![CDATA[<p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>规律：</p><ol><li>第k层有k个元素</li><li>每层第一个和最后一个为1</li><li>对于第k(k&gt;2)层第n(n&gt;1&amp;&amp;n&lt;k)各元素有a[k][n] = a[k-1][n-1]+a[k-1][n]<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vals;</span><br><span class="line">        vals.resize(numRows);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">            vals[i].resize(i+<span class="number">1</span>);</span><br><span class="line">            vals[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            vals[i][vals[i].size()<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;vals[i].size()<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                vals[i][j] = vals[i<span class="number">-1</span>][j<span class="number">-1</span>]+vals[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>余光中的诗</title>
      <link href="/%E9%98%85%E8%AF%BB/%E4%BD%99%E5%85%89%E4%B8%AD%E7%9A%84%E8%AF%97/"/>
      <url>/%E9%98%85%E8%AF%BB/%E4%BD%99%E5%85%89%E4%B8%AD%E7%9A%84%E8%AF%97/</url>
      
        <content type="html"><![CDATA[<p>我会爱上现代诗，很大程度上有余先生的功劳；而我会关注到余先生，很大程度上是我一位高中同学的功劳。<br>先生是在17年12月走的，得知消息后，内心还是有些伤感，但很快也就释然，相信先生定然是坦然且无遗憾地离开了我们。和很多朋友一样，了解到先生还是因为学校教材里收录了的他的作品，一首《乡愁》，便传遍了大江南北，一篇散文《听听那冷雨》，让人惊叹，原来是可以这么唱，散文可以这么写。梁实秋曾评价余光中，右手写诗，左手写散文，成就之高，一时无两。但之后我并未再去深入了解先生的作品，直到高三。班里有位大高个，是我在高中认识并结交的为数不多的好友之一，大家都叫他发哥，估计是身材魁梧的原因吧。可你绝对想不到，这家伙外表粗犷，内心却极其细腻，他很爱读书和摄影。猛虎细嗅蔷薇的感觉，用来形容他再适合不过了。记得高三班里面，的确，每个人座位里，抽屉里全都堆满了书，但几乎全是辅导书，模拟题，这时，发哥时不时拿在手里细细品味的一本《余光中散文诗集》就吸引了我的注意力，我笑嘻嘻地求他借我也看看，温暖的发哥自然不会拒绝，就这样，我一点点地了解到了先生更多的作品。如今先生走了，我不知该怎么还念他，于是又拿起了当年买的他的一本诗集翻看阅读着，顺便摘录几篇自己很喜欢的，与大家共品。<br><blockquote class="blockquote-center"><h1 id="绝色"><a href="#绝色" class="headerlink" title="绝色"></a>绝色</h1><p>美丽而善变的巫娘，那月亮<br>翻译是她的特长<br>却把世界译走了样<br>把太阳的鎔金译成了流银<br>把烈火译成了冰<br>而且带点薄荷的风味<br>凡尝过的人都说<br>译文是全不可靠<br>但比起原文来呢<br>却更加神秘，更加美<br>雪是另一位唯美的译者<br>存心把世界译错<br>或者译对，诗人说<br>只因原文本来就多误<br>所以每当雪姑<br>乘著六瓣的降落伞<br>在风里飞旋地降临<br>这世界一夜之间<br>比革命更彻底<br>竟变得如此白净<br>若逢新雪初霁，满月当空<br>下面平铺著皓影<br>上面流转著亮银<br>而你带笑地向我步来<br>月色与雪色之间<br>你是第三种绝色<br>不知月色加反光的雪色<br>该如何将你的本色<br>——已经够出色的了<br>合译成更绝的艳色？</p></blockquote></p><blockquote class="blockquote-center"><h1 id="寻李白"><a href="#寻李白" class="headerlink" title="寻李白"></a>寻李白</h1><p>痛饮狂歌空度日 飞扬跋扈为谁雄<br>那一双傲慢的靴子至今还落在<br>高力士羞愤的手里，人却不见了<br>把满地的难民和伤兵<br>把胡马和羌笛交践的节奏<br>留给杜二去细细的苦吟<br>自从那年贺知章眼花了<br>认你做谪仙，便更加佯狂<br>用一只中了魔咒的小酒壶<br>把自己藏起来，连太太也寻不到你<br>怨长安城小而壶中天长<br>在所有的诗里你都预言<br>会突然水遁，或许就在明天<br>只扁舟破浪，乱发当风<br>而今，果然你失了踪<br>树敌如林，世人皆欲杀<br>肝硬化怎杀得死你<br>酒入豪肠，七分酿成了月光<br>余下的三分啸成剑气<br>绣口一吐，就半个盛唐<br>从开元到天宝，从洛阳到咸阳<br>冠盖满途车骑的嚣闹<br>不及千年后你的一首<br>水晶绝句轻叩我额头<br>当地一弹挑起的回音<br>一贬世上已经够落魄<br>再放夜郎毋乃太难堪<br>至今成谜是你的籍贯<br>陇西或山东，青莲乡或碎叶城<br>不如归去归哪个故乡<br>凡你醉处，你说过，皆非他乡<br>失踪，是天才唯一的下场<br>身后事，究竟你遁向何处<br>猿啼不住，杜二也苦劝你不住<br>一回头囚窗下竟已白头<br>七仙、五友，都救不了你了<br>匡山给雾锁了，无路可入<br>仍炉火未纯青，就半粒丹砂<br>怎追蹑葛洪袖里的流霞<br>樽中月影，或许那才是你故乡<br>常得你一生痴痴地仰望<br>而无论出门向东哭，向西哭<br>长安却早已陷落<br>这二十四万里的归程<br>也不必惊动大鹏了，也无须招鹤<br>只消把酒杯向半空一扔<br>便旋成一只霍霍的飞碟<br>诡绿的闪光愈转愈快<br>接你回传说里去</p></blockquote><blockquote class="blockquote-center"><h1 id="今生今世"><a href="#今生今世" class="headerlink" title="今生今世"></a>今生今世</h1><p>我最忘情的哭声有两次<br>一次，在我生命的开始<br>一次，在你生命的告终<br>第一次，我不会记得<br>是听你说的<br>第二次，你不会晓得<br>我说也没用<br>但这两次哭声的中间<br>有无穷无尽的笑声<br>一遍一遍又一遍<br>回荡了整整30年<br>你都晓得，我都记得</p></blockquote><blockquote class="blockquote-center"><h1 id="乡愁"><a href="#乡愁" class="headerlink" title="乡愁"></a>乡愁</h1><p>小时候<br> 乡愁是一枚小小的邮票<br> 我在这头<br> 母亲在那头<br> 长大後<br> 乡愁是一张窄窄的船票<br> 我在这头<br> 新娘在那头<br> 後来啊<br> 乡愁是一方矮矮的坟墓<br> 我在外头<br> 母亲在□头<br> 而现在<br> 乡愁是一湾浅浅的海峡<br> 我在这头<br> 大陆在那头</p></blockquote> <blockquote class="blockquote-center"><h1 id="等你，在雨中"><a href="#等你，在雨中" class="headerlink" title="等你，在雨中"></a>等你，在雨中</h1><p>等你，在雨中，在造虹的雨中<br>蝉声沉落，蛙声升起<br>一池的红莲如红焰，在雨中<br>　<br>你来不来都一样，竟感觉<br>每朵莲都像你<br>尤其隔着黄昏，隔着这样的细雨<br>　<br>永恒，刹那，刹那，永恒<br>等你，在时间之外，在时间之外，等你，<br>在刹那，在永恒<br>　<br>如果你的手在我的手里，此刻<br>如果你的清芬<br>在我的鼻孔，我会说，小情人<br>　<br>诺，这只手应该采莲，在吴宫<br>这只手应该<br>摇一柄桂浆，在木兰舟中<br>　<br>一颗星悬在科学馆的飞檐<br>耳坠子一般的悬着<br>瑞士表说都七点了<br>忽然你走来<br>　<br>步雨后的红莲，翩翩，你走来<br>像一首小令<br>从一则爱情的典故里你走来<br>　<br>从姜白石的词里，有韵地，你走来</p></blockquote><blockquote class="blockquote-center"><h1 id="白玉苦瓜"><a href="#白玉苦瓜" class="headerlink" title="白玉苦瓜"></a>白玉苦瓜</h1><p>似醒似睡，缓缓的柔光里<br>似悠悠醒自歉年的大寐<br>一只瓜从从容容在成熟<br>一只苦瓜，不再是色苦<br>日磨月磋琢出深孕的清莹<br>看茎须缭绕，叶掌抚抱<br>哪一年的丰收想一口要吸尽<br>古中国喂了又喂的乳浆<br>完满的圆腻啊酣然而饱<br>那触角，不断向外膨胀<br>充实每一粒酪白的葡萄<br>直到瓜尖，仍翘着当日的新鲜 </p><p>茫茫九州只缩成一张舆图<br>小时候不知道将它叠起<br>一任摊开那无穷无尽<br>硕大似记忆母亲，她的胸脯<br>你便向那片肥沃匍匐<br>用蒂用根索她的恩液<br>苦心的慈悲苦苦哺出<br>不幸呢还是大幸这婴孩<br>钟整个大陆的爱在一只苦瓜<br>皮鞋踩过，马蹄踩过<br>重吨战车的履带踩过<br>一丝伤痕也不曾留下</p><p>只留下隔玻璃这奇迹难信<br>犹带着后土依依的祝福<br>在时光以外奇异的光中<br>熟着，一个自足的宇宙<br>饱满而不虞腐烂，一只仙果<br>不产生在仙山，产在人间<br>久朽了，你的前身，唉，久朽<br>为你换胎的那手，那巧腕<br>千眄万睐巧将你引渡<br>笑对灵魂在白玉里流转<br>一首歌，咏生命曾经是瓜而苦<br>被永恒引渡，成果而甘<br>　　　　　　　　1974.2.11　　　　　　　　</p></blockquote><blockquote class="blockquote-center"><h1 id="下次的约会"><a href="#下次的约会" class="headerlink" title="下次的约会"></a>下次的约会</h1><p>当我死时，你的名字，如最后一瓣花<br>自我的唇上飘落。你的手指<br>是一串串钥匙，玲玲珑珑<br>握在我手中，让我开启<br>让我豁然开启，哪一扇门？</p><p>握你的手而死是幸运的<br>听你说，你仍爱我，听你说<br>凤凰死后还有凤凰<br>春天死后还有春天，但至少<br>有一个五月曾属于我们</p><p>每一根白发仍为你颤抖，每一根潇骚<br>都记得旧时候，记得<br>你踩过的地方绽几朵红莲<br>你立的地方喷一株水仙<br>你立在风中，裙也翩翩，发也翩翩</p><p>覆你的耳朵于我的胸膛<br>听我的心说，它倦了，倦了<br>它已经逾龄，为甄甄啊甄甄<br>它跳得太强烈，跳得太频<br>爱情给它太重的负荷，爱情</p><p>爱情的一端在此，另一端<br>在原始。 上次约会在蓝田<br>再上次，在洛水之滨<br>在洪荒，在沧海，在星云的叆叆<br>在记忆啊记忆之外，另一端爱情</p><p>下次的约会在何处，在何处？<br>你说呢，你说，我依你<br>（你可相信轮回，你可相信？）<br>死亡的黑袖挡住，我看不清楚，可是<br>嗯，我听见了，我一定去</p></blockquote><h1 id="听听那冷雨"><a href="#听听那冷雨" class="headerlink" title="听听那冷雨"></a>听听那冷雨</h1><p>惊蛰一过，春寒加剧。先是料料峭峭，继而雨季开始，时而淋淋漓漓，时而淅淅沥沥，天潮潮地湿湿，即连在梦里，也似乎有把伞撑着。而就凭一把伞，躲过一阵潇潇的冷雨，也躲不过整个雨季。连思想也都是潮润润的。每天回家，曲折穿过金门街到厦门街迷宫式的长巷短巷，雨里风里，走入霏霏令人更想入非非。想这样子的台北凄凄切切完全是黑白片的味道，想整个中国整部中国的历史无非是一张黑白片子，片头到片尾，一直是这样下着雨的。这种感觉，不知道是不是从安东尼奥尼那里来的。不过那—块土地是久违了，二十五年，四分之一的世纪，即使有雨，也隔着千山万山，千伞万伞。十五年，一切都断了，只有气候，只有气象报告还牵连在一起，大寒流从那块土地上弥天卷来，这种酷冷吾与古大陆分担。不能扑进她怀里，被她的裙边扫一扫也算是安慰孺慕之情吧。<br>　　这样想时，严寒里竟有一点温暖的感觉了。这样想时，他希望这些狭长的巷子永远延伸下去，他的思路也可以延伸下去，不是金门街到厦门街，而是金门到厦门。他是厦门人，至少是广义的厦门人，二十年来，不住在厦门，住在厦门街，算是嘲弄吧，也算是安慰。不过说到广义，他同样也是广义的江南人，常州人，南京人，川娃儿，五陵少年。杏花春雨江南，那是他的少年时代了。再过半个月就是清明。安东尼奥尼的镜头摇过去，摇过去又摇过来。残山剩水犹如是，皇天后土犹如是。纭纭黔首、纷纷黎民从北到南犹如是。那里面是中国吗？那里面当然还是中国永远是中国。只是杏花春雨已不再，牧童遥指已不再，剑门细雨渭城轻尘也都已不再。然则他日思夜梦的那片土地，究竟在哪里呢？<br>　　在报纸的头条标题里吗？还是香港的谣言里？还是傅聪的黑键白键马恩聪的跳弓拨弦？还是安东尼奥尼的镜底勒马洲的望中？还是呢，故宫博物院的壁头和玻璃柜内，京戏的锣鼓声中太白和东坡的韵里？<br>　　杏花，春雨，江南。六个方块字，或许那片土就在那里面。而无论赤县也好神州也好中国也好，变来变去，只要仓颉的灵感不灭，美丽的中文不老，那形象那磁石一般的向心力当必然长在。因为一个方块字是一个天地。太初有字，于是汉族的心灵他祖先的回忆和希望便有了寄托。譬如凭空写一个“雨”字，点点滴滴，滂滂沱沱，淅淅沥沥，一切云情雨意，就宛然其中了。视觉上的这种美感，岂是什么rain也好pluie也好所能满足？翻开一部《辞源》或《辞海》，金木水火土，各成世界，而一入“雨”部，古神州的天颜千变万化，便悉在望中，美丽的霜雪云霞，骇人的雷电霹雹，展露的无非是神的好脾气与坏脾气，气象台百读不厌门外汉百思不解的百科全书。<br>　　听听，那冷雨。看看，那冷雨。嗅嗅闻闻，那冷雨，舔舔吧，那冷雨。雨在他的伞上这城市百万人的伞上雨衣上屋上天线上，雨下在基隆港在防波堤海峡的船上，清明这季雨。雨是女性，应该最富于感性。雨气空而迷幻，细细嗅嗅，清清爽爽新新，有一点点薄荷的香味，浓的时候，竟发出草和树林之后特有的淡淡土腥气，也许那竟是蚯蚓的蜗牛的腥气吧，毕竟是惊蛰了啊。也许地上的地下的生命也许古中国层层叠叠的记忆皆蠢蠢而蠕，也许是植物的潜意识和梦紧，那腥气。<br>　　第三次去美国，在高高的丹佛他山居住了两年。美国的西部，多山多沙漠，千里干旱，天，蓝似安格罗萨克逊人的眼睛，地，红如印第安人的肌肤，云，却是罕见的白鸟，落基山簇簇耀目的雪峰上，很少飘云牵雾。一来高，二来干，三来森林线以上，杉柏也止步，中国诗词里“荡胸生层云”或是“商略黄昏雨”的意趣，是落基山上难睹的景象。落基山岭之胜，在石，在雪。那些奇岩怪石，相叠互倚，砌一场惊心动魄的雕塑展览，给太阳和千里的风看。那雪，白得虚虚幻幻，冷得清清醒醒，那股皑皑不绝一仰难尽的气势，压得人呼吸困难，心寒眸酸。不过要领略“白云回望合，青露入看无”的境界，仍须来中国。台湾湿度很高，最饶云气氛题雨意迷离的情调。两度夜宿溪头，树香沁鼻，宵寒袭肘，枕着润碧湿翠苍苍交叠的山影和万缀都歇的俱寂，仙人一样睡去。山中一夜饱雨，次晨醒来，在旭日未升的原始幽静中，冲着隔夜的寒气，踏着满地的断柯折枝和仍在流泻的细股雨水，一径探入森林的秘密，曲曲弯弯，步上山去。溪头的山，树密雾浓，蓊郁的水气从谷底冉冉升起，时稠时稀，蒸腾多姿，幻化无定，只能从雾破云开的空处，窥见乍现即隐的一峰半堑，要纵览全貌，几乎是不可能的。至少上山两次，只能在白茫茫里和溪头诸峰玩捉迷藏的游戏。回到台北，世人问起，除了笑而不答心自问，故作神秘之外，实际的印象，也无非山在虚无之间罢了。云绦烟绕，山隐水迢的中国风景，由来予人宋画的韵味。那天下也许是赵家的天下，那山水却是米家的山水。而究竟，是米氏父子下笔像中国的山水，还是中国的山水上只像宋画，恐怕是谁也说不清楚了吧？<br>　　雨不但可嗅，可亲，更可以听。听听那冷雨。听雨，只要不是石破天惊的台风暴雨，在听觉上总是一种美感。大陆上的秋天，无论是疏雨滴梧桐，或是骤雨打荷叶，听去总有一点凄凉，凄清，凄楚，于今在岛上回味，则在凄楚之外，再笼上一层凄迷了，饶你多少豪情侠气，怕也经不起三番五次的风吹雨打。一打少年听雨，红烛昏沉。再打中年听雨，客舟中江阔云低。三打白头听雨的僧庐下，这更是亡宋之痛，一颗敏感心灵的一生：楼上，江上，庙里，用冷冷的雨珠子串成。十年前，他曾在一场摧心折骨的鬼雨中迷失了自己。雨，该是一滴湿漓漓的灵魂，窗外在喊谁。<br>　　雨打在树上和瓦上，韵律都清脆可听。尤其是铿铿敲在屋瓦上，那古老的音乐，属于中国。王禹的黄冈，破如椽的大竹为屋瓦。据说住在竹楼上面，急雨声如瀑布，密雪声比碎玉，而无论鼓琴，咏诗，下棋，投壶，共鸣的效果都特别好。这样岂不像住在竹和筒里面，任何细脆的声响，怕都会加倍夸大，反而令人耳朵过敏吧。<br>　　雨天的屋瓦，浮漾湿湿的流光，灰而温柔，迎光则微明，背光则幽黯，对于视觉，是一种低沉的安慰。至于雨敲在鳞鳞千瓣的瓦上，由远而近，轻轻重重轻轻，夹着一股股的细流沿瓦槽与屋檐潺潺泻下，各种敲击音与滑音密织成网，谁的千指百指在按摩耳轮。“下雨了”，温柔的灰美人来了，她冰冰的纤手在屋顶拂弄着无数的黑键啊灰键，把晌午一下子奏成了黄昏。<br>　　在古老的大陆上，千屋万户是如此。二十多年前，初来这岛上，日式的瓦屋亦是如此。先是天黯了下来，城市像罩在一块巨幅的毛玻璃里，阴影在户内延长复加深。然后凉凉的水意弥漫在空间，风自每一个角落里旋起，感觉得到，每一个屋顶上呼吸沉重都覆着灰云。雨来了，最轻的敲打乐敲打这城市。苍茫的屋顶，远远近近，一张张敲过去，古老的琴，那细细密密的节奏，单调里自有一种柔婉与亲切，滴滴点点滴滴，似幻似真，若孩时在摇篮里，一曲耳熟的童谣摇摇欲睡，母亲吟哦鼻音与喉音。或是在江南的泽国水乡，一大筐绿油油的桑叶被啮于千百头蚕，细细琐琐屑屑，口器与口器咀咀嚼嚼。雨来了，雨来的时候瓦这幺说，一片瓦说千亿片瓦说，说轻轻地奏吧沉沉地弹，徐徐地叩吧挞挞地打，间间歇歇敲一个雨季，即兴演奏从惊蛰到清明，在零落的坟上冷冷奏挽歌，一片瓦吟千亿片瓦吟。<br>　　在旧式的古屋里听雨，听四月，霏霏不绝的黄梅雨，朝夕不断，旬月绵延，湿黏黏的苔藓从石阶下一直侵到舌底，心底。到七月，听台风台雨在古屋顶上一夜盲奏，千层海底的热浪沸沸被狂风挟挟，掀翻整个太平洋只为向他的矮屋檐重重压下，整个海在他的蝎壳上哗哗泻过。不然便是雷雨夜，白烟一般的纱帐里听羯鼓一通又一通，滔天的暴雨滂滂沛沛扑来，强劲的电琵琶忐忐忑忑忐忐忑忑，弹动屋瓦的惊悸腾腾欲掀起。不然便是斜斜的西北雨斜斜刷在窗玻璃上，鞭在墙上打在阔大的芭蕉叶上，一阵寒潮泻过，秋意便弥湿旧式的庭院了。<br>　　在旧式的古屋里听雨，春雨绵绵听到秋雨潇潇，从少年听到中年，听听那冷雨。雨是一种单调而耐听的音乐是室内乐是室外乐，户内听听，户外听听，冷冷，那音乐。雨是一种回忆的音乐，听听那冷雨，回忆江南的雨下得满地是江湖下在桥上和船上，也下在四川在秧田和蛙塘，—下肥了嘉陵江下湿布谷咕咕的啼声，雨是潮潮润润的音乐下在渴望的唇上，舔舔那冷雨。<br>　　因为雨是最最原始的敲打乐从记忆的彼端敲起。瓦是最最低沉的乐器灰蒙蒙的温柔覆盖着听雨的人，瓦是音乐的雨伞撑起。但不久公寓的时代来临，台北你怎么一下子长高了，瓦的音乐竟成了绝响。千片万片的瓦翩翩，美丽的灰蝴蝶纷纷飞走，飞入历史的记忆。现在雨下下来下在水泥的屋顶和墙上，没有音韵的雨季。树也砍光了，那月桂，那枫树，柳树和擎天的巨椰，雨来的时候不再有丛叶嘈嘈切切，闪动湿湿的绿光迎接。鸟声减了啾啾，蛙声沉了咯咯，秋天的虫吟也减了唧唧。七十年代的台北不需要这些，一个乐队接一个乐队便遣散尽了。要听鸡叫，只有去诗经的韵里找。现在只剩下一张黑白片，黑白的默片。<br>　　正如马车的时代去后，三轮车的伕工也去了。曾经在雨夜，三轮车的油布篷挂起，送她回家的途中，篷里的世界小得多可爱，而且躲在警察的辖区以外，雨衣的口袋越大越好，盛得下他的一只手里握一只纤纤的手。台湾的雨季这么长，该有人发明一种宽宽的双人雨衣，一人分穿一只袖子此外的部分就不必分得太苛。而无论工业如何发达，一时似乎还废不了雨伞。只要雨不倾盆，风不横吹，撑一把伞在雨中仍不失古典的韵味。任雨点敲在黑布伞或是透明的塑胶伞上，将骨柄一旋，雨珠向四方喷溅，伞缘便旋成了一圈飞檐。跟女友共一把雨伞，该是一种美丽的合作吧。最好是初恋，有点兴奋，更有点不好意思，若即若离之间，雨不妨下大一点。真正初恋，恐怕是兴奋得不需要伞的，手牵手在雨中狂奔而去，把年轻的长发的肌肤交给漫天的淋淋漓漓，然后向对方的唇上颊上尝凉凉甜甜的雨水。不过那要非常年轻且激情，同时，也只能发生在法国的新潮片里吧。<br>　　大多数的雨伞想不会为约会张开。上班下班，上学放学，菜市来回的途中。现实的伞，灰色的星期三。握着雨伞。他听那冷雨打在伞上。索性更冷一些就好了，他想。索性把湿湿的灰雨冻成干干爽爽的白雨，六角形的结晶体在无风的空中回回旋旋地降下来。等须眉和肩头白尽时，伸手一拂就落了。二十五年，没有受故乡白雨的祝福，或许发上下一点白霜是一种变相的自我补偿吧。一位英雄，经得起多少次雨季？他的额头是水成岩削成还是火成岩？他的心底究竟有多厚的苔藓？厦门街的雨巷走了二十年与记忆等长，—座无瓦的公寓在巷底等他，一盏灯在楼上的雨窗子里，等他回去，向晚餐后的沉思冥想去整理青苔深深的记忆。<br>　　前尘隔海。古屋不再。听听那冷雨。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 88. 合并两个有序数组</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure></p><p>由于题目已经假定nums1有足够的空间，所以就很好解决了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m,j=<span class="number">0</span>;i&lt;m+n,j&lt;n;i++,j++)&#123;</span><br><span class="line">            nums1[i] = nums2[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = m+n;</span><br><span class="line">        sort(nums1.begin(),nums1.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 83. 删除排序链表中的重复元素</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2</span><br><span class="line">输出: 1-&gt;2</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;<span class="comment">//真正写的时候，链表为空一定不能漏了</span></span><br><span class="line">        <span class="keyword">int</span> val = head-&gt;val;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;p-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val!=val)&#123;</span><br><span class="line">                val = p-&gt;next-&gt;val;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode* n = p-&gt;next-&gt;next;</span><br><span class="line">                p-&gt;next = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 7. 反转整数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-7-%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-7-%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定一个 32 位有符号整数，将整数中的数字进行反转。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure></p><p> 示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure></p><p>注意:</p><p>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。</p><p>这道题主要还是考察细节问题；</p><ol><li>考虑负数的情况</li><li>考虑溢出，包括正溢出和负溢出，即如果是正数，则大于2147483647溢出；如果是负数，则小于-2147483648溢出<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t = x;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            t=-t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;t;t/=<span class="number">10</span>)&#123;</span><br><span class="line">            r=r*<span class="number">10</span>+t%<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> sign;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sign = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sign =<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;<span class="number">2147483647</span>||(sign&amp;&amp;r&gt;<span class="number">2147483648</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(sign)&#123;</span><br><span class="line">                <span class="keyword">return</span> -r;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 69. x 的平方根</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-69-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-69-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p><p>这道题明显就是考察二分，面试时你总不可能给面试官直接调用下sqrt函数吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>,right = x/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> last_mid;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">2</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x/mid&gt;mid)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">                last_mid = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x/mid&lt;mid)&#123;</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last_mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 58. 最后一个单词的长度</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。</p><p>如果不存在最后一个单词，请返回 0 。</p><p>说明：一个单词是指由字母组成，但不包含任何空格的字符串。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;Hello World&quot;</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>,tag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">' '</span>)&#123;</span><br><span class="line">                len++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">               <span class="keyword">if</span>((s[i]==<span class="string">' '</span>||i==<span class="number">0</span>)&amp;&amp;len!=<span class="number">0</span>)&#123;          </span><br><span class="line">                <span class="keyword">return</span> len;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 53. 最大子序和</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure></p><p>进阶:</p><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><p>这是一道很经典的算法问题了，很多算法书在讲到dp问题的时候都是作为一个范例了</p><ul><li>思路1：暴力枚举，但是太low了，复杂度达到了O(n^3)量级，所以基本可以忽略</li><li>思路2：先预处理，因为连续子序列和等于两个前缀和之差，时间复杂度为O(n^2)</li><li>思路3：动态规划解法</li><li>思路4：分治法</li></ul><p>我主要就了解了这几种，还有一些其他的优化解法没怎么学过。<br>INT_MIN在标准头文件limits.h中定义。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN (-INT_MAX - 1)</span></span><br></pre></td></tr></table></figure></p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>转移方程：<strong>dp[i+1] = max(dp[i]+a[i+1])</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = INT_MIN,f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            f = max(f + nums[i],nums[i]);</span><br><span class="line">            result = max(result,f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="预处理解法"><a href="#预处理解法" class="headerlink" title="预处理解法"></a>预处理解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deal(nums.begin(),nums.end());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deal</span><span class="params">(T begin,T end)</span></span>&#123;</span><br><span class="line">          <span class="keyword">int</span> result,cur_min;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">int</span> n = distance(begin,end);</span><br><span class="line">          <span class="keyword">int</span> *sum = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">          sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">          result = INT_MIN;</span><br><span class="line">          cur_min = sum[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">              sum[i] = sum[i<span class="number">-1</span>]+*(begin + i - <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">              result = max(result,sum[i]-cur_min);</span><br><span class="line">              cur_min = min(cur_min,sum[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">delete</span>[] sum;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分治解法"><a href="#分治解法" class="headerlink" title="分治解法"></a>分治解法</h2><p>假设数组A[left,    right]存在最大区间，mid    =    (left    +    right)    /    2，那么无非就是三中情 况：</p><ol><li>最大值在A[left,    mid    -    1]里面<ol start="2"><li>最大值在A[mid    +    1,    right]里面</li><li>最大值跨过了mid，也就是我们需要计算[left,    mid    -    1]区间的最大值，以及[mid +    1,    right]的最大值，然后加上mid，三者之和就是总的最大值</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> divide(A,<span class="number">0</span>,n<span class="number">-1</span>,INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> maxm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> lmax = divide(A,left,mid<span class="number">-1</span>,maxm);</span><br><span class="line">        <span class="keyword">int</span> rmax = divide(A,mid+<span class="number">1</span>,right,maxm);</span><br><span class="line">        maxm = max(maxm,lmax);</span><br><span class="line">        maxm = max(maxm,rmax);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mlmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid<span class="number">-1</span>;i&gt;=left;i--)&#123;</span><br><span class="line">            sum+=A[i];</span><br><span class="line">            mlmax = max(mlmax,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mrmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid+<span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            mrmax = max(mrmax,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        maxm = max(maxm,A[mid]+mlmax+mrmax);</span><br><span class="line">        <span class="keyword">return</span> maxm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 35. 搜索插入位置</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(nums[x<span class="number">-1</span>]&lt;target)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;=target)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 27. 移除元素</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><p><strong>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</strong></p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br></pre></td></tr></table></figure></p><p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br></pre></td></tr></table></figure></p><p>注意这五个元素可为任意顺序。</p><p>你不需要考虑数组中超出新长度后面的元素。<br>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><p>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>int len = removeElement(nums, val);</p><p>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=val)&#123;</span><br><span class="line">                nums[index++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance(nums.begin(),remove(nums.begin(),nums.end(),val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 26. 删除排序数组中的重复项</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p><strong>不要使用额外的数组空间</strong>，你必须在原地修改输入数组并在使用<strong> O(1) 额外</strong>空间的条件下完成。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。</span><br></pre></td></tr></table></figure></p><p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br></pre></td></tr></table></figure></p><p>你不需要考虑数组中超出新长度后面的元素。<br>解法一：标记下标，然后遍历数组元素依次进行比较，出现不等元素就赋值给标记的下一个位置<br>解法二：利用STL里的unique函数（由于给的是有序数组，所以可以直接用）</p><ul><li>unique()是C++标准库函数里面的函数，其功能是去除相邻的重复元素（只保留一个），所以使用前需要对数组进行排序</li><li>distance主要是用来求两个迭代器之间的元素个数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                nums[++pos] = nums[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance(nums.begin(),unique(nums.begin(),nums.end()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 21. 合并两个有序链表</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure></p><p>逐个比较大小，到后面较长的链表的多余元素直接补上<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* p = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> val1 = l1-&gt;val;</span><br><span class="line">            <span class="keyword">int</span> val2 = l2-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(val1&lt;val2)&#123;</span><br><span class="line">                p-&gt;next = l1;</span><br><span class="line">                p = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">                p = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 204. 计数质数</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>统计所有小于非负数整数 n 的质数的数量。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 4</span><br><span class="line">解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure></p><p>先预处理，不是素数的就标记出来<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; isPrime(n,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i;j&lt;n;j+=i)&#123;</span><br><span class="line">                    isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 167. 两数之和 II - 输入有序数组</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><p>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.size();i++)&#123;</span><br><span class="line">            m[numbers[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.size();i++)&#123;</span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> gap = target-numbers[i];</span><br><span class="line">            <span class="keyword">if</span>(m.find(gap)!=m.end()&amp;&amp;m[gap]&gt;i)&#123;</span><br><span class="line">                result.push_back(i+<span class="number">1</span>);</span><br><span class="line">                result.push_back(m[gap]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 136.只出现一次的数字</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有<strong>线性时间复杂度</strong>。 你可以<strong>不使用额外空间</strong>来实现吗？</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>分析，只有一个元素出现一次，其余均出现两次，可以想到异或运算符，<br>遍历整个数组，出现两次的异或以后为0，最后自然只剩下了出现一次的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            x^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode 1.两数之和</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p><p>法一：直接双重循环 暴力解，但会超时，O(n^2)</p><p>法二：哈希，用一个哈希表，存储每个数的对应下标，复杂度O(n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            m[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> gap = target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(m.find(gap)!=m.end()&amp;&amp;m[gap]&gt;i)&#123;</span><br><span class="line">                result.push_back(i);</span><br><span class="line">                result.push_back(m[gap]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>技术书单系列2</title>
      <link href="/%E9%98%85%E8%AF%BB/%E6%8A%80%E6%9C%AF%E4%B9%A6%E5%8D%95%E7%B3%BB%E5%88%972/"/>
      <url>/%E9%98%85%E8%AF%BB/%E6%8A%80%E6%9C%AF%E4%B9%A6%E5%8D%95%E7%B3%BB%E5%88%972/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言相关"><a href="#C语言相关" class="headerlink" title="C语言相关"></a>C语言相关</h1><ul><li><p>《C和指针》</p></li><li><p>《C缺陷与陷阱》</p></li><li><p>《C专家编程》</p></li><li><p>《C语言深度剖析》</p></li></ul><h1 id="C-相关"><a href="#C-相关" class="headerlink" title="C++相关"></a>C++相关</h1><ul><li><p>《C++ Primer 5th》</p></li><li><p>《Effective C++》</p></li><li><p>《深度探索C++对象模型》</p></li><li><p>《STL源码剖析》</p></li></ul><h1 id="计算机底层相关"><a href="#计算机底层相关" class="headerlink" title="计算机底层相关"></a>计算机底层相关</h1><ul><li><p>《编码》</p></li><li><p>《编译原理》</p></li><li><p>《汇编语言》</p></li><li><p>《C++反汇编与逆向分析》</p></li></ul><h1 id="算法、数据结构相关"><a href="#算法、数据结构相关" class="headerlink" title="算法、数据结构相关"></a>算法、数据结构相关</h1><ul><li><p>《算法导论》</p></li><li><p>《编程珠玑》</p></li><li><p>《编程之美》</p></li><li><p>《算法艺术与信息学竞赛》</p></li></ul><h1 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h1><ul><li><p>《深入理解操作系统》</p></li><li><p>《Linux内核完全注释》</p></li><li><p>《自己动手写操作系统》</p></li><li><p>《Windows内核原理与实现》</p></li></ul><h1 id="软件开发相关"><a href="#软件开发相关" class="headerlink" title="软件开发相关"></a>软件开发相关</h1><ul><li><p>《Head First 设计模式》</p></li><li><p>《设计模式-可复用面向对象软件的基础》</p></li><li><p>《重构与模式》</p></li><li><p>《代码大全》</p></li><li><p>《设计模式》</p></li></ul><h1 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h1><ul><li><p>《数据库系统概念》</p></li><li><p>《数据库系统实现》</p></li><li><p>《MySQL技术内幕：sql编程》</p></li><li><p>《MySQL技术内幕：innodb存储引擎》</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书单 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>技术书单系列1</title>
      <link href="/%E9%98%85%E8%AF%BB/%E6%8A%80%E6%9C%AF%E4%B9%A6%E5%8D%95%E7%B3%BB%E5%88%971/"/>
      <url>/%E9%98%85%E8%AF%BB/%E6%8A%80%E6%9C%AF%E4%B9%A6%E5%8D%95%E7%B3%BB%E5%88%971/</url>
      
        <content type="html"><![CDATA[<h1 id="我眼中的阅读"><a href="#我眼中的阅读" class="headerlink" title="我眼中的阅读"></a>我眼中的阅读</h1><p>有这么一句话：看一个人，只需看他读什么书，与什么交往。</p><p>但不知为什么，估计是我的社交圈太小的原因吧，大学里面认识的同学，目前没有几个是真正热爱阅读的，不论是带有功利性质的技能书还是休闲性质的杂书。注意，我没有过分强调读书的功利作用，我从不认为不读书的人就怎么怎么没素养，不读书就不能有大的作为。很多时候这也不过是一种爱好，一种消磨时间的途径而已。所以爱读书的也不必故作清高，但不爱读书的，也请将你的读书无用论收一收，不读书的一个巨大遗憾就是让你们产生了这样的眼界。</p><p>对我来说，书的魅力是巨大的，起初和很多人一样，一看到书就头疼，会有种读不下去的感觉，尤其是面对一些字典般大小的恐龙书。因此很多时候，读书也得讲策略，不是任何一本书都得一字一句的啃下去，有选择有针对性的扩展广度，当发现一本内容精致的好书在一遍遍精读也不迟。这里又提到了选书的问题，其实人这一生，你再怎么努力，能读的书终究是有限的，因此选择成了至关重要的一环，门外汉建议还是根据口碑选择较为靠谱，数年积累的业内口碑一般都不是没有理由的，经典之所以能成为经典，必然是经过一代代人的筛选与淘汰留下的宝藏。</p><p>说起自己，倒也误区多多，一方面，关于买书，我明显对技术书籍有了歧视，至今我买的纸质书里面，大多以古今中外文学名著小说诗歌居多，然而技术书却是能用指头就点的过来的寥寥几本。其中，我可能嫌一些技术书价格过高，网上的pdf版本一搜一大把，何苦花这冤枉钱。但后面意识到，很多技术书却是值这个价，内容对一些原理和思维剖析深刻到位，总之纸质书的阅读感很多时候还是电子书无法取代的。我目前两种媒介都不拒绝，大多时候不方便的话，kindle带在身边就是了，方便的话，翻开纸质书就是撸。另外，在读书笔记方面我做的也是有很大欠缺的，一本书读完，或者一部电影看完，只要不是内容空洞话作品，多多少少也该有点自己的理解与总结吧。转眼已到大二下半年，紧迫感似乎越来越强，面对学业上的考核，大三的实习校招，貌似留给我的阅读时间越来越少，且行且珍惜把。</p><p>中学，在高考中考的指挥棒下，自主时间实在有限，以后工作想必时间上的安排也必然紧张。粗想一下，大学貌似是我人生中为数不多的可以有大把时间读书，大把时间旅游，大把时间培养自主习惯的时候了，生活已经不易，希望有更多的人愿意与我一同追逐心中的书和远方。</p><h1 id="刘大佬认为的面试微软10本必读书"><a href="#刘大佬认为的面试微软10本必读书" class="headerlink" title="刘大佬认为的面试微软10本必读书"></a>刘大佬认为的面试微软10本必读书</h1><ol><li>Code: The Hidden Language of Computer Hardware and Software （《编码的奥秘》）</li><li>Computer System: A Programmer’s Perspective （《深入理解计算机系统》） / Windows via C/C++ （《Windows核心编程》 / 《程序员的自我修养》</li><li>Code Complete 2（《代码大全》）/ The Pragmatic Programmer （《程序员修炼之道》，我也把这本书称为《代码小全》）</li><li>Programming Pearls （《编程珠玑》） / Algorithms / Algorithm Design / 《编程之美》</li><li>The C Programming Language</li><li>The C++ Programming Language / Programming: Principles and Practice Using C++ / Accelerated C++</li><li>The Structure and Interpretation of Computer Programs （《计算机程序的构造和解释》）</li><li>Clean Code / Implementation Patterns</li><li>Design Patterns （《设计模式》） / Agile Software Development, Principles, Patterns, and Practices</li><li>Refactoring （《重构》）</li></ol><h1 id="云风的书单（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）"><a href="#云风的书单（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）" class="headerlink" title="云风的书单（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）"></a>云风的书单（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）</h1><ol><li>C++编程思想</li><li>Effective C++</li><li>深度探索C++对象模型</li><li>C++语言的设计和演化</li><li>C专家编程</li><li>C陷阱与缺陷</li><li>C语言接口与实现</li><li>Lua程序设计</li><li>Linkers and Loaders</li><li>COM本质论</li><li>Windows核心编程</li><li>深入解析Windows操作系统</li><li>程序员修炼之道</li><li>代码大全</li><li>UNIX编程艺术</li><li>设计模式</li><li>代码优化：有效使用内存</li><li>深入理解计算机系统</li><li>深入理解LINUX内核</li><li>TCP/IP 详解</li></ol><h1 id="来自stackoverflow的一个帖子"><a href="#来自stackoverflow的一个帖子" class="headerlink" title="来自stackoverflow的一个帖子"></a>来自stackoverflow的一个帖子</h1><ul><li><a href="https://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read" target="_blank" rel="noopener">原网址</a></li></ul><ol><li>Code Complete (2nd edition) by Steve McConnell</li><li>The Pragmatic Programmer</li><li>Structure and Interpretation of Computer Programs</li><li>The C Programming Language by Kernighan and Ritchie</li><li>Introduction to Algorithms by Cormen, Leiserson, Rivest &amp; Stein</li><li>Design Patterns by the Gang of Four</li><li>Refactoring: Improving the Design of Existing Code</li><li>The Mythical Man Month</li><li>The Art of Computer Programming by Donald Knuth</li><li>Compilers: Principles, Techniques and Tools by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman</li><li>Gödel, Escher, Bach by Douglas Hofstadter</li><li>Clean Code: A Handbook of Agile Software Craftsmanship by Robert C. Martin</li><li>Effective C++</li><li>More Effective C++</li><li>CODE by Charles Petzold</li><li>Programming Pearls by Jon Bentley</li><li>Working Effectively with Legacy Code by Michael C. Feathers</li><li>Peopleware by Demarco and Lister</li><li>Coders at Work by Peter Seibel</li><li>Surely You’re Joking, Mr. Feynman!</li><li>Effective Java 2nd edition</li><li>Patterns of Enterprise Application Architecture by Martin Fowler</li><li>The Little Schemer</li><li>The Seasoned Schemer</li><li>Why’s (Poignant) Guide to Ruby</li><li>The Inmates Are Running The Asylum: Why High Tech Products Drive Us Crazy and How to Restore the Sanity</li><li>The Art of Unix Programming</li><li>Test-Driven Development: By Example by Kent Beck</li><li>Practices of an Agile Developer</li><li>Don’t Make Me Think</li><li>Agile Software Development, Principles, Patterns, and Practices by Robert C. Martin</li><li>Domain Driven Designs by Eric Evans</li><li>The Design of Everyday Things by Donald Norman</li><li>Modern C++ Design by Andrei Alexandrescu</li><li>Best Software Writing I by Joel Spolsky</li><li>The Practice of Programming by Kernighan and Pike</li><li>Pragmatic Thinking and Learning: Refactor Your Wetware by Andy Hunt</li><li>Software Estimation: Demystifying the Black Art by Steve McConnel</li><li>The Passionate Programmer (My Job Went To India) by Chad Fowler</li><li>Hackers: Heroes of the Computer Revolution</li><li>Algorithms + Data Structures = Programs</li><li>Writing Solid Code</li><li>JavaScript - The Good Parts</li><li>Getting Real by 37 Signals</li><li>Foundations of Programming by Karl Seguin</li><li>Computer Graphics: Principles and Practice in C (2nd Edition)</li><li>Thinking in Java by Bruce Eckel</li><li>The Elements of Computing Systems</li><li>Refactoring to Patterns by Joshua Kerievsky</li><li>Modern Operating Systems by Andrew S. Tanenbaum</li><li>The Annotated Turing</li><li>Things That Make Us Smart by Donald Norman</li><li>The Timeless Way of Building by Christopher Alexander</li><li>The Deadline: A Novel About Project Management by Tom DeMarco</li><li>The C++ Programming Language (3rd edition) by Stroustrup</li><li>Patterns of Enterprise Application Architecture</li><li>Computer Systems - A Programmer’s Perspective</li><li>Agile Principles, Patterns, and Practices in C# by Robert C. Martin</li><li>Growing Object-Oriented Software, Guided by Tests</li><li>Framework Design Guidelines by Brad Abrams</li><li>Object Thinking by Dr. David West</li><li>Advanced Programming in the UNIX Environment by W. Richard Stevens</li><li>Hackers and Painters: Big Ideas from the Computer Age</li><li>The Soul of a New Machine by Tracy Kidder</li><li>CLR via C# by Jeffrey Richter</li><li>The Timeless Way of Building by Christopher Alexander</li><li>Design Patterns in C# by Steve Metsker</li><li>Alice in Wonderland by Lewis Carol</li><li>Zen and the Art of Motorcycle Maintenance by Robert M. Pirsig</li><li>About Face - The Essentials of Interaction Design</li><li>Here Comes Everybody: The Power of Organizing Without Organizations by Clay Shirky</li><li>The Tao of Programming</li><li>Computational Beauty of Nature</li><li>Writing Solid Code by Steve Maguire</li><li>Philip and Alex’s Guide to Web Publishing</li><li>Object-Oriented Analysis and Design with Applications by Grady Booch</li><li>Effective Java by Joshua Bloch</li><li>Computability by N. J. Cutland</li><li>Masterminds of Programming</li><li>The Tao Te Ching</li><li>The Productive Programmer</li><li>The Art of Deception by Kevin Mitnick</li><li>The Career Programmer: Guerilla Tactics for an Imperfect World by Christopher Duncan</li><li>Paradigms of Artificial Intelligence Programming: Case studies in Common Lisp</li><li>Masters of Doom</li><li>Pragmatic Unit Testing in C# with NUnit by Andy Hunt and Dave Thomas with Matt Hargett</li><li>How To Solve It by George Polya</li><li>The Alchemist by Paulo Coelho</li><li>Smalltalk-80: The Language and its Implementation</li><li>Writing Secure Code (2nd Edition) by Michael Howard</li><li>Introduction to Functional Programming by Philip Wadler and Richard Bird</li><li>No Bugs! by David Thielen</li><li>Rework by Jason Freid and DHH</li><li>JUnit in Action</li></ol>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书单 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>完全背包</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><p>有n种物品，每种物品的单件重量为w[i],价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，<br>使得背包内物品的总价值最大。其中每种物品都有无穷件。</p><p>完全背包与01背包的唯一区别：完全背包的物品数量每种有无穷件，而01背包的物品数量每种只有1件。</p><p>令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值</p><p>对每种物品有两种策略：</p><ol><li>不放第i件物品，那么dp[i][v] = dp[i-1][v]</li><li>放第i件物品。dp[i][v] = dp[i][v-w[i]]+c[i]<br>由此得出状态转移方程：<pre><code>**dp[i][v] = max(dp[i-1][v],dp[i][v-w[i]]+c[i]) (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V)**边界：dp[0][v] = 0(0&lt;=v&lt;=V)</code></pre>改写成一维形式：<pre><code>**dp[v] = max(dp[v],dp[v-w[i]]+c[i]) (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V)**边界：dp[v] = 0(0&lt;=v&lt;=V)</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=w[i];v&lt;=V;v++)&#123;</span><br><span class="line">    dp[v] = max(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="常见dp问题的模型总结"><a href="#常见dp问题的模型总结" class="headerlink" title="常见dp问题的模型总结"></a>常见dp问题的模型总结</h1><ol><li><p>最大连续子列和<br>令dp[i]表示以A[i]作为末尾的连续序列的最大和。</p></li><li><p>最长不下降子序列（LIS）<br>令dp[i]表示以A[i]结尾的最长不下降子序列长度</p></li><li><p>最长公共子序列（LCS）<br>令dp[i][j]表示字符串A的i号位和字符串B的j号位之前的LCS长度</p></li><li><p>最长回文子串<br>令dp[i][j]表示S[i]至S[j]所表示的子串是否是回文子串</p></li><li><p>数塔dp<br>令dp[i][j]表示从第i行第j个数字出发的到达最底层的所有路径上所能得到的最大和</p></li><li><p>DAG最长路<br>令dp[i]表示从i号顶点出发能获得的最长路径长度</p></li><li><p>01背包<br>令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值</p></li><li><p>完全背包<br>令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>01背包</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01%E8%83%8C%E5%8C%85/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><p>有n件物品，每件物品的重量为w[i]，价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，使得背包<br>内物品的总价值最大。其中每件物品都只有1件。<br>样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 8  //n,v</span><br><span class="line"></span><br><span class="line">3 5 1 2 2 //w[i]</span><br><span class="line"></span><br><span class="line">4 5 2 1 3 //c[i]</span><br></pre></td></tr></table></figure></p><h2 id="暴力枚举的想法"><a href="#暴力枚举的想法" class="headerlink" title="暴力枚举的想法"></a>暴力枚举的想法</h2><p>枚举每一件物品放或者不放进背包，显然每件物品都有两种选择，因此n件物品就有2^n种情况，<br>显然不是理想的解决方案</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>时间复杂度为O(nV)</p><p>令dp[i][v]表示前i件物品（1&lt;=i&lt;=n,0&lt;=v&lt;=V）恰好装入容量为v的背包中所能获得的最大价值。</p><p>考虑对第i件物品的选择策略，有两种策略：</p><ol><li><p>不放第i件物品，那么问题转化为前i-1件物品恰好装入容量为v的背包中所能获得的最大价值，即dp[i-1][v]</p></li><li><p>放第i件物品，那么问题转化为前i-1件物品恰好装入容量为v-w[i]的背包中所能获得的最大价值，即dp[i-1][v-w[i]]+c[i]</p></li></ol><p>由此得出状态转移方程：<br>      <strong>dp[i][v] = max{dp[i-1][v],dp[i-1][v-w[i]]+c[i]} (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V)</strong></p><p>边界： dp[0][v] = 0(0&lt;=v&lt;=V)（即前0件物品放入任何容量为v的背包中都只能获得价值0）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=w[i];v&lt;=V;v++)&#123;</span><br><span class="line">        dp[i][v] = max(dp[i<span class="number">-1</span>][v],dp[i<span class="number">-1</span>][v-w[i]]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码时间复杂度与空间复杂度均为O(nV),其中时间复杂度无法优化，但空间复杂度可以<br>优化的关键在于开一个一维数组dp[v]，枚举方向改变为i从1到n，<strong>v从V到0（逆序）</strong></p><p>状态转移方程： <strong>dp[v] = max{dp[v],dp[v-w[i]]+c[i]} (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=V;v&gt;=w[i];v--)&#123;</span><br><span class="line">        dp[v] = max(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时空间复杂度为O(V)<br>说明：如果是二维数组存放，v的枚举顺序或逆序皆可；但如果用一维数组存放，v的枚举必须为逆序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> w[maxn],c[maxn],dp[maxv];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,V;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;V);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=V;v++)&#123;</span><br><span class="line">        dp[v] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=V;v&gt;=w[i];v--)&#123;</span><br><span class="line">            dp[v] = max(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=V;v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[v]&gt;max)&#123;</span><br><span class="line">            max = dp[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>LeetCode 5. 最长回文子串</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot;也是一个有效答案。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure></p><h1 id="解决思路-1-——-暴力枚举法"><a href="#解决思路-1-——-暴力枚举法" class="headerlink" title="解决思路 1 —— 暴力枚举法"></a>解决思路 1 —— 暴力枚举法</h1><p>暴力枚举法是这几种方法中最直观的求解，<br>求解过程中分别以每个元素为中间元素（奇数为最中间的一个数，偶数为中间元素的其中一个），<br>同时从左右出发，计算出最长的回文子串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> endIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存最大回文子串的起始与终点位置</span></span><br><span class="line">    <span class="keyword">int</span> resStart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resEnd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> countLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">      <span class="comment">/* 回文子串为奇串处理 */</span></span><br><span class="line">      startIndex = i;</span><br><span class="line">      endIndex = i;</span><br><span class="line">      countLen = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(startIndex &gt;= <span class="number">0</span> &amp;&amp; endIndex &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[startIndex] == s[endIndex]) &#123;</span><br><span class="line">          <span class="keyword">if</span>(startIndex == endIndex) &#123;</span><br><span class="line">            countLen++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            countLen += <span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          startIndex--;</span><br><span class="line">          endIndex++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前回文子串大于上一次最大回文子串</span></span><br><span class="line">      <span class="keyword">if</span>(countLen &gt; maxLen) &#123;</span><br><span class="line">        maxLen = countLen;</span><br><span class="line">        resStart = startIndex + <span class="number">1</span>;</span><br><span class="line">        resEnd = endIndex - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 回文子串为奇串处理 */</span></span><br><span class="line">      startIndex = i<span class="number">-1</span>;</span><br><span class="line">      endIndex = i;</span><br><span class="line">      countLen = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(startIndex &gt;= <span class="number">0</span> &amp;&amp; endIndex &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[startIndex] == s[endIndex]) &#123;</span><br><span class="line">          <span class="keyword">if</span>(startIndex == endIndex) &#123;</span><br><span class="line">            countLen++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            countLen += <span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          startIndex--;</span><br><span class="line">          endIndex++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前回文子串大于上一次最大回文子串</span></span><br><span class="line">      <span class="keyword">if</span>(countLen &gt; maxLen) &#123;</span><br><span class="line">        maxLen = countLen;</span><br><span class="line">        resStart = startIndex + <span class="number">1</span>;</span><br><span class="line">        resEnd = endIndex - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.substr(resStart, resEnd - resStart + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：最外层循环复杂度为O(n),内层两个循环的复杂度都为O(n/2),因此时间复杂度为O(n2)。</li><li>空间复杂度：在此算法中，没有使用额外的辅助空间，因此空间复杂度为O(1)。</li></ul><h1 id="解决思路-2-——-记忆化搜索"><a href="#解决思路-2-——-记忆化搜索" class="headerlink" title="解决思路 2 —— 记忆化搜索"></a>解决思路 2 —— 记忆化搜索</h1><p>回文字符串的子串也是回文，我们可以将最长回文子串分解一系列子问题，使用动态规划求解。<br>设状态f(i,j)表示区间[i,j]是否为回文串，<br>f(i,j) = false表示子串[i,j]不是回文，f(i,j)=true表示子串[i,j]是回文串，则有以下的关系：</p><p><img src="/img/4.jpg" alt="Alt"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    n = s.size();</span><br><span class="line">    <span class="keyword">bool</span> **f = <span class="keyword">new</span> <span class="keyword">bool</span>*[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      f[i] = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        f[i][j] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">      f[i][i] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        f[j][i] = (s[j] == s[i] &amp;&amp; (i-j &lt; <span class="number">2</span> || f[j+<span class="number">1</span>][i<span class="number">-1</span>]));</span><br><span class="line">        <span class="keyword">if</span>(f[j][i] &amp;&amp; maxLen &lt; (i-j+<span class="number">1</span>)) &#123;</span><br><span class="line">          maxLen = i - j + <span class="number">1</span>;</span><br><span class="line">          start = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">delete</span>[] f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] f;</span><br><span class="line">    <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：使用了两层循环,因此时间复杂度为O(n2)。</li><li>空间复杂度：使用了f[n][n]作为辅助空间，因此空间复杂度为O(n2)。</li></ul><h1 id="解决思路-3-——-Mancher’s-Algorithm"><a href="#解决思路-3-——-Mancher’s-Algorithm" class="headerlink" title="解决思路 3 —— Mancher’s Algorithm"></a>解决思路 3 —— Mancher’s Algorithm</h1><p>Mancher算法能够很快的得到一个字符串中以任意一个字符为中心的回文子串，<br>其基本原理使用已知回文串的左半部分来推导有半部分。</p><p>我们使用rad[i]表示以第i个字符为中心的最长回文半径，<br>假设我们求出了rad[0,…,i-1]的值，现在我们需要通过已知的结果计算出rad[i]的值，<br>在此我们定义maxRight是i位置前所有回文串能延伸到的最右端位置，并且此时回文串的中心位置为k（取第一个达到最右端的位置），<br>则我们可以得到maxRight = k + rad<a href="中心位置加上半径">k</a>，可以有以下两种情况：</p><p><img src="/img/3.jpg" alt="Alt"></p><p>第一种情况：位置i不在前面的任何回文串中，即i &gt; maxRight,这时则初始化rad[i]=1，然后rad[i]向两边延伸，即</p><p>while(s[i+rad[i]] == s[i-rad[i]])<br>  rad[i]++;<br>第二种情况：i这个位置被前面位置k为中心的回文串包含，即i &lt;= maxRight，这种情况下rad[i]就不是从1开始。由回文串的性质，我们可以知道2k-i这个位置与i关于k对称，在这种情况下由可分为三种情形：<br>第一种情形：以2k-i为中心的回文串有一部分在以i为中心回文串之外，<br>这种情况下rad[i]=maxRight-i=k+rad[k]-i,即为图中空心箭头长度，<br>那有没有可能rad[i]会更长呢？不可能，如果rad[i]会更长，则会延伸到k为中心的子串外，<br>由于i和2k-i的对称性可得到k为中心的子串会大于图中紫色对应的半径，与已知矛盾。</p><p><img src="/img/2.jpg" alt="Alt"></p><p>第二种情形：以2k-i为中心的回文串在以i为中心回文串之内，此时rad[i]=rad[2k-i],<br>那么这个时候rad[i]会更长吗？不可能，如果rad[i]长度更长，则延伸部分与2k-i正好对称，<br>这个时候2k-i子串半径则大于图中蓝色箭头的长度，矛盾。</p><p><img src="/img/1.jpg" alt="Alt"></p><p>第三种情形：以2k-i为中心的回文串与i为中心回文串左端部重叠，则ran[i]=rad[2k-i],并且rad[i]可能继续增加，所以有:<br>rad[i]=rad[2k-i];<br>while(s[i+rad[i]] == s[i-rad[i]])<br>  rad[i]++;<br>上面的方法存在一个问题，就是只能计算出奇数长度的回文子串，偶数的就不行，<br>怎么解决呢？这里使用一个比较好的方法，在原来的串中每两个字符之间添加一个特殊字符，<br>如aabbaca变成^#a#a#b#b#a#c#a#$，这里^$作为字符串的定界符是为了防止算法越界。<br>这样处理后，无论原来的回文子串长度是偶数还是奇数，现在都变成奇数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 字符串预处理，如输入"abba",返回"^#a#b#b#a#$"</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">preProcess</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"^$"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">"^"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">      ret += <span class="string">"#"</span> + s.substr(i,<span class="number">1</span>);</span><br><span class="line">    ret+= <span class="string">"#$"</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> tmpStr = preProcess(s);</span><br><span class="line">    <span class="keyword">int</span> n = tmpStr.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *rad = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> center = <span class="number">0</span>, maxRight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> sym_pos = <span class="number">2</span> * center - i;</span><br><span class="line"></span><br><span class="line">      rad[i] = (maxRight &gt; i) ? min(maxRight - i, rad[sym_pos]) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 以i为中心检索两边的字符串</span></span><br><span class="line">      <span class="keyword">while</span>(tmpStr[i + rad[i]] == tmpStr[i - rad[i]])</span><br><span class="line">        rad[i]++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(i + rad[i] &gt; maxRight) &#123;</span><br><span class="line">        center = i;</span><br><span class="line">        maxRight = i + rad[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找最长的半径</span></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> center_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(rad[i] &gt; maxLen) &#123;</span><br><span class="line">        maxLen = rad[i];</span><br><span class="line">        center_index = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.substr((center_index - maxLen) / <span class="number">2</span>, maxLen<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：Mancher算法时间复杂度为O(n)。</li><li>空间复杂度：空间复杂度也为O(n)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最长回文子串</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p>问题描述：<br>给出一个字符串S，求S的最长回文子串的长度。</p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>枚举子串的两个端点i和j，判断[i,j]区间内的子串是否回文。<br>其中枚举端点需要O(n^2),判断回文需要O(n)因此总的复杂度为O(n^3)</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>时间复杂度为O(n^2)<br>令dp[i][j]表示S[i]至S[j]所表示的子串是否是回文子串，是则为1，不是为0.<br>根据S[i]是否等于S[j]，将转移情况分为两类：</p><ol><li>若S[i]==S[j]，只要S[i+1]到S[j-1]是回文子串，那么S[i]到S[j]就是回文子串；<br>否则，就不是。</li><li>若S[i]!=S[j]那么S[i]到S[j]一定不是回文子串。<br>由此得出状态转移方程：</li></ol><p>dp[i][j]= dp[i+1][j-1],S[i]==S[j]<br>          0,S[i]!=S[j]<br>边界：dp[i][i] = 1,dp[i][i+1] = (S[i]==S[i+1)?1:0</p><p>但是不能按照i和j从小到大进行枚举子串两个端点然后更新dp[i][j]，因为无法保证<br>dp[i+1][j-1]已经被计算过，从而无法得到正确的dp[i][j]</p><p>由于边界表示的是长度为1和2的子串，且每次转移时都对子串的长度减1，因此考虑按子串的长度和子串的初始位置进行枚举<br>即第一遍将长度为3的子串的dp值全部求出，第二遍通过第一遍结果计算长度为4的子串的值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">char</span> S[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gets(S);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(S),ans = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==S[i+<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                ans = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">3</span>;t&lt;=len;t++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+t<span class="number">-1</span>&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+t<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==S[j]&amp;&amp;dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                ans = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="字符串哈希-二分解法"><a href="#字符串哈希-二分解法" class="headerlink" title="字符串哈希+二分解法"></a>字符串哈希+二分解法</h2><p>时间复杂度为O(nlogn)<br>对给定的字符串str，可以先求出其字符串hash数组h1，然后再将str反转，<br>求出反转字符串rstr的hash数组h2，接着按回文串的奇偶情况讨论</p><ul><li><p>回文串的长度是奇数：枚举回文中心点i，二分子串的半径k，找到最大的使子串[i-k,i+k]是回文串的k。</p></li><li><p>回文串的长度是偶数：枚举回文空隙点，令i表示空隙左边第一个元素的下标，二分子串的半径k，找到最大的使子串<br>[i-k+1,i+k]是回文串的k。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> ll p = <span class="number">10000019</span>;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">200010</span>;</span><br><span class="line">ll powp[maxn],h1[maxn],h2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    powp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">        powp[i] = (powp[i<span class="number">-1</span>]*p)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calh</span><span class="params">(ll h[],<span class="built_in">string</span> &amp;str)</span></span>&#123;</span><br><span class="line">    h[<span class="number">0</span>] = str[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        h[i] = (h[i<span class="number">-1</span>]*p+str[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calSingleSubh</span><span class="params">(ll h[],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span> h[j];</span><br><span class="line">    <span class="keyword">return</span> ((h[j]-h[i<span class="number">-1</span>]*powp[j-i+<span class="number">1</span>])%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> len,<span class="keyword">int</span> i,<span class="keyword">int</span> isEven)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> h1l = i-mid+isEven,h1r = i;</span><br><span class="line">        <span class="keyword">int</span> h2l = len<span class="number">-1</span>-(i+mid),h2r = len<span class="number">-1</span>-(i+isEven);</span><br><span class="line">        <span class="keyword">int</span> hashl = calSingleSubh(h1,h1l,h1r);</span><br><span class="line">        <span class="keyword">int</span> hashr = calSingleSubh(h2,h2l,h2r);</span><br><span class="line">        <span class="keyword">if</span>(hashl!=hashr) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    getline(<span class="built_in">cin</span>,str);</span><br><span class="line">    calh(h1,str);</span><br><span class="line">    reverse(str.begin(),str.end());</span><br><span class="line">    calh(h2,str);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> maxlen = min(i,(<span class="keyword">int</span>)str.length()<span class="number">-1</span>-i)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = binarySearch(<span class="number">0</span>,maxlen,str.length(),i,<span class="number">0</span>);</span><br><span class="line">        ans = max(ans,k*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> maxlen = min(i+<span class="number">1</span>,(<span class="keyword">int</span>)str.length()<span class="number">-1</span>-i)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = binarySearch(<span class="number">0</span>,maxlen,str.length(),i,<span class="number">1</span>);</span><br><span class="line">        ans = max(ans,k*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h1><p>时间复杂度为O(n)<br>算法分析：<br>由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。</p><p>举个例子：s=”abbahopxpo”，转换为s_new=”$#a#b#b#a#h#o#p#x#p#o#”（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文abba和一个奇回文opxpo，被转换为#a#b#b#a#和#o#p#x#p#o#，长度都转换成了奇数。</p><p>定义一个辅助数组int p[]，其中p[i]表示以 i 为中心的最长回文的半径<br>p[i] - 1正好是原字符串中最长回文串的长度。</p><p><img src="https://segmentfault.com/img/remote/1460000014416801?w=590&amp;h=190/view" alt="Alt txt"><br>设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。</p><p>假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; mx)  </span><br><span class="line">    p[i] = min(p[<span class="number">2</span> * id - i], mx - i);</span><br></pre></td></tr></table></figure></p><p>2 * id - i为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快查找。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findBMstr</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[str.size() + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=  str.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i] = (p[<span class="number">2</span>*id - i] &lt; (mx - i) ? p[<span class="number">2</span>*id - i] : (mx - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(str[i - p[i]] == str[i + p[i]])</span><br><span class="line">            p[i]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i + p[i] &gt; mx)</span><br><span class="line">        &#123;</span><br><span class="line">            mx = i + p[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, ii;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            ii = i;</span><br><span class="line">            max = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = ii - max ;</span><br><span class="line">    <span class="keyword">int</span> end = ii + max;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] != <span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>  p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"12212321"</span>;</span><br><span class="line">    <span class="built_in">string</span> str0;</span><br><span class="line">    str0 += <span class="string">"$#"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str0 += str[i];</span><br><span class="line">        str0 += <span class="string">"#"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str0 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    findBMstr(str0);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>最长公共子序列</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>最长公共子序列问题描述：<br>给定两个字符串（或数字序列）A和B,求一个字符串，使得这个字符串是A和B的最长公共部分（子序列可以不连续）</p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>设字符串A和B的长度分别是n和m，那么对两个字符串中的每个字符，分别有选与不选两个决策，而得到子序列后<br>比较两个子序列是否相同有需要O(max(m,n))，这样总的复杂度就会达到O(2^(m+n)*max(m,n))，无法承受较大数据</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>令dp[i][j]表示字符串A的i号位和字符串B的j号位之前的LCS长度（下标从1开始）两种决策如下：</p><ol><li><p>若A[i]==B[j]则字符串A与字符串B的LCS增加了1位，即dp[i][j]=dp[i-1][j-1]+!</p></li><li><p>若A[i]!=B[j]，则字符串A的i号位和字符串B的j号位之前的LCS无法延长，因此dp[i][j]将会继承dp[i-1][j]与dp[i][j-1]<br>z中的较大值，即dp[i][j]= max{dp[i-1][j],dp[i][j-1]}</p></li></ol><p>由此可以得到状态转移方程：<br>dp[i][j]= dp[i-1][j-1]+1,A[i]==B[j]<br>          max{dp[i-1][j],dp[i][j-1]},A[i]!=B[j]<br>边界：dp[i][0]=dp[0][j]=0(0&lt;=i&lt;=n,0&lt;=j&lt;=m)<br>时间复杂度为O(nm)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> A[N],B[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    gets(A+<span class="number">1</span>);<span class="comment">//从下标为1开始读入</span></span><br><span class="line">    gets(B+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> lenA = <span class="built_in">strlen</span>(A+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> lenB = <span class="built_in">strlen</span>(B+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lenA;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=lenB;j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lenA;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lenB;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]==B[j])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[lenA][lenB]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>最长不下降子序列</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="最长不下降子序列"><a href="#最长不下降子序列" class="headerlink" title="最长不下降子序列"></a>最长不下降子序列</h1><p>LIS问题：<br>在一个数字序列中，找到一个最长的子序列（可以不连续），使得这个子序列是不下降的</p><h2 id="原始方法"><a href="#原始方法" class="headerlink" title="原始方法"></a>原始方法</h2><p>枚举每种情况，即对于每个元素有取和不取两种选择，然后判断序列是否为不下降序列。<br>如果是不下降序列，则更新最大长度，直到枚举完所有情况并得到最大长度。<br>但这种做法时间复杂度将达到O(2^n)显然不可取</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>用dp[i]表示以A[i]结尾的最长不下降子序列长度，则A[i]有两种情况</p><ol><li>如果存在A[i]之前的元素A<a href="j&lt;i">j</a>，使得A[j]&lt;=A[i]且dp[j]+1&gt;dp[i]（即把A[i]跟以A[j]结尾的LIS后面时能比当前以A[i]结尾的LIS长度更长）<br>，那么就把A[i]跟在以A[j]结尾的LIS后面，形成一条更长的不下降子序列，（令dp[i]=dp[j]+1）</li><li>如果A[i]之前的元素都比A[i]大，那么A[i]就只好自己形成一条LIS,但是长度为1，即这个子序列里面只有一个A[i]</li></ol><p>最后以A[i]结尾的LIS长度就是上述两点中能形成的最大长度</p><p>由此写出状态转移方程：<br>dp[i] = max{1,dp[j]+1}(j=1,2,…i-1&amp;&amp;A[j]&lt;A[i])<br>边界dp[i] = 1(1&lt;=i&lt;=n)<br>整体复杂度为O(n^2)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> A[N],dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;=A[j]&amp;&amp;(dp[j]+<span class="number">1</span>&gt;dp[i]))&#123;</span><br><span class="line">                dp[i] = dp[j]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>最大连续子列和</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%88%97%E5%92%8C/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%88%97%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="最大连续子列和问题"><a href="#最大连续子列和问题" class="headerlink" title="最大连续子列和问题"></a>最大连续子列和问题</h1><p>给定一个数字序列A1，A2，……An,求i，j(1&lt;=i&lt;=j&lt;=n),使得Ai+….Aj最大，输出这个最大和。</p><h3 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h3><p>枚举左端点和右端点（即枚举i和j），需要O(n^2)的复杂度，求和有需要O(n)的复杂度，因此总复杂度为O(n^3)</p><h3 id="方法二：预处理记录前缀和"><a href="#方法二：预处理记录前缀和" class="headerlink" title="方法二：预处理记录前缀和"></a>方法二：预处理记录前缀和</h3><p>记S[i] = A[0]+A[1]….+A[i],这样A[i]+…+A[j] = S[j]-S[i-1];该计算的复杂度为O(1),但总的时间复杂度为O(n^2)</p><h3 id="方法三：动态规划"><a href="#方法三：动态规划" class="headerlink" title="方法三：动态规划"></a>方法三：动态规划</h3><p>动态规划问题的核心与难点其实就在于确定状态和状态转移方程，以及边界分析。<br>步骤一：确定状态<br>令状态dp[i]表示以A[i]作为末尾的连续序列的最大和，<br>因此所求最大和便是dp[0],dp[1],dp[2]…dp[n-1]中的最大值。<br>步骤二：确定状态转移方程，求dp数组<br>以A[i]结尾的连续序列只有两种情况</p><ol><li>这个最大和的连续序列只有一个元素，即以A[i]开始，以A[i]结尾</li><li>这个最大和的连续序列有多个元素，即以A[p]开始，A[i]结尾<br>第一种情况，最大和就是A[i]<br>第二种情况，最大和是dp[i-1]+A[i]<br>所以可以得到状态转移方程<br>dp[i] = max{A[i],dp[i-1]+A[i]}<br>边界为dp[0] = A[0]<br>时间复杂度为O(n)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i] = max(a[i],dp[i<span class="number">-1</span>]+a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;dp[k])&#123;</span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="状态的无后效性"><a href="#状态的无后效性" class="headerlink" title="状态的无后效性"></a>状态的无后效性</h1><p>状态的无后效性是指：当前状态记录了信息，一旦当前状态确定，就不会再改变，且未来的决策只能在已有的一个或若干个状态的<br>基础上进行，历史信息只能通过已有的状态去影响未来的决策。</p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>dp简介</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dp%E7%AE%80%E4%BB%8B/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dp%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划的递归写法和递推写法"><a href="#动态规划的递归写法和递推写法" class="headerlink" title="动态规划的递归写法和递推写法"></a>动态规划的递归写法和递推写法</h1><p>动态规划是一种算法思想，没有固定写法，十分灵活，需要具体问题具体分析</p><p>动态规划是一种用来解决一类最优化问题的算法思想。<br>即将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得到原问题的最优解。<br>动态规划会将每个求解过的子问题的解记录下来，这样当下一次碰到同样的子问题时，就可以直接使用之前记录的结果。</p><h2 id="动态规划的递归写法"><a href="#动态规划的递归写法" class="headerlink" title="动态规划的递归写法"></a>动态规划的递归写法</h2><p>以求解斐波那契数列为例<br>f0=1,f1=1,f(n)=f(n-1)+f(n-2)(n&gt;=2)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f(n<span class="number">-1</span>)+f(n<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码就涉及到了很多重复计算，严重增大了时间复杂度<br>为了便重复计算，可以开一个dp数组，用来保存已经计算过的结果<br>其中dp[n]表示f(n)的结果<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dp[n]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[n];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dp[n] = f(n<span class="number">-1</span>)+f(n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种做法将复杂度由O(2^n)降到了O(n)，这也是名词记忆化搜索的由来。</p><h2 id="动态规划的递推写法"><a href="#动态规划的递推写法" class="headerlink" title="动态规划的递推写法"></a>动态规划的递推写法</h2><p>以数塔问题为例<br>从顶部出发在每一个节点可以选择向左或者向右走，一直走到底层，要求找出一条路径，<br>使得路径上的数字之和最大.<br>不妨令dp[i][j]表示从第i行第j个数字出发的到达底层的所有路径中能得到的最大和。<br>于是dp[1][1]就是dp[2][1]和dp[2][2]的较大值加上5<br>即： dp[1][1] = max(dp[2][1],dp[2][2]+f[1][1])</p><p>状态转移方程：<br>dp[i][j] = max(dp[i+1][j],dp[i+1][j+1]+f[i][j])<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn],dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;f[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        dp[n][j] = f[n][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            dp[i][j] = max(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>])+f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用递推写法采用自底向上，即从边界开始，不断向上解决问题，直到解决目标问题<br>使用递归写法采用自顶向下，即从目标问题开始，将她分解成子问题的组合，直到分解至边界为止</p><ul><li>一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决</li></ul><ol><li><p>分治与动态规划：分治和动态规划都是讲问题分解成子问题，然后合并子问题的解得到原问题的解。<br>但是分治法分解出的子问题时不重叠的，因此分治法解决的问题不拥有重叠子问题，而动态规划解决的问题拥有重叠子问题<br>另外，分治法解决的问题不一定是最优化问题，而动态规划解决的一定是最优化问题</p></li><li><p>贪心和动态规划：贪心和动态规划都要求原问题必须拥有最优子结构。<br>贪心并不等待子问题求解完毕后在选择使用哪一个，而是通过一种策略直接选择一个问题去求解，没被选择的子问题就<br>不在去求解，直接抛弃。<br>而动态规划不管是自底向上还是自顶向下，都是从边界开始向上得到目标问题的解。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>拓扑排序</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="有向无环图"><a href="#有向无环图" class="headerlink" title="有向无环图"></a>有向无环图</h1><p>如果一个有向图的任意顶点都无法通过一些有向边回到自身，那么称这个有向图为有向无环图。</p><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>拓扑排序是将有向无环图G的所有顶点排成一个线性序列，使得对图G中的任意两个顶点u，v，如果<br>存在边u-&gt;v,那么在序列中u一定在v前面。该序列被称为拓扑序列。<br>求解拓扑序列：</p><ol><li>定义一个队列q,并把所有入度为0的结点加入队列</li><li>取队首结点，输出。然后删去所有从它出发的边，并令这些边到达的顶点的入度减1，如果某个顶点的入度减为0，则将其加入队列。</li><li>反复进行2操作，直到队列为空。如果队列为空时入队的结点数目恰好为n，说明拓扑排序成功，图G为有向无环图；<br>否则，拓扑排序失败，图G中有环。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxv];</span><br><span class="line"><span class="keyword">int</span> n,m,inDegree[maxv];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,u);</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        G[u].clear();</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用拓扑排序可以判断一个給定的图是否为有向无环图。</p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>最小生成树</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>最小生成树（MST）是在一个給定的无向图G(v,e)中求一棵树T，使得这棵树拥有图G中的所有顶点，且所有边都是来自<br>图G中的边，并且满足整棵树的边权之和最小。</p><p>三个重要性质</p><ol><li>最小生成树是树，因此其边数等于顶点数减1，且树内一定不会有环。</li><li>对給定的图G（v,e），其最小生成树可以不唯一，但其边权之和一定是唯一的。</li><li>由于最小生成树是在无向图中生成的，因此其根结点可以是这棵树上的任意一个结点，于是，<br>如果题目中涉及最小生成树本身的输出，为了让最小生成树唯一，一般都会直接给出根结点。</li></ol><p>求最小生成树一般有两种算法，即prim算法和kruskal算法。这两种算法均采用了贪心的思想。</p><h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><p>基本思想：对图G（v，e）设置集合s，存放已被访问的顶点，然后每次从集合v-s中选择与集合s的最短距离最小的一个顶点（记为u）<br>访问并加入集合s。之后，令顶点u为中介点，优化所有从u能到达的顶点v与集合s之间的最短距离。<br>这样的操作执行n次，直到集合s已包含所有顶点。其实思路与Dijstra算法类似。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//邻接矩阵写法</span></span><br><span class="line"><span class="keyword">int</span> n,g[maxv][maxv];</span><br><span class="line"><span class="keyword">int</span> d[maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;<span class="comment">//默认0为初始点，返回最小生成树边权之和</span></span><br><span class="line">    fill(d,d+maxv,inf);</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,minm = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">//找到未被访问的顶点中d[]最小的</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minm)&#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minm = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找不到小于inf的d[u],则剩下的顶点和集合s不连通</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        ans+= d[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;<span class="comment">//v未被访问&amp;&amp;u能到达v&amp;&amp;以u为中介点可以使v离集合s更近</span></span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;g[u][v]!=inf&amp;&amp;g[u][v]&lt;d[v])&#123;</span><br><span class="line">                d[v] = g[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//邻接表写法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(d,d+maxv,inf);</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,minm = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minm)&#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minm = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        ans+ = d[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;Adj[u][j]&lt;div)&#123;</span><br><span class="line">                d[v] = g[u][[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h3><p>kruskal算法采用的是边贪心的策略<br>基本思想：在初始状态时隐去图中的所有边，这样图中每个顶点都自成一个连通块。之后执行如下步骤：</p><ol><li>对所有边按边权从小到大排序</li><li>按边权从小到大测试所有边，如果当前测试边所连接的两个顶点不在同一个连通块中，则把这条测试边加入到当前最小生成树中；否则，将边舍弃</li><li>执行步骤2，直到最小生成树中的边数等于总顶点数减1或是测试完所有边时结束。<br>当结束时如果最小生成树的边数小于总顶点数减1，说明该图不连通。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">int</span> cost;<span class="comment">//边权</span></span><br><span class="line">&#125;e[maxe];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost&lt;b.cost;</span><br><span class="line">&#125;</span><br><span class="line">伪代码</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    令最小生成树的边权之和为ans，最小生成树的当前边数为Num_Edge;</span><br><span class="line">    将所有边按边权从小到大排序;</span><br><span class="line">    <span class="keyword">for</span>(从小到大枚举所有边)&#123;</span><br><span class="line">        <span class="keyword">if</span>(当前测试边的两个端点在不同的连通块中)&#123;</span><br><span class="line">            将该测试边加入最小生成树中;</span><br><span class="line">            ans+=测试边的边权;</span><br><span class="line">            最小生成树的当前边数为Num_Edge+<span class="number">1</span>;</span><br><span class="line">            当边数Num_Edge等于顶点数减<span class="number">1</span>时结束循环;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">其中 并查集可以通过查询两个结点所在集合的根结点是否相同来判断他们是否在同一个集合</span><br><span class="line">而只要把测试边的两个端点所在集合合并，就能达到将边加入最小生成树的效果</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[n];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findfather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,Num_Edge = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e,e+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> fau = findfather(e[i].u);</span><br><span class="line">        <span class="keyword">int</span> fav = findfather(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(fau!=fav)&#123;</span><br><span class="line">            father[fau] = fav;</span><br><span class="line">            ans += e[i].cost;</span><br><span class="line">            Num_Edge++;</span><br><span class="line">            <span class="keyword">if</span>(Num_Edge==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Num_Edge!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kruskal算法的时间复杂度主要来源于对边进行排序<br>所以其时间复杂度为O(eloge)<br>综合来看：如果是稠密图（边多），则用prim算法；如果是稀疏图（边少），则用kruskal算法</p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>memset与fill</title>
      <link href="/%E8%AF%AD%E8%A8%80/memset%E4%B8%8Efill/"/>
      <url>/%E8%AF%AD%E8%A8%80/memset%E4%B8%8Efill/</url>
      
        <content type="html"><![CDATA[<h1 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h1><p>memset是计算机中C/C++语言函数。将s所指向的某一块内存中的后n个 字节的内容全部设置为ch指定的ASCII值，</p><p>第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作， 其返回值为s。</p><p>头文件:memory.h或string.h</p><p>函    数：void *memset</p><p>原    型 (void *s,int ch,size_t n);</p><p>void <em>memset(void </em>s, int ch, size_t n);</p><p>函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。</p><p>memset：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法</p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>第一：memset函数按字节对内存块进行初始化，所以不能用它将int数组初始化为0和-1之外的其他值（除非该值高字节和低字节相同）。</p><p>第二：memset(void *s, int ch,size_tn);中key实际范围应该在0~~255，</p><p>因为该函数只能取ch的后八位赋值给你所输入的范围的每个字节，</p><p>比如int a[5]赋值memset（a,-1,sizeof(int )<em>5）与memset（a,511,sizeof(int )</em>5） 所赋值的结果是一样的都为-1；</p><p>因为-1的二进制码为（11111111 11111111 11111111 11111111）而511的二进制码为（00000000 00000000 00000001 11111111）后八位都为（11111111)，</p><p>所以数组中每个字节，如a[0]含四个字节都被赋值为（11111111），其结果为a[0]（11111111 11111111 11111111 11111111），</p><p>及a[0]=-1，因此无论ch多大只有后八位二进制有效，而八位二进制 [2]  的范围（0~255）YKQ改。</p><p>而对字符数组操作时则取后八位赋值给字符数组，其八位值作为ASCII [3]  码。</p><p>第三： 搞反了 ch 和 n 的位置.</p><p>一定要记住如果要把一个char a[20]清零，一定是 memset(a,0,20*sizeof(char));</p><p>而不是 memset(a,20*sizeof(char),0);</p><h1 id="fill-函数"><a href="#fill-函数" class="headerlink" title="fill()函数"></a>fill()函数</h1><p>用途：</p><ul><li><p>按照单元赋值，将一个区间的元素都赋同一个值</p></li><li><p>fill(arr, arr + n, 要填入的内容);</p></li></ul><p>头文件：<algorithm></algorithm></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];    fill(arr, arr + <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="与memset-函数的区别："><a href="#与memset-函数的区别：" class="headerlink" title="与memset()函数的区别："></a>与memset()函数的区别：</h2><p>两者都可以用来对数组填充，memset是对按照字节来填充的，所以一般用来填充char型数组，也经常用于填充int型的全0或全-1操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(arr));</span><br></pre></td></tr></table></figure><p>fill是按照单元来填充的，所以可以填充一个区间的任意值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">fill(arr,arr+<span class="number">10</span>,<span class="number">65</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;fill(arr.begin(),arr.end(),<span class="number">65</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最短路问题</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>最短路径是图论中的一个经典问题：给定图G(v,e)，求一条从起点到终点的路径，使得这条路径上经过的<br>所有边的边权之和最小。</p><p>即解决如下问题：<br>对任意给出的图G（v，e）和起点s，终点t，如何求从s到t的最短路径<br>解决最短路径的常用算法有Dijkstra算法、Bellman-Ford算法，SPFA算法和Floyd算法</p><h3 id="Dijstra算法"><a href="#Dijstra算法" class="headerlink" title="Dijstra算法"></a>Dijstra算法</h3><p>Dijstra算法用来解决单源最短路问题，即给定图G和起点s，通过算法得到s到达其他每个顶点的最短距离。<br>基本思想：对图G（v，e）设置集合s，存放已被访问的顶点，然后每次从集合v-s中选择与起点s的最短距离最小的一个顶点<br>（记为u），访问并加入集合s。之后，令顶点u为中介点，优化起点s与所有从u能到达的顶点v之间的最短距离。<br>这样的操作执行n次，直到集合s已包含所有顶点。<br>算法策略：<br>设置集合s存放已被访问的顶点，然后执行n次下面的两个步骤</p><ol><li>每次从集合v-s中选择与起点s的最短距离最小的一个顶点（记为u），访问并加入集合s</li><li>之后，令顶点u为中介点，优化起点s与所有从u能到达的顶点v之间的最短距离</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">伪代码</span><br><span class="line">Dijkstra(G,d[],s)&#123;</span><br><span class="line">  初始化;</span><br><span class="line">  <span class="keyword">for</span>(循环n次)&#123;</span><br><span class="line">      u = 使d[u]最小的还未被访问的顶点的标号;</span><br><span class="line">      记u已被访问;</span><br><span class="line">      <span class="keyword">for</span>(从u出发能到达的所有顶点v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v未被访问&amp;&amp;以u为中介点使s到顶点v的最短距离d[v]更优)&#123;</span><br><span class="line">         优化d[v];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//邻接矩阵版</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> maxv = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> n,G[maxv][maxv];</span><br><span class="line"><span class="keyword">int</span> d[maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d,d+maxv,inf);<span class="comment">//fill函数将整个d数组赋值为inf</span></span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>,minm = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minm)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                minm = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>;v&lt;n;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[v] == <span class="literal">false</span>&amp;&amp;G[u][v]!=inf&amp;&amp;d[u]+G[u][v]&lt;d[v])&#123;</span><br><span class="line">                d[v] = d[u]+G[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表版</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> v,dis;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d,d+maxv,inf);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,minm=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minm)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                minm=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = Adj[u][j].v;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;d[u]+Adj[u][j].dis&lt;d[v])&#123;</span><br><span class="line">                d[v] = d[u] + Adj[u][j].dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h1><p>Dijstra算法可以很好地解决无负权图的最短路径问题，但如果出现了负权边，Dijstra算法会失效。<br>Bellman-Ford和Dijstra一样，也可以解决单源最短路径问题，同时能处理有负权边的情况。</p><p>由于Bellman-Ford算法需要遍历所有边，所以使用邻接表会比邻接矩阵方便<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis;<span class="comment">//v为邻接边的目标顶点，dis为邻接边的边权</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv]; <span class="comment">//图G的邻接表</span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//n为顶点数，maxv为最大顶点数</span></span><br><span class="line"><span class="keyword">int</span> d[maxv]; <span class="comment">//起点到达各边的最短路径长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d,d+maxv,inf);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">                <span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line">                <span class="keyword">if</span>(d[u]+dis&lt;d[v])&#123;</span><br><span class="line">                    d[v]=d[u]+dis;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下为判断负环的代码</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">            <span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line">            <span class="keyword">if</span>(d[u]+dis&lt;d[v])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于Bellman-Ford算法的时间复杂度达到了O(ve),这并不如意，所以需要进行优化，<br>Bellman-Ford的每轮操作都需要操作所有边，这其中会有大量无意义操作，严重影响了算法性能。<br>由于，只有当某个顶点u的d[u]值改变时，从它出发的邻接点v的d[v]值才有可能被改变。<br>所以可以如下优化：<br>建立一个队列，每次将队首顶点u取出，然后对从u出发的所有边u-&gt;v进行松弛操作，<br>即判断d[u]+length[u-&gt;v]&lt;d[v]是否成立，如果成立，则用d[u]+length[u-&gt;v]覆盖d[v];<br>如果v不在队列中，就把v加入队列。<br>这样操作直到队列为空（说明图中没有从源点可达的负环），或某个顶点的入队次数超过v-1（说明图中存在从源点可达的负环）</p><h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p>上述被优化后的算法即为SPFA算法，期望时间复杂度为O(ve)<br>但如果图中有从源点可达的负环，则SPFA的时间复杂度又会退化为O(ve)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Node&gt; ADj[maxv];</span><br><span class="line"><span class="keyword">int</span> n,d[maxv],num[maxv];</span><br><span class="line"><span class="keyword">bool</span> inq[maxv];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(inq,<span class="literal">false</span>,<span class="keyword">sizeof</span>(inq));</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">    fill(d,d+maxv,inf);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    inq[s]=<span class="literal">true</span>;</span><br><span class="line">    num[s]++;</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        inq[u]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">            <span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line">            <span class="keyword">if</span>(d[u]+dis&lt;d[v])&#123;</span><br><span class="line">                d[v]=d[u]+dis;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v])&#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    inq[v]=<span class="literal">true</span>;</span><br><span class="line">                    num[v]++;</span><br><span class="line">                    <span class="keyword">if</span>(num[v]&gt;=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Flord算法"><a href="#Flord算法" class="headerlink" title="Flord算法"></a>Flord算法</h1><p>Flord算法用来解决全源最短路问题。<br>即对給定的图G（v,e），求任意两点u，v之间的最短路径长度，时间复杂度为O(n^3)所以顶点数要限制约在200以内。<br>用邻接矩阵来实现Flord算法比较合适。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf =<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv =<span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dis[maxv][maxv];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Flord</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][k]!=inf&amp;&amp;dis[k][j]!=inf&amp;&amp;dis[i][k]+dis[k][j]&lt;dis[i][j])&#123;</span><br><span class="line">                    dis[i][j]=dis[i][k]+dis[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    fill(dis[<span class="number">0</span>],dis[<span class="number">0</span>]+maxv*maxv,inf);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dis[i][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        dis[u][v]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    Flord();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,dis[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>图的存储和遍历</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><p>图的存储一般有两种方式：邻接矩阵和邻接表</p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>设图G(V,E)的顶点标号为0,1，……n-1，则令二维数组G[n][n]的两维分别表示图的顶点标号。<br>即如果G[i][j]等于1，指顶点i和顶点j之间有边，如果G[i][j]等于0，指顶点i和顶点j之间没有边，<br>如果为有权图，则令G[i][j]存放边权。<br>但如果题目中顶点数过大，可能会造成内存超限。</p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>图的常用储存结构之一，由表头结点和表结点两部分组成，其中表头结点存储图的各顶点，<br>表结点用单向链表存储表头结点所对应顶点的相邻顶点（也就是表示了图的边）。<br>在有向图里表示表头结点指向其它结点（a-&gt;b）,无向图则表示与表头结点相邻的所有结点（a—b）<br><img src="https://img-blog.csdn.net/20170516155825235?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzMyNDAxMjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表头结点（表示图的顶点）  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vnode</span>&#123;</span>  </span><br><span class="line">       <span class="keyword">char</span> data;             <span class="comment">//顶点数据，这里用字符表示  </span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span> * <span class="title">firstarc</span>;</span>   <span class="comment">//指针指向第一条边   </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">//表结点（表示图的边）  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span>&#123;</span>  </span><br><span class="line">       <span class="keyword">int</span> wt;           <span class="comment">//权重  </span></span><br><span class="line">       <span class="keyword">int</span> adjvex;     <span class="comment">//顶点下标  </span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span> *<span class="title">nextarc</span>;</span>   <span class="comment">//指针指向下一条边  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span> * <span class="title">Arc</span>;</span>  </span><br><span class="line"><span class="comment">//图  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mgraph</span>&#123;</span>  </span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">vnode</span> <span class="title">vexs</span>[100];</span>  </span><br><span class="line">       <span class="keyword">int</span> vexsnum,arcnum;     <span class="comment">//顶点数，边数  </span></span><br><span class="line">&#125; *g;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mgraph</span>* <span class="title">Graph</span>;</span></span><br></pre></td></tr></table></figure><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h3 id="用DFS遍历图"><a href="#用DFS遍历图" class="headerlink" title="用DFS遍历图"></a>用DFS遍历图</h3><p>沿着一条路径直到无法继续前进，才退回到路径上离当前顶点最近的还存在未访问分支顶点的岔道口，并前往访问那些未访问的分支节点，直至遍历完成</p><ul><li>连通分量：在无向图中，如果两个顶点可以互相到达，则称这两个顶点连通，如果图G（V，E）的任意两个顶点都连通，则称图G为连通图，<br>否则，称图G为非连通图，且称其中的极大连通子图为连通分量。</li><li>强连通分量：在有向图中，如果两个顶点可以各自通过一条有向路径到达另一个顶点，则称这两个顶点强联通。如果一个图的任意两个顶点都强联通，<br>则称这个图为强连通图；否则这个图为非强连通图，且称其中的极大连通子图为强联通分量。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">伪代码</span><br><span class="line">DFS(u)&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(从u出发能到达的所有顶点v)</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)</span><br><span class="line">        DFS(v);</span><br><span class="line">&#125;</span><br><span class="line">DFSTrave(G)&#123;</span><br><span class="line">    <span class="keyword">for</span>(G的所有顶点u)</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)</span><br><span class="line">        DFS(u);</span><br><span class="line">&#125;</span><br><span class="line">邻接矩阵实现</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,G[maxv][maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=inf)&#123;</span><br><span class="line">            dfs(v,depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfstrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)&#123;</span><br><span class="line">            dfs(u,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">邻接表实现</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[maxv];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    vis[u] =<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">            dfs(v,depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfstrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)&#123;</span><br><span class="line">            dfs(u,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="用BFS遍历图"><a href="#用BFS遍历图" class="headerlink" title="用BFS遍历图"></a>用BFS遍历图</h3><p>类似树的遍历，遍历图需要使用一个队列，通过反复取出队首顶点，将该顶点可到达的未曾加入过队列的顶点全部入队，直到队列为空时遍历结束。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">伪代码</span><br><span class="line">BFS(u)&#123;</span><br><span class="line">    <span class="built_in">queue</span> q;</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q非空)&#123;</span><br><span class="line">        取出q的队首元素加以访问;</span><br><span class="line">        <span class="keyword">for</span>(从u出发能到达的所有顶点v)</span><br><span class="line">        <span class="keyword">if</span>(inq[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">            将v入队;</span><br><span class="line">            inq[v]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BFSTrave(G)&#123;</span><br><span class="line">    <span class="keyword">for</span>(G的所有顶点u)</span><br><span class="line">        <span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BFS(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">邻接矩阵实现</span><br><span class="line"><span class="keyword">int</span> n,G[maxv][maxv];</span><br><span class="line"><span class="keyword">bool</span> inq[maxv]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u.q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inq[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=inf)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                inq[v]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)&#123;</span><br><span class="line">            BFS(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">邻接表实现</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[maxv];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> inq[maxv]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">            <span class="keyword">if</span>(inq[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                inq[v]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)&#123;</span><br><span class="line">            BFS(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> edges[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">///邻接矩阵  </span></span><br><span class="line">    <span class="keyword">int</span> n;  </span><br><span class="line">    <span class="keyword">int</span> e;  </span><br><span class="line">&#125;graph;  </span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">100</span>];<span class="comment">///访问数组  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creategraph</span><span class="params">(graph &amp;G)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i,j;  </span><br><span class="line">    <span class="keyword">int</span> s,t;  </span><br><span class="line">    <span class="keyword">int</span> v;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.n;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.n;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            G.edges[i][j]=<span class="number">0</span>;<span class="comment">///邻接表初始化  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        vis[i]=<span class="literal">false</span>;<span class="comment">///访问数组初始化  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.e;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t&gt;&gt;v;<span class="comment">///读入顶点数边数和权值  </span></span><br><span class="line">        G.edges[s][t]=v;<span class="comment">///赋值  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(graph G,<span class="keyword">int</span> v)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,v);  </span><br><span class="line">    vis[v]=<span class="literal">true</span>;<span class="comment">///访问第v个定点，并将访问数组置为true  </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.n;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(G.edges[v][i]!=<span class="number">0</span>&amp;&amp;vis[i]==<span class="literal">false</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            dfs(G,i);<span class="comment">///如果i未被访问递归调用dfs  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(graph G,<span class="keyword">int</span> v)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Q;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,v);  </span><br><span class="line">    vis[v]=<span class="literal">true</span>;  </span><br><span class="line">    Q.push(v);  </span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> i,j;  </span><br><span class="line">        i=Q.front();<span class="comment">///取队头元素  </span></span><br><span class="line">        Q.pop();<span class="comment">///队头元素出队  </span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.n;j++)  </span><br><span class="line">        &#123;<span class="comment">///检查所有邻接点  </span></span><br><span class="line">            <span class="keyword">if</span>(G.edges[i][j]!=<span class="number">0</span>&amp;&amp;vis[j]==<span class="literal">false</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,j);  </span><br><span class="line">                vis[j]=<span class="literal">true</span>;  </span><br><span class="line">                Q.push(j);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n,e;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"输入图的顶点数和边数："</span>);  </span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;e;  </span><br><span class="line">        graph G;  </span><br><span class="line">        G.n=n;  </span><br><span class="line">        G.e=e;  </span><br><span class="line">        creategraph(G);  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"输出深度优先遍历序列："</span>);  </span><br><span class="line">        dfs(G,<span class="number">0</span>);  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"\n"</span>);  </span><br><span class="line">        creategraph(G);  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"输出广度优先遍历序列："</span>);  </span><br><span class="line">        bfs(G,<span class="number">0</span>);  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>堆的简介</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E7%9A%84%E7%AE%80%E4%BB%8B/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E7%9A%84%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="堆的定义与基本操作"><a href="#堆的定义与基本操作" class="headerlink" title="堆的定义与基本操作"></a>堆的定义与基本操作</h1><p>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子结点的值。<br>如果父亲结点的值大于或等于孩子结点的值，则称这样的堆为大顶堆，这时每个结点的值都是以它为根结点的子树的最大值；<br>如果父亲结点的值小于或等于孩子结点的值，则称这样的堆为小顶堆，这时每个结点的值都是以它为根结点的子树的最小值。<br>堆一般用于优先队列的实现，优先队列实现默认使用大顶堆。</p><h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><p>用数组来存储完全二叉树，则结点就按层序存储于数组中，其中第一个结点存于数组中的1号位，第i号结点的左孩子为2i，右孩子为2i+1<br>建堆采用结点向下调整的方法：<br>如果结点存在，总是将当前结点V与它的左右孩子进行比较，，假如孩子中存在权值比结点V大的，就将其中权值最大的那个孩子结点与结点V交换。<br>交换完毕后继续让结点V和孩子比较，直到结点V的孩子的权值都比结点V的权值小或是结点V不存在孩子结点<br>时间复杂度O(logn)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> heap[maxn],n=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//对heap数组在[low,high]范围进行向下调整</span></span><br><span class="line"><span class="comment">//low为欲调整结点的数组下标，high为堆的最后一个元素的数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=low,j=i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;=high&amp;&amp;heap[j+<span class="number">1</span>]&gt;heap[j])&#123;</span><br><span class="line">            i=j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(heap[j]&gt;heap[i])&#123;</span><br><span class="line">            swap(heap[j]&gt;heap[i]);</span><br><span class="line">            i=j;</span><br><span class="line">            j=i*<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        downAdjust(i,n);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">  heap[<span class="number">1</span>]=heap[n--];</span><br><span class="line">  downAdjust(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="往堆里添加一个元素"><a href="#往堆里添加一个元素" class="headerlink" title="往堆里添加一个元素"></a>往堆里添加一个元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=high,j=i/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;=low)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap[j]&lt;heap[i])&#123;</span><br><span class="line">            swap(heap[j],heap[i]);</span><br><span class="line">            i=j;</span><br><span class="line">            j=i/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    heap[++n]=x;</span><br><span class="line">    UpAdjust(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序是指使用堆结构对一个序列进行排序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    createHeap();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">        swap(heap[i],heap[<span class="number">1</span>]);</span><br><span class="line">        downAdjust(<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>并查集</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集的定义"><a href="#并查集的定义" class="headerlink" title="并查集的定义"></a>并查集的定义</h1><p>并查集是一种维护集合的数据结构：合并（Union）、查找（Find）、集合（Set）<br>并查集支持以下两个操作：</p><ul><li>合并：合并两个集合</li><li>查找：判断两个元素是否在一个集合<br>通过数组即可实现<h2 id="并查集基本操作"><a href="#并查集基本操作" class="headerlink" title="并查集基本操作"></a>并查集基本操作</h2></li></ul><ol><li><p>初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  father[i]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找<br>由于规定同一个集合中只存在一个根结点，因此查找操作就是对給定的结点寻找其根结点的过程<br>实现方式：递推或递归<br>思路：反复寻找父亲结点，直到找到根结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递推低吗</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=father[x])&#123;</span><br><span class="line">        x=father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==father[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> findFather(father[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>3.合并<br>合并是指把两个集合合并成一个集合，题目中一般给出两个元素，要求把这两个元素所在集合合并。<br>一般是先判断两个元素是否属于同一集合，只有当两个元素属于不同集合时才合并，而合并的过程一般是<br>把其中一个集合的根结点的父亲指向另一个集合的根结点。<br>思路：</p><ul><li>对于給定的两个元素a，b，判断它们是否属于同一集合。可以调用查找函数对这两个元素分别查找根结点，然后判断其根节点是否相同</li><li>合并两个集合：在第一步中获得了两个元素的根结点faA和faB，因此只需要把其中一个的父亲结点指向另一个结点。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> faA=findFather(a);</span><br><span class="line">  <span class="keyword">int</span> fab=findFather(b);</span><br><span class="line">  <span class="keyword">if</span>(faA!=faB)&#123;</span><br><span class="line">    father[faA]=faB;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>并查集产生的每一个集合都是一棵树</p><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>当题目给出的元素数量很多并且形成一条链，则上述查找函数效率较低，需进行优化<br>把当前查询结点的路径上的所有结点的父亲都指向根结点，查找的时候就不需要一直回溯去找父亲了，查询复杂度降为O(1）<br>转换步骤：</p><ol><li>按原先的写法获得x的根结点r</li><li>重新从x开始走一遍寻找根结点的过程，把路径上经过的所有结点的父亲全部改为根结点r<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=x;</span><br><span class="line">  <span class="keyword">while</span>(x!=father[x])&#123;</span><br><span class="line">    x=father[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(a!=father[x])&#123;</span><br><span class="line">    <span class="keyword">int</span> z=a;</span><br><span class="line">    a=father[a];</span><br><span class="line">    father[z]=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(v==father[v]) <span class="keyword">return</span> v;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f=findFather(father[v]);</span><br><span class="line">    father[v]=f;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>平衡二叉树</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="平衡二叉树的定义"><a href="#平衡二叉树的定义" class="headerlink" title="平衡二叉树的定义"></a>平衡二叉树的定义</h1><p>当使用序列{1,2,3,4,5}构建二叉查找树，会得到一棵长链条式的树，此时对这棵树中的结点进行查找，<br>时间复杂度会达到O(n)，为了优化数据查询，需要对树的结构进行调整，使树的高度在每次插入元素后仍能保持O(logn)<br>的级别，这样能让查询操作仍然为O(logn)的时间复杂度<br>AVL树仍然是一棵二叉查找树，只是在其基础上增加了平衡要求。<br>即对AVL树的任意结点来说，其左子树与右子树的高度之差的绝对值不超过1，其中左子树和右子树的高度之差称为该结点的平衡因子。<br>只要能随时保证每个结点的平衡因子的绝对值不超过1，AVL的高度就始终能保持O(logn)级别。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结点结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,height;</span><br><span class="line">    node *lchild,*rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//生成一个新结点，v为结点权值</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    node* Node = <span class="keyword">new</span> node;</span><br><span class="line">    Node-&gt;v=v;</span><br><span class="line">    Node-&gt;height=<span class="number">1</span>;</span><br><span class="line">    Node-&gt;lchild=Node-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取以root为根结点的子树的当前height</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算结点root的平衡因子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getHeight(root-&gt;lchild)-getHeight(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新结点root的height</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateHeight</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    root-&gt;height=max(getHeight(root-&gt;lchild),getHeight(root-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="平衡二叉树的基本操作"><a href="#平衡二叉树的基本操作" class="headerlink" title="平衡二叉树的基本操作"></a>平衡二叉树的基本操作</h2><ol><li><p>查找操作<br>类似于二叉查找树，由于AVL树的高度为O(logn)级别，所以查找操作的时间复杂度为O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"search failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==root-&gt;data)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;data)&#123;</span><br><span class="line">        search(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        search(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>旋转操作<br><img src="https://img-blog.csdn.net/20141201123218032?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29sbG9ubg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(node* &amp;root)</span></span>&#123;</span><br><span class="line">    node* temp=root-&gt;rchild;</span><br><span class="line">    root-&gt;rchild=temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild=root;</span><br><span class="line">    UpdateHeight(root);</span><br><span class="line">    UpdateHeight(temp);</span><br><span class="line">    root=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(node* &amp;root)</span></span>&#123;</span><br><span class="line">    node* temp=root-&gt;lchild;</span><br><span class="line">    root-&gt;lchild=temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild=root;</span><br><span class="line">    UpdateHeight(root);</span><br><span class="line">    UpdateHeight(temp);</span><br><span class="line">    root=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入操作<br>只要把最靠近插入结点的失衡结点调整到正常，路径上的所有结点就都会平衡<br>在二叉查找树的插入操作基础上从下往上判断结点是否失衡，因此需要在每个insert函数之后更新当前子树高度，<br>并在这之后根据树型是LL型、LR型、RR型、RL型之一来进行平衡操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=newNode(v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v&lt;root-&gt;v)&#123;</span><br><span class="line">        insert(root-&gt;lchild,v);</span><br><span class="line">        UpdateHeight(root);</span><br><span class="line">        <span class="keyword">if</span>(getBalanceFactor(root)==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild)==<span class="number">1</span>)&#123;</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild)==<span class="number">1</span>)&#123;</span><br><span class="line">                L(root-&gt;lchild);</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert(root-&gt;rchild,v);</span><br><span class="line">        UpdateHeight(root);</span><br><span class="line">        <span class="keyword">if</span>(getBalanceFactor(root)==<span class="number">-2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild)==<span class="number">1</span>)&#123;</span><br><span class="line">                R(root-&gt;rchild);</span><br><span class="line">                L(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AVL树的建立<br>建立在插入操作的基础上，依次插入n个结点即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    node* root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        insert(root,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>二叉查找树</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><h2 id="二叉查找树的定义"><a href="#二叉查找树的定义" class="headerlink" title="二叉查找树的定义"></a>二叉查找树的定义</h2><p>二叉查找树是一种特殊的二叉树，又称二叉排序树、二叉搜索树。<br>二叉查找树的递归定义：</p><ol><li>二叉查找树要么为一棵空树。</li><li>二叉查找树要么为由根结点、左子树、右子树组成，其中左子树和右子树都是二叉查找树，<br>且左子树上所有结点的数据域均小于或等于根结点的数据域，右子树上所有结点的数据域均大于等于根节点的数据域。</li></ol><p>二叉查找树其实是一棵数据有序的树。即对树上的每个结点，都满足其左子树上所有结点的数据域均小于或等于根结点的数据域，<br>右子树上所有结点的数据域均大于根结点的数据域。</p><h1 id="二叉查找树的基本操作"><a href="#二叉查找树的基本操作" class="headerlink" title="二叉查找树的基本操作"></a>二叉查找树的基本操作</h1><ol><li>查找操作<br>由二叉查找树的性质得：可以只选择一棵子树进行遍历，因此查找将会是从树根到查找结点的一条路径，<br>故最坏时间复杂度为O(h),h为二叉查找树高度<br>基本思路：</li><li>如果当前根结点为空，则查找失败，返回</li><li>如果需要查找的值x等于当前根结点的数据域root-&gt;data，说明查找成功，访问</li><li>如果需要查找的值x小于当前根结点的数据域root-&gt;data,则向左子树root-&gt;lchild递归查找</li><li><p>如果需要查找的值x大于当前根结点的数据域root-&gt;data,则向右子树root-&gt;rchild递归查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"search failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==root-&gt;data)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;data)&#123;</span><br><span class="line">        search(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        search(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入操作<br>对一棵二叉查找树来说，查找某个数据域的结点一定是沿着确定的路径进行的。<br>当某个需要查找的值在二叉查找树中查找成功，说明结点已经存在；<br>反之，查找失败的地方一定是结点需要插入的位置。<br>插入操作的时间复杂对也是O(h)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            root=newNode(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==root-&gt;data)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;data)&#123;</span><br><span class="line">        insert(root-&gt;lchild,x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert(root-&gt;rchild,x);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉查找树的建立<br>建立一棵二叉查找树就是先后插入n个结点的过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    node* root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        insert(root,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉查找树的删除（确保删除后仍是一棵二叉查找树）<br>一般有两种做法，时间复杂度都为O(h)<br>删除操作的基本思路：</p></li><li>如果当前结点root为空，说明不存在权值为x的结点，返回</li><li>如果当前结点root的权值恰为给定的权值x，说明找到了想要删除的结点，进入删除处理<br>a. 如果当前结点root不存在左右孩子，说明是叶子结点，直接删除<br>b. 如果当前结点root存在左孩子，那么在左子树中寻找结点前驱pre，然后让pre的数据覆盖root，接着在右子树中删除节点next<br>c. 如果当前结点root存在右孩子，那么在右子树中寻找结点后继next，然后让next的数据覆盖root，接着在右子树中删除节点next</li><li>如果当前结点root的权值大于给定的权值x，则在左子树中递归删除权值为x的结点</li><li>如果当前结点root的权值大于給定的权值x，则在右子树中递归删除权值为x的结点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找以root为根结点的树中的最大权值结点</span></span><br><span class="line"><span class="function">node* <span class="title">findMax</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;rchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=root-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找以root为根结点的树中权值最小的结点</span></span><br><span class="line"><span class="function">node* <span class="title">findMin</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=root-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(node* &amp;root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data==x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;root-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            root=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        node* pre=findMax(root-&gt;lchild);</span><br><span class="line">        root-&gt;data=pre-&gt;data;</span><br><span class="line">        deleteNode(root-&gt;lchild,pre-&gt;data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        node* next=findMin(root-&gt;rchild);</span><br><span class="line">        root-&gt;data=next-&gt;data;</span><br><span class="line">        deleteNode(root-&gt;rchild,next-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data&gt;x)&#123;</span><br><span class="line">    deleteNode(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    deleteNode(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="二叉查找树的性质"><a href="#二叉查找树的性质" class="headerlink" title="二叉查找树的性质"></a>二叉查找树的性质</h2><p>对二叉查找树进行中序遍历，遍历的结果是有序的</p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>树的遍历</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><h3 id="树的静态写法"><a href="#树的静态写法" class="headerlink" title="树的静态写法"></a>树的静态写法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">typename</span> data;<span class="comment">//数据域</span></span><br><span class="line">  <span class="keyword">int</span> child[maxn];<span class="comment">//指针域，存放所有子结点的下标</span></span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;</span><br><span class="line">    <span class="built_in">vector</span> child;</span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    Node[index].data=v;</span><br><span class="line">    Node[index].child.clear();</span><br><span class="line">    <span class="keyword">return</span> index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树的先根遍历"><a href="#树的先根遍历" class="headerlink" title="树的先根遍历"></a>树的先根遍历</h3><p>先访问根结点，在访问子树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,Node[root].data);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[root].child/size();i++)&#123;</span><br><span class="line">        preorder(Node[root].child[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="树的层序遍历"><a href="#树的层序遍历" class="headerlink" title="树的层序遍历"></a>树的层序遍历</h3><p>与二叉树的层序遍历类似，一般使用一个队列来存放结点在数组中的下标，每次取出队首元素来访问，并将<br>其所有子结点加入队列，直到队列为空。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> front=q.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,Node[front].data);</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[front].child.size();i++)&#123;</span><br><span class="line">            q.push(Node[front].child[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要对结点的层次进行记录</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> layer;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    Node[root].layer=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> front=q.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,Node[front].data);</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[front].child.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> child = Node[front].child[i];</span><br><span class="line">            q.push(Node[front].child[i]);</span><br><span class="line">            q.push(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Memory</title>
      <link href="/%E8%AF%AD%E8%A8%80/Memory/"/>
      <url>/%E8%AF%AD%E8%A8%80/Memory/</url>
      
        <content type="html"><![CDATA[<ul><li>转载于<a href="https://github.com/xuelangZF/CS_Offer/blob/master/C%2B%2B/Memory.md" target="_blank" rel="noopener">https://github.com/xuelangZF/CS_Offer/blob/master/C%2B%2B/Memory.md</a></li></ul><p>内存管理是C++最令人切齿痛恨的问题，也是C++最有争议的问题，C++高手从中获得了更好的性能，更大的自由，C++菜鸟的收获则是一遍一遍的检查代码和对C++的痛恨，但内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生。</p><p>在C/C++中，进程地址空间分成5个区：</p><ol><li>正文(text)段：正文段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入口处（修改）操作——它是不可写的。</li><li><code>DATA段（数据段）</code>：初始化数据段包含程序中明确地赋初值的变量，例如初始化后的全局变量和静态局部变量。</li><li><code>BSS段（未初始化数据段）</code>：BSS段包含了程序中未初始化的全局变量，程序开始执行前，内核将此段中的数据初始化为0或者空指针。</li><li>堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</li><li>栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li></ol><p>下图显示了这些段的一种典型安排方式：</p><p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/C++_Memory_1.jpg" alt=""></p><p>看下面例子：</p><pre><code>void f() {     int* p=new int[5]; }</code></pre><p>在栈内存中存放了一个指向一块堆内存的指针p。程序首先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中指针 p。</p><h1 id="内存分配回收"><a href="#内存分配回收" class="headerlink" title="内存分配回收"></a>内存分配回收</h1><p>有时候需要一次为很多对象分配/释放内存，为此 C++ 提供了 new/delete 操作符。为了让 new 分配一个对象数组，需要在类型名后跟一对方括号，在其中指明要分配的对象的数目。</p><pre><code>int *pia = new int[10];typedef int arrT[10];   // arrT 表示 10 个int的数组类型 int *p = new arrT;      // 分配一个 10 个 int 的数组，p指向第一个int。编译器执行时和第一句完全一样</code></pre><p>虽然通常称new T[] 分配的内存为动态数组，但当我们用new分配一个数组时，并未得到一个<code>数组类型的对象</code>，而是得到一个相应元素类型的<strong>指针</strong>。由于分配的内存并不是一个数组类型，因此不能对动态数组调用 begin 或 end，也不能用范围 for 语句来处理动态数组中的元素，sizeof 的结果也和真正的数组类型的对象不同。</p><p>默认情况下，new 分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。不过也可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号。</p><pre><code>int *pia = new int[10];int *pia2 = new int[10](0);</code></pre><p>使用new操作符来分配对象内存时会经历三个步骤：</p><ol><li>调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</li><li>编译器运行相应的构造函数以构造对象，并为其传入初值。</li><li>对象构造完成后，返回一个指向该对象的指针。</li></ol><p>当我们使用一条 delete 表达式删除一个动态分配的对象时：</p><pre><code>delete sp;          // 销毁 *sp, 然后释放 sp 指向的内存空间delete [] arr;      // 销毁数组中的元素，然后释放对应的内存空间</code></pre><p>实际上执行了两步操作：</p><ol><li>对 sp 所指的对象或者 arr 所指的数组中的元素执行对应的析构函数。</li><li>编译器调用标准库operator delete(或operator delete[])函数释放内存空间。</li></ol><p>数组中的元素按逆序销毁，即最后一个元素首先被销毁，然后是倒数第二个，依次类推。当释放一个指向数组的指针时，空方括号对是必需的：它指示编译器此指针指向一个对象数组的第一个元素。<strong>如果在 delete 一个指向数组的指针时忽略了方括号，或者在 delete 一个指向单一对象的指针时使用了方括号，其行为是未定义的。</strong></p><p>［<a href="http://www.nowcoder.com/questionTerminal/84598a88502c499d995db941c5fb62a2" target="_blank" rel="noopener">内存管理错误代码</a>］<br>［<a href="http://www.nowcoder.com/questionTerminal/9fb652d48bee45bcb47771b2e3c6f690" target="_blank" rel="noopener">delete 内存泄漏</a>］  </p><h2 id="malloc-和-free-操作"><a href="#malloc-和-free-操作" class="headerlink" title="malloc 和 free 操作"></a>malloc 和 free 操作</h2><p><code>void *malloc(long NumBytes)</code> 分配 NumBytes 个字节，并返回了指向这块内存的首指针。如果分配失败，则返回一个空指针（NULL）。分配失败的原因有多种，比如说空间不足就是一种。malloc() 是从堆里面分配空间，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</p><p>malloc()分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息——分配块的长度，分配块是否已经可用（free 掉）。用结构体来记录管理信息，如下：</p><pre><code>struct mem_control_block {     int is_available;    //该块是否可用；    int size;            //该块可用空间的大小 };</code></pre><p><code>void free(void *FirstByte)</code> 将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存，让它重新得到自由。free()释放的是<code>指针指向的内存</code>！指针并没有被释放，指针仍然指向原来的存储空间。指针是一个变量，只有程序结束时才被销毁。释放了内存空间后，原来指向这块空间的指针还是存在！只不过现在指针指向的内容是未定义的，因此，释放内存后最好把指针指向NULL，防止后面不小心又解引用该指针了。</p><p>free()函数非常简单，只有一个参数，只要把指向申请空间的指针传递给free()即可。这是因为 free 是根据结构体 mem_control_block 的信息来释放malloc()申请的空间。</p><pre><code>void free(void *ptr){    struct mem_control_block *free;    free = ptr - sizeof(struct mem_control_block);    free-&gt;is_available = 1;    return;}</code></pre><p>malloc 的一个具体使用例子在 <a href="https://gist.github.com/xuelangZF/573b1da0fbe0e7c6a568bd9530456766" target="_blank" rel="noopener">gist</a> 上。</p><h2 id="new-和-malloc-的对比"><a href="#new-和-malloc-的对比" class="headerlink" title="new 和 malloc 的对比"></a>new 和 malloc 的对比</h2><ol><li>new/delete是C++操作符，malloc/free是C/C++函数。</li><li>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的大小。</li><li>new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构，而malloc只负责分配空间。</li><li>new 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void <em> ，需要通过强制类型转换将 void</em> 指针转换成我们需要的类型。</li><li>效率上：malloc的效率高一点，因为只分配了空间。</li><li>operator new /operator delete 可以被重载，而 malloc/free 并不允许重载。</li></ol><h2 id="常见的内存错误"><a href="#常见的内存错误" class="headerlink" title="常见的内存错误"></a>常见的内存错误</h2><p>常见内存错误以及解决办法:</p><ul><li>内存分配未成功，却使用了它。（在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用<code>assert(p!=NULL)</code>进行检查。如果是用malloc或new来申请内存，应该用<code>if(p==NULL)</code>或<code>if(p!=NULL)</code>进行防错处理。）</li><li>内存分配虽然成功，但是尚未初始化就引用它。（无论用何种方式创建数组，都应该初始化）</li><li>内存分配成功并且已经初始化，但操作越过了内存的边界。例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</li><li>忘记了释放内存，造成内存泄露。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete）。</li><li>释放了内存却继续使用它。</li></ul><h1 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h1><p>缓冲区是一块可读写的连续的计算机内存区域，高级语言定义的变量、数组、结构体等在运行时可以说都是保存在缓冲区内的。除了代码段和受操作系统保护的数据区域，其他的内存区域都可以作为<code>缓冲区</code>，因此缓冲区溢出的位置可能在.Data 和 .BSS段，也可能在堆、栈段。</p><ul><li>.Data段和.BSS段存储了用户程序的全局变量，静态变量等；</li><li>栈空间存储了用户程序的<code>函数栈帧</code>（包括参数、局部数据等），用来实现函数调用机制。</li><li>堆空间存储了程序运行时动态申请的内存数据等。</li></ul><p>在C/C++语言中，通常使用<code>字符数组</code>和<code>malloc/new</code>内存分配函数来分配缓冲区。使用这些缓冲区时，理想的情况是程序检查数据长度，不允许输入超过缓冲区长度的字符。但是绝大多数程序并不会保证数据长度总是与所分配的缓冲区空间相匹配，这就会导致<code>缓冲区溢出</code>问题。</p><h2 id="函数栈帧"><a href="#函数栈帧" class="headerlink" title="函数栈帧"></a>函数栈帧</h2><p>栈的主要功能是实现函数的调用，在介绍栈溢出原理之前，需要弄清函数调用时栈空间发生了怎样的变化。每次函数调用时，系统会把函数的返回地址（函数调用指令后紧跟指令的地址），一些关键的寄存器值保存在栈内，函数的实际参数和局部变量（包括数据、结构体、对象等）也会保存在栈内。这些数据统称为<code>函数调用的栈帧</code>，而且每次函数调用都会有个独立的栈帧，这也为递归函数的实现提供了可能。</p><p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/C++_Memory_2.jpg" alt=""></p><p>如图所示，定义了一个简单的函数function，它接受一个整形参数，做一次乘法操作并返回。当调用function(0)时，arg参数记录了值0入栈，并将call function指令下一条指令的地址0x00bd16f0保存到栈内，然后跳转到function函数内部执行。每个函数定义都会有函数头和函数尾代码，如图绿框表示。因为函数内需要用ebp寄存器保存函数栈帧基址，因此先保存ebp原来的值到栈内，然后将栈指针esp内容保存到ebp。函数返回前需要做相反的操作——将esp指针恢复，并弹出ebp。</p><p>之所以会有缓冲区溢出的可能，主要是因为<strong>栈空间内保存了函数的返回地址</strong>。该地址保存了函数调用结束后后续执行的指令的位置，对于计算机安全来说，该信息是很敏感的。如果有人恶意修改了这个返回地址，并使该返回地址指向了一个新的代码位置，程序便能从其它位置继续执行。也就是说攻击者可以利用缓冲区溢出来窜改进程运行时栈，从而改变程序正常流向，轻则导致程序崩溃，重则系统特权被窃取。</p><h2 id="溢出原理"><a href="#溢出原理" class="headerlink" title="溢出原理"></a>溢出原理</h2><p>从根本上讲，在程序将数据读入或复制到缓冲区中的任何时候，它需要在复制之前检查是否有足够的空间。遗憾的是，C 和 C++ 附带的大量危险函数（或普遍使用的库）无法做到这点。程序对这些函数的任何使用都是一个警告信号，因为除非慎重地使用它们，否则它们就会成为程序缺陷。</p><p>比如在使用不安全的strcpy库函数时，系统会盲目地将data的全部数据拷贝到buffer指向的内存区域。buffer的长度是有限的，一旦data的数据长度超过BUF_LEN，便会产生缓冲区溢出。如下图所示：</p><p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/C++_Memory_3.jpg" alt="溢出示例"></p><p>由于栈是低地址方向增长的，因此局部数组buffer的指针在缓冲区的下方。当把data的数据拷贝到buffer内时，超过缓冲区区域的高地址部分数据会“淹没”原本的其他栈帧数据，根据淹没数据的内容不同，可能会有产生以下情况：</p><ol><li>淹没了其他的局部变量。如果被淹没的局部变量是条件变量，那么可能会改变函数原本的执行流程。这种方式可以用于破解简单的软件验证。</li><li>淹没了ebp的值。修改了函数执行结束后要恢复的栈指针，将会导致栈帧失去平衡。</li><li>淹没了返回地址。这是栈溢出原理的核心所在，通过淹没的方式修改函数的返回地址，使程序代码执行“意外”的流程！</li><li>淹没参数变量。修改函数的参数变量也可能改变当前函数的执行结果和流程。</li><li>淹没上级函数的栈帧，情况与上述4点类似，只不过影响的是上级函数的执行。当然这里的前提是保证函数能正常返回，即函数地址不能被随意修改。</li></ol><p>如果在data本身的数据内就保存了一系列的指令的二进制代码，一旦栈溢出修改了函数的返回地址，并将该地址指向这段二进制代码的真实位置，那么就完成了基本的溢出攻击行为。</p><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p><p>内存泄漏是最难发现的常见错误之一，因为除非用完内存或调用malloc失败，否则都不会导致任何问题。实际上，使用C/C++这类没有垃圾回收机制的语言时，很多时间都花在处理如何正确释放内存上。如果程序运行时间足够长，如后台进程运行在服务器上，只要服务器不宕机就一直运行，一个小小的失误也会对程序造成重大的影响，如造成某些关键服务失败。</p><p>C++中的内存泄露一般指<code>堆中的内存泄露</code>。堆内存是我们手动malloc/realloc/new申请的，程序不会自动回收，需要调用free或delete手动释放，否则就会造成内存泄露。内存泄露常见的原因大概有以下几种：</p><ol><li>“无主”内存：申请内存后，指针指向内存的起始地址，若丢失或修改这个指针，那么申请的内存将丢失且没法释放。</li><li>异常分支导致资源未释放：程序正常执行没有问题，但是如果遇到异常，正常执行的顺序或分支会被打断，得不到执行。所以在异常处理的代码中，要确保系统资源的释放。</li><li>类的析构函数为非虚函数：析构函数为虚函数，利用多态来调用指针指向对象的析构函数，而不是基类的析构函数。</li></ol><p>下面来看一个简单的内存泄漏示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *x = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> *y = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">// free(x);</span></span><br><span class="line">    <span class="comment">// delete []y;</span></span><br><span class="line">    <span class="comment">// x = NULL;</span></span><br><span class="line">    <span class="comment">// y = NULL;</span></span><br><span class="line">&#125;                    <span class="comment">// problem here: memory leak -- x, y not freed</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存泄漏检测"><a href="#内存泄漏检测" class="headerlink" title="内存泄漏检测"></a>内存泄漏检测</h2><p>内存泄露检测的关键在于记录分配内存和释放内存的操作，看看能不能匹配。跟踪每一块内存的声明周期，例如：每当申请一块内存后，把指向它的指针加入到List中，当释放时，再把对应的指针从List中删除，到程序最后检查List就可以知道有没有内存泄露了。</p><p>在一般的linux发行版中，有一个自带的工具可以很方便的替你完成这些事，这个工具就是mtrace。mtrace为内存分配、释放函数（malloc, realloc, memalign, free）安装hook函数，这些hook函数记录内存申请和释放的trace信息。 </p><p>不过还有一款强大的检测工具 Valgrind，它是运行在Linux上一套基于仿真技术的程序调试和分析工具，包含一个内核——一个软件合成的CPU，和一系列的小工具，每个工具都可以完成一项任务──调试，分析，或测试等，其中Memcheck 工具可以用来方便的检测内存泄漏。</p><p>可以用下面命令检测程序是否发生内存泄漏：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --leak-check=yes ./demo.o</span><br></pre></td></tr></table></figure><p>对于下面的程序来说</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* still_reachable;</span><br><span class="line">Node* possible_lost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *tmp = <span class="keyword">new</span> Node;   <span class="comment">// definitely_lost</span></span><br><span class="line">    tmp-&gt;next = <span class="keyword">new</span> Node;   <span class="comment">// indirectly_lost</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    show();</span><br><span class="line">    still_reachable = <span class="keyword">new</span> Node;</span><br><span class="line">    possible_lost = <span class="keyword">new</span> Node[<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有四种类型的内存泄漏（关于这四种泄漏类型的详细内容，参考  <a href="http://valgrind.org/docs/manual/mc-manual.html#mc-manual.leaks" target="_blank" rel="noopener">Memory leak detection</a>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">==45310== LEAK SUMMARY:</span><br><span class="line">==45310==    definitely lost: 16 bytes <span class="keyword">in</span> 1 blocks</span><br><span class="line">==45310==    indirectly lost: 16 bytes <span class="keyword">in</span> 1 blocks</span><br><span class="line">==45310==      possibly lost: 2,096 bytes <span class="keyword">in</span> 2 blocks</span><br><span class="line">==45310==    still reachable: 16 bytes <span class="keyword">in</span> 1 blocks</span><br><span class="line">==45310==         suppressed: 20,125 bytes <span class="keyword">in</span> 189 blocks</span><br><span class="line">==45310== Reachable blocks (those to <span class="built_in">which</span> a pointer was found) are not shown.</span><br></pre></td></tr></table></figure><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://www.cnblogs.com/QG-whz/p/5140930.html" target="_blank" rel="noopener">细说new与malloc的10点区别</a><br><a href="http://stackoverflow.com/questions/93039/where-are-static-variables-stored-in-c-c" target="_blank" rel="noopener">Where are static variables stored (in C/C++)?</a><br><a href="http://www.inf.udec.cl/~leo/teoX.pdf" target="_blank" rel="noopener">Memory management in C: The heap and the stack</a><br><a href="http://www.cnblogs.com/clover-toeic/p/3737011.html" target="_blank" rel="noopener">缓冲区溢出详解</a><br><a href="http://www.cnblogs.com/fanzhidongyzby/p/3250405.html" target="_blank" rel="noopener">缓冲区溢出攻击</a><br><a href="http://blog.jobbole.com/95375/" target="_blank" rel="noopener">C/C++内存泄漏及检测</a><br><a href="http://valgrind.org/docs/manual/mc-manual.html#mc-manual.leaks" target="_blank" rel="noopener">Doc: Valgrind：Memory leak detection</a><br><a href="http://zhiqiang.org/note/md/check-cpp-memory-with-valgrind.html" target="_blank" rel="noopener">用valgrind检查C++程序的内存泄漏</a><br><a href="http://www.csee.umbc.edu/~chang/cs313.s02/stack.shtml" target="_blank" rel="noopener">C Function Call Conventions and the Stack</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p>二叉树的遍历是指通过一定的顺序访问二叉树的所有结点。<br>一般包括：先序遍历、中序遍历、后序遍历、层次遍历<br>先序、中序、后序的遍历一般通过深度优先搜索实现，层次遍历一般通过广度优先搜索实现。</p><h2 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1. 先序遍历"></a>1. 先序遍历</h2><p>遍历顺序：根结点-&gt;左子树-&gt;右子树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">    preorder(root-&gt;lchild);</span><br><span class="line">    preorder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h2><p>遍历顺序：左子树-&gt;根结点-&gt;右子树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">    inorder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h2><p>遍历顺序：左子树-&gt;右子树-&gt;根结点<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(root-&gt;lchild);</span><br><span class="line">    postorder(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-层序遍历"><a href="#4-层序遍历" class="headerlink" title="4. 层序遍历"></a>4. 层序遍历</h2><p>层序遍历指按层次的顺序从根结点向下逐层进行遍历，且对同一层的节点为从左到右遍历。<br>基本思路：从根结点开始广度优先搜索</p><ul><li>将根结点root加入队列</li><li>取出队首结点，访问它</li><li>如果该结点有左孩子，将左孩子入队。</li><li>如果该结点有右孩子，将右孩子入队</li><li><p>返回第二步，直到队列为空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node* now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,noe-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;lchild!=<span class="literal">NULL</span>) q.push(now-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;rchild!=<span class="literal">NULL</span>) q.push(now-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果题目要求计算每个结点所处层次，可以在二叉树结点的定义中添加一个记录层次的layer变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> layer;</span><br><span class="line">    node* lchild;</span><br><span class="line">    node* rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node*&gt; q;</span><br><span class="line">    root-&gt;layer=<span class="number">1</span>;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node* now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,noe-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                now-&gt;lchild-&gt;layer=now-&gt;layer+<span class="number">1</span>;</span><br><span class="line">                q.push(now-&gt;lchild);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;rchild!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            now-&gt;rchild-&gt;layer=now-&gt;layer+<span class="number">1</span>;</span><br><span class="line">                q.push(now-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>问题：给定一棵二叉树的先序遍历序列和中序遍历序列（或者给定后序序列和中序序列），要求重建这棵二叉树。</p><h3 id="中序序列-确定左右子树-可以与先序序列、后序序列、层序序列（确定根结点）中的任意一个来构建唯一地二叉树，后三者任意搭配都不能构建唯一的二叉树"><a href="#中序序列-确定左右子树-可以与先序序列、后序序列、层序序列（确定根结点）中的任意一个来构建唯一地二叉树，后三者任意搭配都不能构建唯一的二叉树" class="headerlink" title="中序序列(确定左右子树)可以与先序序列、后序序列、层序序列（确定根结点）中的任意一个来构建唯一地二叉树，后三者任意搭配都不能构建唯一的二叉树"></a>中序序列(确定左右子树)可以与先序序列、后序序列、层序序列（确定根结点）中的任意一个来构建唯一地二叉树，后三者任意搭配都不能构建唯一的二叉树</h3><p>假设已知先序序列为pre1,pre2……中序序列为in1,in2……<br>则先序序列中的第一个元素pre1是当前二叉树的根结点<br>当前二叉树的根结点又将中序序列划分为左子树和右子树，在中序序列中找到某个结点ink，使得ink=pre1。<br>左子树结点个数numLeft=k-1，同时可得出左右子树的先序和中序序列区间。<br>递归边界：先序序列的长度小于等于0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> prel ,<span class="keyword">int</span> prer,<span class="keyword">int</span> inl,<span class="keyword">int</span> inr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prel&lt;prer)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* root=<span class="keyword">new</span> node;</span><br><span class="line">    root-&gt;data=pre[prel];</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k=inl;k&lt;=inr;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[k]==pre[prel])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numLeft=k-inl;</span><br><span class="line">    root-&gt;lchild=create(prel+<span class="number">1</span>,prel+numLeft,inl,k<span class="number">-1</span>);</span><br><span class="line">    root-&gt;rchild=create(prel+numLeft+<span class="number">1</span>,prer,k+<span class="number">1</span>,inr);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二叉树的静态实现"><a href="#二叉树的静态实现" class="headerlink" title="二叉树的静态实现"></a>二叉树的静态实现</h3><p>不用指针，只用数组实现二叉树基本操作</p><ul><li>静态二叉链表<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;</span><br><span class="line">    <span class="keyword">int</span> lchild;</span><br><span class="line">    <span class="keyword">int</span> rchild;</span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    Node[index].data=v;</span><br><span class="line">    Node[index].lchild=<span class="number">-1</span>;</span><br><span class="line">    Node[index].rchild=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二叉树的查找、插入、建立"><a href="#二叉树的查找、插入、建立" class="headerlink" title="二叉树的查找、插入、建立"></a>二叉树的查找、插入、建立</h3><p>root为根结点在数组中的下标<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> x,<span class="keyword">int</span> newdata)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Node[root].data==x)&#123;</span><br><span class="line">        Node[root].data=newdata;</span><br><span class="line">    &#125;</span><br><span class="line">    search(Node[root].lchild,x,newdata);</span><br><span class="line">    search(Node[root].rchil,x,newdata);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="number">-1</span>)&#123;</span><br><span class="line">        root==newNode(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x插在左子树)&#123;</span><br><span class="line">        insert(Node[root].lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    insert(Node[root].rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        insert(root,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的遍历-1"><a href="#二叉树的遍历-1" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Node[root].data);</span><br><span class="line">    preorder(Node[root].lchild);</span><br><span class="line">    preorder(Node[root].rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(Node[root].lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Node[root].data);</span><br><span class="line">    inorder(Node[root].rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(Node[root].lchild);</span><br><span class="line">    postorder(Node[root].rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Node[root].data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,Node[now].data);</span><br><span class="line">        <span class="keyword">if</span>(Node[now].lchild!=<span class="number">-1</span>) q.push(Node[now].lchild);</span><br><span class="line">        <span class="keyword">if</span>(Node[now].rchild!=<span class="number">-1</span>) q.push(Node[now].rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>《素媛》与《熔炉》</title>
      <link href="/%E5%BD%B1%E9%9F%B3/%E3%80%8A%E7%B4%A0%E5%AA%9B%E3%80%8B%E4%B8%8E%E3%80%8A%E7%86%94%E7%82%89%E3%80%8B/"/>
      <url>/%E5%BD%B1%E9%9F%B3/%E3%80%8A%E7%B4%A0%E5%AA%9B%E3%80%8B%E4%B8%8E%E3%80%8A%E7%86%94%E7%82%89%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="现实依旧残酷"><a href="#现实依旧残酷" class="headerlink" title="现实依旧残酷"></a>现实依旧残酷</h1><p>　　最近看了两部韩国电影，正好五一假期有空，想写点什么。在知乎上看过一个话题，人开始废掉的标志是什么？记得有人答说当一个人沉迷于短期便可轻易获得快感的事物时，有人答说当一个开始拒绝输出的时候便是废掉的开始。我感到恐慌，我意识到尽管一天到晚都在读书，在听歌看电影，在接受各种信息，但我不能一位接收而不输出，其实这也是我搞这个静态博客的初衷。我知道自己文笔不行，但我还是想写点东西，想记录点生活。论文学，读了《红楼梦》便知道什么才是大家之作，这样的奇书需要怎么的积淀才能写就。很明显，一般人都达不到这样的高度，但这并不妨碍我继续输出自己的想法，学编程也一样，当一个人学编程只看书看视频听课，却从不自己不敲代码，那么注定是失败的学习者，而敲代码的过程，其实也就是输出的过程。<br>　　<img src="/img/熔炉.jpg" alt="Alt text"></p><p>　　回到正题，为什么要把素媛和熔炉放到一起，一个显然的原因就是这两部都是反映未成年人被性侵的黑现实题材，我不清楚是因为自己接触的电影太少，还是不了解国内状况，为什么中国相应的题材电影没有令我印象深刻的，难道我们国家已经社会和谐，大家都生活在了一个幸福美满的国度里了吗，甚至已经没必要在去关注未成年人的成长问题？素媛和熔炉都是根据真实事件改编的电影，韩国在反映黑暗面现实题材的电影方面似乎做得比较好，有些放在国内怕是审批都过不了，两部电影最后的结局让人痛心与无奈，但这也是电影出彩的一个方面之一吧。以往很多电影，剧情发展到后期，基本就是坏蛋绳之以法，恶有恶报。但不得不承认，现实中很多人的恶报来的并没那么快，被害人可能死不瞑目，犯人却依旧逍遥法外的情况并不少，冤判，错判，更恶劣的，权钱交易，有钱有势的才是爹，普通人的生命就如草芥一般。寒假看的红楼梦，其实曹公也写到了很多底层人的生活，起初读红楼梦可能只关注到宝玉、宝钗、黛玉三者恋为主线的少男少女之间的情情爱爱，但这其实就低估了曹公的作品了，从繁华到幻灭，情确实是红楼梦的一大主题，但其实里面写到了很多卑微者的命运，很多人无力反抗这样命运，最终只能认命。<br>　　<img src="/img/素媛.jpg" alt="Alt text"><br>　　2012年夏天，7岁女童独自在家睡觉，半夜被一男子入室掳走，实施了强奸和殴打，事后该男子用树枝和其他条状硬物捅女童的阴道和肠道，女童被附近的居民发现在一条小河边，当时下着雨，女童重度昏迷，大小便失禁，血肉模糊。送医治疗后经诊断，肠道没有一处完好的地方，手术几乎把肠子全部切除，阴道和肠道中间的部分全部破坏，阴道在外伤的情况下又被粪便感染，子宫受损，也就是说，子宫，阴道，肠道都受到重创，安装了人造肛门之后，终身都要带着便便袋生活，有可能无月经无生育能力。孩子很惨，但凶手抓到后拒不认罪，不赔偿，孩子的父母都是普通老百姓，支付医药费都很困难，一直申诉，一方面是为女儿讨公道，一方面是想得到赔偿给孩子更好的治疗。这就是素媛背后的真实事件，其实比起熔炉，素媛这部电影倒是让人感到更加温暖。影片其实可以注意到很多人物心理、行为等在事发前后发生了巨大的变化。素媛的爸爸就令人感动，在平常日子里，从吃饭时的自顾自，对素媛的生活，学习等等虽不能说毫不在意吧，但确实没花多少心思在自己的女儿身上，事发后，后悔自然无用，但我们看到了一个父亲应有的担当，你能想象一个大男人，在大夏天穿着那种厚厚的卡通套装，只为陪伴在女儿身边，为了接触他，让她开心，安心，试问生活中的父亲都表现的如何？之所以说这部电影暖心，不仅仅是事发家庭成员自身的坚强，当然其实他们也已经到了崩溃的边缘，记得素媛的母亲甚至抱怨，为什么那么多小孩，这种事为什么偏偏发生在自己的女儿身上，我宁愿所有人的小孩都遭受同样的伤害！这其实也是痛苦的一种发泄。<br>　　素媛其实除了批判，总体上格调还是偏暖的。其中有很多震撼的地方，尤其是素媛，这个9岁的小女孩竟然能这么懂事，心智竟然已经如此成熟。发生不幸，他仍能想到自己的爸妈，能体会到爸妈的痛苦，甚至知道为自己治病家里要花不少钱，他会内疚。素媛与夙愿，这是一个寓意着希望的女孩，活着就是希望，更何况还能看到她灿烂的笑容。最后判决如此不公，冲动的父亲甚至打算与凶手同归于尽，但就在砸向凶手的瞬间，冲动的父亲被素媛抱住了，她不希望父亲做傻事。事发后，身边的朋友捐款的捐款，素媛的同学也在默默支持着他。这里有个叫荣植的小胖子很可爱，他后面来到素媛的店门口，对他父亲说，当时如果等素媛一起上学，素媛就不会出这种事了，他觉得很自责，然后嚎啕大哭，这是一个小孩的真性情。回到主旋律，还是反映了社会对未成年人的淡漠，素媛其实是一个非常单纯善良的小女孩，即是自己上学迟到了，但不给坏叔叔撑伞却还是于心不忍，注意到这里他只是认为想帮助别人，但实际上身边的人非但没有夸她，反认为是她的错。也许很多人心想，你何苦这么好心，自己都要来不及上课了，还想着别人？另外，事发后还有一帮人很令人淡漠，一帮是那群媒体记者，于他们而言，这是热点，当然得蜂拥往上挤，可是除了采访，他们几乎完全没有顾及当事人的感受。另一帮人就是法庭上那帮家伙了，我很好奇为嫌疑人辩护的律师内心是什么想法，当她对着一个9岁的受害女孩提问时能如此正气？<br>　　而《熔炉》怕是就比较沉重了。完全反应的是人性的黑暗面，格调悲凉而沉重。<br>　　《熔炉》，是根据韩国光州一所聋哑学校校长性侵儿童的真实事件改编的电影，真实事件中，从校长到老师共10余人，先后对超过30名聋哑儿童进行性侵，有很多连10岁都还不到。其实小说和电影的改编免不了要进行艺术方面的加工，现实中的黑暗恐怕更是令人难以想象。为什么于我而言，素媛偏向温暖，而熔炉却是令人沉痛。事实上，两者之间的社会危害性的强度也是显然有强弱之分的。素媛里的犯人仅仅只是一个普通的无奈，一个有前科的混混，另外素媛还有很多关系她的人，不仅仅只是她的父母。而熔炉不同，熔炉事件的双方是差距悬殊的，一方是有权有势的聋哑学校校长，另一方很多甚至都是无父无母的残障儿童，在这样差距悬殊的情况下，一旦人性黑暗面涌现，受害的一方是显然并且是毫无还手之力的。影片中孩子们唯一的幸运是遇到了一个好老师，男主和女主为了救孩子确实尽了全力，我影片结尾我们都看到了，罪恶的一方并没有受到相应的处罚，其实这也是很多现实事件的真实写照。倘若，这些孩子一直没有遇到善良的能帮助他们的人，结果又会如何，惨遭毒手的孩子只会继续增加。社会上好人确实不少，但坏人不能说已经没有了，尤其是一些有权有势的坏人克服不了自己人性黑暗的一面，那么造成的后果必然是灾难性的，弱势群体得不到保护，一方面作为法治社会体现了制度上的欠缺，法律不够完善，另一方面，这是一起社会事件，更大程度上反映了集体意识的淡漠。事不关己高高挂起，何苦自讨没趣去得罪哪些大人物呢？越得不到重视，黑暗面便越猖狂，社会也就越畸形。<br>　　最后撇开电影，回到自己。说实话，影片中的事件都是我无法想象和体会的，或者说触动可能还不是特别强烈。因为我长这么大，都还算生活在一个相对阳光的环境里，认识了很多人，可以说有好有坏。但其实人性是复杂的，一般碰到的人很少回想小说或电影里讲人性展现的非常露骨，人们可能会不知不觉隐藏自己的某一面。无论怎么说，我接触到的同学，老师，长辈，陌生人，可能这个让你讨厌，那个令你烦恼，但不至于说他是一个坏人，未成年人受到欺凌的事件我遇到过，但也许并没有引起自己的关注，首先那时我自己也是个小孩，因为没碰到很严重的，我会以为他们只是一言不合，打起架来了。从小到大，由于自己多愁善感的性格，可以说是烦恼不断，但困扰自己的无非是些普普通通的小事，人生不如意事十之八九嘛。但如果电影中的事件发生在自己身边，自己会表现为一个怎样的角色，我甚至不敢想，为什么不敢想，因为很可能，如果受害者不是自己的亲人，可能也就是感叹一番，为自己茶余饭后多了点谈资罢了，我真的会去做些什么吗？会作为正义的化身，不顾生死与暗势力反抗吗？至于其他人，可能还在为自己的房贷车贷发愁呢。熔炉的真实事件是涉及到了暗杀的程度，没有勇气，只有一腔热血的你会不会坚持正义？再进步一步，如果受害者是自己或者是自己的亲人，你会怎么做，这时怕是做不到无动于衷了吧？你又能做些什么？注意到，一般受害的往往是弱势群体，也就是你没钱没权没话语权。你相信法庭吗？你相信律师吗？你相信警察吗？不瞎写了，代码还没敲完呢…回见　　</p>]]></content>
      
      
      <categories>
          
          <category> 影音 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>葬花词</title>
      <link href="/%E9%98%85%E8%AF%BB/%E8%91%AC%E8%8A%B1%E8%AF%8D/"/>
      <url>/%E9%98%85%E8%AF%BB/%E8%91%AC%E8%8A%B1%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="程高通行本《葬花吟》"><a href="#程高通行本《葬花吟》" class="headerlink" title="　　　程高通行本《葬花吟》"></a>　　　程高通行本《葬花吟》</h1><blockquote class="blockquote-center"><p>　　　　　　　　　花谢花飞花满天，红消香断有谁怜？<br>　　　　　　　　　游丝软系飘春榭，落絮轻沾扑绣帘。<br>　　　　　　　　　闺中女儿惜春暮，愁绪满怀无释处。<br>　　　　　　　　　手把花锄出绣帘，忍踏落花来复去。<br>　　　　　　　　　柳丝榆荚自芳菲，不管桃飘与李飞；<br>　　　　　　　　　桃李明年能再发，明年闺中知有谁？<br>　　　　　　　　　三月香巢已垒成，梁间燕子太无情！<br>　　　　　　　　　明年花发虽可啄，却不道人去梁空巢也倾。<br>　　　　　　　　　一年三百六十日，风刀霜剑严相逼；<br>　　　　　　　　　明媚鲜妍能几时，一朝漂泊难寻觅。<br>　　　　　　　　　花开易见落难寻，阶前愁杀葬花人，<br>　　　　　　　　　独倚花锄泪暗洒，洒上空枝见血痕。<br>　　　　　　　　　杜鹃无语正黄昏，荷锄归去掩重门；<br>　　　　　　　　　青灯照壁人初睡，冷雨敲窗被未温。<br>　　　　　　　　　怪奴底事倍伤神？半为怜春半恼春。<br>　　　　　　　　　怜春忽至恼忽去，至又无言去未闻。<br>　　　　　　　　　昨宵庭外悲歌发，知是花魂与鸟魂？<br>　　　　　　　　　花魂鸟魂总难留，鸟自无言花自羞；<br>　　　　　　　　　愿侬此日生双翼，随花飞到天尽头。<br>　　　　　　　　　天尽头，何处有香丘？<br>　　　　　　　　　未若锦囊收艳骨，一抔净土掩风流3。<br>　　　　　　　　　质本洁来还洁去，强于污淖陷渠沟。<br>　　　　　　　　　尔今死去侬收葬，未卜侬身何日丧？<br>　　　　　　　　　侬今葬花人笑痴，他年葬侬知是谁？<br>　　　　　　　　　试看春残花渐落，便是红颜老死时；<br>　　　　　　　　　一朝春尽红颜老，花落人亡两不知！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树的定义与性质</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%80%A7%E8%B4%A8/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="树的定义与性质"><a href="#树的定义与性质" class="headerlink" title="树的定义与性质"></a>树的定义与性质</h2><p>由若干结点和若干条边组成的数据结构。<br>常用性质：</p><ol><li>树可以没有结点，这种情况把树称为空树。</li><li>树的层次从根结点开始算起，即根结点为第一层，根结点子树的根结点为第二层，以此类推。</li><li>把结点的子树棵数称为结点的度，树中结点的最大的度称为树的度。</li><li>由于一条边连接两个结点，且树中不存在环，因此对有n个结点的树，边数一定是n-1.<br>满足连通、边数等于顶点数-1的结构一定是一棵树。</li><li>叶子结点被定义为度为0的结点，因此当树中只有一个结点（即只有根结点）时，根结点也算作叶子结点。</li><li>结点的深度是指从根结点（深度为1）开始自顶向下逐层累加至该结点的深度值。<br>结点的高度是指从最底层叶子结点开始自底向上逐层累加至该结点时的高度值。<br>树的深度是指树中结点的最大深度，树的高度是指树中结点的最大高度。对树而言，深度与高度相等。</li><li>多棵树组合在一起称为森林，即森林是若干树的集合。<h2 id="二叉树的递归定义（用自身定义自身）"><a href="#二叉树的递归定义（用自身定义自身）" class="headerlink" title="二叉树的递归定义（用自身定义自身）"></a>二叉树的递归定义（用自身定义自身）</h2></li><li>二叉树要么没有根结点，是一棵空树。</li><li>二叉树要么由根结点、左子树。右子树组成，且左子树和右子树都是二叉树。</li></ol><ul><li>两种特殊二叉树</li></ul><ol><li>满二叉树： 每一层的结点个数都达到了当层能达到的最大结点数</li><li>完全二叉树： 除了最下面一层之外，其余层的结点个数都达到了当层能达到的最大结点数，<br>且最下面一层只从左到右连续存在若干结点，而这些结点右边的结点全部不存在。</li></ol><ul><li>树的其他概念</li></ul><ol><li>层次：层次类似于家谱中的辈分关系</li><li>孩子结点、父亲结点、兄弟结点、祖先结点、子孙结点：一个结点的子树的根结点称为它的孩子结点，<br>而它称为孩子节点的父亲结点。与该结点同父亲的结点称为该结点的兄弟结点。<h2 id="二叉树的存储结构与基本操作"><a href="#二叉树的存储结构与基本操作" class="headerlink" title="二叉树的存储结构与基本操作"></a>二叉树的存储结构与基本操作</h2></li><li><p>二叉树的存储结构<br>与链表类似，只是指针域改为两个——指向左子树的根结点地址和右子树的根结点地址。<br>如果某个子树不存在，则指向NULL</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">typename</span> data;<span class="comment">//数据域</span></span><br><span class="line">  node* lchild;<span class="comment">//指向左子树根结点的指针</span></span><br><span class="line">  node* rchild;<span class="comment">//指向右子树根结点的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//根结点初始化</span></span><br><span class="line">node* root=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//往二叉树中插入结点</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">  node* Node = <span class="keyword">new</span> node;<span class="comment">//申请一个node型变量的地址空间</span></span><br><span class="line">  Node-&gt;data=v;<span class="comment">//结点权值</span></span><br><span class="line">  Node-lchild=Node-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> Node;<span class="comment">//返回新建结点的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉树的查找、修改<br>查找操作是指在给定数据域的条件下，在二叉树中找到所有数据域为给定数据域的结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root,<span class="keyword">int</span> x,<span class="keyword">int</span> newdata)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;<span class="comment">//空树（递归边界）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data==x)&#123;<span class="comment">//找到数据域为x的结点，把它修改为newdata</span></span><br><span class="line">        root-&gt;data=newdata;</span><br><span class="line">    &#125;</span><br><span class="line">    search(root-&gt;lchild,x,newdata);<span class="comment">//往左子树搜索x（递归式）</span></span><br><span class="line">    search(root-&gt;rchild,x,newdata);<span class="comment">//往右子树搜索x（递归式）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉树结点的插入<br>结点的插入位置一般取决于数据域需要在二叉树中存放的位置，且对給定结点来说，它在二叉树中的插入位置只会有一个。<br>即二叉树结点的插入位置就是数据域在二叉树中查找失败的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;<span class="comment">//空树，即查找失败，即插入位置（递归边界）</span></span><br><span class="line">        root=newNode(x);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x需插在左子树)&#123;</span><br><span class="line">        insert(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    insert(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">上述中，根结点指针root使用了&amp;引用，即在函数中修改root会直接修改原变量，如果不用引用，就无法将</span><br><span class="line">新结点接到二叉树上面，而search函数中修改的是指针root指向的内容，而不是root本身，所以不需要引用。</span><br></pre></td></tr></table></figure></li><li><p>二叉树的创建</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        node* root=<span class="literal">NULL</span>;<span class="comment">//新建空根结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            insert(root,data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>root==NULL与*root==NULL的区别<br>即结点不存在与结点存在但没有内容的区别</p></li><li>完全二叉树存储结构<br>对完全二叉树的任一结点x，其左孩子编号一定为2x，右孩子编号为2x+1.<br>完全二叉树可以通过建立一个大小为2^k的数组来存放所有结点的信息，其中k为完全二叉树的最大高度<br>且1号位必须存放根结点，该数组中元素存放的顺序恰好为该完全二叉树的层序遍历序列<br>判断某个结点是否为叶结点的标志为：该结点（下标记为t）的左子结点的编号2*t大于结点总个数n<br>判断某个结点是否为空结点的标志：该结点下标t大于结点总个数n。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>组合数</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%84%E5%90%88%E6%95%B0/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%84%E5%90%88%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="例1：求n！中有多少质因子p"><a href="#例1：求n！中有多少质因子p" class="headerlink" title="例1：求n！中有多少质因子p"></a>例1：求n！中有多少质因子p</h3><p>  直观想法：计算从1~n的每个数各有多少个质因子p，然后将结果累加，时间复杂度为O(nlogn).<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=i;</span><br><span class="line">        <span class="keyword">while</span>(temp%p==<span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            temp/=p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///O(logn)的算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    whil(n)&#123;</span><br><span class="line">    ans+=n/p;</span><br><span class="line">    n/=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n/p+cal(n/p,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="组合数的计算"><a href="#组合数的计算" class="headerlink" title="组合数的计算"></a>组合数的计算</h2><p><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D219/sign=001e9280d1b44aed5d4eb9e58a1d876a/279759ee3d6d55fb34fde7ec66224f4a21a4ddc5.jpg" alt="Alt text"><br>互补性质</p><p>即从m个不同元素中取出n个元素的组合数=从m个不同元素中取出 (m-n) 个元素的组合数；</p><p>这个性质很容易理解，例如C(9,2)=C(9,7)，即从9个元素里选择2个元素的方法与从9个元素里选择7个元素的方法是相等的。<br>规定：C(n,0)=1<br>2.组合恒等式<br>若表示在 n 个物品中选取 m 个物品，则如存在下述公式：C(n,m)=C(n,n-m)=C(n-1,m-1)+C(n-1,m)。</p><h3 id="通过定义直接计算"><a href="#通过定义直接计算" class="headerlink" title="通过定义直接计算"></a>通过定义直接计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">c</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans*=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        ans/=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n-m;i++)&#123;</span><br><span class="line">        ans/=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过递推公式计算"><a href="#通过递推公式计算" class="headerlink" title="通过递推公式计算"></a>通过递推公式计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res[<span class="number">67</span>][<span class="number">67</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">c</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(m==<span class="number">0</span>||m==n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(res[n][m]!=<span class="number">0</span>) <span class="keyword">return</span> res[n][m];</span><br><span class="line">   <span class="keyword">return</span> res[n][m]=c(n<span class="number">-1</span>,m)+c(n<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///打表计算</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n=<span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        res[i][<span class="number">0</span>]=res[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">            res[i][j]=res[i<span class="number">-1</span>][j]+res[i<span class="number">-1</span>][j<span class="number">-1</span>];<span class="comment">///递推计算c(i,j)</span></span><br><span class="line">            res[i][i-j]=res[i][j];<span class="comment">///c(i,i-j)=c(i,j)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过定义式的变形计算"><a href="#通过定义式的变形计算" class="headerlink" title="通过定义式的变形计算"></a>通过定义式的变形计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">c</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    ans=ans*(n-m+i)/i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算C-n-m-p"><a href="#计算C-n-m-p" class="headerlink" title="计算C(n,m)%p"></a>计算C(n,m)%p</h1><h3 id="通过递推公式计算-1"><a href="#通过递推公式计算-1" class="headerlink" title="通过递推公式计算"></a>通过递推公式计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">递归：</span><br><span class="line"><span class="keyword">int</span> res[<span class="number">1010</span>][<span class="number">1010</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>||m==n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(res[n][m]!=<span class="number">0</span>) <span class="keyword">return</span> res[n][m];</span><br><span class="line">    <span class="keyword">return</span> res[n][m]=(c(n<span class="number">-1</span>,m)+c(n<span class="number">-1</span>,m<span class="number">-1</span>))%p;</span><br><span class="line">&#125;</span><br><span class="line">递推：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    res[i][<span class="number">0</span>]=res[i][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">        res[i][j]=(res[i<span class="number">-1</span>][j]+res[i<span class="number">-1</span>][j<span class="number">-1</span>])%p;</span><br><span class="line">        res[i][i-j]=res[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据定义式计算"><a href="#根据定义式计算" class="headerlink" title="根据定义式计算"></a>根据定义式计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> ,n,<span class="keyword">int</span> m,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;prime[i]&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> c=cal(n,prime[i])-cal(m,prime[i])-cal(n-m,prime[i]);</span><br><span class="line">        ans=ans*binaryPow(prime[i],c,p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据定义式的变形计算"><a href="#根据定义式的变形计算" class="headerlink" title="根据定义式的变形计算"></a>根据定义式的变形计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///求c(n,m)%p,且m&lt;p,p为素数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        ans=ans*(n-m+<span class="number">1</span>)%p;</span><br><span class="line">        ans=ans*inverse(i,p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///求c(n,m)%p,m任意,p为素数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>,nump=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=n-m+i;</span><br><span class="line">        <span class="keyword">while</span>(temp%p==<span class="number">0</span>)&#123;</span><br><span class="line">            nump++;</span><br><span class="line">            temp/=p;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=ans*temp%p;</span><br><span class="line">        temp=i;</span><br><span class="line">        <span class="keyword">while</span>(temp%p==<span class="number">0</span>)&#123;</span><br><span class="line">            nump--;</span><br><span class="line">            temp/=p;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=ans*inverse(temp,p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nump&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lucas定理<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lucas</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> c(n%p,m%p)*Lucas(n/p,m/p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>algorithm头文件下常用函数</title>
      <link href="/%E8%AF%AD%E8%A8%80/algorithm%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/%E8%AF%AD%E8%A8%80/algorithm%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="algorithm头文件下常用函数"><a href="#algorithm头文件下常用函数" class="headerlink" title="algorithm头文件下常用函数"></a>algorithm头文件下常用函数</h1><h3 id="1-max-min-abs"><a href="#1-max-min-abs" class="headerlink" title="1. max(),min(),abs()"></a>1. max(),min(),abs()</h3><p>max(x,y)和min(x,y)分别返回x和y中的最大值和最小值，且参数必须是两个。<br>abs(x) 返回x的绝对值。x必须为整数，浮点型的绝对值要用math头文件下的fabs</p><h3 id="2-swap"><a href="#2-swap" class="headerlink" title="2. swap()"></a>2. swap()</h3><p>swap(x,y)用来交换x和y的值</p><h3 id="3-reverse"><a href="#3-reverse" class="headerlink" title="3. reverse()"></a>3. reverse()</h3><p>reverse(it,it2) 可以将数组指针在[it,it2)之间的元素或容器的迭代器在[it,it2)范围内的元素进行反转。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    reverse(a,a+<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str=<span class="string">"abcdefghi"</span>;</span><br><span class="line">    reverse(str.begin()+<span class="number">2</span>,str.begin()+<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-next-permutation"><a href="#4-next-permutation" class="headerlink" title="4. next_permutation()"></a>4. next_permutation()</h3><p>next_permutation() 给出一个序列在全排列中的下一个序列<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>]);</span><br><span class="line">    &#125;<span class="keyword">while</span>(next_permutation(a,a+<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-fill"><a href="#5-fill" class="headerlink" title="5. fill()"></a>5. fill()</h3><p>fill() 可以把数组或容器中的某一段区间赋为某个相同的值。和memset不同，这里的赋值可以使数组类型对应范围中的任意值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    fill(a,a+<span class="number">5</span>,<span class="number">233</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-sort"><a href="#6-sort" class="headerlink" title="6. sort()"></a>6. sort()</h3><p>默认为递增排序</p><ul><li><p>若要递减排序，需要增加比较函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+n,cmp);</span><br></pre></td></tr></table></figure></li><li><p>结构体数组排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.x&gt;b.x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a.x!=b.x) <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>容器排序，在STL标砖容器中，只有vector/string/deque可以sort</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    vi.push_back(<span class="number">3</span>);</span><br><span class="line">    vi.push_back(<span class="number">1</span>);</span><br><span class="line">    vi.push_back(<span class="number">2</span>);</span><br><span class="line">    sort(vi.begin(),vi.end(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,vi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-lower-bound-和upper-bound"><a href="#7-lower-bound-和upper-bound" class="headerlink" title="7. lower_bound()和upper_bound()"></a>7. lower_bound()和upper_bound()</h3><p>lower_bound 和 upper_bound()需要用在一个有序数组或容器中。<br>lower_bound(first,last,val) 用来寻找在数组或容器的[first,last)范围内第一个值大于等于<br>val元素的位置，如果是数组，返回该位置的指针；若果是容器，返回该位置的迭代器<br>upper_bound(first,last,val) 用来寻找在数组或容器的[first,last)范围内第一个值大于<br>val元素的位置，如果是数组，返回该位置的指针；若果是容器，返回该位置的迭代器<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,lower_bound(a,a+<span class="number">10</span>,<span class="number">3</span>)-a,upper_bound(a,a+<span class="number">10</span>,<span class="number">3</span>)-a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pair简介</title>
      <link href="/%E8%AF%AD%E8%A8%80/pair%E7%AE%80%E4%BB%8B/"/>
      <url>/%E8%AF%AD%E8%A8%80/pair%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><p>pair 可以看作一个内部有两个元素的结构体，且这两个元素的类型是可以指定的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair1</span>&#123;</span></span><br><span class="line">    typename1 first;</span><br><span class="line">    typename2 second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-pair定义"><a href="#1-pair定义" class="headerlink" title="1. pair定义"></a>1. pair定义</h3><p>需要添加<map>或<utility>头文件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;typename1,typename2&gt; name;</span><br><span class="line">pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line">pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p(<span class="string">"haha"</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//临时构建pair</span></span><br><span class="line">pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(<span class="string">"hhha"</span>,<span class="number">5</span>);</span><br><span class="line">make_pair(<span class="string">"hhha"</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure></utility></map></p><h3 id="2-pair中元素访问"><a href="#2-pair中元素访问" class="headerlink" title="2. pair中元素访问"></a>2. pair中元素访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line">    p.first=<span class="string">"haha"</span>;</span><br><span class="line">    p.second=<span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p.first&lt;&lt;<span class="string">" "</span>&lt;&lt;p.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    p=make_pair(<span class="string">"xixi"</span>,<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p.first&lt;&lt;<span class="string">" "</span>&lt;&lt;p.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    p=pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(<span class="string">"heihei"</span>,<span class="number">555</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p.first&lt;&lt;<span class="string">" "</span>&lt;&lt;p.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-pair常用函数"><a href="#3-pair常用函数" class="headerlink" title="3. pair常用函数"></a>3. pair常用函数</h3><p>两个pair类型可直接用==、！=、&lt;、&lt;=、&gt;、&gt;=比较大小，先比较first，若first相等，在比较second<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p1(<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p2(<span class="number">5</span>,<span class="number">15</span>);</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p3(<span class="number">10</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(p1&lt;p3) <span class="built_in">printf</span>(<span class="string">"p1&lt;p3\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(p1&lt;=p3) <span class="built_in">printf</span>(<span class="string">"p1&lt;=p3\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(p1&lt;p2) <span class="built_in">printf</span>(<span class="string">"p1&lt;p2\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-pair常见用途"><a href="#4-pair常见用途" class="headerlink" title="4. pair常见用途"></a>4. pair常见用途</h3><ul><li>代替二元结构体及其构造函数，节省编码时间</li><li>作为map的键值对进行插入<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp.insert(make_pair(<span class="string">"heihei"</span>,<span class="number">5</span>));</span><br><span class="line">    mp.insert(pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(<span class="string">"haha"</span>,<span class="number">6</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>stack简介</title>
      <link href="/%E8%AF%AD%E8%A8%80/stack%E7%AE%80%E4%BB%8B/"/>
      <url>/%E8%AF%AD%E8%A8%80/stack%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="stack常见用法"><a href="#stack常见用法" class="headerlink" title="stack常见用法"></a>stack常见用法</h1><p>stack 指栈，是STL中实现的一个后进先出的容器</p><h3 id="1-stack定义"><a href="#1-stack定义" class="headerlink" title="1. stack定义"></a>1. stack定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; name;</span><br></pre></td></tr></table></figure><h3 id="2-stack内容器元素访问"><a href="#2-stack内容器元素访问" class="headerlink" title="2. stack内容器元素访问"></a>2. stack内容器元素访问</h3><p>只能通过top()来访问栈顶元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        st.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,st.top());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-stack常用函数"><a href="#3-stack常用函数" class="headerlink" title="3. stack常用函数"></a>3. stack常用函数</h3><ol><li><p>push()<br>push(x) 将元素x压栈，时间复杂度 O(1)</p></li><li><p>top()<br>top() 获得栈顶元素，时间复杂度 O(1)</p></li><li><p>pop()<br>pop() 用来弹出栈顶元素，时间复杂度 O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        st.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,st.top());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>empty()<br>empty() 判断stack是否为空，为空返回true，否则返回false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">if</span>(st.empty()==<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    st.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(st.empty()==<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>size()<br>返回stack内元素个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        st.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,st.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="stack常见用途"><a href="#stack常见用途" class="headerlink" title="stack常见用途"></a>stack常见用途</h3><p>stack 常被用于模拟实现一些递归，防止程序对栈内存的限制而导致程序运行出错</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>queue简介</title>
      <link href="/%E8%AF%AD%E8%A8%80/queue%E7%AE%80%E4%BB%8B/"/>
      <url>/%E8%AF%AD%E8%A8%80/queue%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="queue的常见用法"><a href="#queue的常见用法" class="headerlink" title="queue的常见用法"></a>queue的常见用法</h1><p>queue 队列，在stl中实现了一个先进先出的容器。</p><h4 id="1-queue的定义"><a href="#1-queue的定义" class="headerlink" title="1. queue的定义"></a>1. queue的定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><h3 id="2-queue容器内的元素访问"><a href="#2-queue容器内的元素访问" class="headerlink" title="2. queue容器内的元素访问"></a>2. queue容器内的元素访问</h3><p>在STL中通过front()访问队首元素，通过back()访问队尾元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,q.front(),q.back());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-queue-的常用函数"><a href="#3-queue-的常用函数" class="headerlink" title="3. queue 的常用函数"></a>3. queue 的常用函数</h3><ol><li>push()<br>push(x) 将x进行入队</li><li>front()访问队首元素，back()访问队尾元素。</li><li><p>pop() 令队首元素出队</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,q.front());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>empty()<br>empty()检测queue是否为空，为空，返回true；否则，返回false</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">if</span>(q.empty()==<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(q.empty()==<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>size()<br>size()返回queue内元素的个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="优先队列-priority-queue的常见用法"><a href="#优先队列-priority-queue的常见用法" class="headerlink" title="优先队列 priority_queue的常见用法"></a>优先队列 priority_queue的常见用法</h1><p>优先队列，底层用堆实现。队首元素一定是当前队列中优先级最高的一个。<br>可以在任何时候往优先队列中加入元素，而优先队列底层的数据结构堆（heap）会随时调整结构，<br>使每次的队首元素都是优先级最大的。</p><h3 id="1-priority-queue的定义"><a href="#1-priority-queue的定义" class="headerlink" title="1. priority_queue的定义"></a>1. priority_queue的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><h3 id="2-priority-queue容器内元素访问"><a href="#2-priority-queue容器内元素访问" class="headerlink" title="2. priority_queue容器内元素访问"></a>2. priority_queue容器内元素访问</h3><p>通过top()函数来访问队首（堆顶）元素，即优先级最高的元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">3</span>);</span><br><span class="line">    q.push(<span class="number">4</span>);</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.top());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-priority-queue的常用函数"><a href="#3-priority-queue的常用函数" class="headerlink" title="3. priority_queue的常用函数"></a>3. priority_queue的常用函数</h3><ol><li><p>push()<br>push(x) 将元素x入队，时间复杂度O(logn)</p></li><li><p>top()<br>top() 获得队首元素，时间复杂度O(1)</p></li><li><p>pop()<br>pop() 令队首元素出队，时间复杂对O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">3</span>);</span><br><span class="line">    q.push(<span class="number">4</span>);</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.top());</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.top());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>empty()<br>empty()检测优先队列是否为空，为空，返回true，否则返回false，时间复杂度O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">if</span>(q.empty()==<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(q.empty()==<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Empty\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>size()<br>size() 返回队列内元素个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-priority-queue内元素优先级位置"><a href="#4-priority-queue内元素优先级位置" class="headerlink" title="4. priority_queue内元素优先级位置"></a>4. priority_queue内元素优先级位置</h3><ul><li><p>基本数据类型的优先级位置<br>一般是数字大的优先级越高<br>以下两种优先队列定义等价</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">//vector&lt;int&gt; 是指承载底层数据结构堆的容器，less&lt;int&gt;则是对第一个参数的比较类</span></span><br><span class="line"><span class="comment">//less&lt;int&gt;表示数字大的优先级越大，greater&lt;int&gt;表示数字小的优先级越大</span></span><br></pre></td></tr></table></figure></li><li><p>结构体的优先级设置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span>&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line">frind <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> fruit &amp;f1,<span class="keyword">const</span> fruit &amp;f2)&#123;</span><br><span class="line">  <span class="keyword">return</span> f1.price&gt;f2.price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>map简介</title>
      <link href="/%E8%AF%AD%E8%A8%80/map%E7%AE%80%E4%BB%8B/"/>
      <url>/%E8%AF%AD%E8%A8%80/map%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="map-映射"><a href="#map-映射" class="headerlink" title="map(映射)"></a>map(映射)</h1><p>  平时定义的数组，其实都是一种映射，但都是将int型映射到其他类型。而map可以将任何基本类型映射到任何基本类型。<br>  比如建立string型到int型的映射。</p><h3 id="map的定义"><a href="#map的定义" class="headerlink" title="map的定义"></a>map的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;typename1,typename2&gt; mp;</span><br><span class="line">其中 typename1是键的类型，typename2是值的类型</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;,<span class="built_in">string</span>&gt; mp;</span><br></pre></td></tr></table></figure><h3 id="map内元素访问"><a href="#map内元素访问" class="headerlink" title="map内元素访问"></a>map内元素访问</h3><p>map一般有两种访问方式：通过下标访问或通过迭代器访问。</p><ol><li><p>通过下标访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'c'</span>] = <span class="number">20</span>;</span><br><span class="line">    mp[<span class="string">'c'</span>] = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mp[<span class="string">'c'</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过迭代器访问<br>map&lt;typename1,typename2&gt;::iterator it;<br>map可以使用it-&gt;first来访问键，使用it-&gt;second来访问值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'m'</span>] =<span class="number">20</span>;</span><br><span class="line">    mp[<span class="string">'r'</span>] =<span class="number">30</span>;</span><br><span class="line">    mp[<span class="string">'a'</span>] =<span class="number">40</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c %d\n"</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//map会以键从小到大的顺序自动排序，这是由于map内部是使用红黑树实现的（set也是），</span></span><br><span class="line">在建立映射的过程中会自动实现从小到大的排序功能</span><br></pre></td></tr></table></figure></li></ol><h3 id="map常用函数实例解析"><a href="#map常用函数实例解析" class="headerlink" title="map常用函数实例解析"></a>map常用函数实例解析</h3><ol><li><p>find()<br>find(key)返回键为key的映射的迭代器，时间复杂度为O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'a'</span>] =<span class="number">1</span>;</span><br><span class="line">    mp[<span class="string">'b'</span>] =<span class="number">2</span>;</span><br><span class="line">    mp[<span class="string">'c'</span>] =<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it = mp.find(<span class="string">'b'</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c %d\n"</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>erase()<br>erase()两种用法：删除单个元素、删除一个区间内所有元素</p></li></ol><ul><li>删除单个元素<br>mp.erase(it), 时间复杂度O(1)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'a'</span>] =<span class="number">1</span>;</span><br><span class="line">    mp[<span class="string">'b'</span>] =<span class="number">2</span>;</span><br><span class="line">    mp[<span class="string">'c'</span>] =<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it = mp.find(<span class="string">'b'</span>);</span><br><span class="line">    mp.erase(it);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it =mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c %d\n"</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>mp.erase(key) 时间复杂度为O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'a'</span>] =<span class="number">1</span>;</span><br><span class="line">    mp[<span class="string">'b'</span>] =<span class="number">2</span>;</span><br><span class="line">    mp[<span class="string">'c'</span>] =<span class="number">3</span>;</span><br><span class="line">    mp.erase(<span class="string">'b'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it =mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c %d\n"</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除一个区间内所有元素<br>mp.erase(first,last) first:要删除的区间的其实迭代器<pre><code>last: 要删除的区间的末尾迭代器的下一个地址。时间复杂度：O(last-first)</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'a'</span>] =<span class="number">1</span>;</span><br><span class="line">    mp[<span class="string">'b'</span>] =<span class="number">2</span>;</span><br><span class="line">    mp[<span class="string">'c'</span>] =<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it = mp.find(<span class="string">'b'</span>);</span><br><span class="line">    mp.erase(it,mp.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it =mp.begin();it!=mp.end();it++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c %d\n"</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>size()<br>size()用来获得map中映射的对数，时间复杂度为O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'a'</span>] =<span class="number">1</span>;</span><br><span class="line">    mp[<span class="string">'b'</span>] =<span class="number">2</span>;</span><br><span class="line">    mp[<span class="string">'c'</span>] =<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mp.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>clear()<br>clear()用来清空map中的所有元素，复杂度为O(n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'a'</span>] =<span class="number">1</span>;</span><br><span class="line">    mp[<span class="string">'b'</span>] =<span class="number">2</span>;</span><br><span class="line">    mp[<span class="string">'c'</span>] =<span class="number">3</span>;</span><br><span class="line">    mp.clear();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mp.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="map常见用途"><a href="#map常见用途" class="headerlink" title="map常见用途"></a>map常见用途</h3><ul><li>需要建立字符（字符串）与整数之间的映射</li><li>判断大整数或其他类型数据是否存在的题目，把map当bool数组</li><li>字符串和字符串之间的映射<br>map的键和值是唯一的，如果一个键要对应多个值，只能用multimap</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>string简介</title>
      <link href="/%E8%AF%AD%E8%A8%80/string%E7%AE%80%E4%BB%8B/"/>
      <url>/%E8%AF%AD%E8%A8%80/string%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="string-的常见用法"><a href="#string-的常见用法" class="headerlink" title="string 的常见用法"></a>string 的常见用法</h1><h3 id="1-string的定义"><a href="#1-string的定义" class="headerlink" title="1. string的定义"></a>1. string的定义</h3><p>string str;<br>string str= “abcd”;</p><h3 id="2-string-内容访问"><a href="#2-string-内容访问" class="headerlink" title="2. string 内容访问"></a>2. string 内容访问</h3><ul><li><p>通过下标访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str=<span class="string">"abcd"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str=<span class="string">"abcd"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str.c_str());<span class="comment">///用C_str()将string类型转换为字符数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过迭代器访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str=<span class="string">"abcd"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">string</span>::iterator it=str.begin();it!=str.end();it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-string-常用函数"><a href="#3-string-常用函数" class="headerlink" title="3.string 常用函数"></a>3.string 常用函数</h3><ul><li><p>operator +=<br>string加法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1=<span class="string">"abcd"</span>,str2=<span class="string">"xya"</span>,str3;</span><br><span class="line">    str3=str1+str2;</span><br><span class="line">    str1+=str2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>compare operator<br>两个string类型可直接使用==、！=、&lt;、&lt;=、&gt;、&gt;=比较大小，比较规则为字典序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1=<span class="string">"aaa"</span>,str2=<span class="string">"bbb"</span>,str3=<span class="string">"ccc"</span>,str4=<span class="string">"qqq"</span>;</span><br><span class="line">    <span class="keyword">if</span>(str1&lt;str2) <span class="built_in">printf</span>(<span class="string">"ok\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>length()/size()<br>返回string的长度，两者用法基本相同</p></li><li><p>insert()<br>insert(pos,string),在pos号位置插入字符串string<br>insert(it,it2,it3) it为原字符串的欲插入位置，it2，it3为待插字符串的首尾迭代器<br>表示串[it2,it3)将被插在it位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"abcxyz"</span>,str2=<span class="string">"opq"</span>;</span><br><span class="line">    str.insert(str.begin()+<span class="number">3</span>,str2.begin(),str2.end());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>erase()</p></li></ul><ol><li><p>删除单个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"abcxyzefs"</span>;</span><br><span class="line">    str.erase(str.begin()+<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除一个区间内所有元素</p></li></ol><ul><li><p>str.erase(first,last) 删除[first,last)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"abcxyzefs"</span>;</span><br><span class="line">    str.erase(str.begin()+<span class="number">2</span>,str.end()<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>str.erase(pos,length) pos 为要删除的起始位置，length为删除的字符个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"abcxyzefs"</span>;</span><br><span class="line">    str.erase(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>clear() 清空string中的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"abcxyzefs"</span>;</span><br><span class="line">    str.clear();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,str.length());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>substr()<br>substr(pos,len) 返回从pos号位开始，长度为len的子串，时间复杂度为O(len)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"Thank you for your smile!"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str.substr(<span class="number">0</span>,<span class="number">5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>string::npos<br>string::npos 是一个常数，其本身值为-1，由于属于unsigned_int 类型，可认作unsigned_int类型的最大值<br>string::npos用以作为find函数失败时的的返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">string</span>::npos==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1 is true."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">string</span>::npos==<span class="number">4294967295</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"4294967295 is alse true"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>find()<br>str.find(str2),当str2是str的子串，返回其在str中第一次出现的位置；如果不是，那么返回string::npos<br>str.find(str2,pos) 从str的pos号位开始匹配str2<br>复杂度为O(mn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str= <span class="string">"Thank you for your smile"</span>;</span><br><span class="line">    <span class="built_in">string</span> str2=<span class="string">"you"</span>;</span><br><span class="line">    <span class="built_in">string</span> str3=<span class="string">"me"</span>;</span><br><span class="line">    <span class="keyword">if</span>(str.find(str2)!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;str.find(str2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str.find(str2,<span class="number">7</span>)!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;str.find(str2,<span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str.find(str3)!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;str.find(str3)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"no position for me"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>replace()<br>str.replace(pos,len,str2) 把str从pos号位开始，长度为len的子串替换为str2<br>str.replace(it1,it2,str2) 把str的迭代器[it1,it2)范围的子串替换为str2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str= <span class="string">"Thank you for your smile"</span>;</span><br><span class="line">    <span class="built_in">string</span> str2=<span class="string">"you"</span>;</span><br><span class="line">    <span class="built_in">string</span> str3=<span class="string">"me"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str.replace(<span class="number">10</span>,<span class="number">4</span>,str2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str.replace(str.begin(),str.begin()+<span class="number">5</span>,str3)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>set简简介</title>
      <link href="/%E8%AF%AD%E8%A8%80/set%E7%AE%80%E4%BB%8B/"/>
      <url>/%E8%AF%AD%E8%A8%80/set%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="set的常见用法"><a href="#set的常见用法" class="headerlink" title="set的常见用法"></a>set的常见用法</h1><p>  set指集合，是一个内部自动有序且不含重复元素的容器。</p><h3 id="1-set的定义"><a href="#1-set的定义" class="headerlink" title="1. set的定义"></a>1. set的定义</h3><p>set<typename> name;<br>set<int> name;<br>set<double> name;<br>set<char> name;<br>set<node> name;<br>set数组定义<br>set<trpename> Arrayname[arraysize];<br>set<int> a[100];<br>// a[0]~a[99]中的每一个都是一个set容器</int></trpename></node></char></double></int></typename></p><h3 id="2-set容器内元素的访问"><a href="#2-set容器内元素的访问" class="headerlink" title="2. set容器内元素的访问"></a>2. set容器内元素的访问</h3><p>set只能通过迭代器访问<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;::iterator ir;</span><br><span class="line">得到迭代器it后，可通过*it访问<span class="built_in">set</span>内的元素</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    st.insert(<span class="number">3</span>);</span><br><span class="line">    st.insert(<span class="number">4</span>);</span><br><span class="line">    st.insert(<span class="number">5</span>);</span><br><span class="line">    st.insert(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = st.begin();it!=st.end();it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="set的常用函数"><a href="#set的常用函数" class="headerlink" title="set的常用函数"></a>set的常用函数</h3><ol><li>insert()<br>insert(x)可将x插入set容器中，并自动排序和去重，时间复杂度为O(logn)</li><li><p>find()<br>find(x)返回set中对应值x的迭代器，时间复杂度为O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        st.insert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = st.find(<span class="number">2</span>);<span class="comment">///在set里查找2，返回其迭代器</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*it);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>erase()<br>两种用法： 删除单个元素</p><pre><code>删除一个区间内的所有元素</code></pre></li></ol><ul><li><p>st.erase(it), it为所需要删除元素的迭代器，时间复杂度为O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    st.insert(<span class="number">100</span>);</span><br><span class="line">    st.insert(<span class="number">200</span>);</span><br><span class="line">    st.insert(<span class="number">111</span>);</span><br><span class="line">    st.insert(<span class="number">300</span>);</span><br><span class="line">    st.insert(<span class="number">100</span>);</span><br><span class="line">    st.erase(st.find(<span class="number">100</span>));</span><br><span class="line">    st.erase(st.find(<span class="number">200</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=st.begin();it!=st.end();it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>st.erase(value) value为所要删除元素的值，时间复杂度为O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    st.insert(<span class="number">100</span>);</span><br><span class="line">    st.insert(<span class="number">200</span>);</span><br><span class="line">    st.insert(<span class="number">111</span>);</span><br><span class="line">    st.insert(<span class="number">300</span>);</span><br><span class="line">    st.insert(<span class="number">100</span>);</span><br><span class="line">    st.erase(<span class="number">111</span>);</span><br><span class="line">    st.erase(<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=st.begin();it!=st.end();it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除一个区间内的所有元素<br>st.erase(first,last) 删除[first,last),时间复杂度为O（last-first）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    st.insert(<span class="number">20</span>);</span><br><span class="line">    st.insert(<span class="number">10</span>);</span><br><span class="line">    st.insert(<span class="number">40</span>);</span><br><span class="line">    st.insert(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = st.find(<span class="number">30</span>);</span><br><span class="line">    st.erase(it,st.end());</span><br><span class="line">    <span class="keyword">for</span>(it = st.begin();it!=st.end();it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>clear()<br>clear()用来清空set中的所有元素，复杂度为O（n）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    st.insert(<span class="number">20</span>);</span><br><span class="line">    st.insert(<span class="number">10</span>);</span><br><span class="line">    st.insert(<span class="number">40</span>);</span><br><span class="line">    st.insert(<span class="number">30</span>);</span><br><span class="line">    st.clear();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,st.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set常见用途"><a href="#set常见用途" class="headerlink" title="set常见用途"></a>set常见用途</h3><p>set主要作用 为自动去重并按升序排序<br>set中元素具有唯一性，如果要处理不唯一情况，要用multiset<br>c++11标准中增加了unordered_set,以散列代替set内部的红黑树（一种自平衡二叉查找树）实现，<br>使其可以用来处理只去重但不排序的需求，速度比set快很多</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vector简介</title>
      <link href="/%E8%AF%AD%E8%A8%80/vector%E7%AE%80%E4%BB%8B/"/>
      <url>/%E8%AF%AD%E8%A8%80/vector%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="vector的常见用法"><a href="#vector的常见用法" class="headerlink" title="vector的常见用法"></a>vector的常见用法</h1><p>vector 翻译为向量，也可理解为 变长数组，即长度根据需要而自动改变的数组。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">vector</span>的定义</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; name;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; name;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; name;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; name;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; name;</span><br><span class="line">二维：</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; Arrayname[arraySize];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></p><h3 id="2-vector容器内元素访问"><a href="#2-vector容器内元素访问" class="headerlink" title="2. vector容器内元素访问"></a>2. vector容器内元素访问</h3><ul><li>通过下标访问<br>和访问普通数组一样，对一个定义为vector<typename> vi的vector容器来说，直接访问vi[index]即可。<br>这里的下标范围为0~vi.size()-1</typename></li><li>通过迭代器访问<br>迭代器（iterator）可以理解为类似一种指针的东西，其定义为：<br>vector<int>::iterator it;<br>vector<double>::iterator it;<br>这样即得到迭代器 it 通过*it访问vector里的元素<br>vector<int> vi;<br>for(int i=1;i&lt;=5;i++){<br>vi.push_back(i);<br>}<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vi.begin();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*(it+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">v[i] 等价于 *(vi.begin()+i)</span><br><span class="line">begin()  用于取vi的首元素地址</span><br><span class="line">而end() 用于取vi尾元素地址的下一个地址，即 左闭右开</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vi.begin();</span><br><span class="line">    <span class="keyword">for</span>(it = vi.begin();it!=vi.end();it++)</span><br><span class="line">    &#123;<span class="comment">///vector的迭代器不支持it&lt;vi.end(),所以只能用it!=vi.end();</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></int></double></int></li></ul><h3 id="vector常用函数"><a href="#vector常用函数" class="headerlink" title="vector常用函数"></a>vector常用函数</h3><ol><li><p>push_back() 在vector后面添加一个元素，时间复杂度为O（1）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vi.size();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,vi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>pop_back() 删除vector的尾元素，时间复杂度为O（）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vi.pop_back();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vi.size();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,vi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>size() 用来获得vector中元素的个数，时间复杂度为O（），size()返回unsigned类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,vi.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>clear() 用来清空vector中所有元素，时间复杂度为o（n）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vi.clear();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,vi.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>insert() insert(it,x)用来向vector的任意迭代器it处插入一个元素x，时间复杂度为O（n）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vi.insert(vi.begin()+<span class="number">2</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vi.size();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,vi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>erase()<br>erase() 有两种用法：删除单个元素；</p><pre><code>删除一个区间内的所有元素。时间复杂度为O（N）</code></pre></li></ol><ul><li><p>删除单个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vi.erase(vi.begin()+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vi.size();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,vi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除一个区间内的所有元素<br>erase(first,last) 即删除[first,last)内的所有元素<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vi.erase(vi.begin()+<span class="number">1</span>,vi.begin()+<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vi.size();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,vi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="vector常见用途"><a href="#vector常见用途" class="headerlink" title="vector常见用途"></a>vector常见用途</h3><ol><li><p>存储数据</p></li><li><p>用邻接表存储图</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>素数问题</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B4%A0%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B4%A0%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><p>  素数又称为质数，是指除了1和本身外，不能被其他数整除的一类数。</p><h3 id="素数判断"><a href="#素数判断" class="headerlink" title="素数判断"></a>素数判断</h3><p>直接遍历循环复杂度为O(n);<br>复杂度为O(sqrt(n))的算法;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sqr = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span>*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sqr;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简洁写法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="素数表的获取"><a href="#素数表的获取" class="headerlink" title="素数表的获取"></a>素数表的获取</h3><p>思路一： 根据判断素数的方法，直接从1~n进行枚举，若为素数则加入表中，枚举部分复杂度为O(n),判断素数部分复杂度为O(sqrt(n)),<br>所以总复杂度为O(n*sqrt(n)),该算法对于n小于10^5可以承受;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sqr = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span>*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sqr;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">101</span>],num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> p[<span class="number">101</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find_Prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">101</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isprime(i)) &#123;</span><br><span class="line">            prime[num++]=i;</span><br><span class="line">            p[i]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Find_Prime();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,prime[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路二：埃氏筛法，复杂度为O(nloglogn).<br>       欧拉筛法，复杂度为O(n).<br>素数筛法的关键在于筛字，即从小到大枚举所有数，对每一个素数，筛去它的所有倍数，剩下的均为素数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn],num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> p[maxn]=&#123;<span class="number">0</span>&#125;;<span class="comment">//如果i为素数，则p[i]为false,否则，p[i]为true</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find_Prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            prime[num++]=i;<span class="comment">//将素数i存入数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;maxn;j+=i)&#123;<span class="comment">//筛去所有i的倍数，两个循环条件均不能加=</span></span><br><span class="line">                p[j]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Find_Prime();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,prime[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>大整数运算</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="大整数运算"><a href="#大整数运算" class="headerlink" title="大整数运算"></a>大整数运算</h1><p>  大整数的含义为：用基本数据类型无法存储其精度的整数，即没有办法用已有的数据类型来表示并计算，而需要去模拟加减乘除的过程，</p><h2 id="大整数的存储"><a href="#大整数的存储" class="headerlink" title="大整数的存储"></a>大整数的存储</h2><p>  使用数组存储，即整数的高位存储在数组的高位，整数的低位存储在数组的低位。由于运算时都是从整数的低位到高位进行枚举，<br>  所以顺序存储与该思维相合。<br>  注意点：当整数按字符串%s读入时是逆位存储的，所以需要反转至另一数组。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bign</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> d[<span class="number">1000</span>];</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  bign()&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">  len = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">bign <span class="title">change</span><span class="params">(<span class="keyword">char</span> str[])</span></span>&#123;</span><br><span class="line">    bign a;</span><br><span class="line">    a.len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)&#123;</span><br><span class="line">        a.d[i]=str[a.len-i<span class="number">-1</span>]-<span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">比较两个bign变量的大小：先判断两者的len大小，如果不相等，以长的</span><br><span class="line">为大；如果相等，则从高位到低位进行比较，直到出现某一位不等，结束比较。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(bign a,bign b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.len&gt;b.len) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.len&lt;b.len) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.d[i]&gt;b.d[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a.d[i]&lt;b.d[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><p>对两个数其中的每一位进行加法的步骤：将该位上的两个数字相加，得到的结果取个位数作为该位结果，取十位数作为新的进位<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bign</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> d[<span class="number">1000</span>];</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  bign()&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">  len = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">bign <span class="title">change</span><span class="params">(<span class="keyword">char</span> str[])</span></span>&#123;</span><br><span class="line">    bign a;</span><br><span class="line">    a.len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)&#123;</span><br><span class="line">        a.d[i]=str[a.len-i<span class="number">-1</span>]-<span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">bign <span class="title">add</span><span class="params">(bign a,bign b)</span></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=a.d[i]+b.d[i]+carry;</span><br><span class="line">        c.d[c.len++]=temp%<span class="number">10</span>;</span><br><span class="line">        carry=temp/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry!=<span class="number">0</span>)&#123;</span><br><span class="line">        c.d[c.len++]=carry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(bign a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,a.d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">1000</span>],str2[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,str1,str2);</span><br><span class="line">    bign a=change(str1);</span><br><span class="line">    bign b=change(str2);</span><br><span class="line">    print(add(a,b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">上述写法两个对象都是非负整数，如果有一方是负的，可以在转换到数组这一步时</span><br><span class="line">去掉其负号，然后采用高精度减法；如果两个都是负的，就都去掉负号后采用高精度加法，最后加上负号。</span><br></pre></td></tr></table></figure></p><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><p>步骤：对每一步，比较被减位和减位，如果不够减，则令被减位的高位减1，被减位加10在进行减法；如果够减，则直接减。<br>减法后高位可能有多余的0，要除去它们，但也要保证结果至少有一位数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">sub</span><span class="params">(bign a,bign b)</span></span>&#123;</span><br><span class="line">        bign c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.d[i]&lt;b.d[i])&#123;</span><br><span class="line">                a.d[i+<span class="number">1</span>]--;</span><br><span class="line">                a.d[i]+=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            c.d[c.len++]=a.d[i]-b.d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(c.len<span class="number">-1</span>&gt;=<span class="number">1</span>&amp;&amp;c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">            c.len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="高精度与低精度的乘法"><a href="#高精度与低精度的乘法" class="headerlink" title="高精度与低精度的乘法"></a>高精度与低精度的乘法</h3><p>步骤：取bign的某位与int型整体相乘，再与进位相加，所得结果的个位数作为该位结果，高位作为新的进位。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">multi</span><span class="params">(bign a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=a.d[i]*b+carry;</span><br><span class="line">        c.d[c.len++]=temp%<span class="number">10</span>;</span><br><span class="line">        carry=temp/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(carry!=<span class="number">0</span>)&#123;</span><br><span class="line">        c.d[c.len++]=carry%<span class="number">10</span>;</span><br><span class="line">        carry/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="高精度与低精度的除法"><a href="#高精度与低精度的除法" class="headerlink" title="高精度与低精度的除法"></a>高精度与低精度的除法</h3><p>步骤：上一步的余数乘以10加上该步的位，得到该步临时的被除数，将其与除数比较：如果不够除，则该位的商为0；如果够除，<br>则商即为对应的商，余数即为对应的余数。最后一步要注意高位可能有多余的0，要去除它们，但也要保证结果至少有一位数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">divide</span><span class="params">(bign a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;r)</span></span>&#123;<span class="comment">//r为余数</span></span><br><span class="line">    bign c;</span><br><span class="line">    c.len=a.len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        r=r*<span class="number">10</span>+a.d[i];</span><br><span class="line">        <span class="keyword">if</span>(r&lt;b) c.d[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            c.d[i]=r/b;</span><br><span class="line">            r=r%b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.len=<span class="number">1</span>&gt;=<span class="number">1</span>&amp;&amp;c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">        c.len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>模式匹配</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h2><p>1、 BF算法是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串P的第一个字符进行匹配，若相等，则继续比较S的第二个字符和P的第二个字符；若不相等，则比较S的第二个字符和P的第一个字符，其实相当于将整个模式串往后移了一位，依次比较下去，直到得出最后的匹配结果。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BF_Find</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="built_in">string</span>&amp; t)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,count=<span class="number">0</span>;<span class="comment">//初始化  </span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;s.size())  <span class="comment">//未比较到串尾  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(s.at(i)==t.at(j)) <span class="comment">//继续比较后续字符  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">            count++;&#125;  </span><br><span class="line">       <span class="keyword">else</span>   <span class="comment">//指针后退重新匹配  </span></span><br><span class="line">       &#123;  </span><br><span class="line">           i=i-j+<span class="number">1</span>;  </span><br><span class="line">           j=<span class="number">0</span>;  </span><br><span class="line">           count=<span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(count==t.size())  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"BF算法模式匹配成功,起始位置是:"</span>&lt;&lt;i-count+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">            <span class="keyword">return</span> (i-count+<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"字符串匹配失败!"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>2、KMP算法与BF算法的区别就在于KMP算法巧妙的消除了指针i的回溯问题，只需确定下次匹配j的位置即可，使得问题的复杂度由O(mn)下降到O(m+n)。</p><p>在KMP算法中，为了确定在匹配不成功时，下次匹配时j的位置，引入了next[]数组，next[j]的值表示P[1…j-1]中最长的后缀等于相同字符序列的前缀的长度。</p><p>　 对于next[]数组的定义如下：</p><p>   （1) next[j] = 0（ j = 1）（t1与Si比较不相等时，下一步进行t1与Si+1的比较）</p><p>　 （2) next[j] = max(k)（1&lt;k&lt;j且 P[1…k-1]=P[j-k+1,j-1]）</p><p>{设next[j]=k;(1&lt;k&lt;j)</p><p>若tk=tj 则next[j+1]=k+1;即next[j+1]=next[j]+1;</p><p>若tk!=tj 则next[j+1]=next[k]+1;               </p><p>}</p><p>　 （3) next[j] = 1  (k=1)(不存在相同子串，下一步进行t1与si的比较)</p><p>因此KMP算法的思想就是：在匹配过程称，若发生不匹配的情况，则目标串的指针i不变，将模式串的指针j移动到next[j]的位置继续进行匹配；当指针j退至0时，指针i和指针j需同时增加1。也就是说，当发生不匹配的情况，让模式串继续往后移，而移动的位数就是模式串的长度-部分匹配值（最长相同前后缀的长度），因为BF里面每次指针i回溯，会导致符合匹配的字符再一次匹配，增大了时间开销。</p><p>求next数组是难点，一般有递推法（用一个while循环）和直接法两种。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BF_Find</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="built_in">string</span>&amp; t)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,count=<span class="number">0</span>;<span class="comment">//初始化  </span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;s.size())  <span class="comment">//未比较到串尾  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(s.at(i)==t.at(j)) <span class="comment">//继续比较后续字符  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">            count++;&#125;  </span><br><span class="line">       <span class="keyword">else</span>   <span class="comment">//指针后退重新匹配  </span></span><br><span class="line">       &#123;  </span><br><span class="line">           i=i-j+<span class="number">1</span>;  </span><br><span class="line">           j=<span class="number">0</span>;  </span><br><span class="line">           count=<span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(count==t.size())  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"BF算法模式匹配成功,起始位置是:"</span>&lt;&lt;i-count+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">            <span class="keyword">return</span> (i-count+<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"字符串匹配失败!"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="keyword">int</span> *next)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> len = s.size();  </span><br><span class="line">     next[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">     next[<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">1</span>;  </span><br><span class="line">     <span class="keyword">while</span>(i &lt; len - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">            <span class="keyword">int</span> j = next[i];  </span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s.at(j) != s.at(i)) j = next[j];  </span><br><span class="line">            <span class="keyword">if</span>(s.at(j) == s.at(i))  next[i + <span class="number">1</span>] = j + <span class="number">1</span>;<span class="comment">//根据next的定义推导出公式  </span></span><br><span class="line">            <span class="keyword">else</span> next[i + <span class="number">1</span>] = j;  </span><br><span class="line">            i++;  </span><br><span class="line">      &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getnextval</span><span class="params">(<span class="built_in">string</span> &amp; s,<span class="keyword">int</span> *next)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;  </span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> len=s.size();  </span><br><span class="line">    <span class="keyword">while</span>(i&lt;len)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||s.at(i)==s.at(j))&#123;  </span><br><span class="line">            ++i;++j;  </span><br><span class="line">            <span class="keyword">if</span> (s.at(i)!=s.at(j)) next[i]=j;  </span><br><span class="line">            <span class="keyword">else</span> next[i]=next[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> j=next[j];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP_Find</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="built_in">string</span>&amp;t)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"> <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;  </span><br><span class="line"> <span class="keyword">int</span> n =t.size();  </span><br><span class="line"> <span class="keyword">int</span> *next = <span class="keyword">new</span> <span class="keyword">int</span>[n];  </span><br><span class="line"> GetNext(t,next);  </span><br><span class="line"> <span class="keyword">while</span>(i&lt;s.size()&amp;&amp;j&lt;t.size()) <span class="comment">//两个串均未比较到串尾  </span></span><br><span class="line">  &#123;  </span><br><span class="line">     <span class="keyword">if</span>((j == <span class="number">0</span>)||(s.at(i)==t.at(j))) <span class="comment">//继续比较后续字符  </span></span><br><span class="line">              &#123;  </span><br><span class="line">                  i++;  </span><br><span class="line">                  j++;  </span><br><span class="line">              &#125;  </span><br><span class="line">              <span class="keyword">else</span>  </span><br><span class="line">              &#123;  </span><br><span class="line">                  j = next[j];<span class="comment">//模式串后移  </span></span><br><span class="line">              &#125;  </span><br><span class="line">   &#125; <span class="keyword">if</span>(j==t.size())  </span><br><span class="line">  &#123;  </span><br><span class="line">   <span class="keyword">int</span> index=i-t.size()+<span class="number">1</span>;  </span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"KMP算法：子串从长串的第"</span>&lt;&lt;index&lt;&lt;<span class="string">"位开始匹配成功!"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">   <span class="keyword">return</span> index;  </span><br><span class="line">  &#125;  </span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"字符串匹配失败!"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">string</span> str1,str2;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入主串:"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str1;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入子串:"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str2;  </span><br><span class="line">    KMP_Find(str1,str2);  </span><br><span class="line">    BF_Find(str1,str2);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>My movie list of 2017</title>
      <link href="/%E5%BD%B1%E9%9F%B3/My-movie-list-of-2017/"/>
      <url>/%E5%BD%B1%E9%9F%B3/My-movie-list-of-2017/</url>
      
        <content type="html"><![CDATA[<h1 id="17年看过的几部不错的电影"><a href="#17年看过的几部不错的电影" class="headerlink" title="17年看过的几部不错的电影"></a>17年看过的几部不错的电影</h1><blockquote class="blockquote-center"><ol><li>《肖申克的救赎》</li><li>《海边的曼彻斯特》</li><li>《梦与狂想的王国》</li><li>《辛德勒的名单》</li><li>《至爱梵高》</li><li>《熔炉》</li><li>《窃听风暴》</li><li>《美丽心灵》</li><li>《v字仇杀队》</li><li>《忠犬八公的故事》</li><li>《春光乍泄》</li><li>《钢琴家》</li><li>《阿甘正传》</li><li>《霸王别姬》</li><li>《沉默的羔羊系列》</li><li>《蝴蝶效应系列》</li><li>《杀人游戏》</li><li>《海洋》</li><li>《千钧一发》</li><li>《源代码》</li><li>《超脱》</li><li>《猫鼠游戏》</li><li>《心迷宫》</li><li>《寻梦环游记》</li><li>《猫妖记》</li><li>《芳华》</li><li>《奇幻森林》</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 影音 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>八大排序</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<ol><li>插入排序（直接插入排序、希尔排序）</li><li>交换排序（冒泡排序、快速排序）</li><li>选择排序（直接选择排序、堆排序）</li><li>归并排序</li><li>分配排序（基数排序）<br>所需辅助空间最多：归并排序<br>所需辅助空间最少：堆排序<br>平均速度最快：快速排序<br>不稳定：快速排序、希尔排序、堆排序<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3>基本思想：在要排序的一组数中，假设前面（n-1）个数已经有序，现在要把第n个数插到前面的有序数中，<br>使得这n个数也是有序的。如此反复循环，直到全部有序。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">     <span class="keyword">int</span> j=i-<span class="number">1</span>;</span><br><span class="line">     temp=a[i];</span><br><span class="line">     <span class="keyword">for</span>(;j&gt;=<span class="number">0</span>&amp;&amp;temp&lt;a[j];j--)&#123;</span><br><span class="line">       a[j+<span class="number">1</span>]=a[j];<span class="comment">//将大于temp的值整体后移一位</span></span><br><span class="line">     &#125;</span><br><span class="line">     a[j+<span class="number">1</span>]=temp;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">     System.out.println(a[i]);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h4><ul><li><p>最佳情况：O(n)</p></li><li><p>最坏情况：O(n^2)</p></li><li><p>平均时间复杂度：O(n^2)</p></li><li><p>空间复杂度：O(1)</p></li><li><p>稳定排序算法</p></li></ul><h3 id="希尔排序（最小增量排序）"><a href="#希尔排序（最小增量排序）" class="headerlink" title="希尔排序（最小增量排序）"></a>希尔排序（最小增量排序）</h3><p>基本思想：先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d。<br>对每组中全部元素进行直接插入排序，然后再用一个较小的增量对它进行分组，在每组中再进行直接插入排序。<br>当增量减到1，进行直接插入排序后，排序完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellFort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">double</span> d1=a.length;</span><br><span class="line">   <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">     d1=Math.ceil(d1/<span class="number">2</span>);</span><br><span class="line">     <span class="keyword">int</span> d = (<span class="keyword">int</span>) d1;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;d;x++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=x+d;i&lt;a.length;i+=d)&#123;</span><br><span class="line">         <span class="keyword">int</span> j=i-d;</span><br><span class="line">         temp=a[i];</span><br><span class="line">         <span class="keyword">for</span>(;j&gt;=<span class="number">0</span>&amp;&amp;temp&lt;a[j];j-=d)&#123;</span><br><span class="line">           a[j+d]=a[j];</span><br><span class="line">         &#125;</span><br><span class="line">         a[j+d]=temp;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(d==<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li><p>最佳情况：O(nlogn)</p></li><li><p>最坏情况：O(nlogn)</p></li><li><p>平均时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(1)</p></li><li><p>不稳定排序算法</p></li></ul><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；<br>然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> position=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> j=i+<span class="number">1</span>;</span><br><span class="line">    position=i;</span><br><span class="line">    <span class="keyword">int</span> temp=a[i];</span><br><span class="line">    <span class="keyword">for</span>(;j&lt;a.length;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j]&lt;temp)&#123;</span><br><span class="line">        temp=a[j];</span><br><span class="line">        position=j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[position]=a[i];</span><br><span class="line">    a[i]=temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li><p>最佳情况：O(n^2)</p></li><li><p>最差情况：O(n^2)</p></li><li><p>平均时间复杂度：O(n^2)</p></li><li><p>空间复杂度：O(1)</p></li><li><p>不稳定排序算法</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>基本思想：堆排序是一种树形选择排序，是对直接选择排序的优化。<br>堆的定义：具有n个元素的序列（h1,h2…hn）,当且仅当满足(hi&gt;=h2i,hi&gt;=2i+1)或(hi&lt;=h2i,hi&lt;=2i+1)(i=1,2,….,n/2)时称为堆。<br>堆顶元素（即第一个元素）必为最大项（大顶堆）。<br>完全二叉树可以很直观地表示堆的结构。</p></li></ul><p>堆排序需要两个过程</p><ol><li>建堆</li><li>堆顶与堆的最后一个元素交换位置<br>这就对应了堆排序的两个函数</li><li>建堆</li><li>交换，从堆中踢出最大数</li><li>剩余结点再建堆，再交换踢出最大数</li><li>以此类推：最后堆中剩余的最后两个结点交换，踢出一个，排序完成。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] data,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=data[i];</span><br><span class="line">    data[i]=data[j];</span><br><span class="line">    data[j]=tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] data,<span class="keyword">int</span> lastIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(lastIndex-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      <span class="keyword">int</span> k=i;</span><br><span class="line">      <span class="keyword">while</span>(k*<span class="number">2</span>+<span class="number">1</span>&lt;=lastIndex)&#123;</span><br><span class="line">        <span class="keyword">int</span> biggerIndex=<span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(biggerIndex&lt;lastIndex)&#123;</span><br><span class="line">          <span class="keyword">if</span>(data[biggerIndex]&lt;data[biggerIndex+<span class="number">1</span>])&#123;</span><br><span class="line">            biggerIndex++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data[k]&lt;data[biggerIndex])&#123;</span><br><span class="line">          swap(data,k,biggerIndex);</span><br><span class="line">          k=biggerIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"开始排序"</span>);</span><br><span class="line">    <span class="keyword">int</span> arrayLength=a.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arrayLength-<span class="number">1</span>;i++)&#123;</span><br><span class="line">      buildMaxHeap(a,arrayLength-<span class="number">1</span>-i);</span><br><span class="line">      swap(a,<span class="number">0</span>,arrayLength-<span class="number">1</span>-i);</span><br><span class="line">      System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>&#125;;</span><br><span class="line">  </span><br><span class="line">    heapSort(a);</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li><p>最佳情况：O(nlogn)</p></li><li><p>最坏情况：O(nlogn)</p></li><li><p>平均时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(1)</p></li><li><p>不稳定排序算法</p></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>基本思想：在要排序的一组数中。对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，<br>让较大的数往下沉，较小的往上冒。<br>即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">        temp=a[j];</span><br><span class="line">        a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>]=temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">  System.out.println(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li><p>最佳情况：O(n) </p></li><li><p>最差情况：O(n^2)</p></li><li><p>平均时间复杂度：O(n^2)</p></li><li><p>空间复杂度为O(1)</p></li><li><p>稳定排序算法</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>基本思想：选择一个基准元素，通常选择第一个元素或者最后一个元素，<br>通过一趟扫描，将待排序序列分成两部分，一部分比基准元素小，一部分大于等于基准元素，<br>此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMiddle</span><span class="params">(<span class="keyword">int</span>[] list,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=list[low];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">      <span class="keyword">while</span>(low&lt;high&amp;&amp;list[high]&gt;=tmp)&#123;</span><br><span class="line">        high--;</span><br><span class="line">      &#125;</span><br><span class="line">      list[low]=list[high];</span><br><span class="line">      <span class="keyword">while</span>(low&lt;high&amp;&amp;list[low]&lt;=tmp)&#123;</span><br><span class="line">        low++;</span><br><span class="line">      &#125;</span><br><span class="line">      list[high]=list[low];</span><br><span class="line">    &#125;</span><br><span class="line">    list[low]=tmp;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] list, <span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">      <span class="keyword">int</span> middle=getMiddle(list, low, high);</span><br><span class="line">      quickSort(list,low,middle-<span class="number">1</span>);</span><br><span class="line">      quickSort(list,middle+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] a2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a2.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      quickSort(a2,<span class="number">0</span>,a2.length-<span class="number">1</span>);;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>&#125;;</span><br><span class="line">    </span><br><span class="line">     quick(a);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">       System.out.println(a[i]);</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a>算法分析：</h4><ul><li><p>最佳情况：O(nlogn)</p></li><li><p>最坏情况：O(n^2)</p></li><li><p>平均时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(nlogn)</p></li><li><p>不稳定排序算法</p></li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>基本思想：归并排序法是将两个（或两个以上）有序表合并成一个新的有序表，<br>即把待排序序列分为若干个子序列，每个子序列是有序的。然后把子序列合并成整体有序序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">      <span class="keyword">int</span> center=(left+right)/<span class="number">2</span>;</span><br><span class="line">      sort(data,left,center);</span><br><span class="line">      sort(data, center+<span class="number">1</span>, right);</span><br><span class="line">      merge(data,left,center,right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] data,<span class="keyword">int</span> left,<span class="keyword">int</span> center,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [] tmpArr=<span class="keyword">new</span> <span class="keyword">int</span>[data.length];</span><br><span class="line">    <span class="keyword">int</span> mid=center+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> third=left;</span><br><span class="line">    <span class="keyword">int</span> tmp=left;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=center&amp;&amp;mid&lt;=right)&#123;</span><br><span class="line">      <span class="keyword">if</span>(data[left]&lt;=data[mid])&#123;</span><br><span class="line">        tmpArr[third++]=data[left++];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        tmpArr[third++]=data[mid++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(mid&lt;=right)&#123;</span><br><span class="line">      tmpArr[third++]=data[mid++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=center)&#123;</span><br><span class="line">      tmpArr[third++]=data[left++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tmp&lt;=right)&#123;</span><br><span class="line">      data[tmp]=tmpArr[tmp++];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(data));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>&#125;;</span><br><span class="line">    sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li><p>最佳情况：O(n)</p></li><li><p>最坏情况：O(nlogn)</p></li><li><p>平均时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(n)</p></li><li><p>稳定排序算法</p></li></ul><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基本思想：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>&#125;;</span><br><span class="line">   sort(a);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">     System.out.println(a[i]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max=array[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array[i]&gt;max)&#123;</span><br><span class="line">      max=array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> time=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(max&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    max/=<span class="number">10</span>;</span><br><span class="line">    time++;</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;ArrayList&gt;queue=<span class="keyword">new</span> ArrayList&lt;ArrayList&gt;();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt;queue1=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    queue.add(queue1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;time;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;array.length;j++)&#123;</span><br><span class="line">      <span class="keyword">int</span> x= array[j]%(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i+<span class="number">1</span>)/(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i);</span><br><span class="line">      ArrayList&lt;Integer&gt;queue2=queue.get(x);</span><br><span class="line">      queue2.add(array[j]);</span><br><span class="line">      queue.set(x,queue2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">      <span class="keyword">while</span>(queue.get(k).size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt;queue3=queue.get(k);</span><br><span class="line">        array[count]=queue3.get(<span class="number">0</span>);</span><br><span class="line">        queue3.remove(<span class="number">0</span>);</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a>算法分析：</h4><ul><li><p>最佳情况：O(n*k)</p></li><li><p>最坏情况：O(n*k)</p></li><li><p>平均时间复杂度：O(n*k)</p></li><li><p>空间复杂度：O(n)</p></li><li><p>稳定排序算法</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>洛神赋</title>
      <link href="/%E9%98%85%E8%AF%BB/%E6%B4%9B%E7%A5%9E%E8%B5%8B/"/>
      <url>/%E9%98%85%E8%AF%BB/%E6%B4%9B%E7%A5%9E%E8%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="洛神赋"><a href="#洛神赋" class="headerlink" title="洛神赋"></a>洛神赋</h1><p>　　　　　　　【作者】曹植 【朝代】魏晋<br>黄初三年，余朝京师，还济洛川。古人有言，斯水之神，名曰宓妃。感宋玉对楚王神女之事，遂作斯赋。其辞曰：</p><p>余从京域，言归东藩。背伊阙，越轘辕，经通谷，陵景山。日既西倾，车殆马烦。尔乃税驾乎蘅皋，秣驷乎芝田，容与乎阳林，流眄乎洛川。于是精移神骇，忽焉思散。俯则末察，仰以殊观，睹一丽人，于岩之畔。乃援御者而告之曰：“尔有觌于彼者乎？彼何人斯？若此之艳也！”御者对曰：“臣闻河洛之神，名曰宓妃。然则君王所见，无乃日乎？其状若何？臣愿闻之。”</p><p>余告之曰：“其形也，翩若惊鸿，婉若游龙。荣曜秋菊，华茂春松。仿佛兮若轻云之蔽月，飘摇兮若流风之回雪。远而望之，皎若太阳升朝霞；迫而察之，灼若芙蕖出渌波。秾纤得衷，修短合度。肩若削成，腰如约素。延颈秀项，皓质呈露。芳泽无加，铅华弗御。云髻峨峨，修眉联娟。丹唇外朗，皓齿内鲜，明眸善睐，靥辅承权。瑰姿艳逸，仪静体闲。柔情绰态，媚于语言。奇服旷世，骨像应图。披罗衣之璀粲兮，珥瑶碧之华琚。戴金翠之首饰，缀明珠以耀躯。践远游之文履，曳雾绡之轻裾。微幽兰之芳蔼兮，步踟蹰于山隅。</p><p>于是忽焉纵体，以遨以嬉。左倚采旄，右荫桂旗。壤皓腕于神浒兮，采湍濑之玄芝。余情悦其淑美兮，心振荡而不怡。无良媒以接欢兮，托微波而通辞。愿诚素之先达兮，解玉佩以要之。嗟佳人之信修，羌习礼而明诗。抗琼［王弟］以和予兮，指潜渊而为期。执眷眷之款实兮，惧斯灵之我欺。感交甫之弃言兮，怅犹豫而狐疑。收和颜而静志兮，申礼防以自持。</p><p>于是洛灵感焉，徙倚彷徨，神光离合，乍阴乍阳。竦轻躯以鹤立，若将飞而未翔。践椒涂之郁烈，步蘅薄而流芳。超长吟以永慕兮，声哀厉而弥长。</p><p>尔乃众灵杂遢，命俦啸侣，或戏清流，或翔神渚，或采明珠，或拾翠羽。从南湘之二妃，携汉滨之游女。叹匏瓜之无匹兮，咏牵牛之独处。扬轻袿之猗靡兮，翳修袖以延伫。体迅飞凫，飘忽若神，凌波微步，罗袜生尘。动无常则，若危若安。进止难期，若往若还。转眄流精，光润玉颜。含辞未吐，气若幽兰。华容婀娜，令我忘餐。</p><p>于是屏翳收风，川后静波。冯夷鸣鼓，女娲清歌。腾文鱼以警乘，鸣玉鸾以偕逝。六龙俨其齐首，载云车之容裔，鲸鲵踊而夹毂，水禽翔而为卫。</p><p>于是越北沚。过南冈，纡素领，回清阳，动朱唇以徐言，陈交接之大纲。恨人神之道殊兮，怨盛年之莫当。抗罗袂以掩涕兮，泪流襟之浪浪。悼良会之永绝兮。哀一逝而异乡。无微情以效爱兮，献江南之明。虽潜处于太阳，长寄心于君王。忽不悟其所舍，怅神宵而蔽光。</p><p>于是背下陵高，足往神留，遗情想像，顾望怀愁。冀灵体之复形，御轻舟而上溯。浮长川而忘返，思绵绵督。夜耿耿而不寐，沾繁霜而至曙。命仆夫而就驾，吾将归乎东路。揽騑辔以抗策，怅盘桓而不能去。</p><p>备注：赋，是我国古代的一种文体，它讲究文采，韵律，兼具诗歌和散文性质。是以“铺采摛文，体物写志”为手段，侧重于写景，借景抒情。以“颂美”和“讽喻”为目的的一种有韵文体。它多用铺陈叙事的手法，赋必须押韵，这是赋区别于其他文体的一个主要特征。 起于战国，盛于两汉。赋最早出现于诸子散文中，叫”短赋“；以屈原为代表的”骚体“是诗向赋的过渡，叫”骚赋“；汉代正式确立了赋的体例，称为“辞赋”；魏晋以后，赋日益向骈文方向发展，叫做“骈赋”；唐代又由骈体转为律体，叫“律赋”；宋代用散文的形式写赋，称“文赋”。著名的赋体文章有司马相如的《子虚赋》，杜牧的《阿房宫赋》，欧阳修的《秋声赋》，苏轼的《赤壁赋》等。<br>作者曹植以浪漫主义的手法，通过梦幻的境界，描写人神之间的真挚爱情，但终因“人神殊道”无从结合而惆怅分离。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>长恨歌</title>
      <link href="/%E9%98%85%E8%AF%BB/%E9%95%BF%E6%81%A8%E6%AD%8C/"/>
      <url>/%E9%98%85%E8%AF%BB/%E9%95%BF%E6%81%A8%E6%AD%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="长恨歌"><a href="#长恨歌" class="headerlink" title="　　　　　长恨歌"></a>　　　　　长恨歌</h1><blockquote class="blockquote-center"><p>　　　　　　　　　　　　　　　　　　【唐】　白居易<br>　　　　　　　　　　汉皇重色思倾国，御宇多年求不得。</p><p>　　　　　　　　　　杨家有女初长成，养在深闺人未识。</p><p>　　　　　　　　　　天生丽质难自弃，一朝选在君王侧。</p><p>　　　　　　　　　　回眸一笑百媚生，六宫粉黛无颜色。</p><p>　　　　　　　　　　春寒赐浴华清池，温泉水滑洗凝脂。</p><p>　　　　　　　　　　侍儿扶起娇无力，始是新承恩泽时。</p><p>　　　　　　　　　　云鬓花颜金步摇，芙蓉帐暖度春宵。</p><p>　　　　　　　　　　春宵苦短日高起，从此君王不早朝。</p><p>　　　　　　　　　　承欢侍宴无闲暇，春从春游夜专夜。</p><p>　　　　　　　　　　后宫佳丽三千人，三千宠爱在一身。</p><p>　　　　　　　　　　金屋妆成娇侍夜，玉楼宴罢醉和春。</p><p>　　　　　　　　　　姊妹弟兄皆列土，可怜光彩生门户。</p><p>　　　　　　　　　　遂令天下父母心，不重生男重生女。</p><p>　　　　　　　　　　骊宫高处入青云，仙乐风飘处处闻。</p><p>　　　　　　　　　　缓歌谩舞凝丝竹，尽日君王看不足。</p><p>　　　　　　　　　　渔阳鼙鼓动地来，惊破霓裳羽衣曲。</p><p>　　　　　　　　　　九重城阙烟尘生，千乘万骑西南行。</p><p>　　　　　　　　　　翠华摇摇行复止，西出都门百余里。</p><p>　　　　　　　　　　六军不发无奈何，宛转蛾眉马前死。</p><p>　　　　　　　　　　花钿委地无人收，翠翘金雀玉搔头。</p><p>　　　　　　　　　　君王掩面救不得，回看血泪相和流。</p><p>　　　　　　　　　　黄埃散漫风萧索，云栈萦纡登剑阁。</p><p>　　　　　　　　　　峨嵋山下少人行，旌旗无光日色薄。</p><p>　　　　　　　　　　蜀江水碧蜀山青，圣主朝朝暮暮情。</p><p>　　　　　　　　　　行宫见月伤心色，夜雨闻铃肠断声。</p><p>　　　　　　　　　　天旋地转回龙驭，到此踌躇不能去。</p><p>　　　　　　　　　　马嵬坡下泥土中，不见玉颜空死处。</p><p>　　　　　　　　　　君臣相顾尽沾衣，东望都门信马归。</p><p>　　　　　　　　　　归来池苑皆依旧，太液芙蓉未央柳。</p><p>　　　　　　　　　　芙蓉如面柳如眉，对此如何不泪垂。</p><p>　　　　　　　　　　春风桃李花开日，秋雨梧桐叶落时。</p><p>　　　　　　　　　　西宫南内多秋草，落叶满阶红不扫。</p><p>　　　　　　　　　　梨园弟子白发新，椒房阿监青娥老。</p><p>　　　　　　　　　　夕殿萤飞思悄然，孤灯挑尽未成眠。</p><p>　　　　　　　　　　迟迟钟鼓初长夜，耿耿星河欲曙天。</p><p>　　　　　　　　　　鸳鸯瓦冷霜华重，翡翠衾寒谁与共。</p><p>　　　　　　　　　　悠悠生死别经年，魂魄不曾来入梦。</p><p>　　　　　　　　　　临邛道士鸿都客，能以精诚致魂魄。</p><p>　　　　　　　　　　为感君王辗转思，遂教方士殷勤觅。</p><p>　　　　　　　　　　排空驭气奔如电，升天入地求之遍。</p><p>　　　　　　　　　　上穷碧落下黄泉，两处茫茫皆不见。</p><p>　　　　　　　　　　忽闻海上有仙山，山在虚无缥渺间。</p><p>　　　　　　　　　　楼阁玲珑五云起，其中绰约多仙子。</p><p>　　　　　　　　　　中有一人字太真，雪肤花貌参差是。</p><p>　　　　　　　　　　金阙西厢叩玉扃，转教小玉报双成。</p><p>　　　　　　　　　　闻道汉家天子使，九华帐里梦魂惊。</p><p>　　　　　　　　　　揽衣推枕起徘徊，珠箔银屏迤逦开。</p><p>　　　　　　　　　　云鬓半偏新睡觉，花冠不整下堂来。</p><p>　　　　　　　　　　风吹仙袂飘飘举，犹似霓裳羽衣舞。</p><p>　　　　　　　　　　玉容寂寞泪阑干，梨花一枝春带雨。</p><p>　　　　　　　　　　含情凝睇谢君王，一别音容两渺茫。</p><p>　　　　　　　　　　昭阳殿里恩爱绝，蓬莱宫中日月长。</p><p>　　　　　　　　　　回头下望人寰处，不见长安见尘雾。</p><p>　　　　　　　　　　惟将旧物表深情，钿合金钗寄将去。</p><p>　　　　　　　　　　钗留一股合一扇，钗擘黄金合分钿。</p><p>　　　　　　　　　　但教心似金钿坚，天上人间会相见。</p><p>　　　　　　　　　　临别殷勤重寄词，词中有誓两心知。</p><p>　　　　　　　　　　七月七日长生殿，夜半无人私语时。</p><p>　　　　　　　　　　在天愿作比翼鸟，在地愿为连理枝。</p><p>　　　　　　　　　　天长地久有时尽，此恨绵绵无绝期。　　　　　　　　　　</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>好了歌</title>
      <link href="/%E9%98%85%E8%AF%BB/%E5%A5%BD%E4%BA%86%E6%AD%8C/"/>
      <url>/%E9%98%85%E8%AF%BB/%E5%A5%BD%E4%BA%86%E6%AD%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="红楼梦原文"><a href="#红楼梦原文" class="headerlink" title="红楼梦原文"></a>红楼梦原文</h1><p>甄士隐知投人不著，心中未免悔恨，再兼上年惊唬，急忿怨痛已伤，暮年之人，贫病交攻，竟渐渐的露出那下世的光景来。可巧这日拄了拐杖挣到街前散散心时，忽见那边来了一个跛足道人，疯癫落拓，麻鞋鹑衣，口内念着几句言词道：<br><blockquote class="blockquote-center"><p>世人都晓神仙好，惟有功名忘不了！<br>古今将相在何方？荒冢一堆草没了。<br>世人都晓神仙好，只有金银忘不了！<br>终朝只恨聚无多，及到多时眼闭了。<br>世人都晓神仙好，只有娇妻忘不了！<br>君生日日说恩情，君死又随人去了。<br>世人都晓神仙好，只有儿孙忘不了！<br>痴心父母古来多，孝顺儿孙谁见了？</p></blockquote></p><p>士隐听了，便迎上来道：“你满口说些甚么？只听见些‘好了’‘好了’。”那道人笑道：“你若果听见‘好了’二字，还算你明白。可知世上万般，好便是了，了便是好。若不了，便不好；若要好，须是了。我这歌儿便名《好了歌》。”士隐本是有夙慧的，一闻此言，心中早已彻悟，因笑道：“且住！待我将你这《好了歌》注解出来何如？”道人笑道：“你就请解。”士隐乃说道：<br><blockquote class="blockquote-center"><p>陋室空堂，当年笏满床。<br>衰草枯杨，曾为歌舞场。<br>蛛丝儿结满雕梁，绿纱今又糊在蓬窗上。<br>说甚么脂正浓、粉正香，如何两鬓又成霜？<br>昨日黄土陇头送白骨，今宵红灯帐底卧鸳鸯。<br>金满箱，银满箱，展眼乞丐人皆谤。<br>正叹他人命不长，那知自己归来丧！<br>训有方，保不定日后作强梁。<br>择膏粱，谁承望流落在烟花巷！<br>因嫌纱帽小，致使锁枷杠，<br>昨怜破袄寒，今嫌紫蟒长。<br>乱烘烘你方唱罢我登场，反认他乡是故乡。<br>甚荒唐，到头来都是为他人作嫁衣裳。</p></blockquote></p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>归并排序</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>  最基本的2-路归并排序。<br>  原理：将序列两两分组，将序列归并为[n/2]个组，组内单独排序；然后将这些组再两两归并，<br>  生成[n/4]个组，组内在单独排序；以此内推，直到只剩下一个组为止。<br>  时间复杂度为O(nlogn)<br>例：将序列{66,12,33,57,64,27,18}进行2路归并排序</p><ol><li><p>第一趟</p>{ { 12,66 },{ 33,57 },{ 27,64 },{ 18 } }</li><li><p>第二题</p>{ { 12,33,57,66 },{ 18,27,64 } }</li><li><p>第三趟{12,18,27,33,57,64,66}</p></li></ol><ul><li><p>递归实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l1,<span class="keyword">int</span> r1,<span class="keyword">int</span> l2,<span class="keyword">int</span> r2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=l1,j=l2;</span><br><span class="line">    <span class="keyword">int</span> temp[maxn],index=<span class="number">0</span>;<span class="comment">//temp临时存放合并后的数组，index为其下标</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=r1&amp;&amp;j&lt;=r2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])&#123;</span><br><span class="line">            temp[index++]=a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp[index++]=a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=r1) temp[index++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r2) temp[index++]=a[j++];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">        a[l1+i]=temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    mergeSort(a,left,mid); <span class="comment">//左子区间归并排序</span></span><br><span class="line">    mergeSort(a,mid+<span class="number">1</span>,right);<span class="comment">//右子区间归并排序</span></span><br><span class="line">    merge(a,left,mid,mid+<span class="number">1</span>,right); 将左右子区间合并</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非递归实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">2</span>;step/<span class="number">2</span>&lt;=n;step*=<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i+=step)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=i+step/<span class="number">2</span><span class="number">-1</span>;  </span><br><span class="line">        <span class="keyword">if</span>(mid+<span class="number">1</span>&lt;=n)&#123;     <span class="comment">//sort(a+i,a+min(i+step,n+1));</span></span><br><span class="line">            merge(a,i,mid,mid+<span class="number">1</span>,min(i+step<span class="number">-1</span>,n))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>区间贪心</title>
      <link href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83/"/>
      <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>  贪心是用来解决一类最优化问题，并希望由局部最优策略来推得全局最优结果的算法思想。<br>  贪心算法使用的问题一定满足最优子结构性质，即一个问题的最优解可以由它的子问题的最优解有效地构造出来。</p><h2 id="区间不相交问题："><a href="#区间不相交问题：" class="headerlink" title="区间不相交问题："></a>区间不相交问题：</h2><p>  给出n个开区间(x,y),从中选择尽可能多的区间，使得这些开区间两两没有交集。<br>  首先考虑最简单的情况，即开区间I1被开区间I2包含，那么I1显然是最好的选择，因为这样就有更大的空间去容纳其他区间。<br>  之后将所有开区间按左端点x从大到小排序，总是先选择左端点最大的区间。当然也可以考虑选择右端点最小的区间。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">110</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inteval</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Inteval a,Inteval b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a.x!=b.x) <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n),n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;q[i].x,&amp;q[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(q,q+n,cmp);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>,lastx = q[<span class="number">0</span>].x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i].y&lt;=lastx)&#123;</span><br><span class="line">                lastx=q[i].x;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="区间选点问题："><a href="#区间选点问题：" class="headerlink" title="区间选点问题："></a>区间选点问题：</h2><p>  给出n个闭区间[x,y],求最少需要确定多少个点，才能使每个闭区间中都至少存在一个点。</p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ZCMU2034</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/ZCMU-2034/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/ZCMU-2034/</url>
      
        <content type="html"><![CDATA[<h1 id="阶乘计算"><a href="#阶乘计算" class="headerlink" title="阶乘计算"></a>阶乘计算</h1><p>Time Limit: 1 Sec  Memory Limit: 128 MB<br>Submit: 43  Solved: 34<br>[Submit][Status][Web Board]<br>Description<br>输入一个正整数n，输出n!的值。<br>其中n!=1<em> 2 </em> 3 <em>…</em>n。<br>算法描述<br>n!可能很大，而计算机能表示的整数范围有限，需要使用高精度计算的方法。使用一个数组A来表示一个大整数a，A[0]表示a的个位，A[1]表示a的十位，依次类推。<br>将a乘以一个整数k变为将数组A的每一个元素都乘以k，请注意处理相应的进位。<br>首先将a设为1，然后乘2，乘3，当乘到n时，即得到了n!的值。</p><p>Input<br>　　输入包含一个正整数n，n&lt;=1000。</p><p>Output<br>　　输出n!的准确值。</p><p>Sample Input<br>10<br>Sample Output<br>3628800<br>HINT<br>Source<br>基础练习</p><p>相当于是大数的阶乘，也就是基本类型存不下，需要用数组来进行模拟。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3000</span>],i,j,n;  </span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">0</span>,s;  </span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);  </span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3000</span>;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            s=a[j]*i+c;  </span><br><span class="line">            a[j]=s%<span class="number">10</span>;  </span><br><span class="line">            c=s/<span class="number">10</span>;<span class="comment">//保留进位  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2999</span>;i&gt;=<span class="number">0</span>;i--)  </span><br><span class="line">        <span class="keyword">if</span>(a[i])  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">for</span>(j=i;j&gt;=<span class="number">0</span>;j--)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[j]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZCMU </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ZCMU-1620</title>
      <link href="/%E9%A2%98%E8%A7%A3%E9%9B%86/ZCMU-1620/"/>
      <url>/%E9%A2%98%E8%A7%A3%E9%9B%86/ZCMU-1620/</url>
      
        <content type="html"><![CDATA[<h2 id="1620-全排列"><a href="#1620-全排列" class="headerlink" title="1620: 全排列"></a>1620: 全排列</h2><p>Time Limit: 1 Sec  Memory Limit: 128 MB<br>Submit: 198  Solved: 89<br>[Submit][Status][Web Board]<br>Description<br>给定n个数 a[0] , a[1] …….. a[n-1], 输出其全排列。</p><p>Input<br>第一行输入一个数n，（n&lt;7）</p><p>接下来一行输入n个数。</p><p>Output<br>按字典序从小到大输出全排列</p><p>Sample Input<br>3<br>1 2 3<br>3<br>1 2 2<br>Sample Output<br>1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1<br>1 2 2<br>2 1 2<br>2 2 1<br>HINT</p><ul><li><p>全排列，枚举排列常用的方法有两种：一种是递归枚举，另一种是用STL中的next_permutation</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_permutation</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> *p,<span class="keyword">int</span> *a,<span class="keyword">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!i||p[i]!=p[i<span class="number">-1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ok=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c1=<span class="number">0</span>,c2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cur;j++)<span class="keyword">if</span>(a[j]==p[i]) c1++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) <span class="keyword">if</span>(p[i]==p[j]) c2++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(c1&lt;c2)&#123;</span><br><span class="line">            a[cur]=p[i];</span><br><span class="line">            print_permutation(n,p,a,cur+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,p[<span class="number">10</span>],a[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(p,p+n);</span><br><span class="line">        print_permutation(n,p,a,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        sort(a,a+n);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n<span class="number">-1</span>]);</span><br><span class="line">        &#125;<span class="keyword">while</span>(next_permutation(a,a+n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 题解集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZCMU </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《控方证人》观后感</title>
      <link href="/%E5%BD%B1%E9%9F%B3/%E3%80%8A%E6%8E%A7%E6%96%B9%E8%AF%81%E4%BA%BA%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/"/>
      <url>/%E5%BD%B1%E9%9F%B3/%E3%80%8A%E6%8E%A7%E6%96%B9%E8%AF%81%E4%BA%BA%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p>  　　这个周末有点小忙哈哈，没办法，得准备Ｊａｖａ课件呀，好歹也是个愚人节呢，得让自己放松下，于是花了点时间看了部老电影《控方证人》，一部上世纪６０年代的电影，一部黑白片。我一般不大会特意去找某部电影，一些早已被广为认可的经典我会时不时抽几部欣赏欣赏，很少有令我失望过，当然，这次也不例外。<br>  　　很好的一部剧情片，惊悚我倒没怎么感觉到，但不得不说，一流的演员以及一流的剧本让我佩服不已，至少我是被骗到了，结局在我的意料之外，当然中间确实有些困惑的地方，我很理解为什么沃尔的妻子竟然当起了控方证人。影片开始，个性鲜明的律师威尔弗里德爵士便出现在荧幕上，很有意思的一个家伙，一看到雪茄就耐不住想吸上一口，看似嘴不饶人，其实内心善良热诚。他身边的护士尽管一天到晚啰里啰嗦招人烦，却也是真正为威尔弗里德爵士的健康着想。紧接着，剧情展开，控方与被告的辩论也即将展开。<br>  　　我为什么说我被骗到了，起初我真的认为沃尔是无辜的，是被冤枉的，富婆的死只是被某个入室抢劫犯误杀了，紧接着，伟大的威尔弗里德爵士作为正义的化身，冒着身体旧病复发的风险为沃尔展开辩护，然后一步步过关斩将，去的胜利，沃尔无罪释放！看，结局多么美好，但细想一番，若真是如此，这剧情片恐怕也难成为经典了。开头的警巡，包括之后的女佣，这两人的证词在我看来都很正常，警巡，按照职业习惯进行了正常的回答。至于女佣，势利的姿态可以说是展现的很充分，哈哈，这世上没有无缘无故的恨，沃尔的出现让本该属于她的遗产瞬间成为一场空，他恨透了沃尔，巴不得看着他上绞刑架．．但后一位控方证人让我难以理解，那就是沃尔的妻子克里斯汀，她的出现让我困惑，我相信威尔弗里德爵士当时也是和我相似的心情。看似恩爱的夫妻有什么理由说反目就反目呢，难道之前的感情本就是虚假的？没看到结尾，我真的没猜到这对夫妻竟然都在演戏，在法庭上演了一出精彩的戏。只不过人人喊打的克里斯汀确是陷入爱情的有心人，而看似无辜的沃尔才是花心大萝卜，才是真凶。法律规定，嫌疑人的妻子是无法为其辩护的，证词无效，于是克里斯汀就想到了该当控告，直到最后决定判决的那几分情书信纸，也不过只是她的计划一部分。好可怕的一个女人，竟然铁定了心犯伪证罪也要救这样一个花心大萝卜，难以理解。两个人一唱一和的一出戏，骗过了整个法庭，我没有想到，沃尔竟然真的杀了富婆，更没想到克里斯汀知道是他杀了富婆还要牺牲自己就他，更没想到两人的感情，谁是真心，谁是假意让我一脸蒙蔽，人生如戏，全靠演技呀！哈哈哈～～</p>]]></content>
      
      
      <categories>
          
          <category> 影音 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的2017书单</title>
      <link href="/%E9%98%85%E8%AF%BB/%E6%88%91%E7%9A%842017%E4%B9%A6%E5%8D%95/"/>
      <url>/%E9%98%85%E8%AF%BB/%E6%88%91%E7%9A%842017%E4%B9%A6%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="你好-这是我的2017书单。"><a href="#你好-这是我的2017书单。" class="headerlink" title="你好,这是我的2017书单。"></a>你好,这是我的2017书单。</h1><blockquote class="blockquote-center"><p>1、《平凡的世界》<br>2、《霜冷长河》<br>3、《霍乱时期的爱情》<br>4、《文化苦旅》<br>5、《千年一叹》<br>6、《许三观卖血记》<br>7、《白夜行》<br>8、《嫌疑人X的献身》<br>9、《解忧杂货店》<br>10、《资治通鉴》<br>11、《活着》<br>12、《三体》<br>13、《百年孤独》<br>14、《活着为了讲述》<br>15、《人生》<br>16、《偷影子的人》<br>17、《黄金时代》<br>18、《无声告白》<br>19、《小王子》<br>20、《夜莺与玫瑰》<br>21、《飘》<br>22、《海边的卡夫卡》<br>23、《东方快车上的谋杀案》<br>24、《挪威的森林》<br>25、《雪国》<br>26、《不能承受的生命之轻》<br>27、《恶意》<br>28、《陶庵梦忆》<br>29、《红楼梦》<br>30、《沉默的大多数》<br>31、《少年维特的烦恼》<br>32、《傲慢与偏见》<br>33、《麦田里的守望者》<br>34、《北岛诗集》<br>35、《顾城诗集》<br>36、《海子诗集》<br>37、《余光中散文诗集》<br>38、《鳄鱼街》<br>39、《自由在高处》<br>40、《愿你与这世界温暖相拥》<br>41、《很高兴见到你》<br>42、《无证之罪》<br>43、《白马山庄杀人事件》<br>44、《浮士德》<br>45、《老人与海》<br>46、《北鸢》<br>47、《菜根谭》<br>48、《单恋》<br>49、《鬼谷子》<br>50、《人类群星闪耀时》<br>51、《人间词话》<br>52、《古文观止》<br>53、《假面饭店》<br>54、《幻夜》<br>55、《看见》<br>56、《撒哈拉的故事》<br>57、《月亮和六便士》<br>58、《漫漫自由路》<br>59、《1984》<br>60、《1980年代的爱情》<br>61、《本草纲目》<br>62、《傅雷家书》<br>63、《我们三》<br>64、《围城》<br>65、《钱钟书传》<br>66、《草房子》<br>67、《我的职业是小说家》<br>68、《爱你就像爱生命》<br>69、《这些人那些事》<br>70、《明朝那些事》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书单 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++字符串操作</title>
      <link href="/%E8%AF%AD%E8%A8%80/C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
      <url>/%E8%AF%AD%E8%A8%80/C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="1）字符串操作"><a href="#1）字符串操作" class="headerlink" title="1）字符串操作"></a>1）字符串操作</h1><p>strcpy(p, p1) 复制字符串<br>strncpy(p, p1, n) 复制指定长度字符串<br>strcat(p, p1) 附加字符串<br>strncat(p, p1, n) 附加指定长度字符串<br>strlen(p) 取字符串长度<br>strcmp(p, p1) 比较字符串<br>strcasecmp忽略大小写比较字符串<br>strncmp(p, p1, n) 比较指定长度字符串<br>strchr(p, c) 在字符串中查找指定字符<br>strrchr(p, c) 在字符串中反向查找<br>strstr(p, p1) 查找字符串<br>strpbrk(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找该集合的任一元素<br>strspn(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找不属于该集合的任一元素的偏移<br>strcspn(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找属于该集合的任一元素的偏移  </p><ul><li>具有指定长度的字符串处理函数在已处理的字符串之后填补零结尾符</li></ul><h1 id="2）字符串到数值类型的转换"><a href="#2）字符串到数值类型的转换" class="headerlink" title="2）字符串到数值类型的转换"></a>2）字符串到数值类型的转换</h1><p>strtod(p, ppend) 从字符串 p 中转换 double 类型数值，并将后续的字符串指针存储到 ppend 指向的 char* 类型存储。<br>strtol(p, ppend, base) 从字符串 p 中转换 long 类型整型数值，base 显式设置转换的整型进制，设置为 0 以根据特定格式判断所用进制，0x, 0X 前缀以解释为十六进制格式整型，0    前缀以解释为八进制格式整型<br>atoi(p) 字符串转换到 int 整型<br>atof(p) 字符串转换到 double 符点数<br>atol(p) 字符串转换到 long 整型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void *memset(void *dest, int c, size_t count);  </span><br><span class="line">将dest前面count个字符置为字符c.  返回dest的值.</span><br><span class="line"></span><br><span class="line">void *memmove(void *dest, const void *src, size_t count);  </span><br><span class="line">从src复制count字节的字符到dest. 如果src和dest出现重叠, 函数会自动处理.  返回dest的值.</span><br><span class="line"></span><br><span class="line">void *memcpy(void *dest, const void *src, size_t count);  </span><br><span class="line">从src复制count字节的字符到dest. 与memmove功能一样, 只是不能处理src和dest出现重叠.  返回dest的值.</span><br><span class="line"></span><br><span class="line">void *memchr(const void *buf, int c, size_t count);  </span><br><span class="line">在buf前面count字节中查找首次出现字符c的位置. 找到了字符c或者已经搜寻了count个字节, 查找即停止. 操作成功则返回buf中首次出现c的位置指针, 否则返回NULL.</span><br><span class="line"></span><br><span class="line">void *_memccpy(void *dest, const void *src, int c, size_t count);  </span><br><span class="line">从src复制0个或多个字节的字符到dest. 当字符c被复制或者count个字符被复制时, 复制停止.</span><br><span class="line"></span><br><span class="line">如果字符c被复制, 函数返回这个字符后面紧挨一个字符位置的指针. 否则返回NULL.</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">实现<span class="built_in">strcpy</span>函数,将源串strSrc的内容复制到目标串strDest，返回值为指向目标串的指针</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *strDest,<span class="keyword">const</span> <span class="keyword">char</span> *strSrc)</span><span class="comment">//源字符串+const，表明其为输入参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert((strDest!=<span class="literal">NULL</span>&amp;&amp;(strSrc!=<span class="literal">NULL</span>)));</span><br><span class="line">    <span class="comment">//对源地址和目的地址加非0判断</span></span><br><span class="line">    <span class="keyword">char</span> *address=strDest;</span><br><span class="line">    <span class="keyword">while</span>((*strDest++=*strSrc++)!=<span class="string">'\0'</span>);</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br><span class="line">实现<span class="built_in">strcat</span>函数：将源串添加到str1的末尾，同时覆盖旧串末尾的<span class="string">'\0'</span>,在新串末尾+<span class="string">'\0'</span>,返回指向str1的指针。</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p=str1;</span><br><span class="line">    assert((str1!=<span class="literal">NULL</span>)&amp;&amp;(str2!=<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(*str1!=<span class="string">'\0'</span>)</span><br><span class="line">        str1++;</span><br><span class="line">    <span class="keyword">while</span>(*str1++=*str2++);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcmp</span>函数：比较str1和str2两个字符串的大小，若str1&gt;str2，则返回正数；若str1&lt;str2，则返回负数；若str1==str2，则返回<span class="number">0</span>。</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">strcmp</span>(<span class="keyword">const</span> <span class="keyword">char</span> *str1,<span class="keyword">const</span> <span class="keyword">char</span> *str2)</span><br><span class="line">&#123;</span><br><span class="line">    assert((str1!=<span class="literal">NULL</span>)&amp;&amp;(str2!=<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(*str1&amp;&amp;*str2&amp;&amp;(*str1==*str2))</span><br><span class="line">    &#123;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *str1-*str2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s,<span class="keyword">int</span> c,<span class="keyword">size_t</span> n)</span> <span class="comment">//将已开辟内存空间s的首n个字节的值设为c</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(s!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span> *tmp=(<span class="keyword">char</span> *)s;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        *tmp++=(<span class="keyword">char</span>)c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest,<span class="keyword">const</span> <span class="keyword">void</span> *src,<span class="keyword">size_t</span> n)</span><span class="comment">//从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(dest!=<span class="literal">NULL</span>&amp;&amp;src!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span> *tmpdest=(<span class="keyword">char</span> *)dest;</span><br><span class="line">    <span class="keyword">char</span> *tmpsrc=(<span class="keyword">char</span> *)src;</span><br><span class="line">    <span class="keyword">while</span>(n-- &gt;<span class="number">0</span>)</span><br><span class="line">        *tmpdest++=*tmpsrc++;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现C的strstr"><a href="#实现C的strstr" class="headerlink" title="实现C的strstr"></a>实现C的strstr</h2><p>功能：从字符串str1中查找是否有字符串str2，<br>    -如果有，从str1中的str2位置起，返回str1中str2起始位置的指针，如果没有，返回null。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mystrstr</span><span class="params">(<span class="keyword">char</span> *s1 , <span class="keyword">char</span> *s2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(*s1==<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(*s2)   </span><br><span class="line">            <span class="keyword">return</span>(<span class="keyword">char</span>*)<span class="literal">NULL</span>;  </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">char</span>*)s1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(*s1)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(s2[i]==<span class="number">0</span>)   </span><br><span class="line">                <span class="keyword">return</span> s1;  </span><br><span class="line">            <span class="keyword">if</span>(s2[i]!=s1[i])   </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        s1++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">strStr</span><span class="params">(<span class="keyword">char</span> *haystack, <span class="keyword">char</span> *needle)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// Start typing your C/C++ solution below  </span></span><br><span class="line">        <span class="comment">// DO NOT write int main() function  </span></span><br><span class="line">        <span class="keyword">int</span> i,j;  </span><br><span class="line">        <span class="keyword">for</span> (i = j = <span class="number">0</span>; haystack[i] &amp;&amp; needle[j];) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;  </span><br><span class="line">                ++i;  </span><br><span class="line">                ++j;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                i = i - j + <span class="number">1</span>;  </span><br><span class="line">                j = <span class="number">0</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> needle[j]?<span class="number">0</span>:(haystack + i - j);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="用C语言实现函数void-memmove-void-dest-const-void-src-size-t-n-。"><a href="#用C语言实现函数void-memmove-void-dest-const-void-src-size-t-n-。" class="headerlink" title="用C语言实现函数void memmove(void dest, const void *src, size_t n)。"></a>用C语言实现函数void <em>memmove(void </em>dest, const void *src, size_t n)。</h3><p>memmove函数的功能死拷贝src所指向内存内容前n个字节到dest所指的地址上。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">my_memmove</span><span class="params">( <span class="keyword">void</span> * <span class="keyword">const</span> dest, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> src, <span class="keyword">size_t</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// check parameters</span></span><br><span class="line">   <span class="keyword">if</span>( <span class="number">0</span> == n )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>( <span class="literal">NULL</span> == dest || <span class="literal">NULL</span> == src )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span> * psrc = (<span class="keyword">char</span> *)src;</span><br><span class="line">   <span class="keyword">char</span> * pdest = (<span class="keyword">char</span> *)dest;</span><br><span class="line">   <span class="keyword">if</span>( pdest &lt;= psrc || pdest &gt; psrc + n )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"forward overlapping"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="comment">// copy forward direction</span></span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">      &#123;</span><br><span class="line">         *pdest = *psrc;</span><br><span class="line">         pdest++;</span><br><span class="line">         psrc++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"backward overlapping"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="comment">// copy backward direction</span></span><br><span class="line">      pdest = pdest + n;</span><br><span class="line">      psrc = psrc + n;</span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">size_t</span> i = <span class="number">0</span>; i&lt; n; i++ )</span><br><span class="line">      &#123;</span><br><span class="line">         *pdest = *psrc;</span><br><span class="line">         pdest--;</span><br><span class="line">         psrc--;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> *src = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">   <span class="built_in">sprintf</span>( src, <span class="string">"%s"</span>, <span class="string">"hello world!"</span> );</span><br><span class="line">   <span class="keyword">char</span> * dest = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">   <span class="built_in">memset</span>( dest, <span class="number">0</span>, <span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span> ) );</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; src &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">char</span> * result = (<span class="keyword">char</span>*)my_memmove( dest, src, <span class="built_in">strlen</span>(src) );</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">delete</span> src;</span><br><span class="line">   <span class="keyword">delete</span> dest;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="设计一个反转字符串的函数-char-reverse-str-char-str-不使用系统函数。"><a href="#设计一个反转字符串的函数-char-reverse-str-char-str-不使用系统函数。" class="headerlink" title="设计一个反转字符串的函数 char reverse_str(char str),不使用系统函数。"></a>设计一个反转字符串的函数 char <em>reverse_str(char </em>str),不使用系统函数。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现字符串反转     </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">reverse</span><span class="params">(<span class="keyword">char</span> *str)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="keyword">if</span>( !str )     </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);     </span><br><span class="line">    <span class="keyword">if</span>( len &gt; <span class="number">1</span> )     </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="keyword">char</span> ctemp =str[<span class="number">0</span>];     </span><br><span class="line">        str[<span class="number">0</span>] = str[len<span class="number">-1</span>];        </span><br><span class="line">        str[len-1] = '/0';// 最后一个字符在下次递归时不再处理     </span><br><span class="line">        reverse(str+<span class="number">1</span>); <span class="comment">// 递归调用     </span></span><br><span class="line">        str[len<span class="number">-1</span>] = ctemp;     </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str;     </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归实现字符串反转  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">reverse</span><span class="params">(<span class="keyword">char</span> *str)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="keyword">if</span>( !str )     </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);     </span><br><span class="line">    <span class="keyword">char</span> temp;     </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++ )     </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="comment">// 交换前后两个相应位置的字符     </span></span><br><span class="line">        temp = *(str + i);     </span><br><span class="line">        *(str + i) = *(str + len - <span class="number">1</span> - i);     </span><br><span class="line">        *(str + len - <span class="number">1</span> - i) = temp;     </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str;     </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> src[] = &#123;<span class="string">"abcdef"</span>&#125;;  </span><br><span class="line">    <span class="keyword">char</span> *pdest = reverse(src);  </span><br><span class="line"></span><br><span class="line">    getchar();  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的2016电影</title>
      <link href="/%E5%BD%B1%E9%9F%B3/%E6%88%91%E7%9A%842016%E7%94%B5%E5%BD%B1/"/>
      <url>/%E5%BD%B1%E9%9F%B3/%E6%88%91%E7%9A%842016%E7%94%B5%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="你好-这是我的2016电影列表。"><a href="#你好-这是我的2016电影列表。" class="headerlink" title="你好,这是我的2016电影列表。"></a>你好,这是我的2016电影列表。</h1><blockquote class="blockquote-center"><p>1、《马力和马克思》<br>2、《怦然心动》<br>3、《天堂电影院》<br>4、《海上钢琴师》<br>5、《教父系列》<br>6、《控方证人》<br>7、《千与千寻》<br>8、《从你的全世界路过》<br>9、《战狼2》<br>10、《金刚狼3》<br>11、《大话西游系列》<br>12、《鬼子来了》<br>13、《让子弹飞》<br>14、《天才枪手》<br>15、《比利比恩的中场战事》<br>16、《麦兜的故事》<br>17、《美国丽人》<br>18、《泰坦尼克号》<br>19、《阿飞正传》<br>20、《x森林系列》<br>21、《辩护人》<br>22、《记忆碎片》<br>23、《哈尔的移动城堡》<br>24、《烈日灼心》<br>25、《一条狗的使命》<br>26、《致命魔术》<br>27、《星际穿越》<br>28、《驯龙高手》<br>29、《幸福终点站》<br>30、《时空恋旅人》<br>31、《致命ID》<br>32、《你的名字》<br>33、《幽灵公主》<br>34、《盗梦空间》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 影音 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的2016书单</title>
      <link href="/%E9%98%85%E8%AF%BB/%E6%88%91%E7%9A%842016%E4%B9%A6%E5%8D%95/"/>
      <url>/%E9%98%85%E8%AF%BB/%E6%88%91%E7%9A%842016%E4%B9%A6%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="你好-这是我的2016书单。"><a href="#你好-这是我的2016书单。" class="headerlink" title="你好,这是我的2016书单。"></a>你好,这是我的2016书单。</h1><blockquote class="blockquote-center"><p>1、《一句顶一万句》<br>2、《寻路中国》<br>3、《人类简史》<br>4、《一只特立独行的猪》<br>5、《三国演义》<br>6、《世说新语》<br>7、《战国策》<br>8、《春风沉醉的夜晚》<br>9、《水浒传》<br>10、《茶花女》<br>11、《天黑以后》<br>12、《悟空传》<br>13、《苦妓回忆录》<br>14、《不属于我们的世纪》<br>15、《身份的焦虑》<br>16、《追忆似水年华》<br>17、《约翰克里斯多夫》<br>18、《无名的裘德》<br>19、《高老头》<br>20、《浮生六记》<br>21、《二手时间》<br>22、《洗澡》<br>23、《爱情和其他魔鬼》<br>24、《芳华》<br>25、《冰与火之歌》<br>26、《远山淡影》<br>27、《目送》<br>28、《自深深处》<br>29、《巨人的陨落》<br>30、《余华短篇集》<br>31、《基督山伯爵》<br>32、《三个火枪手》<br>33、《和喜欢的一切在一起》<br>34、《弗兰克尔自传》<br>35、《重新认识你自己》<br>36、《二十四史》<br>37、《长恨歌》<br>38、《面包树上的女人》<br>39、《追随你的心》<br>40、《不能不去爱的两件事》<br>41、《在这复杂世界里》<br>42、《坏小孩》<br>43、《季羡林私人史》<br>44、《金瓶梅》<br>45、《孤独六讲》<br>46、《我们生活在巨大的差距里》<br>47、《分身》<br>48、《宿命》<br>49、《快乐是在心里》<br>50、《我的精神家园》<br>51、《万历十五年》<br>52、《撒切尔夫人传》<br>53、《飞鸟集》<br>54、《幻灭》<br>55、《当我跑步时我谈些什么》<br>56、《富爸爸、穷爸爸》<br>57、《雅舍小品》<br>58、《一个女子恋爱的时候》<br>59、《从一到无穷大》<br>60、《虚无的十字架》<br>61、《资本论》<br>62、《白说》<br>63、《在细雨中呼喊》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书单 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
