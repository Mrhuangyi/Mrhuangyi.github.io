{"meta":{"title":"你的小黄^_^","subtitle":"码奴生来就只知道前进","description":"终于活成了别人喜欢的样子","author":"Mr.Huangyi","url":"http://huangyiblog.com","root":"/"},"pages":[{"title":"关于","date":"2018-03-30T12:23:02.000Z","updated":"2019-04-21T09:30:47.933Z","comments":false,"path":"about/index.html","permalink":"http://huangyiblog.com/about/index.html","excerpt":"","text":"小黄个人信息 本科/XXXX大学(2016.9-2020.7)/计算机科学与技术 工作年限：XXXXX年 邮箱：hy18757163093@gmail.com 地点：杭州 关于本博客：主要用于自己的学习笔记积累，以及记录一些生活随笔。 关于我： 与恶龙搏斗过久，自身亦成为恶龙；凝视深渊过久，深渊必将回以凝视。"},{"title":"archives","date":"2018-03-31T11:54:08.000Z","updated":"2018-10-09T14:43:20.696Z","comments":false,"path":"archives/index.html","permalink":"http://huangyiblog.com/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-10-14T04:30:45.824Z","updated":"2018-10-09T14:43:20.696Z","comments":false,"path":"categories/index.html","permalink":"http://huangyiblog.com/categories/index.html","excerpt":"","text":""},{"title":"guestbook","date":"2018-04-09T08:20:52.000Z","updated":"2018-10-09T14:43:20.697Z","comments":true,"path":"guestbook/index.html","permalink":"http://huangyiblog.com/guestbook/index.html","excerpt":"","text":""},{"title":"home","date":"2018-04-01T11:50:14.000Z","updated":"2018-10-09T14:43:20.697Z","comments":true,"path":"home/index.html","permalink":"http://huangyiblog.com/home/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-09T14:43:20.744Z","updated":"2018-10-09T14:43:20.744Z","comments":false,"path":"tags/index.html","permalink":"http://huangyiblog.com/tags/index.html","excerpt":"","text":""},{"title":"book","date":"2018-10-14T08:36:55.000Z","updated":"2018-10-14T08:36:55.488Z","comments":true,"path":"categories/book/index.html","permalink":"http://huangyiblog.com/categories/book/index.html","excerpt":"","text":""},{"title":"media","date":"2018-10-14T08:37:03.000Z","updated":"2018-10-14T08:37:03.655Z","comments":true,"path":"categories/media/index.html","permalink":"http://huangyiblog.com/categories/media/index.html","excerpt":"","text":""}],"posts":[{"title":"重温海上钢琴师","slug":"重温海上钢琴师","date":"2019-11-19T14:00:22.000Z","updated":"2019-12-22T12:20:26.547Z","comments":true,"path":"影音/重温海上钢琴师/","link":"","permalink":"http://huangyiblog.com/影音/重温海上钢琴师/","excerpt":"记得上一次看海上钢琴师是在中学的时候了，也是我第一次看海上钢琴师。我到现在都觉得自己很庆幸，能够早早地就发现一部如此动人的电影，如此触动人心的故事。","text":"记得上一次看海上钢琴师是在中学的时候了，也是我第一次看海上钢琴师。我到现在都觉得自己很庆幸，能够早早地就发现一部如此动人的电影，如此触动人心的故事。 其实发现一部好的作品，认识一部好的作品并不容易。大家都承认红楼梦是世界名著，是古典文学巅峰之作，但是你若是让我小学就去看红楼梦，我还真不一定有耐心看下去，我很庆幸，自己大学抽出了时间，认真的看了红楼梦。接触到海上钢琴师也是我的幸运，其实之前我也在电视上看到过这部电影中享誉盛名的斗琴片段，但当时我并不会很在意，很多人应该都有类似的体会。一个人在夜晚安安静静将一部３小时的电影从头看到尾和平时嘈杂的环境中无意看一个小片段是完全不同的体验。记得是初中的时候吧，有阵子家里没有装宽带，上不了网，玩不了游戏，在家实在无聊的发愁，后来发现笔记本里有几部之前老姐下好的电影，我便将这些电影从头到尾全看了一遍，一部也没落下。也许我就是在这个阶段喜欢上了电影吧。 海上钢琴师是一部什么样的电影？每个人都有不一样的答案，我相信也有人不喜欢这部电影甚至有些厌恶。心里想着这电影传达了什么消极的价值观，男主明明就是懦弱。喜欢的人看到的也各有不同，有的人认为海上钢琴师讲述了一个钢琴天才的传奇一生，有些人认为这电影讲的是爵士乐，也有人认为讲的是爱情，或者只是一个海上乌托邦。我觉得都很正常，一部电影，一本书要做的并不是要让所有人都拍手称赞才算成功。能成为影史上的一部经典自然有着其特别的魅力之处。所以当得知海上钢琴师即将在国内修复重映的消息时，我就想着无论如何也要去电影院重温一下年少时的感动。 中学时我看完电影最受触动的是1900的执著，我想不明白，拥有如此天赋与才华，为何至死都不愿下船？这个问题其实Max也问过，其实很多人都问过，甚至1900在电影里也做过不止一次的解答。影片结尾1900和Max的对话中，1900是这么说的，“Why why why…I think land people waste a lot of time wondering why. Winter comes they can’t wait for summer; summer comes they’re living dread of winter. That’s why. It wasn’t what I saw that stopped me, Max. It was what I didn’t see. You understand that? What I didn’t see. In all that sprawling city there was everything except an end.” 陆上的人总喜欢刨根问底，虚度了大好光阴。冬天忧虑夏天的姗姗来迟，夏天则担心冬天的将至。所以他们不停四处游走，追求一个遥不可及、四季如夏的地方-我并不羡慕。阻止了我的脚步的，并不是我所看见的东西，而是我所无法看见的那些东西。你明白吗？我看不见的那些东西。在那个无限蔓延的城市里，什么东西都有，唯独没有尽头。或许我们可以试着去理解1900，它很孤独吗？也许吧，但在他的钢琴世界里并不孤独，他还有一个知己Max，他很懦弱吗？ 也许吧，面对心爱的女生，却连一份录音碟都没能有勇气送出去，面对心爱的女生，连下船的勇气都拿不出，但他对抗世俗，对抗无尽欲望的勇气是无数人不及的。1900生于大海上的一艘船上，最后也选择了在船上终结自己的一生，让自己能够一直在海上弹着钢琴。影片中有两次提到了1900不愿下船，一次就是我上面提到的，Max在即将废弃的破船上找到他时，还有一次就是当他想要去找他心爱的女生时。第一次只差一点点，他就迈出了那一步，可是仍旧放弃了，那时它是真的有下船的想法的，将来或许可以娶一位美丽的太太，生几个孩子，成为一名光鲜亮丽，名震四海的钢琴家，可他望了望弥漫着硝烟的无尽都市，他确定了这不是他想要的生活。 影片的台词很美，很动人。打动人的场景也有很多，备受推崇的斗琴片段，最后在琴键上点燃着的香烟一直为人所乐道。其实我非常喜欢这电影里的一些初遇的片段，1900和Max初次相遇，Max晕船晕的厉害，1900为了帮他在晃荡的大海上弹着钢琴帮助他沉醉，放松。1900录制唱片的时候和女主初次相遇，琴键随着注视的目光移动着，心跳随着琴键跳动着，1900喜欢上了她。我不知道该如何描述，总之很美的画面。有些时候电影很打动人，还有个原因就是引起了你的共鸣。大家或许会觉得1900怎么这么窝囊，看见了喜欢的女生，连个礼物都没勇气送出去，最后还亲手把礼物给毁了。哈哈哈，何其相似，我和1900在这方面是在太像了，甚至我还不如她。我高中有个很喜欢的女生，知道吗，真的喜欢上一个人我是睡不着觉吃不下饭的，成天胡思乱想，我发现了自己很自卑，我担心影响双方的学习，但喜欢就是喜欢，我想方设法的，我想过要写情书，我想过要送礼物，我去问，去网上查，我想知道女生喜欢什么礼物。是的，后面礼物确实买了，写情书的信封都买了，但是到了高中毕业我都没送出去。可能这就是暗恋吧。现在想想1900的多次无果的尝试，总是不经意间就想到可笑的自己，1900也很有趣，甚至偷偷跑进女生宿舍，小心翼翼，生怕被人发现，最后却连一张音碟都没送出去，实在有些遗憾。 很好的故事，很美的传奇，我心中的经典电影永远会给海上钢琴师留一份位置。1900是个很纯粹的人，可能现实生活中这样的人并不多，但电影的魅力就是帮助我们时不时想一想，是不是该放慢点脚步，偶尔也去想想诗和远方呢？是吧。","categories":[{"name":"影音","slug":"影音","permalink":"http://huangyiblog.com/categories/影音/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://huangyiblog.com/tags/电影/"}]},{"title":"HashMap源码阅读","slug":"HashMap源码阅读","date":"2019-09-02T05:20:35.000Z","updated":"2019-09-02T05:21:42.831Z","comments":true,"path":"uncategorized/HashMap源码阅读/","link":"","permalink":"http://huangyiblog.com/uncategorized/HashMap源码阅读/","excerpt":"","text":"HashMap源码分析(基于jdk1.8)底层数据结构分析虽然我看的源码是jdk1.8的，但我还是想先提一提jdk1.7的底层实现。jdk1.8对HashMap做了很多优化，但无疑对源码理解增加了不少难度，举个例子，光红黑树就够你研究的了。所以如果是初步学习的话，我倒是推荐先看看jdk1.7的实现。 1.7HashMap的底层实现底层结构数组 + 单链表内部包含一个Entry类型的数组table 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152transient Entry[] table;static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; public final int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; public final String toString() &#123; return getKey() + \"=\" + getValue(); &#125;&#125; Entry是一个链表，每个链表里面存储着键值对。也就是说table数组的每个位置被当做一个桶，每个桶里放着一个单链表。HashMap使用拉链法解决Hash冲突。 put操作1.7由于并没有引入红黑树，所以相对还简单点。另外put有可能会发生hash冲突，HashMap采用拉链法解决hash冲突，并且在单链表中的插入采用的是头插法，这里注意下，在jdk1.8里面已经改成了尾插法。1.7在多线程环境下还是会出现数据丢失和死循环等问题，主要是多线程同时put时，如果同时出发rehash操作，会导致HashMap中的链表出现循环结点，导致之后get操作时会死循环jdk1.8解决了单链表死循环的问题，但数据丢失还是存在jdk1.8的解决方案为声明两对指针，维护两个链表，依次在末端添加元素。 put方法具体流程： 首先判断判断键值对数组 table 是否为空或为 null，否则执行 resize()进行扩容; 判断key是否为null，如果是，统一存放在第0个桶 确定桶下标 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value 插入新的键值对 12345678910111213141516171819202122232425262728293031public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; // 键为 null 单独处理， /* * HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() * 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。 * HashMap 使用第 0 个桶存放键为 null 的键值对。 */ if (key == null) return putForNullKey(value); int hash = hash(key); // 确定桶下标 int i = indexFor(hash, table.length); // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // 插入新键值对 addEntry(hash, key, value, i); return null;&#125; 扩容操作HashMap 采用动态扩容来根据当前的 键值对数量N 值来调整 table长度M 值，使得空间效率和时间效率都能得到保证。 和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。各参数的具体含义： capacity: 表示table数组的容量大小，默认为16。并且capacity值必须为n的n次方，具体为什么这么规定后面会提到 size: 键值对数量 threshold: size的临界值，阈值，当size 大于等于 threshold时进行扩容 loadFactor: 加载因子，默认为0.75.threshold = capacity * loadFactor 每次扩容时，令capacity为原来的2倍 扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，该操作性能消耗较大 重新计算桶下标在扩容的时候，需要把键值对重新放到对应的桶上，此时自然需要计算桶下标，HashMap使用的一个很巧妙的方法，可以有效提高代码性能。 这里利用了一个特点，那就是之前提到的capacity容量必须始终为2的n次方，为什么要这么规定，主要有两方面原因： length 为 2 的整数次幂的话，h&amp;(length-1)就相当于对 length 取模，这样便保证了散列的均匀，同时也提升了效率。 length 为 2 的整数次幂的话，为偶数，这样 length-1 为奇数，奇数的最后一位是 1，这样便保证了 h&amp;(length-1)的最后一位可能为 0，也可能为 1(这取决于 h 的值)，即与后的结果可能为偶数，也可能为奇数，这样便可以保证 散列的均匀性，而如果 length 为奇数的话，很明显 length-1 为偶数，它的最后一位是 0，这样 h&amp;(length-1)的最后一 位肯定为 0，即只能为偶数，这样任何 hash 值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间， 因此，length 取 2 的整数次幂，是为了使不同 hash 值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。 再来看上面的问题，计算桶下标，由于capacity始终为2的n次方，所以capacity的二进制格式中始终只有1个1.我们拿16扩容到32举例12capacity : 00010000new capacity : 00100000 对每个即将插入的键key： 如果这个key的hash值在第5位为0，那么取模得到的结果和扩容前一样 如果这个key的hash值在第5位为1，那么取模得到的结果为扩容前的结果+capacity。 另外，虽然HashMap的构造函数允许用户传入的容量是随机的，但源码里都自动将其转换为2den次方。123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 具体的扩容源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static final int DEFAULT_INITIAL_CAPACITY = 16;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;transient Entry[] table;transient int size;int threshold;final float loadFactor;transient int modCount;void addEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); if (size++ &gt;= threshold) resize(2 * table.length);&#125;void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor);&#125;void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125;&#125; JDK1.8 详细源码底层数据结构简单点说就是：数组+单链表+红黑树 put操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * put键值对 */ public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; /** * 如果定位到的数组位置没有元素 就直接插入。 * 如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果 * key不相同，就判断p是否是一个树节点，如果是就调用e = * ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素 * 添加进入。如果不是就遍历链表插入(插入的是链表尾部)。 */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //如果table未进行初始化或者长度为0，那么进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //确定桶下标，如果桶为空，直接放入 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); //桶中已经有元素 else &#123; Node&lt;K,V&gt; e; K k; //比较桶中第一个元素(数组中的结点)的hash值相等，key相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //hash值不相等，即key不相等；为红黑树结点,将节点插入树中 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //为链表结点 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // 在链表尾部插入结点 p.next = newNode(hash, key, value, null); // 结点数量达到阈值，转化为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 判断链表中结点的key值与插入的元素的key值是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 表示在桶中找到key值、hash值与插入元素相等的结点，覆盖旧值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 实际大小超过阈值进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; get操作12345678910111213141516171819202122232425262728293031323334/** * 返回键key对应的值 */ public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; /** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */ final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; 扩容操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 扩容具体实现 */ final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过设定最大值，扩充为原来的两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 完整源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614161516161617161816191620162116221623162416251626162716281629163016311632163316341635163616371638163916401641164216431644164516461647164816491650165116521653165416551656165716581659166016611662166316641665166616671668166916701671167216731674167516761677167816791680168116821683168416851686168716881689169016911692169316941695169616971698169917001701170217031704170517061707170817091710171117121713171417151716171717181719172017211722172317241725172617271728172917301731173217331734173517361737173817391740174117421743174417451746174717481749175017511752175317541755175617571758175917601761176217631764176517661767176817691770177117721773177417751776177717781779178017811782178317841785178617871788178917901791179217931794179517961797179817991800180118021803180418051806180718081809181018111812181318141815181618171818181918201821182218231824182518261827182818291830183118321833183418351836183718381839184018411842184318441845184618471848184918501851185218531854185518561857185818591860186118621863186418651866186718681869187018711872187318741875187618771878187918801881188218831884188518861887188818891890189118921893189418951896189718981899190019011902190319041905190619071908190919101911191219131914191519161917191819191920192119221923192419251926192719281929193019311932193319341935193619371938193919401941194219431944194519461947194819491950195119521953195419551956195719581959196019611962196319641965196619671968196919701971197219731974197519761977197819791980198119821983198419851986198719881989199019911992199319941995199619971998199920002001public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; //序列号 private static final long serialVersionUID = 362498820763181265L; /** * 默认的初始容量，且必须为2的n次方. */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 /** * 最大容量 */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * 默认的装载因子 */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * 当结点数大于8转为红黑树 */ static final int TREEIFY_THRESHOLD = 8; /** * 当结点数小于6，红黑树转为单链表 */ static final int UNTREEIFY_THRESHOLD = 6; /** * 桶中单链表转为红黑树对应的table最小值 */ static final int MIN_TREEIFY_CAPACITY = 64; /** * Node结点，继承自Map.Entry&lt;K,V&gt; */ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; //重写hashcode()方法 public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; 重写equals方法 public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; //改进后的散列算法，高位参与运算 static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; /** * Returns x's Class if it is of the form \"class C implements * Comparable&lt;C&gt;\", else null. */ static Class&lt;?&gt; comparableClassFor(Object x) &#123; if (x instanceof Comparable) &#123; Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p; if ((c = x.getClass()) == String.class) // bypass checks return c; if ((ts = c.getGenericInterfaces()) != null) &#123; for (int i = 0; i &lt; ts.length; ++i) &#123; if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp; ((p = (ParameterizedType)t).getRawType() == Comparable.class) &amp;&amp; (as = p.getActualTypeArguments()) != null &amp;&amp; as.length == 1 &amp;&amp; as[0] == c) // type arg is c return c; &#125; &#125; &#125; return null; &#125; /** * Returns k.compareTo(x) if x matches kc (k's screened comparable * class), else 0. */ @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) // for cast to Comparable static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) &#123; return (x == null || x.getClass() != kc ? 0 : ((Comparable)k).compareTo(x)); &#125; /** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; /* ---------------- Fields -------------- */ /** * 存储键值对结点的数组 */ transient Node&lt;K,V&gt;[] table; /** * 存放具体元素的值 */ transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; /** * 存放键值对的数量 */ transient int size; /** * 增加、删除、修改map结构的计数器 */ transient int modCount; /** * 扩容临界值 */ int threshold; /** * 加载因子 */ final float loadFactor; // 指定“容量大小”和“加载因子”的构造函数 public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; // 指定“容量大小”的构造函数 public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; /** * 默认构造函数。 * (16) and the default load factor (0.75). */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; // 包含另一个“Map”的构造函数 public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; /** * Implements Map.putAll and Map constructor * * @param m the map * @param evict false when initially constructing this map, else * true (relayed to method afterNodeInsertion). */ final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125; &#125; /** * 返回当前map中键值对的数量 */ public int size() &#123; return size; &#125; /** * 判断当前map是否为空 */ public boolean isEmpty() &#123; return size == 0; &#125; /** * 返回键key对应的值 */ public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; /** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */ final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; /** * 判断当前map中是否存在某个键key */ public boolean containsKey(Object key) &#123; return getNode(hash(key), key) != null; &#125; /** * put键值对 */ public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; /** * 如果定位到的数组位置没有元素 就直接插入。 * 如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果 * key不相同，就判断p是否是一个树节点，如果是就调用e = * ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素 * 添加进入。如果不是就遍历链表插入(插入的是链表尾部)。 */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //如果table未进行初始化或者长度为0，那么进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //确定桶下标，如果桶为空，直接放入 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); //桶中已经有元素 else &#123; Node&lt;K,V&gt; e; K k; //比较桶中第一个元素(数组中的结点)的hash值相等，key相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //hash值不相等，即key不相等；为红黑树结点,将节点插入树中 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //为链表结点 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // 在链表尾部插入结点 p.next = newNode(hash, key, value, null); // 结点数量达到阈值，转化为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 判断链表中结点的key值与插入的元素的key值是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 表示在桶中找到key值、hash值与插入元素相等的结点，覆盖旧值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 实际大小超过阈值进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; /** * 扩容具体实现 */ final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过设定最大值，扩充为原来的两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; /** * 将所有链表结点转为树结点 */ final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); &#125; &#125; /** * 拷贝所有指定map到map里面去 */ public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; putMapEntries(m, true); &#125; /** * 删除指定键值对 */ public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; &#125; /** * */ final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null; &#125; /** * 清空当前map */ public void clear() &#123; Node&lt;K,V&gt;[] tab; modCount++; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; size = 0; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; &#125; &#125; /** * 判断当前map里面是否有一个或多个key对应的值为value */ public boolean containsValue(Object value) &#123; Node&lt;K,V&gt;[] tab; V v; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; if ((v = e.value) == value || (value != null &amp;&amp; value.equals(v))) return true; &#125; &#125; &#125; return false; &#125; /** * 返回一个map中包含的key集合 */ public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; if (ks == null) &#123; ks = new KeySet(); keySet = ks; &#125; return ks; &#125; final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; /** * 返回一个map中包含的value集合 */ public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; if (vs == null) &#123; vs = new Values(); values = vs; &#125; return vs; &#125; final class Values extends AbstractCollection&lt;V&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;V&gt; iterator() &#123; return new ValueIterator(); &#125; public final boolean contains(Object o) &#123; return containsValue(o); &#125; public final Spliterator&lt;V&gt; spliterator() &#123; return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super V&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.value); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; /** * 返回map中包含的键值对集合 */ public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es; return (es = entrySet) == null ? (entrySet = new EntrySet()) : es; &#125; final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(); &#125; public final boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Node&lt;K,V&gt; candidate = getNode(hash(key), key); return candidate != null &amp;&amp; candidate.equals(e); &#125; public final boolean remove(Object o) &#123; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Object value = e.getValue(); return removeNode(hash(key), key, value, true, true) != null; &#125; return false; &#125; public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123; return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; // Overrides of JDK8 Map extension methods @Override public V getOrDefault(Object key, V defaultValue) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? defaultValue : e.value; &#125; @Override public V putIfAbsent(K key, V value) &#123; return putVal(hash(key), key, value, true, true); &#125; @Override public boolean remove(Object key, Object value) &#123; return removeNode(hash(key), key, value, true, true) != null; &#125; @Override public boolean replace(K key, V oldValue, V newValue) &#123; Node&lt;K,V&gt; e; V v; if ((e = getNode(hash(key), key)) != null &amp;&amp; ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) &#123; e.value = newValue; afterNodeAccess(e); return true; &#125; return false; &#125; @Override public V replace(K key, V value) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) != null) &#123; V oldValue = e.value; e.value = value; afterNodeAccess(e); return oldValue; &#125; return null; &#125; @Override public V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) &#123; if (mappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; V oldValue; if (old != null &amp;&amp; (oldValue = old.value) != null) &#123; afterNodeAccess(old); return oldValue; &#125; &#125; V v = mappingFunction.apply(key); if (v == null) &#123; return null; &#125; else if (old != null) &#123; old.value = v; afterNodeAccess(old); return v; &#125; else if (t != null) t.putTreeVal(this, tab, hash, key, v); else &#123; tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); return v; &#125; public V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; if (remappingFunction == null) throw new NullPointerException(); Node&lt;K,V&gt; e; V oldValue; int hash = hash(key); if ((e = getNode(hash, key)) != null &amp;&amp; (oldValue = e.value) != null) &#123; V v = remappingFunction.apply(key, oldValue); if (v != null) &#123; e.value = v; afterNodeAccess(e); return v; &#125; else removeNode(hash, key, null, false, true); &#125; return null; &#125; @Override public V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; &#125; V oldValue = (old == null) ? null : old.value; V v = remappingFunction.apply(key, oldValue); if (old != null) &#123; if (v != null) &#123; old.value = v; afterNodeAccess(old); &#125; else removeNode(hash, key, null, false, true); &#125; else if (v != null) &#123; if (t != null) t.putTreeVal(this, tab, hash, key, v); else &#123; tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); &#125; return v; &#125; @Override public V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123; if (value == null) throw new NullPointerException(); if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; &#125; if (old != null) &#123; V v; if (old.value != null) v = remappingFunction.apply(old.value, value); else v = value; if (v != null) &#123; old.value = v; afterNodeAccess(old); &#125; else removeNode(hash, key, null, false, true); return v; &#125; if (value != null) &#123; if (t != null) t.putTreeVal(this, tab, hash, key, value); else &#123; tab[i] = newNode(hash, key, value, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); &#125; return value; &#125; @Override public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key, e.value); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; @Override public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) &#123; Node&lt;K,V&gt;[] tab; if (function == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; e.value = function.apply(e.key, e.value); &#125; &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; /* ------------------------------------------------------------ */ // 克隆和序列化相关函数 /** * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and * values themselves are not cloned. * * @return a shallow copy of this map */ @SuppressWarnings(\"unchecked\") @Override public Object clone() &#123; HashMap&lt;K,V&gt; result; try &#123; result = (HashMap&lt;K,V&gt;)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; result.reinitialize(); result.putMapEntries(this, false); return result; &#125; // These methods are also used when serializing HashSets final float loadFactor() &#123; return loadFactor; &#125; final int capacity() &#123; return (table != null) ? table.length : (threshold &gt; 0) ? threshold : DEFAULT_INITIAL_CAPACITY; &#125; /** * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e., * serialize it). * * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the * bucket array) is emitted (int), followed by the * &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value * mappings), followed by the key (Object) and value (Object) * for each key-value mapping. The key-value mappings are * emitted in no particular order. */ private void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; int buckets = capacity(); // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); s.writeInt(buckets); s.writeInt(size); internalWriteEntries(s); &#125; /** * Reconstitute the &#123;@code HashMap&#125; instance from a stream (i.e., * deserialize it). */ private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(\"Illegal load factor: \" + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(\"Illegal mappings count: \" + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it's the nearest public type to // what we're actually creating. SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(\"unchecked\") K key = (K) s.readObject(); @SuppressWarnings(\"unchecked\") V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125; &#125; /* ------------------------------------------------------------ */ // i迭代器相关函数 abstract class HashIterator &#123; Node&lt;K,V&gt; next; // next entry to return Node&lt;K,V&gt; current; // current entry int expectedModCount; // for fast-fail int index; // current slot HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e; &#125; public final void remove() &#123; Node&lt;K,V&gt; p = current; if (p == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); current = null; K key = p.key; removeNode(hash(key), key, null, false, false); expectedModCount = modCount; &#125; &#125; final class KeyIterator extends HashIterator implements Iterator&lt;K&gt; &#123; public final K next() &#123; return nextNode().key; &#125; &#125; final class ValueIterator extends HashIterator implements Iterator&lt;V&gt; &#123; public final V next() &#123; return nextNode().value; &#125; &#125; final class EntryIterator extends HashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125; &#125; /* ------------------------------------------------------------ */ // spliterators static class HashMapSpliterator&lt;K,V&gt; &#123; final HashMap&lt;K,V&gt; map; Node&lt;K,V&gt; current; // current node int index; // current index, modified on advance/split int fence; // one past last index int est; // size estimate int expectedModCount; // for comodification checks HashMapSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; this.map = m; this.index = origin; this.fence = fence; this.est = est; this.expectedModCount = expectedModCount; &#125; final int getFence() &#123; // initialize fence and size on first use int hi; if ((hi = fence) &lt; 0) &#123; HashMap&lt;K,V&gt; m = map; est = m.size; expectedModCount = m.modCount; Node&lt;K,V&gt;[] tab = m.table; hi = fence = (tab == null) ? 0 : tab.length; &#125; return hi; &#125; public final long estimateSize() &#123; getFence(); // force init return (long) est; &#125; &#125; static final class KeySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;K&gt; &#123; KeySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public KeySpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super K&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p.key); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super K&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; K k = current.key; current = current.next; action.accept(k); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; &#125; &#125; static final class ValueSpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;V&gt; &#123; ValueSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public ValueSpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super V&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p.value); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super V&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; V v = current.value; current = current.next; action.accept(v); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0); &#125; &#125; static final class EntrySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; EntrySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public EntrySpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; Node&lt;K,V&gt; e = current; current = current.next; action.accept(e); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; &#125; &#125; /* ------------------------------------------------------------ */ // LinkedHashMap support /* * The following package-protected methods are designed to be * overridden by LinkedHashMap, but not by any other subclass. * Nearly all other internal methods are also package-protected * but are declared final, so can be used by LinkedHashMap, view * classes, and HashSet. */ // Create a regular (non-tree) node Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(hash, key, value, next); &#125; // For conversion from TreeNodes to plain nodes Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(p.hash, p.key, p.value, next); &#125; // Create a tree bin node TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new TreeNode&lt;&gt;(hash, key, value, next); &#125; // For treeifyBin TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next); &#125; /** * Reset to initial default state. Called by clone and readObject. */ void reinitialize() &#123; table = null; entrySet = null; keySet = null; values = null; modCount = 0; threshold = 0; size = 0; &#125; // Callbacks to allow LinkedHashMap post-actions void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125; void afterNodeInsertion(boolean evict) &#123; &#125; void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125; // Called only from writeObject, to ensure compatible ordering. void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException &#123; Node&lt;K,V&gt;[] tab; if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; s.writeObject(e.key); s.writeObject(e.value); &#125; &#125; &#125; &#125; /* ------------------------------------------------------------ */ // Tree bins /** * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn * extends Node) so can be used as extension of either regular or * linked node. */ static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; /** * Returns root of tree containing this node. */ final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; &#125; /** * Ensures that the given root is the first node of its bin. */ static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123; int n; if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) &#123; int index = (n - 1) &amp; root.hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; if (root != first) &#123; Node&lt;K,V&gt; rn; tab[index] = root; TreeNode&lt;K,V&gt; rp = root.prev; if ((rn = root.next) != null) ((TreeNode&lt;K,V&gt;)rn).prev = rp; if (rp != null) rp.next = rn; if (first != null) first.prev = root; root.next = first; root.prev = null; &#125; assert checkInvariants(root); &#125; &#125; /** * Finds the node starting at root p with the given hash and key. * The kc argument caches comparableClassFor(key) upon first use * comparing keys. */ final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; TreeNode&lt;K,V&gt; p = this; do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; if ((ph = p.hash) &gt; h) p = pl; else if (ph &lt; h) p = pr; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; else if ((q = pr.find(h, k, kc)) != null) return q; else p = pl; &#125; while (p != null); return null; &#125; /** * Calls find for root node. */ final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; return ((parent != null) ? root() : this).find(h, k, null); &#125; /** * Tie-breaking utility for ordering insertions when equal * hashCodes and non-comparable. We don't require a total * order, just a consistent insertion rule to maintain * equivalence across rebalancings. Tie-breaking further than * necessary simplifies testing a bit. */ static int tieBreakOrder(Object a, Object b) &#123; int d; if (a == null || b == null || (d = a.getClass().getName(). compareTo(b.getClass().getName())) == 0) d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -1 : 1); return d; &#125; /** * Forms tree of the nodes linked from this node. * @return root of tree */ final void treeify(Node&lt;K,V&gt;[] tab) &#123; TreeNode&lt;K,V&gt; root = null; for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123; next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; if (root == null) &#123; x.parent = null; x.red = false; root = x; &#125; else &#123; K k = x.key; int h = x.hash; Class&lt;?&gt; kc = null; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; root = balanceInsertion(root, x); break; &#125; &#125; &#125; &#125; moveRootToFront(tab, root); &#125; /** * Returns a list of non-TreeNodes replacing those linked from * this node. */ final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123; Node&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; q = this; q != null; q = q.next) &#123; Node&lt;K,V&gt; p = map.replacementNode(q, null); if (tl == null) hd = p; else tl.next = p; tl = p; &#125; return hd; &#125; /** * Tree version of putVal. */ final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) &#123; Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) &#123; if (!searched) &#123; TreeNode&lt;K,V&gt; q, ch; searched = true; if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; &#125; dir = tieBreakOrder(k, pk); &#125; TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; &#125; &#125; &#125; /** * Removes the given node, that must be present before this call. * This is messier than typical red-black deletion code because we * cannot swap the contents of an interior node with a leaf * successor that is pinned by \"next\" pointers that are accessible * independently during traversal. So instead we swap the tree * linkages. If the current tree appears to have too few nodes, * the bin is converted back to a plain bin. (The test triggers * somewhere between 2 and 6 nodes, depending on tree structure). */ final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable) &#123; int n; if (tab == null || (n = tab.length) == 0) return; int index = (n - 1) &amp; hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; if (pred == null) tab[index] = first = succ; else pred.next = succ; if (succ != null) succ.prev = pred; if (first == null) return; if (root.parent != null) root = root.root(); if (root == null || root.right == null || (rl = root.left) == null || rl.left == null) &#123; tab[index] = first.untreeify(map); // too small return; &#125; TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement; if (pl != null &amp;&amp; pr != null) &#123; TreeNode&lt;K,V&gt; s = pr, sl; while ((sl = s.left) != null) // find successor s = sl; boolean c = s.red; s.red = p.red; p.red = c; // swap colors TreeNode&lt;K,V&gt; sr = s.right; TreeNode&lt;K,V&gt; pp = p.parent; if (s == pr) &#123; // p was s's direct parent p.parent = s; s.right = p; &#125; else &#123; TreeNode&lt;K,V&gt; sp = s.parent; if ((p.parent = sp) != null) &#123; if (s == sp.left) sp.left = p; else sp.right = p; &#125; if ((s.right = pr) != null) pr.parent = s; &#125; p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p; &#125; else if (pl != null) replacement = pl; else if (pr != null) replacement = pr; else replacement = p; if (replacement != p) &#123; TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null; &#125; TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement); if (replacement == p) &#123; // detach TreeNode&lt;K,V&gt; pp = p.parent; p.parent = null; if (pp != null) &#123; if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; &#125; &#125; if (movable) moveRootToFront(tab, r); &#125; /** * Splits nodes in a tree bin into lower and upper tree bins, * or untreeifies if now too small. Called only from resize; * see above discussion about split bits and indices. * * @param map the map * @param tab the table for recording bin heads * @param index the index of the table being split * @param bit the bit of hash to split on */ final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; // Relink into lo and hi lists, preserving order TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; if ((e.hash &amp; bit) == 0) &#123; if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; &#125; else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; &#125; &#125; if (loHead != null) &#123; if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else &#123; tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); &#125; &#125; if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125; &#125; /* ------------------------------------------------------------ */ // Red-black tree methods, all adapted from CLR static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; r, pp, rl; if (p != null &amp;&amp; (r = p.right) != null) &#123; if ((rl = p.right = r.left) != null) rl.parent = p; if ((pp = r.parent = p.parent) == null) (root = r).red = false; else if (pp.left == p) pp.left = r; else pp.right = r; r.left = p; p.parent = r; &#125; return root; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; l, pp, lr; if (p != null &amp;&amp; (l = p.left) != null) &#123; if ((lr = p.left = l.right) != null) lr.parent = p; if ((pp = l.parent = p.parent) == null) (root = l).red = false; else if (pp.right == p) pp.right = l; else pp.left = l; l.right = p; p.parent = l; &#125; return root; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; x.red = true; for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123; if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (!xp.red || (xpp = xp.parent) == null) return root; if (xp == (xppl = xpp.left)) &#123; if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123; xppr.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.right) &#123; root = rotateLeft(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateRight(root, xpp); &#125; &#125; &#125; &#125; else &#123; if (xppl != null &amp;&amp; xppl.red) &#123; xppl.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.left) &#123; root = rotateRight(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateLeft(root, xpp); &#125; &#125; &#125; &#125; &#125; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123; if (x == null || x == root) return root; else if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (x.red) &#123; x.red = false; return root; &#125; else if ((xpl = xp.left) == x) &#123; if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123; xpr.red = false; xp.red = true; root = rotateLeft(root, xp); xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right; if ((sr == null || !sr.red) &amp;&amp; (sl == null || !sl.red)) &#123; xpr.red = true; x = xp; &#125; else &#123; if (sr == null || !sr.red) &#123; if (sl != null) sl.red = false; xpr.red = true; root = rotateRight(root, xpr); xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr != null) &#123; xpr.red = (xp == null) ? false : xp.red; if ((sr = xpr.right) != null) sr.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateLeft(root, xp); &#125; x = root; &#125; &#125; &#125; else &#123; // symmetric if (xpl != null &amp;&amp; xpl.red) &#123; xpl.red = false; xp.red = true; root = rotateRight(root, xp); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right; if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red)) &#123; xpl.red = true; x = xp; &#125; else &#123; if (sl == null || !sl.red) &#123; if (sr != null) sr.red = false; xpl.red = true; root = rotateLeft(root, xpl); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl != null) &#123; xpl.red = (xp == null) ? false : xp.red; if ((sl = xpl.left) != null) sl.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateRight(root, xp); &#125; x = root; &#125; &#125; &#125; &#125; &#125; /** * Recursive invariant check */ static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) &#123; TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right, tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next; if (tb != null &amp;&amp; tb.next != t) return false; if (tn != null &amp;&amp; tn.prev != t) return false; if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right) return false; if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash)) return false; if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash)) return false; if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red) return false; if (tl != null &amp;&amp; !checkInvariants(tl)) return false; if (tr != null &amp;&amp; !checkInvariants(tr)) return false; return true; &#125; &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huangyiblog.com/tags/Java/"}]},{"title":"LinkedList源码阅读","slug":"LinkedList源码阅读","date":"2019-09-02T05:18:43.000Z","updated":"2019-09-02T05:19:50.132Z","comments":true,"path":"uncategorized/LinkedList源码阅读/","link":"","permalink":"http://huangyiblog.com/uncategorized/LinkedList源码阅读/","excerpt":"","text":"LinkedList源码阅读(jdk1.8)简介：LinkedList继承自AbstractSequentialList，实现了List、Deque、Cloneable、Serializable接口。底层数据结构为双向链表。 实现了List接口，所以可以进行队列操作 实现了Deque接口，所以可以进行双端队列操作 实现了Cloneable接口，支持克隆 实现了Serializable接口，，支持序列化 LinkedList和ArrayList区别 LinkedList基于双向链表实现，ArrayList基于动态数组实现 LinkedList不支持随机访问，ArrayList支持 LinkedList插入删除元素效率更高，只需移动指针，平均时间复杂度为O(1)。而ArrayList插入删除元素受元素位置影响，平均时间复杂度为O(n) LinkedList与ArrayList都是非同步的，也就是都是非线程安全的 内存空间方面：LinkedList在结点结构上由于保存了每个结点的值，前驱和后继指针，所以会有一定的内存占用，ArrayList的内存占用主要体现在扩容后往往不能充分利用已开辟的空间，尾部会有空余。 构造函数123456789101112 /** * 构造一个空的 list. */public LinkedList() &#123;&#125; /** * 构造一个维护Collection集合元素的 list. */public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 详细源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; //List中元素的个数 transient int size = 0; /** * 指向头结点的指针 */ transient Node&lt;E&gt; first; /** * 指向尾结点的指针 */ transient Node&lt;E&gt; last; /** * 构造一个空的 list. */ public LinkedList() &#123; &#125; /** * 构造一个包含特定集合的List，返回顺序为该集合的迭代器顺序 */ public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; /** * 将e元素作为第一个结点. */ private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); //first指针指向这个新结点 first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++; &#125; /** * 将e元素作为最后一个结点 */ void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; /** * 在非空结点succ前面插入元素e */ void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; &#125; /** * 释放首个非空结点f. */ private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // 帮助进行垃圾回收 first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element; &#125; /** * 释放最后一个非空结点l */ private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // 帮助进行垃圾回收 last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element; &#125; /** * 释放非空结点x. */ E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; /** * 返回list里面的第一个元素 */ public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item; &#125; /** * 返回list中的最后一个元素 */ public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item; &#125; /** * 删除list中的第一个元素并返回该元素 */ public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); &#125; /** * 删除list中的最后一个元素并返回该元素 */ public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); &#125; /** * 在list头部插入指定元素e */ public void addFirst(E e) &#123; linkFirst(e); &#125; /** * 在list尾部添加指定元素e */ public void addLast(E e) &#123; linkLast(e); &#125; /** * 判断list中是否包含指定元素o */ public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; /** * 返回list中的元素个数 */ public int size() &#123; return size; &#125; /** * 在list尾部添加指定元素e */ public boolean add(E e) &#123; linkLast(e); return true; &#125; /** * 删除list中第一次出现的某个指定元素e * 如果list里面不存在该元素，则无需改变 */ public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125; /** * 添加指定集合的所有元素到list尾部 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; /** * 添加指定集合的所有元素到index开始的位置 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; for (Object o : a) &#123; @SuppressWarnings(\"unchecked\") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true; &#125; /** * 删除list中的所有元素 */ public void clear() &#123; //将结点之间的所有指针都指向null虽不是必须的，但有助于垃圾回收 for (Node&lt;E&gt; x = first; x != null; ) &#123; Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; &#125; first = last = null; size = 0; modCount++; &#125; // Positional Access Operations /** * 返回list中指定位置的元素 */ public E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125; /** * 替换list中指定位置的元素 */ public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal; &#125; /** * 插入指定元素element到list的index位置 */ public void add(int index, E element) &#123; checkPositionIndex(index); //如果index等于list的大小，那么将element添加到list尾部 if (index == size) linkLast(element); else //否则添加的index位置前面 linkBefore(element, node(index)); &#125; /** * 删除list中指定位置的结点 */ public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index)); &#125; /** * 判断给定下标位置是否存在元素 */ private boolean isElementIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt; size; &#125; /** * 判断给定下标是否有效 */ private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size; &#125; /** * 构造一个下标越界的返回信息 */ private String outOfBoundsMsg(int index) &#123; return \"Index: \"+index+\", Size: \"+size; &#125; private void checkElementIndex(int index) &#123; if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 返回指定下标的非空结点 */ Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); //如果index小于size的一半，那么从前往后遍历 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; //反之，从后往前遍历 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; // Search Operations /** * 返回某元素第一次出现的下标位置 */ public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125; /** * 返回某元素最后一次出现的下标位置 */ public int lastIndexOf(Object o) &#123; int index = size; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; &#125; &#125; return -1; &#125; // 队列操作 /** * 返回list的首个元素 */ public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; &#125; /** * 返回list的首个元素 */ public E element() &#123; return getFirst(); &#125; /** * 删除list的首个元素 */ public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f); &#125; /** * 删除list的首个元素 */ public E remove() &#123; return removeFirst(); &#125; /** * 添加指定元素作为list的尾元素 */ public boolean offer(E e) &#123; return add(e); &#125; // 出队操作 /** * 在list首部插入元素 */ public boolean offerFirst(E e) &#123; addFirst(e); return true; &#125; /** * 插入指定元素到list尾部 */ public boolean offerLast(E e) &#123; addLast(e); return true; &#125; /** * 返回list的首个元素 * @since 1.6 */ public E peekFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; &#125; /** * 返回list的最后一个元素 * @since 1.6 */ public E peekLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : l.item; &#125; /** * 删除list的首个元素 * @since 1.6 */ public E pollFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f); &#125; /** * 删除list的最后一个元素 * @since 1.6 */ public E pollLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l); &#125; /** * 在list首部添加元素 * @since 1.6 */ public void push(E e) &#123; addFirst(e); &#125; /** * 移除list中的首个元素 * @since 1.6 */ public E pop() &#123; return removeFirst(); &#125; /** * 删除list中第一个出现的指定元素o * @since 1.6 */ public boolean removeFirstOccurrence(Object o) &#123; return remove(o); &#125; /** * 删除list中最后一个出现的指定元素o * @since 1.6 */ public boolean removeLastOccurrence(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125; /** * 返回从index开始的list迭代器 */ public ListIterator&lt;E&gt; listIterator(int index) &#123; checkPositionIndex(index); return new ListItr(index); &#125;//List迭代器 private class ListItr implements ListIterator&lt;E&gt; &#123; //上一次返回的结点 private Node&lt;E&gt; lastReturned; //下一个结点 private Node&lt;E&gt; next; //下一个结点对应的索引值 private int nextIndex; //期望改变的索引值，用来实现快速失败机制 private int expectedModCount = modCount; //构造函数,从index开始迭代 ListItr(int index) &#123; // assert isPositionIndex(index); next = (index == size) ? null : node(index); nextIndex = index; &#125; //判断是否存在下一个元素 public boolean hasNext() &#123; //根据下一个结点的索引值是否小于size来判断是否到达list末尾 return nextIndex &lt; size; &#125; //获取下一个元素 public E next() &#123; checkForComodification(); if (!hasNext()) throw new NoSuchElementException(); lastReturned = next; next = next.next; nextIndex++; return lastReturned.item; &#125; //是否存在前一个元素 public boolean hasPrevious() &#123; //通过下一个结点的索引是否大于0来判断是否到达首结点 return nextIndex &gt; 0; &#125; //获取上一个元素 public E previous() &#123; checkForComodification(); if (!hasPrevious()) throw new NoSuchElementException(); //让next指针指向链表的上一个元素 lastReturned = next = (next == null) ? last : next.prev; nextIndex--; return lastReturned.item; &#125; //获取下一个元素的索引 public int nextIndex() &#123; return nextIndex; &#125; //获取上一个元素的索引 public int previousIndex() &#123; return nextIndex - 1; &#125; //删除当前元素 public void remove() &#123; checkForComodification(); if (lastReturned == null) throw new IllegalStateException(); Node&lt;E&gt; lastNext = lastReturned.next; unlink(lastReturned); if (next == lastReturned) next = lastNext; else nextIndex--; lastReturned = null; expectedModCount++; &#125; //设置当前结点为e public void set(E e) &#123; if (lastReturned == null) throw new IllegalStateException(); checkForComodification(); lastReturned.item = e; &#125; //如果next指针为空，将元素e添加到链表的末尾，否则将元素e添加到当前结点的前面 public void add(E e) &#123; checkForComodification(); lastReturned = null; if (next == null) linkLast(e); else linkBefore(e, next); nextIndex++; expectedModCount++; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123; action.accept(next.item); lastReturned = next; next = next.next; nextIndex++; &#125; checkForComodification(); &#125; // 判断modCount和expectedModCount是否相等，依次来实现fail-fast机制 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; //结点的数据结构 private static class Node&lt;E&gt; &#123; //元素值 E item; //后继指针 Node&lt;E&gt; next; //前驱指针 Node&lt;E&gt; prev; //结点的构造函数 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; /** * 反向迭代器 * @since 1.6 */ public Iterator&lt;E&gt; descendingIterator() &#123; return new DescendingIterator(); &#125; /** * Adapter to provide descending iterators via ListItr.previous */ private class DescendingIterator implements Iterator&lt;E&gt; &#123; private final ListItr itr = new ListItr(size()); public boolean hasNext() &#123; return itr.hasPrevious(); &#125; public E next() &#123; return itr.previous(); &#125; public void remove() &#123; itr.remove(); &#125; &#125; @SuppressWarnings(\"unchecked\") private LinkedList&lt;E&gt; superClone() &#123; try &#123; return (LinkedList&lt;E&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(e); &#125; &#125; /** * 返回一个list实例的浅拷贝 */ public Object clone() &#123; LinkedList&lt;E&gt; clone = superClone(); // Put clone into \"virgin\" state clone.first = clone.last = null; clone.size = 0; clone.modCount = 0; // Initialize clone with our elements for (Node&lt;E&gt; x = first; x != null; x = x.next) clone.add(x.item); return clone; &#125; /** * 按照合适的顺序（从第一个到最后一个）返回一个包含list中所有元素的数组 */ public Object[] toArray() &#123; Object[] result = new Object[size]; int i = 0; for (Node&lt;E&gt; x = first; x != null; x = x.next) result[i++] = x.item; return result; &#125; /** * 使用泛型返回LinkedList的模板数组 */ @SuppressWarnings(\"unchecked\") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); int i = 0; Object[] result = a; for (Node&lt;E&gt; x = first; x != null; x = x.next) result[i++] = x.item; if (a.length &gt; size) a[size] = null; return a; &#125; private static final long serialVersionUID = 876323262645176354L; /** * 序列化的写入函数，将LinkedList的所有元素写入到输出流s中 */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic s.defaultWriteObject(); // Write out size s.writeInt(size); // Write out all elements in the proper order. for (Node&lt;E&gt; x = first; x != null; x = x.next) s.writeObject(x.item); &#125; /** * 序列化的读取函数 */ @SuppressWarnings(\"unchecked\") private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // Read in size int size = s.readInt(); // Read in all elements in the proper order. for (int i = 0; i &lt; size; i++) linkLast((E)s.readObject()); &#125; /** * * @since 1.8 */ @Override public Spliterator&lt;E&gt; spliterator() &#123; return new LLSpliterator&lt;E&gt;(this, -1, 0); &#125; /** A customized variant of Spliterators.IteratorSpliterator */ static final class LLSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; &#123; static final int BATCH_UNIT = 1 &lt;&lt; 10; // batch array size increment static final int MAX_BATCH = 1 &lt;&lt; 25; // max batch array size; final LinkedList&lt;E&gt; list; // null OK unless traversed Node&lt;E&gt; current; // current node; null until initialized int est; // size estimate; -1 until first needed int expectedModCount; // initialized when est set int batch; // batch size for splits LLSpliterator(LinkedList&lt;E&gt; list, int est, int expectedModCount) &#123; this.list = list; this.est = est; this.expectedModCount = expectedModCount; &#125; final int getEst() &#123; int s; // force initialization final LinkedList&lt;E&gt; lst; if ((s = est) &lt; 0) &#123; if ((lst = list) == null) s = est = 0; else &#123; expectedModCount = lst.modCount; current = lst.first; s = est = lst.size; &#125; &#125; return s; &#125; public long estimateSize() &#123; return (long) getEst(); &#125; public Spliterator&lt;E&gt; trySplit() &#123; Node&lt;E&gt; p; int s = getEst(); if (s &gt; 1 &amp;&amp; (p = current) != null) &#123; int n = batch + BATCH_UNIT; if (n &gt; s) n = s; if (n &gt; MAX_BATCH) n = MAX_BATCH; Object[] a = new Object[n]; int j = 0; do &#123; a[j++] = p.item; &#125; while ((p = p.next) != null &amp;&amp; j &lt; n); current = p; batch = j; est = s - j; return Spliterators.spliterator(a, 0, j, Spliterator.ORDERED); &#125; return null; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Node&lt;E&gt; p; int n; if (action == null) throw new NullPointerException(); if ((n = getEst()) &gt; 0 &amp;&amp; (p = current) != null) &#123; current = null; est = 0; do &#123; E e = p.item; p = p.next; action.accept(e); &#125; while (p != null &amp;&amp; --n &gt; 0); &#125; if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; public boolean tryAdvance(Consumer&lt;? super E&gt; action) &#123; Node&lt;E&gt; p; if (action == null) throw new NullPointerException(); if (getEst() &gt; 0 &amp;&amp; (p = current) != null) &#123; --est; E e = p.item; current = p.next; action.accept(e); if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; return false; &#125; public int characteristics() &#123; return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huangyiblog.com/tags/Java/"}]},{"title":"Vector源码阅读","slug":"Vector源码阅读","date":"2019-09-02T05:15:22.000Z","updated":"2019-09-02T05:18:07.312Z","comments":true,"path":"uncategorized/Vector源码阅读/","link":"","permalink":"http://huangyiblog.com/uncategorized/Vector源码阅读/","excerpt":"","text":"Vector源码阅读(基于jdk1.8)前几天看了ArrayList，今天再来看看Vector，这两个其实大同小异，基本结构都差不多，只是一些细节上有区别：比如线程安全与否，扩容的大小等，Vector的线程安全通过在方法上直接加synchronized实现。扩容默认扩大为原来的2倍。 还是先来看类的定义，搞清类的结构层次：可以看到Vector继承了AbstractList，实现了List，RandomAccess，Cloneable，Serializable接口。从上面我们就可以得出Vector是一个矢量队列，支持一些增加、删除、修改、遍历等功能，可以快速随机访问，可以被克隆，支持序列化等123public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 接下来看一些变量定义123456789//底层结构为object数组，和ArrayList一样，不过我们可以注意到访问修饰符有所不同，Vector用protected修饰，而ArrayList用private修饰。我们知道private变量只能被当前类的方法访问，而protected可以被同一包中的所有类和其他包的子类访问protected Object[] elementData;//动态数组的实际有效大小protected int elementCount;//动态数组的增长系数：若开始没有人为指定，则默认增加一倍的大小protected int capacityIncrement;//Vector的序列版本号private static final long serialVersionUID = -2767605614048989439L; Vector的四种构造函数 默认构造函数Vector() capacity是Vector的默认容量大小。当由于增加数据导致容量增加时，每次容量会增加一倍。Vector(int capacity) capacity是Vector的默认容量大小，capacityIncrement是每次Vector容量增加时的增量值。Vector(int capacity, int capacityIncrement) 创建一个包含collection的VectorVector(Collection&lt;? extends E&gt; collection) 1234567891011121314151617181920212223242526272829303132333435363738/** * 构造一个空的Vector，输入参数为自定义的初始容量和增长系数 */public Vector(int initialCapacity, int capacityIncrement) &#123; super(); //如果初始容量参数&lt;0，抛出异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement;&#125;/** * 构造一个初始容量为initialCapacity的空的Vector，默认增加一倍大小 */public Vector(int initialCapacity) &#123; this(initialCapacity, 0);&#125;/** * 默认构造函数 */public Vector() &#123; this(10);&#125;/** * 创建一个包含collection的Vector */public Vector(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); elementCount = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, elementCount, Object[].class);&#125; Vector扩容Vector扩容默认扩容为原来的2倍 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 确定Vector数组当前的容量大小 */ public synchronized void ensureCapacity(int minCapacity) &#123; if (minCapacity &gt; 0) &#123; modCount++; ensureCapacityHelper(minCapacity); &#125; &#125; /** * 如果当前容量&gt;当前数组长度，那么调用grow(minCapacity)进行扩容，注意这个方法并没有用synchronized修饰，因为他是在ensureCapacity()中被调用的，而ensureCapacity()已经被加锁了 */ private void ensureCapacityHelper(int minCapacity) &#123; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * 设置能够扩展的最大数组大小 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //扩容核心函数 private void grow(int minCapacity) &#123; // overflow-conscious code //将旧的容量赋值为数组长度 int oldCapacity = elementData.length; //如果容量增量系数&gt;0那么设置新容量为oldCapacity+capacityIncrement，否则为oldCapacity + oldCapacity int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); //如果新容量&lt;数组实际所需容量，令newCapacity = minCapacity if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //如果新容量大于数组最大扩容大小，如果当前所需容量&gt;MAX_ARRAY_SIZE，那么新容量设为 Integer.MAX_VALUE，否则设为 MAX_ARRAY_SIZE if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; Vector遍历方式Vector主要支持4中遍历方式 通过迭代器遍历元素 通过for-each循环遍历 利用下标访问随机遍历 使用Enumeration遍历 测试代码 123456789101112131415161718192021222324252627282930313233package Collection;import java.util.*;public class TestVector &#123; public static void main(String[] args) &#123; Vector v = new Vector(); v.add(1); v.add(2); v.add(3); v.add(4); v.add(5); Enumeration enu = v.elements(); while(enu.hasMoreElements()) &#123; System.out.println(enu.nextElement()); &#125; Integer value = null; for( Object val : v) &#123; System.out.println(val); &#125; Iterator&lt;Integer&gt; iter = v.iterator(); while(iter.hasNext()) &#123; System.out.println(iter.next()); &#125; for(int i = 0; i &lt; v.size(); i++) &#123; System.out.println(v.get(i)); &#125; &#125;&#125; 剩余主要方法源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857 /** * 将数组Vector中的全部元素都拷贝到数组anArray中去，调用本地方法arraycopy实现 */ public synchronized void copyInto(Object[] anArray) &#123; System.arraycopy(elementData, 0, anArray, 0, elementCount); &#125; /** * 将当前容量设为实际元素个数 */ public synchronized void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (elementCount &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, elementCount); &#125; &#125; /** *设置Vector数组的大小 */ public synchronized void setSize(int newSize) &#123; modCount++; // 若 \"newSize 大于 Vector容量\"，则调整Vector的大小。 if (newSize &gt; elementCount) &#123; ensureCapacityHelper(newSize); &#125; else &#123; // 若 \"newSize 小于/等于 Vector容量\"，则将newSize位置开始的元素都设置为null for (int i = newSize ; i &lt; elementCount ; i++) &#123; elementData[i] = null; &#125; &#125; elementCount = newSize; &#125; /** * 返回Vector的当前容量 */ public synchronized int capacity() &#123; return elementData.length; &#125; /** * 返回Vector里面的元素个数 */ public synchronized int size() &#123; return elementCount; &#125; /** * 判断Vector是否为空 */ public synchronized boolean isEmpty() &#123; return elementCount == 0; &#125; // 返回“Vector中全部元素对应的Enumeration” public Enumeration&lt;E&gt; elements() &#123; return new Enumeration&lt;E&gt;() &#123; int count = 0; //判断是否存在下一个元素 public boolean hasMoreElements() &#123; return count &lt; elementCount; &#125; //获取下一个元素 public E nextElement() &#123; synchronized (Vector.this) &#123; if (count &lt; elementCount) &#123; return elementData(count++); &#125; &#125; throw new NoSuchElementException(\"Vector Enumeration\"); &#125; &#125;; &#125; /** * 返回Vector数组里面是否包含对象o */ public boolean contains(Object o) &#123; return indexOf(o, 0) &gt;= 0; &#125; /** * 返回Vector数组中第一次出现对象o的下标，如果不存在，那么返回-1 */ public int indexOf(Object o) &#123; return indexOf(o, 0); &#125; /** * 返回从index出开始第一次出现对象o的下标，如果不存在，那么返回-1 */ public synchronized int indexOf(Object o, int index) &#123; if (o == null) &#123; for (int i = index ; i &lt; elementCount ; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = index ; i &lt; elementCount ; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回对象o在数组中最后一次出现的下标，如果不存在，返回-1 */ public synchronized int lastIndexOf(Object o) &#123; return lastIndexOf(o, elementCount-1); &#125; /** * 返回从index开始对象o在数组中最后一次出现的下标，如果不存在，返回-1 */ public synchronized int lastIndexOf(Object o, int index) &#123; if (index &gt;= elementCount) throw new IndexOutOfBoundsException(index + \" &gt;= \"+ elementCount); if (o == null) &#123; for (int i = index; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = index; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回数组指定下标位置的元素，如果index&gt;=elementCount，则抛出数组越界异常 * (&#123;@code index &lt; 0 || index &gt;= size()&#125;) */ public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); &#125; return elementData(index); &#125; /** * 返回数组的第一个元素 */ public synchronized E firstElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(0); &#125; /** * 返回数组的最后一个元素 */ public synchronized E lastElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(elementCount - 1); &#125; /** * 将数组下标为index位置的元素设置为给定obj对象 */ public synchronized void setElementAt(E obj, int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); &#125; elementData[index] = obj; &#125; /** * 删除指定下标位置的元素 */ public synchronized void removeElementAt(int index) &#123; modCount++; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); &#125; else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; int j = elementCount - index - 1; if (j &gt; 0) &#123; //将数组index+1开始往后元素全都往前移一位 System.arraycopy(elementData, index + 1, elementData, index, j); &#125; elementCount--; //让最后一个元素指向null，方便GC工作 elementData[elementCount] = null; /* to let gc do its work */ &#125; /** * 在指定位置插入元素 */ public synchronized void insertElementAt(E obj, int index) &#123; modCount++; if (index &gt; elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt; \" + elementCount); &#125; //增加数组容量 ensureCapacityHelper(elementCount + 1); //从index开始将数组所以元素都往后移一位 System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); //复制新对象 elementData[index] = obj; //元素个数+1 elementCount++; &#125; /** * 在数组末尾增加一个元素，首先数组的容量增加1 */ public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; &#125; /** * 删除数组中第一次出现的obj对象 */ public synchronized boolean removeElement(Object obj) &#123; modCount++; int i = indexOf(obj); if (i &gt;= 0) &#123; removeElementAt(i); return true; &#125; return false; &#125; /** * 删除数组中所有元素，为了便于GC，让每个位置都指向null */ public synchronized void removeAllElements() &#123; modCount++; // Let gc do its work for (int i = 0; i &lt; elementCount; i++) elementData[i] = null; elementCount = 0; &#125; /** * 返回一个object的克隆 */ public synchronized Object clone() &#123; try &#123; @SuppressWarnings(\"unchecked\") Vector&lt;E&gt; v = (Vector&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, elementCount); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; &#125; /** * 返回一个数组包含Vector中的所有元素 * @since 1.2 */ public synchronized Object[] toArray() &#123; return Arrays.copyOf(elementData, elementCount); &#125; /** * 返回Vector的模板数组。所谓模板数组，即可以将T设为任意的数据类型 * @since 1.2 */ @SuppressWarnings(\"unchecked\") public synchronized &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; elementCount) return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass()); System.arraycopy(elementData, 0, a, 0, elementCount); if (a.length &gt; elementCount) a[elementCount] = null; return a; &#125; // Positional Access Operations @SuppressWarnings(\"unchecked\") E elementData(int index) &#123; return (E) elementData[index]; &#125; /** * 返回指定下标位置的元素 * @since 1.2 */ public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index); &#125; /** * 用element替换数组中指定下标位置的元素 * @since 1.2 */ public synchronized E set(int index, E element) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; /** * 在数组末尾添加指定元素 * @since 1.2 */ public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; &#125; /** * 删除数组中第一次出现的指定对象 * @since 1.2 */ public boolean remove(Object o) &#123; return removeElement(o); &#125; /** * 在数组指定位置插入元素 * @since 1.2 */ public void add(int index, E element) &#123; insertElementAt(element, index); &#125; /** * 删除数组指定位置的元素 * @since 1.2 */ public synchronized E remove(int index) &#123; modCount++; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); int numMoved = elementCount - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--elementCount] = null; // Let gc do its work return oldValue; &#125; /** *删除数组所有元素 * @since 1.2 */ public void clear() &#123; removeAllElements(); &#125; // Bulk Operations /** * 返回一个数组是否包含给定集合中的所有元素 */ public synchronized boolean containsAll(Collection&lt;?&gt; c) &#123; return super.containsAll(c); &#125; /** * 在Vector数组末尾添加特定集合中的所有元素 * @since 1.2 */ public synchronized boolean addAll(Collection&lt;? extends E&gt; c) &#123; modCount++; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); System.arraycopy(a, 0, elementData, elementCount, numNew); elementCount += numNew; return numNew != 0; &#125; /** * 删除Vector中在给定集合中存在的所有元素 * @since 1.2 */ public synchronized boolean removeAll(Collection&lt;?&gt; c) &#123; return super.removeAll(c); &#125; /** * 删除Vector中在给定集合中不存在的元素 * @since 1.2 */ public synchronized boolean retainAll(Collection&lt;?&gt; c) &#123; return super.retainAll(c); &#125; /** * 将给定集合的所有元素插入到Vector的特定位置 * @since 1.2 */ public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; modCount++; if (index &lt; 0 || index &gt; elementCount) throw new ArrayIndexOutOfBoundsException(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); int numMoved = elementCount - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); elementCount += numNew; return numNew != 0; &#125; /** * 比较两个数组是否相等 */ public synchronized boolean equals(Object o) &#123; return super.equals(o); &#125; /** * 返回哈希值 */ public synchronized int hashCode() &#123; return super.hashCode(); &#125; /** * 返回数组的字符串表示 */ public synchronized String toString() &#123; return super.toString(); &#125; /** * 获取Vector中fromIndex(包括)到toIndex(不包括)的子集 */ public synchronized List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; return Collections.synchronizedList(super.subList(fromIndex, toIndex), this); &#125; /** * 删除Vector中fromIndex到toIndex的元素 */ protected synchronized void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = elementCount - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work int newElementCount = elementCount - (toIndex-fromIndex); while (elementCount != newElementCount) elementData[--elementCount] = null; &#125; /** * 从二进制流中读取对象实例 */ private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; ObjectInputStream.GetField gfields = in.readFields(); int count = gfields.get(\"elementCount\", 0); Object[] data = (Object[])gfields.get(\"elementData\", null); if (count &lt; 0 || data == null || count &gt; data.length) &#123; throw new StreamCorruptedException(\"Inconsistent vector internals\"); &#125; elementCount = count; elementData = data.clone(); &#125; /** * 序列化保存一个对象的状态 */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; final java.io.ObjectOutputStream.PutField fields = s.putFields(); final Object[] data; synchronized (this) &#123; fields.put(\"capacityIncrement\", capacityIncrement); fields.put(\"elementCount\", elementCount); data = elementData.clone(); &#125; fields.put(\"elementData\", data); s.writeFields(); &#125; /** * 返回一个列表迭代器 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public synchronized ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; elementCount) throw new IndexOutOfBoundsException(\"Index: \"+index); return new ListItr(index); &#125; /** * Returns a list iterator over the elements in this list (in proper * sequence). * * &lt;p&gt;The returned list iterator is &lt;a href=\"#fail-fast\"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @see #listIterator(int) */ public synchronized ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** * Returns an iterator over the elements in this list in proper sequence. * * &lt;p&gt;The returned iterator is &lt;a href=\"#fail-fast\"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @return an iterator over the elements in this list in proper sequence */ public synchronized Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; // Racy but within spec, since modifications are checked // within or after synchronization in next/previous return cursor != elementCount; &#125; public E next() &#123; synchronized (Vector.this) &#123; checkForComodification(); int i = cursor; if (i &gt;= elementCount) throw new NoSuchElementException(); cursor = i + 1; return elementData(lastRet = i); &#125; &#125; public void remove() &#123; if (lastRet == -1) throw new IllegalStateException(); synchronized (Vector.this) &#123; checkForComodification(); Vector.this.remove(lastRet); expectedModCount = modCount; &#125; cursor = lastRet; lastRet = -1; &#125; @Override public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); synchronized (Vector.this) &#123; final int size = elementCount; int i = cursor; if (i &gt;= size) &#123; return; &#125; @SuppressWarnings(\"unchecked\") final E[] elementData = (E[]) Vector.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; action.accept(elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; /** * An optimized version of AbstractList.ListItr */ final class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public E previous() &#123; synchronized (Vector.this) &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); cursor = i; return elementData(lastRet = i); &#125; &#125; public void set(E e) &#123; if (lastRet == -1) throw new IllegalStateException(); synchronized (Vector.this) &#123; checkForComodification(); Vector.this.set(lastRet, e); &#125; &#125; public void add(E e) &#123; int i = cursor; synchronized (Vector.this) &#123; checkForComodification(); Vector.this.add(i, e); expectedModCount = modCount; &#125; cursor = i + 1; lastRet = -1; &#125; &#125; @Override public synchronized void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(\"unchecked\") final E[] elementData = (E[]) this.elementData; final int elementCount = this.elementCount; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; elementCount; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public synchronized boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); // figure out which elements are to be removed // any exception thrown from the filter predicate at this stage // will leave the collection unmodified int removeCount = 0; final int size = elementCount; final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; @SuppressWarnings(\"unchecked\") final E element = (E) elementData[i]; if (filter.test(element)) &#123; removeSet.set(i); removeCount++; &#125; &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; // shift surviving elements left over the spaces left by removed elements final boolean anyToRemove = removeCount &gt; 0; if (anyToRemove) &#123; final int newSize = size - removeCount; for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123; i = removeSet.nextClearBit(i); elementData[j] = elementData[i]; &#125; for (int k=newSize; k &lt; size; k++) &#123; elementData[k] = null; // Let gc do its work &#125; elementCount = newSize; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; return anyToRemove; &#125; @Override @SuppressWarnings(\"unchecked\") public synchronized void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final int expectedModCount = modCount; final int size = elementCount; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; elementData[i] = operator.apply((E) elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; @SuppressWarnings(\"unchecked\") @Override public synchronized void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, elementCount, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; /** * Creates a &lt;em&gt;&lt;a href=\"Spliterator.html#binding\"&gt;late-binding&lt;/a&gt;&lt;/em&gt; * and &lt;em&gt;fail-fast&lt;/em&gt; &#123;@link Spliterator&#125; over the elements in this * list. * * &lt;p&gt;The &#123;@code Spliterator&#125; reports &#123;@link Spliterator#SIZED&#125;, * &#123;@link Spliterator#SUBSIZED&#125;, and &#123;@link Spliterator#ORDERED&#125;. * Overriding implementations should document the reporting of additional * characteristic values. * * @return a &#123;@code Spliterator&#125; over the elements in this list * @since 1.8 */ @Override public Spliterator&lt;E&gt; spliterator() &#123; return new VectorSpliterator&lt;&gt;(this, null, 0, -1, 0); &#125; /** Similar to ArrayList Spliterator */ static final class VectorSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; &#123; private final Vector&lt;E&gt; list; private Object[] array; private int index; // current index, modified on advance/split private int fence; // -1 until used; then one past last index private int expectedModCount; // initialized when fence set /** Create new spliterator covering the given range */ VectorSpliterator(Vector&lt;E&gt; list, Object[] array, int origin, int fence, int expectedModCount) &#123; this.list = list; this.array = array; this.index = origin; this.fence = fence; this.expectedModCount = expectedModCount; &#125; private int getFence() &#123; // initialize on first use int hi; if ((hi = fence) &lt; 0) &#123; synchronized(list) &#123; array = list.elementData; expectedModCount = list.modCount; hi = fence = list.elementCount; &#125; &#125; return hi; &#125; public Spliterator&lt;E&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid) ? null : new VectorSpliterator&lt;E&gt;(list, array, lo, index = mid, expectedModCount); &#125; @SuppressWarnings(\"unchecked\") public boolean tryAdvance(Consumer&lt;? super E&gt; action) &#123; int i; if (action == null) throw new NullPointerException(); if (getFence() &gt; (i = index)) &#123; index = i + 1; action.accept((E)array[i]); if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; return false; &#125; @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; int i, hi; // hoist accesses and checks from loop Vector&lt;E&gt; lst; Object[] a; if (action == null) throw new NullPointerException(); if ((lst = list) != null) &#123; if ((hi = fence) &lt; 0) &#123; synchronized(lst) &#123; expectedModCount = lst.modCount; a = array = lst.elementData; hi = fence = lst.elementCount; &#125; &#125; else a = array; if (a != null &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) &#123; while (i &lt; hi) action.accept((E) a[i++]); if (lst.modCount == expectedModCount) return; &#125; &#125; throw new ConcurrentModificationException(); &#125; public long estimateSize() &#123; return (long) (getFence() - index); &#125; public int characteristics() &#123; return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://huangyiblog.com/tags/Java/"}]},{"title":"字节跳动提前批第二批笔试题","slug":"字节跳动提前批第二批笔试题","date":"2019-07-16T05:11:27.000Z","updated":"2019-07-16T05:16:55.451Z","comments":true,"path":"题解集/字节跳动提前批第二批笔试题/","link":"","permalink":"http://huangyiblog.com/题解集/字节跳动提前批第二批笔试题/","excerpt":"","text":"第二批一共四道编程题…2道dp一道暴力搜索，一道田忌赛马，虽然有两道是经典题，但本菜鸡还是扛不住，宇宙条这难度还是让人服气的，另外面经就不写了，凉面写起来不舒服… 第一题田忌赛马赤裸裸的田忌赛马，有兴趣的话可以去网上搜一搜hdu，没什么变动。有两队人，输入n，表示每队有n个人，接着输入两行，每行n个数字，每个数字代表这个队员的速度。两队进行赛跑，赢一局，加一分，输一局，减一分，平局，不加不减，问你怎么跑第一队积分最高。 思路：对两队人按照从快到慢都进行排序，之后从慢马开始比：如果a队跑的慢的比b队跑得慢的快，那么直接加一分，继续比如果a队跑的慢的比b队跑的慢的慢，那么我们实际操作时让a队跑的慢的跟b队跑的最快的比，此时减一分如果两队的跑的慢的一样快，那么此时先比较两队跑的快的，a队跑的快的如果比b队跑得快的还要快，那么加一分，反之减一分，其余情况为平局，不加不减。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// toutiao1.cpp// Algorithm//// Created by huangyi on 2019/7/7.// Copyright © 2019 Leetcode. All rights reserved.//#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 2020;int a[maxn], b[maxn];bool cmp(int a, int b) &#123; return a &gt; b;&#125;int main()&#123; int n, len1, len2; int res = 0; scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf(\"%d %d\", &amp;a[i], &amp;b[i]); &#125; //将两队马从快到慢排序 sort(a, a + n, cmp); sort(b, b + n, cmp); //最慢的马的位置 len1 = len2 = n - 1; int i = 0, j = 0; while(i &lt;= len1 &amp;&amp; j &lt;= len2) &#123; //a队慢马 &gt; b队慢马，加一分 if(a[len1] &gt; b[len2]) &#123; res++; len1--; len2--; &#125; else if(a[len1] &lt; b[len2]) &#123; res--;//我们让j++,len1--就是让a队的慢马跟b队的快马比 j++; len1--; &#125; else &#123; if(i &lt; len1) &#123; if(a[i] &lt;= b[j]) &#123; //a队的快马不能赢 if(a[len1] &lt; b[j]) &#123; res--; &#125; len1--; j++; &#125; else &#123; //a队的快马赢了 res++; i++; j++; &#125; &#125; else &#123; //平局 len1--; len2--; &#125; &#125; &#125; printf(\"%d\\n\", res); return 0;&#125; 第二题，捡石头游戏输入n，表示一共有n块石头，之后输入n个数，每个数代表当前石头的积分。现在有两队人，a队和b队。假设a队先开始捡石头，第一次可以捡1到2块，之后b队捡石头，b队可以捡一队的两倍范围，也就是b队可以捡2到4块，一直轮流下去。问你怎么减石头，a队可以得到最高的积分，输出该积分。 123456输入样例：52 7 9 4 3输出样例：9 1234567891011121314151617181920212223242526272829303132333435363738394041//// toutiao2.cpp// Algorithm//// Created by huangyi on 2019/7/7.// Copyright © 2019 Leetcode. All rights reserved.//#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[2010],b[2010],c[2010],dp[2010][2010];int main()&#123; scanf( \"%d\" , &amp;n); for( int i=1 ; i&lt;=n ; i++ )&#123; scanf( \"%d\" , &amp;a[i] ); &#125; b[n] = a[n]; for( int i=n-1 ; i&gt;=1 ; i-- )&#123; b[i] = a[i]+b[i+1]; &#125; for( int i=1 ; i&lt;=n ; i++ )&#123; dp[n][i] = a[n]; &#125; for( int i=n-1 ; i&gt;=1 ; i-- )&#123; for( int k=1 ; i+k&lt;=n ; k++ )&#123; c[k] = b[i]-dp[i+k][k]; &#125; for( int k=2 ; i+k&lt;=n ; k++ )&#123; c[k] = max( c[k] , c[k-1] ); &#125; for( int j=1 ; j&lt;=n ; j++ )&#123; int k = min(j*2,n-i); dp[i][j] = c[k]; if( i+j+j&gt;n ) dp[i][j] = b[i]; &#125; &#125; printf( \"%d\\n\" , dp[1][1] ); return 0;&#125; 第三题，围桌子输入n和m，表示一共有n个人，之后一行输入n个数，分别表示每个人的身高，现在要求这些人围成一圈，要求是相邻的两个人身高不能超过m，问你一共有几种方案。 一开始没什么想法，用了两个if竟然也过了好几个样例..后来看了下，n个人的范围很小，不超过10。可以猜想这题应该是个暴力搜索。不过代码最后没有提交测试过，不知道对不对… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//// toutiao3.cpp// Algorithm//// Created by huangyi on 2019/7/7.// Copyright © 2019 Leetcode. All rights reserved.//#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,ans,a[15],b[15],v[15];void dfs( int idx )&#123; if( idx == n )&#123; if( abs(b[0] - b[n-1]) &lt;= m ) ans++; return; &#125; for( int i = 0; i &lt; n; i++ )&#123; if( v[i] ) continue; if( abs(a[i] - b[idx - 1]) &lt;= m )&#123; v[i] = 1; b[idx] = a[i]; dfs(idx + 1); v[i] = 0; &#125; &#125;&#125;int main()&#123; scanf( \"%d%d\" , &amp;n , &amp;m ); for( int i=0 ; i&lt;n ; i++ )&#123; scanf( \"%d\" , &amp;a[i] ); &#125; if( n==1 )&#123; printf( \"1\\n\" ); &#125;else if( n==2&amp;&amp;abs( a[0]-a[1] )&lt;=m )&#123; printf( \"1\\n\" ); &#125;else&#123; for( int i = 0; i &lt; n; i++ )&#123; v[i] = 0; &#125; ans = 0; for( int i=0 ; i&lt;n ; i++ )&#123; b[0] = a[i]; v[i] = 1; dfs( 1 ); &#125; printf( \"%d\\n\" , ans ); &#125; return 0;&#125; 01背包输入n和m，代表背包上限和物品个数，输入w数组和c数组，分别代表每个物品的消耗和积分，问你怎么取物品放到背包里，积分能够最大。 123456789101112131415161718192021222324252627282930313233//// toutiao4.cpp// Algorithm//// Created by huangyi on 2019/7/7.// Copyright © 2019 Leetcode. All rights reserved.//#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100;const int maxv = 2010;//w[]消耗数组，c[]积分数组，dp[][]//令dp[i][j]表示前i件物品（1&lt;=i&lt;=n,0&lt;=j&lt;=n）恰好装入容量为j的背包中所能获得的最大价值int w[maxn],c[maxn],dp[maxn][maxv];int main()&#123; int n,m; //n为背包上限，m为物品个数 scanf(\"%d%d\",&amp;n, &amp;m); for(int i = 0;i &lt; m;i++)&#123; scanf(\"%d %d\",&amp;w[i], &amp;c[i]); &#125; for(int i = 1; i &lt;= m; i++)&#123; for(int j = w[i]; j &lt;= n; j++)&#123; dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]]+c[i]); &#125; &#125; printf(\"%d\\n\",dp[m][n]); return 0;&#125; 阿里巴巴两道笔试题三个线程交替打印alialiali…，一个打印a，一个打印l，一个打印i思路：可以利用Condition的await和signal方法来等待和唤醒线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package thread;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class FirstThreadTest &#123; public static void main(String[] args) &#123; final AlternateDemo ad = new AlternateDemo(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; ad.loopA(); &#125; &#125; &#125;, \"a\").start(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; ad.loopB(); &#125; &#125; &#125;, \"l\").start(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; ad.loopC(); //System.out.println(\"-----------------------------------\"); &#125; &#125; &#125;, \"i\").start(); &#125;&#125;class AlternateDemo &#123; private int number = 1; //当前正在执行线程的标记 private Lock lock = new ReentrantLock(); private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); public void loopA() &#123; lock.lock(); try &#123; //1. 判断 if (number != 1) &#123; condition1.await(); &#125; //2. 打印 System.out.print(Thread.currentThread().getName()); //3. 唤醒 number = 2; condition2.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void loopB() &#123; lock.lock(); try &#123; //1. 判断 if (number != 2) &#123; condition2.await(); &#125; //2. 打印 System.out.print(Thread.currentThread().getName()); //3. 唤醒 number = 3; condition3.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void loopC() &#123; lock.lock(); try &#123; //1. 判断 if (number != 3) &#123; condition3.await(); &#125; //2. 打印 System.out.print(Thread.currentThread().getName()); //3. 唤醒 number = 1; condition1.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 字符串模式匹配有一个字符串它的构成是词+空格的组合，如“北京 杭州 杭州 北京”， 要求输入一个匹配模式（简单的以字符来写）， 比如 aabb, 来判断该字符串是否符合该模式， 举个例子： pattern = “abba”, str=”北京 杭州 杭州 北京” 返回 true pattern = “aabb”, str=”北京 杭州 杭州 北京” 返回 false pattern = “baab”, str=”北京 杭州 杭州 北京” 返回 true 思路，建立两个map，把两个字符数组和单词数组分别映射到map里去，键分别为字符和单词，值都是int。同时建立两个int数组，分别用来存放相应map映射的值。最后只需要比较两个数组是否相等即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//// Ali2.cpp// Algorithm//// Created by huangyi on 2019/7/12.// Copyright © 2019 Leetcode. All rights reserved.//#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const ull base = 1000003;const int mod = 1e9+7;string pattern,str;map&lt;char,int&gt; mp1;map&lt;string,int&gt; mp2;int num1,num2;vector&lt;int&gt;a;vector&lt;int&gt;b;bool same()&#123; if( a.size()!=b.size() )&#123; return false; &#125; for( int i=0 ; i&lt;a.size() ; i++ )&#123; if( a[i]!=b[i] )&#123; return false; &#125; &#125; return true;&#125;int main()&#123; cin&gt;&gt;pattern; getchar(); getline( cin , str ); for( int i=0 ; i&lt;pattern.length() ; i++ )&#123; if( !mp1.count(pattern[i]) )&#123; mp1[pattern[i]] = ++num1; &#125; a.push_back(mp1[pattern[i]]); &#125; string part = \"\"; for( int i=0 ; i&lt;=str.length() ; i++ )&#123; if( i==str.length()||str[i]==' ' )&#123; if( !mp2.count(part) )&#123; mp2[part] = ++num2; &#125; b.push_back(mp2[part]); part = \"\"; &#125;else&#123; part = part+str[i]; &#125; &#125; if( same() ) &#123; printf( \"true\\n\" ); &#125; else &#123; printf( \"false\\n\" ); &#125; return 0;&#125;","categories":[{"name":"题解集","slug":"题解集","permalink":"http://huangyiblog.com/categories/题解集/"}],"tags":[]},{"title":"ArrayList源码阅读","slug":"ArrayList源码阅读","date":"2019-06-23T06:04:41.000Z","updated":"2019-09-02T05:13:27.289Z","comments":true,"path":"算法和数据结构/ArrayList源码阅读/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/ArrayList源码阅读/","excerpt":"","text":"ArrayList源码阅读（基于jdk1.8）我们先来看看类的定义： 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable `用的都是Java泛型，继承了AbstractList类，实现了List、RandomAccess、Cloneable、Serializable接口，大致可以了解到了ArrayList是个列表，可以实现克隆，序列化，随机访问，RandomAccess相当于一个随机访问的标志。12private static final int DEFAULT_CAPACITY = 10;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; ArrayList默认初始容量为10，另外我们知道HashMap的默认初始容量为16，而普通的数组是没有默认初始大小的。底层数据结构就是一个object数组我们也可以自定义初始容量：1234567891011121314151617181920212223242526272829public ArrayList(int initialCapacity) &#123; //新建object数组时判断下初始容量的参数是否大于0，若果等于0，则依旧为空数组，如果小于0，那么抛出非法异常 if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125; &#125;/** * 使用默认值10构建一个空的List */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; //我们也可以构建一个包含collection的ArrayListpublic ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; ArrayList的扩容我们常说ArrayList就是一个动态数组，是因为它实现了动态扩容的机制。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 如果有必要，增加ArrayList实例的容量以确保它至少能够容纳元素的数量 * @param minCapacity 所需的最少容量 */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125;//计算最小的扩容量 private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //返回默认容量和输入最小容量的较大值 return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125;//判断是否需要扩容 private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) //进行扩容 grow(minCapacity); &#125; /** * 要分配的最大数组大小 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * * ArrayList扩容核心方法 * @param minCapacity 所需的最小容量 */ private void grow(int minCapacity) &#123; // oldCapacity存放旧的容量，newCapacity存放新容量 int oldCapacity = elementData.length; //计算新容量，用到了位运算，相当于newCapacity=1.5倍的oldCapacity int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; /* 如果新容量大于数组定义的最大容量，那么调用 hugeCapacity(minCapacity)来比较minCapacity和 MAX_ARRAY_SIZE 如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。 */ if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: //最后要调用Arrays.copyOf将原数组整个复制到新数组里，这一操作性能开销较大 elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; System.arraycopy()和Arrays.copyOf()方法 arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置，arraycopy由本地方法C语言具体实现 1234public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 提示：我源码是在Oraclejdk里面查看的，并不是openjdk，所以如果想查看openjdk中相关的native本地方法源码，需要再去下载openjdk。拿上述arraycopy方法举例:在jvm.cpp文件中会有如下代码123456789101112131415JVM_ENTRY(void, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos, jobject dst, jint dst_pos, jint length)) JVMWrapper(\"JVM_ArrayCopy\"); // Check if we have null pointers if (src == NULL || dst == NULL) &#123; THROW(vmSymbols::java_lang_NullPointerException()); &#125; arrayOop s = arrayOop(JNIHandles::resolve_non_null(src)); arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst)); assert(s-&gt;is_oop(), \"JVM_ArrayCopy: src not an oop\"); assert(d-&gt;is_oop(), \"JVM_ArrayCopy: dst not an oop\"); // Do copy s-&gt;klass()-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);JVM_END 会发现上述代码只是对空指针做了检查，具体的拷贝函数我们还需要找到objArrayKlass.cpp文件1234567891011121314151617181920212223242526272829303132333435void ObjArrayKlass::copy_array(arrayOop s, int src_pos, arrayOop d, int dst_pos, int length, TRAPS) &#123; assert(s-&gt;is_objArray(), \"must be obj array\"); //断言，判断是否为数组对象 if (!d-&gt;is_objArray()) &#123; THROW(vmSymbols::java_lang_ArrayStoreException()); &#125; // 检查给定参数是不是都有效 if (src_pos &lt; 0 || dst_pos &lt; 0 || length &lt; 0) &#123; THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException()); &#125; // 检查长度范围是否有效 if ( (((unsigned int) length + (unsigned int) src_pos) &gt; (unsigned int) s-&gt;length()) || (((unsigned int) length + (unsigned int) dst_pos) &gt; (unsigned int) d-&gt;length()) ) &#123; THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException()); &#125; // Special case. Boundary cases must be checked first // This allows the following call: copy_array(s, s.length(), d.length(), 0). // This is correct, since the position is supposed to be an 'in between point', i.e., s.length(), // points to the right of the last element. if (length==0) &#123; return; &#125; if (UseCompressedOops) &#123; narrowOop* const src = objArrayOop(s)-&gt;obj_at_addr&lt;narrowOop&gt;(src_pos); narrowOop* const dst = objArrayOop(d)-&gt;obj_at_addr&lt;narrowOop&gt;(dst_pos); do_copy&lt;narrowOop&gt;(s, src, d, dst, length, CHECK); &#125; else &#123; oop* const src = objArrayOop(s)-&gt;obj_at_addr&lt;oop&gt;(src_pos); oop* const dst = objArrayOop(d)-&gt;obj_at_addr&lt;oop&gt;(dst_pos); do_copy&lt;oop&gt; (s, src, d, dst, length, CHECK); &#125;&#125; copyOf()是系统自动在内部新建一个数组，并返回该数组。我们可以发现copyOf()其实还是调用了arraycopy进行实现123456789public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings(\"unchecked\") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; &#125; Fail-FastmodCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。 在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。 java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改） 相对应的自然还有Fail-Safe安全失败 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。 java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。 和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。 ArrayList的遍历12345678910111213141516171819202122232425262728293031323334353637package Collection;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class TestArrayList &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"hello\"); list.add(\"World\"); list.add(\"aaaa\"); //第一种：for循环遍历 for(String str : list) &#123; System.out.println(str); &#125; //第二种：利用随机访问遍历 for(int i = 0; i &lt; list.size(); i++) &#123; System.out.print(list.get(i)); &#125; String[] strArray = new String[list.size()]; list.toArray(strArray); for(int i = 0; i &lt; strArray.length; i++) &#123; System.out.print(strArray[i]); &#125; //第三种：通过迭代器遍历 Iterator&lt;String&gt; ite = list.iterator(); while(ite.hasNext()) &#123; System.out.print(ite.next()); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; /** * 数组的默认初始容量 */ private static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。 transient Object[] elementData; // non-private to simplify nested class access /** * ArrayList的大小 (它包含的元素个数). */ private int size; /** * 使用指定容量大小构建一个空的list */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125; &#125; /** * 使用默认值10构建一个空的List */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; /** * 对ArrayList进行大小修建，使之为当前list的大小. * 一个应用可以使用这个操作缩小ArrayList实例所占的存储空间. */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; /** * 返回list的元素个数 */ public int size() &#123; return size; &#125; /** * 利用size是否为0判断list里面有无元素 */ public boolean isEmpty() &#123; return size == 0; &#125; /** * 利用对象o的下标是否大于等于0判断list里面是否包含某一特定元素 */ public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; /** * 返回某个元素在数组中第一次出现时的下标,如果不存在返回-1 */ public int indexOf(Object o) &#123; if (o == null) &#123;//如果o为null先遍历数组是否存在为null的元素 for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回某个元素在数组中最后一次出现的下标，若不存在，那么返回-1 * 逆序遍历即可 */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） */ public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; &#125; /** * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素 * 的数组 */ public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; /** */ @SuppressWarnings(\"unchecked\") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; // Positional Access Operations @SuppressWarnings(\"unchecked\") E elementData(int index) &#123; return (E) elementData[index]; &#125; /** * 返回此列表中指定位置的元素。 */ public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; /** * 设置列表中指定索引的元素 */ public E set(int index, E element) &#123; //对index进行界限检查 rangeCheck(index); E oldValue = elementData(index); //用新值替换旧值 elementData[index] = element; return oldValue; &#125; /** * 在列表末位添加指定元素 */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; /** * 在此列表中的指定位置插入指定的元素。 *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */ public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //用arraycopy()实现数组复制 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; /** * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 * 需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。 */ public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) //可以看到在列表特定位置添加元素，删除元素用的都是arraycopy()方法 System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // 末尾元素指向null以便GC工作时回收 return oldValue; &#125; /** *从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。返回true，如果此列表包含指定的元素 */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; /* * Private remove method that skips bounds checking and does not * return the value removed. */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; /** * 移除列表中所有元素 */ public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; /** * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; /** * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; /** * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。 *将任何后续元素移动到左侧（减少其索引）。 */ protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; &#125; /** * 检查给定的索引是否在size范围内，不是的话抛出下标越界异常 */ private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * add和addAll使用的rangeCheck的一个版本 */ private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 返回IndexOutOfBoundsException细节信息 */ private String outOfBoundsMsg(int index) &#123; return \"Index: \"+index+\", Size: \"+size; &#125; /** * 从此列表中删除指定集合中包含的所有元素。 */ public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false); &#125; /** * 从此列表中删除其中不包含在指定集合中的所有元素。 */ public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; /** * 序列化列表，以流的形式保存状态 */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * 反序列化 */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; /** * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。 *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 *返回的列表迭代器是fail-fast 。 */ public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(\"Index: \"+index); return new ListItr(index); &#125; /** * 返回列表中的列表迭代器（按适当的顺序）。 *返回的列表迭代器是fail-fast 。 */ public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** * 以正确的顺序返回该列表中的元素的迭代器。 *返回的迭代器是fail-fast 。 */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.ListItr */ private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; @SuppressWarnings(\"unchecked\") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; /** * 返回一个fromIndex和toIndex之间的子列表 */ public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); &#125; static void subListRangeCheck(int fromIndex, int toIndex, int size) &#123; if (fromIndex &lt; 0) throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex); if (toIndex &gt; size) throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex); if (fromIndex &gt; toIndex) throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") &gt; toIndex(\" + toIndex + \")\"); &#125; private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final AbstractList&lt;E&gt; parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; &#125; public E set(int index, E e) &#123; rangeCheck(index); checkForComodification(); E oldValue = ArrayList.this.elementData(offset + index); ArrayList.this.elementData[offset + index] = e; return oldValue; &#125; public E get(int index) &#123; rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index); &#125; public int size() &#123; checkForComodification(); return this.size; &#125; public void add(int index, E e) &#123; rangeCheckForAdd(index); checkForComodification(); parent.add(parentOffset + index, e); this.modCount = parent.modCount; this.size++; &#125; public E remove(int index) &#123; rangeCheck(index); checkForComodification(); E result = parent.remove(parentOffset + index); this.modCount = parent.modCount; this.size--; return result; &#125; protected void removeRange(int fromIndex, int toIndex) &#123; checkForComodification(); parent.removeRange(parentOffset + fromIndex, parentOffset + toIndex); this.modCount = parent.modCount; this.size -= toIndex - fromIndex; &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(this.size, c); &#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); int cSize = c.size(); if (cSize==0) return false; checkForComodification(); parent.addAll(parentOffset + index, c); this.modCount = parent.modCount; this.size += cSize; return true; &#125; public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125; public ListIterator&lt;E&gt; listIterator(final int index) &#123; checkForComodification(); rangeCheckForAdd(index); final int offset = this.offset; return new ListIterator&lt;E&gt;() &#123; int cursor = index; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() &#123; return cursor != SubList.this.size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= SubList.this.size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[offset + (lastRet = i)]; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; @SuppressWarnings(\"unchecked\") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[offset + (lastRet = i)]; &#125; @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = SubList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[offset + (i++)]); &#125; // update once at end of iteration to reduce heap write traffic lastRet = cursor = i; checkForComodification(); &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; SubList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(offset + lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; SubList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (expectedModCount != ArrayList.this.modCount) throw new ConcurrentModificationException(); &#125; &#125;; &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, offset, fromIndex, toIndex); &#125; private void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private String outOfBoundsMsg(int index) &#123; return \"Index: \"+index+\", Size: \"+this.size; &#125; private void checkForComodification() &#123; if (ArrayList.this.modCount != this.modCount) throw new ConcurrentModificationException(); &#125; public Spliterator&lt;E&gt; spliterator() &#123; checkForComodification(); return new ArrayListSpliterator&lt;E&gt;(ArrayList.this, offset, offset + this.size, this.modCount); &#125; &#125; @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(\"unchecked\") final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override public Spliterator&lt;E&gt; spliterator() &#123; return new ArrayListSpliterator&lt;&gt;(this, 0, -1, 0); &#125; /** Index-based split-by-two, lazily initialized Spliterator */ static final class ArrayListSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; &#123; private final ArrayList&lt;E&gt; list; private int index; // current index, modified on advance/split private int fence; // -1 until used; then one past last index private int expectedModCount; // initialized when fence set /** Create new spliterator covering the given range */ ArrayListSpliterator(ArrayList&lt;E&gt; list, int origin, int fence, int expectedModCount) &#123; this.list = list; // OK if null unless traversed this.index = origin; this.fence = fence; this.expectedModCount = expectedModCount; &#125; private int getFence() &#123; // initialize fence to size on first use int hi; // (a specialized variant appears in method forEach) ArrayList&lt;E&gt; lst; if ((hi = fence) &lt; 0) &#123; if ((lst = list) == null) hi = fence = 0; else &#123; expectedModCount = lst.modCount; hi = fence = lst.size; &#125; &#125; return hi; &#125; public ArrayListSpliterator&lt;E&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid) ? null : // divide range in half unless too small new ArrayListSpliterator&lt;E&gt;(list, lo, index = mid, expectedModCount); &#125; public boolean tryAdvance(Consumer&lt;? super E&gt; action) &#123; if (action == null) throw new NullPointerException(); int hi = getFence(), i = index; if (i &lt; hi) &#123; index = i + 1; @SuppressWarnings(\"unchecked\") E e = (E)list.elementData[i]; action.accept(e); if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; return false; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; int i, hi, mc; // hoist accesses and checks from loop ArrayList&lt;E&gt; lst; Object[] a; if (action == null) throw new NullPointerException(); if ((lst = list) != null &amp;&amp; (a = lst.elementData) != null) &#123; if ((hi = fence) &lt; 0) &#123; mc = lst.modCount; hi = lst.size; &#125; else mc = expectedModCount; if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) &#123; for (; i &lt; hi; ++i) &#123; @SuppressWarnings(\"unchecked\") E e = (E) a[i]; action.accept(e); &#125; if (lst.modCount == mc) return; &#125; &#125; throw new ConcurrentModificationException(); &#125; public long estimateSize() &#123; return (long) (getFence() - index); &#125; public int characteristics() &#123; return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; &#125; &#125; @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); // figure out which elements are to be removed // any exception thrown from the filter predicate at this stage // will leave the collection unmodified int removeCount = 0; final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; @SuppressWarnings(\"unchecked\") final E element = (E) elementData[i]; if (filter.test(element)) &#123; removeSet.set(i); removeCount++; &#125; &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; // shift surviving elements left over the spaces left by removed elements final boolean anyToRemove = removeCount &gt; 0; if (anyToRemove) &#123; final int newSize = size - removeCount; for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123; i = removeSet.nextClearBit(i); elementData[j] = elementData[i]; &#125; for (int k=newSize; k &lt; size; k++) &#123; elementData[k] = null; // Let gc do its work &#125; this.size = newSize; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; return anyToRemove; &#125; @Override @SuppressWarnings(\"unchecked\") public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; elementData[i] = operator.apply((E) elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; @Override @SuppressWarnings(\"unchecked\") public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125;&#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://huangyiblog.com/tags/Java/"}]},{"title":"redis数据结构入门","slug":"redis数据结构入门","date":"2019-04-27T12:35:16.000Z","updated":"2019-04-27T12:51:19.127Z","comments":true,"path":"业务开发/redis数据结构入门/","link":"","permalink":"http://huangyiblog.com/业务开发/redis数据结构入门/","excerpt":"参考资料：《redis设计与实现》 redis介绍Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。 上面一段话是redis中文网的官方介绍。有几个关键的点值得注意： redis属于内存存储，数据是存在内存里面的 redis本质是数据结构服务器，官方提供了各种数据结构供你使用，你可以将redis用作数据库或者缓存。 redis的存储方式为key-value的形式存储，所以redis是非关系型数据库","text":"参考资料：《redis设计与实现》 redis介绍Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。 上面一段话是redis中文网的官方介绍。有几个关键的点值得注意： redis属于内存存储，数据是存在内存里面的 redis本质是数据结构服务器，官方提供了各种数据结构供你使用，你可以将redis用作数据库或者缓存。 redis的存储方式为key-value的形式存储，所以redis是非关系型数据库 为什么我们要用redis学一门技术之前往往会出现这么一个问题，它好在哪里，为什么值得学？值得用？官方给出了以下几点优势： 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 我们看到上面第一点就是性能极高！！那么问题来了，redis是怎么做到这么快的读写速度的？这个问题我当时面试的时候也被问到过…说白了就是让你说清楚redis为什么很快？？ redis为什么很快关于redis为什么快的问题，有两点我们其实很容易想到： redis是基于内存的，内存的读写速度很快 redis是单线程的，在一定程度上减少了竞争锁和频繁的上下文切换 我们知道一般数据库的读写都是需要经过磁盘的，而磁盘的读写速度相对于内存来说绝对是算慢的了，所以我们需要用缓存，我们希望不要每次进行读写都跑去数据库进行操作。mybatis为什么要设置一级缓存，二级缓存？主要还是为了不希望每次读取数据都要到数据库去读取，以提升性能。 但是除了上述两点，还有什么特点是提升了redis的性能的呢？ 其实还有一点很重要：redis采用了非阻塞的网络IO多路复用技术来保证多连接的时候系统的高吞吐量。也就是指多个socket网络连接复用同一个线程。 另外还有两点： redis整体的hash数据结构提高了读取速度，以及压缩表和跳跃表等的使用。 redis采用了效率较高的事件分离器，内部采用非阻塞执行方式。 redis的数据类型Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。 数据类型 可以存储的值 操作 STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作 LIST 列表 从两端压入或者弹出元素 对单个或者多个元素 进行修剪，只保留一个范围内的元素 SET 无序集合 添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在 ZSET 有序集合 添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名 redis的存储形式为key-value，其中key为字符串，value可以是string、list、hash、set、zset。redis并没有直接使用这些数据结构来构建key-value数据库，而是基于这些数据结构构建了一个对象系统。每个相应的键对象、值对象都有自己的类型、编码、和指向底层数据结构的指针。 字符串string是redis最基本的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。 实例12345678127.0.0.1:6379&gt; set name &quot;xiaohuang&quot;OK127.0.0.1:6379&gt; get name&quot;xiaohuang&quot;127.0.0.1:6379&gt; del name(integer) 1127.0.0.1:6379&gt; get name(nil) SDS(简单动态字符串)redis自己构建了一种叫做简单动态字符串（SDS）的抽象类型，并将SDS用作redis的默认字符串表示。每个sdshdr结构表示一个SDS值：12345678struct sdshdr &#123; //记录buf数组中已使用的字节数量 int len; //记录buf数组中未使用的字节数量 int free; //字节数组，用来保存字符串 char buf[];&#125; C字符串和SDS的区别 C字符串 SDS 获取字符串长度的复杂度为O(N) 获取字符串长度的复杂度为O(1) API不安全，可能会造成缓冲区溢出 API安全，不会造成缓冲区溢出 修改字符串长度n次必然要进行N次内存重分配 修改字符串N次最多需要N次内存重分配 只能保存文本数据 可以保存文本或二进制 可以使用所有&lt;string.h&gt;库函数 可以使用部分&lt;string.h&gt; 库函数 列表Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。 实例：12345678910127.0.0.1:6379&gt; lpush list-key redis(integer) 1127.0.0.1:6379&gt; lpush list-key mongodb(integer) 2127.0.0.1:6379&gt; rpush list-key java(integer) 3127.0.0.1:6379&gt; lrange list-key 0 51) &quot;mongodb&quot;2) &quot;redis&quot;3) &quot;java&quot; 链表 redis列表键的底层实现之一为链表 每个链表结点listnode的结构表示： 12345678typedef struct listNode &#123; //前置节点 struct listNode *prev; //后置节点 struct listNode *next; //结点值 void *value;&#125;listNode; list链表结构 1234567891011121314typedef struct list &#123; //表头节点 listNode *head; //表尾节点 listNode *tail; //链表节点数量 unsigned long len; //节点值复制函数 void *(*dup) (void *ptr); //节点值释放函数 void *(*free) (void *ptr); //节点值对比函数 int (*match) (void *ptr, void *key);&#125;list; redis链表特性 无环双向链表 获取表头指针和表尾指针的复杂度为O(1) 获取某个节点的前置节点和后置节点的复杂度为O(1) 获取链表中节点数量的复杂度为O(1) 链表使用 void* 指针来保存节点值，链表可以保存不同类型的值 哈希Redis hash 是一个键值对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 实例：12345678910111213141516171819127.0.0.1:6379&gt; hset hash-key field1 value1(integer) 1127.0.0.1:6379&gt; hset hash-key field2 value2(integer) 1127.0.0.1:6379&gt; hset hash-key field3 value3(integer) 1127.0.0.1:6379&gt; hset hash-key field1 value1(integer) 0127.0.0.1:6379&gt; hgetall hash-key1) &quot;field1&quot;2) &quot;value1&quot;3) &quot;field2&quot;4) &quot;value2&quot;5) &quot;field3&quot;6) &quot;value3&quot;127.0.0.1:6379&gt; hdel hash-key field1(integer) 1127.0.0.1:6379&gt; hget hash-key field2&quot;value2&quot; hash表结构与哈希表节点结构12345678910typedef struct dictht&#123; //哈希表数组 dictEntry **table; //哈希表大小 unsigned long size; //哈希表大小掩码，用于计算索引值，总是等于size-1 unsigned long sizemask; //该哈希表已有节点数量 unsigned long used;&#125;dictht; 123456789101112typedef struct dictEntry&#123; //键 void *key; //值 union&#123; void *val; uint64_t u64; int64_t s64; &#125;v; //指向下个哈希表节点，形成链表 struct dictEntry *next;&#125;dictEntry; 字典结构表示123456typedef struct dict&#123; dictType *type; void *privdata; dictht ht[2]; int trehashidx; /* rehashing not in progress if rehashidx == -1 */&#125;dict; 1234567891011121314typedef struct dictType &#123; //计算哈希值 unsigned int (*hashFunction) (const void *key); //复制键 void *(*keyDup) (void *privdata, const void *key); //复制值 void *(*valDup) (void *privdata, const void *obj); //对比建 int (*keyCompare) (void *privdata, const void *key1, const void *key2); //销毁键 void (*keyDestructor) (void *privdata, void *key); //销毁值 void (*valDestructor) (void *privdata, void *obj);&#125;dictType; 当我们要插入新的键值对到字典里面的时候，首先要根据键值对的键计算得到哈希值，然后根据哈希值得到索引值，最后将相应包含键值对的哈希表节点放到哈希数组的制定索引位置。整个过程你会发现和Java里的HashMap很相似。hash = dict-&gt;type-&gt;hashFunction(key);index = hash &amp; dict-&gt;ht[x].sizemask; 当两个或两个以上的键被分配到哈希表数组的同一个索引出，我们认为此时发生了hash冲突。和HashMap相似，redis的哈希表也是使用链地址法来解决哈希冲突。被分配到同一个索引的多个结点可以利用next指针构成一个单链表，并且为了提升性能，总是将新节点添加到链表的表头位置(复杂度为O(1)), 但是rehash（重新散列）redis和Java并不同，redis采用的是渐进式rehash，而不是一次性完成。因为如果数据量过大，一次性rehash会导致较大的计算延时，可能会导致服务器在一段时间内停止服务。 具体的rehash步骤： 为ht[0]分配空间，让字典同时持有ht[0]，ht[1]两个哈希表 在字典中维持一个索引计数器变量rehashidx，并将其设为0，表示rehash开始 在rehash期间，每次对字典执行添加、查找或更新操作时，程序除了执行指定的操作以外，还会将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash完成后，将rehashidx的值增加1 不断执行以上操作，当ht[0]的所有键值对都被rehash到ht[1]，程序将rehashidx的值设为-1，表示rehash完成。 集合集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 实例：12345678910111213141516171819127.0.0.1:6379&gt; sadd set-key redis(integer) 1127.0.0.1:6379&gt; sadd set-key java(integer) 1127.0.0.1:6379&gt; sadd set-key mysql(integer) 1127.0.0.1:6379&gt; sadd set-key redis(integer) 0127.0.0.1:6379&gt; smembers set-key1) &quot;java&quot;2) &quot;redis&quot;3) &quot;mysql&quot;127.0.0.1:6379&gt; sismember set-key redis(integer) 1127.0.0.1:6379&gt; srem set-key mysql(integer) 1127.0.0.1:6379&gt; smembers set-key1) &quot;java&quot;2) &quot;redis&quot; 整数集合(intset)整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且元素数量不多，redis会使用整数集合作为集合键的底层实现。 12345678typedef struct intset&#123; //编码方式 uint32_t encoding; //集合包含的元素数量 uint32_t length; //保存元素的数组 int8_t contents[];&#125;intset; 关于整数集合如何升级，可以自行查阅黄建宏的《redis设计与实现》redis的整数集合底层为有序，无重复的数组，有需要时，程序会改变数组类型。整数集合只支持升级操作，不支持降级操作 有序集合实例：1234567891011121314151617181920212223127.0.0.1:6379&gt; zadd zset-key 11 member1(integer) 1127.0.0.1:6379&gt; zadd zset-key 9 member2(integer) 1127.0.0.1:6379&gt; zadd zset-key 13 member3(integer) 1127.0.0.1:6379&gt; zadd zset-key 13 member3(integer) 0127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores1) &quot;member2&quot;2) &quot;9&quot;3) &quot;member1&quot;4) &quot;11&quot;5) &quot;member3&quot;6) &quot;13&quot;127.0.0.1:6379&gt; zrem zset-key member1(integer) 1127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores1) &quot;member2&quot;2) &quot;9&quot;3) &quot;member3&quot;4) &quot;13&quot;127.0.0.1:6379&gt; 跳跃表跳跃表是一种有序数据结构，属于有序集合键的底层实现之一，它通过在每个节点中维持多个指向其他节点的指针，从而能够快速访问节点。平均复杂度O(logN)，最坏O(N)复杂度,如果一个有序集合包含的元素比较多，或者有序集合中元素的成员是比较长的字符串时，redis就会使用跳跃表来作为有序集合键的底层实现。跳跃表除了在有序集合中用到，在redis的集群节点中也有用作内部数据结构。 跳跃表节点结构123456789101112131415typedef struct zskiplistNode &#123; //后退指针 struct zskiplistNode *backward; //分值 double score; //成员对象 robj *obj; //层 struct zskiplistLevel &#123; //前进指针 struct zskiplistNode *forward; //跨度 unsigned int span; &#125;level[];&#125;zskiplistNode; 跳跃表结构 12345678typedef struct zskiplist &#123; //表头节点和表尾节点 structz skiplistNode *header, *tail; //表中节点数量 unsigned long length; //表中层数最大的节点的层数 int level;&#125;zskiplist; 每个跳跃表节点的层高都是1到32之间的随机数 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须唯一 跳跃表中的节点按照分值大小进行排序，当分值相同，按照成员对象的大小进行排序 与红黑树等平衡树相比，跳跃表的优势在于： 插入速度快，不需要旋转等操作来维持平衡 支持无锁操作 实现相对简单","categories":[{"name":"业务开发","slug":"业务开发","permalink":"http://huangyiblog.com/categories/业务开发/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://huangyiblog.com/tags/Redis/"}]},{"title":"一个成功的git分支模型","slug":"一个成功的git分支模型","date":"2019-03-16T11:20:45.000Z","updated":"2019-04-27T12:50:54.163Z","comments":true,"path":"译文集/一个成功的git分支模型/","link":"","permalink":"http://huangyiblog.com/译文集/一个成功的git分支模型/","excerpt":"一个成功的Git分支模型 原文链接：https://nvie.com/posts/a-successful-git-branching-model/原文作者： Vincent Driessen 在这片文章我介绍了一些我在一年前为一些项目（包括工作和私人）介绍的开发模型，并且事实证明非常成功。一直以来我都打算专门为其写一篇文章，然而我几乎完全找不到空闲的时间来做这件事，直到现在。我不会讨论任何有关项目的细节，只关注这个分支策略和发布管理。","text":"一个成功的Git分支模型 原文链接：https://nvie.com/posts/a-successful-git-branching-model/原文作者： Vincent Driessen 在这片文章我介绍了一些我在一年前为一些项目（包括工作和私人）介绍的开发模型，并且事实证明非常成功。一直以来我都打算专门为其写一篇文章，然而我几乎完全找不到空闲的时间来做这件事，直到现在。我不会讨论任何有关项目的细节，只关注这个分支策略和发布管理。 为什么要用git？有关Git与集中式源代码控制系统相比的优缺点的详细讨论，请参阅如下网站：网站上述论坛有很多思想碰撞的火焰。作为一个开发者，在今天所有其他的工具里面我更偏爱Git。Git确实改变了开发人员对合并与分支的看法。从经典的CVS / Subversion世界来看，合并/分支一直被认为有点可怕（“小心合并冲突，它们会咬你！”）以及有时候你在一段时间只做一次的事情。 但是使用Git，这些操作变得非常轻便和简单，并且它们被认为是您日常工作流程的核心部分之一。例如，在CVS / Subversion 书籍中，分支与合并首先在后面的章节中被讨论（对于高级用户），而在 每一本 Git 书中，它已经在第3章（基础知识）中被介绍过。 由于其简单性和重复性，分支和合并不再是一件令人害怕的事情。版本控制工具应该比其他任何东西更有助于进行分支/合并的操作。 关于这个工具讲够了，让我们进入这个开发模型。我将在这里介绍的模型本质上不再是每个团队成员必须遵循的为了进入托管软件开发过程的一组程序。 分散但集中我们使用的存储库设置与该分支模型配合良好，具有中心“真实”存储库。请注意，这个仓库只被认为是一个中央仓库（因为Git是DVCS，在技术层面没有这种中央仓库这种东西）。我们将此repo称为origin，因为所有Git用户都熟悉此名称。 每个开发人员都会拉取并推送到origin。但除了集中式推拉关系之外，每个开发人员还可以从其他同行中获取更改以形成子团队。例如，在将正在进行的工作过早推进origin之前，在开发一项大的新功能时，这对于两个或更多开发人员一起工作可能是有用的 。在上图中，有爱丽丝和鲍勃，爱丽丝和大卫以及克莱尔和大卫这些子团队。 从技术上讲，这意味着Alice已经定义了一个Git远程，名为bob，指向Bob的存储库，反之亦然。 主要分支在核心部分，开发模型受到现有模型的极大启发。中央仓库拥有两个主要分支，具有无限的生命周期： master develop 该master分支的origin应该对每一位Git用户都很熟悉。与master分支并行的另一个分支称为develop分支。 我们认为origin/master是反映这个HEAD源代码生产就绪状态的主要分支 。 我们认为origin/develop是主要的分支，其源代码 HEAD始终反映了最新交付的下一版本中开发被更改的状态。有些人称之为“整合分支”。这是在夜间自动被构建的地方。 当develop分支中的源代码到达稳定点并准备好被发布时，所有的更改都应该以某种方式被合并到master分支，然后使用版本号进行标记。上述将如何执行进一步详细讨论。 因此，当每次将更改合并回master时，根据定义，这是一个新的生产版本。我们对此非常严格，因此从理论上讲，我们可以使用Git钩子脚本在每次提交时对master自动构建和发布我们的软件到我们的生产服务器 。 支持分支接着上面的主要分支master和develop，我们的发展模式，采用了多种支持分支机构，以帮助团队成员进行并行开发，缓解功能跟踪，为生产版本做准备，并协助快速修复现场制作的问题。与主要分支不同，这些分支的寿命有限，因为它们最终会被删除。 我们可能使用的不同类型的分支是： 功能分支 发布分支机构 修补程序分支 这些分支中的每一个都有特定的目的，并且必须遵守关于哪些分支可以是它们的起始分支以及哪些分支必须是它们的合并目标的严格规则。我们将在一分钟内讨论它们。 从技术角度来看，这些分支绝不是“特殊的”。分支类型根据我们如何使用它们进行分类。他们当然是老的Git分支。 功能分支 可能会分支于：develop 必须合并回：develop 分支命名约定：anything except master, develop, release-*, or hotfix-* 功能分支（或有时称为主题分支）用于为即将发布或将来的版本开发新功能。在开始开发功能时，此功能将会在其中合并的目标版本，但可能在此时未知。功能分支的本质是，只要功能处于开发阶段，它就会存在，但最终会被合并回develop（以便将新功能添加到即将发布的版本中）或丢弃（在实验令人失望的情况下）。 功能分支通常仅存在于开发人员存储库中，而不存在于origin。 创建一个功能分支12$ git checkout -b myfeature develop 切换到新分支“myfeature” 在开发中加入完成的功能完成的功能可能会合并到develop分支中，以确保将它们添加到即将发布的版本中： 12345678$ git checkout develop 切换到分支&apos;develop&apos;$ git merge --no-ff myfeature 更新ea1b82a..05e9557（更改摘要）$ git branch -d myfeature 已删除分支myfeature（为05e9557）。$ git push origin开发 该–no-ff标志会导致合并始终创建新的提交对象，即使可以使用快进执行合并。这样可以避免丢失有关历史上存在的功能分支的信息，并将所有一起添加的功能提交组合在一起。两者相比： 在后一种情况下，不可能从Git历史中看到哪些提交对象一起实现了一个功能 - 您必须手动读取所有日志消息。恢复整个功能（即一组提交）在后一种情况下也是一件真正令人头痛的事，而如果使用该–no-ff标志则很容易完成 。 是的，它会创建一些（空的）提交对象，但增益远远大于成本。 发布分支可能会分支于：develop必须合并回：develop 和 master分支命名约定：release-* 发布分支支持准备新的生产版本。它们允许最后一刻点缀我和交叉t。此外，它们允许修复小错误并为发布准备元数据（版本号，构建日期等）。通过在发布分支上执行所有这些工作，develop 分支将被清除以接收下一个大版本的功能。 新发布分支的关键时刻develop是开发（几乎）反映新版本的期望状态。至少所有针对要构建的版本的功能必须在此时合并到其中 。针对未来版本的所有功能可能不会 - 他们必须等到发布分支后。 正是在发布分支的开始，即将发布的版本被分配了一个版本号 - 而不是之前的版本号。直到那一刻，这个develop 分支反映了“下一个版本”的变化，但不清楚“下一个版本”最终是否会变为0.3或1.0，直到发布分支开始。该决定是在发布分支的开始时做出的，并根据项目相关版本号冲突的规则执行。 创建一个发布分支发布分支是从develop分支创建的。例如，假设版本1.1.5是当前的生产版本，我们即将推出一个大版本。状态develop为“下一个版本”做好了准备，我们已经决定这将成为版本1.2（而不是1.1.6或2.0）。因此，我们为发布分支提供反映新版本号的名称： 1234567$ git checkout -b release-1.2 develop 切换到新分支“release-1.2”$ ./bump-version.sh 1.2 文件修改成功，版本提升到1.2。$ git commit -a -m “Bumped version number to 1.2”[release-1.2 74d9424] Bumped version number改为1.21个文件被改变，1个插入（+），1个删除（ - ） 在创建新分支并切换到它后，我们会修改版本号。这个bump-version.sh是一个虚构的shell脚本，它可以更改工作副本中的某些文件以反映新版本。（这当然可以手动更改 - 关键是某些文件会发生变化。）然后，该冲突版本号会被提交。 这个新的分支可能存在一段时间，直到发布可能会被真正推出。在此期间，可以在此分支中应用错误修复（而不是在develop分支上）。严禁在此处添加大型新功能。它们必须合并到develop，因此要等待下一个大版本。 完成一个发布分支当发布分支的状态准备好成为真正的发布版本时，需要执行一些操作。首先，发布分支被合并到 master（因为每次提交到master的都是按照定义的新版本，请记住）。接下来，master必须标记该提交，以便将来参考此历史版本。最后，需要将发布分支上所做的更改合并回到develop，以便将来的版本也包含这些错误修复。 Git的前两个步骤：123456$ git checkout master切换到分支&apos;master&apos;$ git merge --no-ff release-1.2 由递归合并而成。（更改摘要）$ git tag -a 1.2 该版本现已完成，并标记以供将来参考。 编辑：您可能还想使用-s或-u 标记以加密方式对您的标记进行签名。 为了保持发布分支中所做的更改，我们需要将这些更改合并到develop。在Git中：12345$ git checkout develop 切换到分支&apos;develop&apos;$ git merge --no-ff release-1.2 由递归合并而成。（变更摘要） 这一步很可能导致合并冲突（甚至，因为我们已经更改了版本号）。如果是这样，请修复并提交。 现在我们已经完成了，并且可能会删除发布分支，因为我们不再需要它了： 12$ git branch -d release-1.2 删除了分支版本1.2（ff452fe）。 修补程序分支可能会分支于：master必须合并回：develop 和 master分支命名约定：hotfix-* 修补程序分支非常类似于发布分支，因为它们也是为了准备新的生产版本，尽管是计划外的。它们源于必须立即实际生产版本的不良状态采取反应。当必须立即解决生产版本中的关键错误时，可以从标记生产版本的主分支上的相应标记分支修补程序分支。 实质是团队成员（在develop分支机构）的工作可以继续，而另一个人正在准备快速生产修复。 创建修补程序分支从master分支创建修补程序分支。例如，假设版本1.2是当前生产版本正在运行的版本并且由于严重错误而出现了bug。但是变化在develop分支仍然不稳定。然后我们可以分支出修补程序分支并开始修复问题：1234567$ git checkout -b hotfix-1.2.1 master 切换到新分支“hotfix-1.2.1”$ ./bump-version.sh 1.2.1 文件修改成功，版本提升到1.2.1。$ git commit -a -m “Bumped version number to 1.2.1”[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.11个文件改变了，1个插入（+），1个删除（ - ） 分支后不要忘记碰撞版本号！然后，修复错误并在一个或多个单独的提交中提交修复。 123$ git commit -m “修复了严重生产问题”[hotfix-1.2.1 abbe5d6]修复了严重生产问题5个文件发生了变化，32个插入（+），17个删除（ - ） 完成一个修补程序分支完成后，需要将错误修复合并回到master，但也需要合并回到develop，以保证错误修复程序也包含在下一个版本中。这与发布分支的完成方式完全相似。首先，更新master并标记版本。 123456$ git checkout master 切换到分支&apos;master&apos;$ git merge --no-ff hotfix-1.2.1 由递归合并。（更改摘要）$ git tag -a 1.2.1 编辑：您可能还想使用-s或-u 标记以加密方式对您的标记进行签名。 接下来，在develop分支中也包括错误修复： 12345$ git checkout develop 切换到分支&apos;develop&apos;$ git merge --no-ff hotfix-1.2.1 由递归合并。（变更摘要） 此处规则的一个例外是， 当发布分支当前存在时，需要将修补程序更改合并到该发布分支中，而不是develop分支。在发布分支完成时，将错误修复反向合并到发布分支中最终会导致错误修复也被合并到develop分支。（如果develop分支立即工作并涉及次错误修复并且不能等待发布分支完成，您可以安全地将错误修复合并到develop分支。） 最后，删除临时分支： 12$ git branch -d hotfix-1.2.1 删除了分支修补程序-12.2.1（是abbe5d6）。 摘要虽然这个分支模型没有什么真正令人震惊的地方，但这篇文章开头的“大图”可以被证明在我们的项目中非常有用。它形成了一个易于理解的优雅模型，并能够让团队成员形成对分支和发布过程的共同理解。","categories":[{"name":"译文集","slug":"译文集","permalink":"http://huangyiblog.com/categories/译文集/"}],"tags":[]},{"title":"风口过了，猪还是猪","slug":"风口过了，猪还是猪","date":"2019-03-02T04:08:27.000Z","updated":"2019-03-02T04:45:44.528Z","comments":true,"path":"随笔/风口过了，猪还是猪/","link":"","permalink":"http://huangyiblog.com/随笔/风口过了，猪还是猪/","excerpt":"","text":"风口过了，猪还是不会飞互联网界内有句话挺有名，站在风口上，猪都能飞起来。这话不难理解，往前回顾这些年it行业的迅猛发展，一批又一批的独角兽成长起来，动不动估值上亿，上市的造富神话一个又一个，大家都期待着下一个阿里巴巴的诞生。但从2018年的p2p爆雷，以及年底和19年初的各个公司爆出了裁员。事实上大面积的裁员是真的，当然还在招人也是真的。这里一方面有国内大经济环境恶劣的原因，另一方行业本身的泡沫不小。 国内经济下行也不是我随便说说的，你们有关注过其他行业其实应该也有听到点消息，虽然通常都是互联网裁员会炒的比较火，但传统制造业日子也并不好过，全球制造业各个巨头也都在裁员，虽说还谈不上类似08年，97年的金融危机，但这个时候出现问题，风险还是蛮大的。至少我觉得资本一旦寒冬，且不说已经冬天，或许凛冬将至。这种时候能偷着乐的估计也就老师、公务员这种体制内的吧？给资本家打工你都需要意识到公司不是你的家。大环境不是我们这些普通人能够改变的，你能做的只有做好自己。我觉得如何应对危机，最重要的一条，那就是终身学习，你得让自己保持足够的竞争力。其余的点也有很多，比如别给自己加杠杆，背高负债，高消费等等。由俭入奢容易，由奢入俭难。裁员其实没那么可怕，能力在线，另外找一家就是了。但有些人压力就会不小。此前我就见过不少帖子，杭州，深圳都有，无非就是杠杆买了房，每个月背着一两万的房贷然后被炒鱿鱼，这就有点心累了。 这两年中国经济的持续增持有两条大腿一直在撑着，一条腿是房地产，一条腿是互联网。但恕我直言，我个人觉得经济泡沫最大的就是这两条腿。当像我这种在校生，或者你身边很多的人，开口闭口谈天都是房价，买房之类的，我觉得就很危险，这有点像全民买房的前兆，热钱全流入房地产，实体业必然受影响。杭州自从G20开完，再加上备受期待的亚运会加持，房价整体趋势就是猛涨，另一方面，棚改政策，城中村改造也是传出了不少造富神话，拆迁户各种送房送钱，补贴的钱又再次流入房地产，至于政府，卖地卖得好就行了。 互联网的问题一方面太虚了，另一方面各种红利用得也快差不多了，遭遇瓶颈是必然的。人口红利，微信，也好，淘宝也好，移动互联网这一块很大程度上得益于人口红利，但如今微信的用户其实已经很难再上涨。互金就不说了，去年倒闭的企业不少，至于游戏，国内主流游戏厂商股价全是下跌，游戏其实受政策影响很大，你版号拿不到，光有技术没什么卵用，另外游戏的赌博性质很高，虽说很赚钱，但往往是亏的企业多。大多数游戏的存活周期都不长，顶多几年算不错了，一款游戏从研发到最后发布，一系列的都是在砸钱，最后如果没什么用户，没什么玩家支持，那这些钱往往是打水漂的多。总之前几年互联网迅猛扩张，但并没出现什么新的比较好的增长点。倒是各种新概念很火，AI、VR、区块链等等，也许下一次产业革命就跟这些点有关，但是光有概念，没办法应用落地，赚不了钱，投资人是不会买账的！放放PPT，画画大饼就能融资的日子已经过去了。 总之大环境不好，个人是很难独善其身的，学生该学习的还是好好学习，该找工作的还是要好好找工作，该上班的还是好好上班。网上无非两种观点：悲观的认为这次的冬天会很冷，时间会很长，乐观的，对中国经济充满信息的，认为转暖也快了。特朗普会选择伤敌一千自损八百的贸易战政策不是没有原因的，直接的原因就是想扼制中国高端制造业的转型升级，也就是要扼制中国的发展，但我相信美国应该也看到了中国自身经济也存在着不少问题才敢直接打贸易战。既然是市场经济，与资本分不开的经济。那么经济规律你是躲不了的，经济危机你是避免不了的，可以说美国下一次金融危机必然还是会发生，或早或晚罢了，拖得越晚，反弹的越厉害。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://huangyiblog.com/categories/随笔/"}],"tags":[]},{"title":"为什么我说考验人性多半会令你失望","slug":"为什么我说考验人性多半会令你失望","date":"2018-12-25T07:42:51.000Z","updated":"2018-12-30T13:58:23.953Z","comments":true,"path":"随笔/为什么我说考验人性多半会令你失望/","link":"","permalink":"http://huangyiblog.com/随笔/为什么我说考验人性多半会令你失望/","excerpt":"永远不要去尝试考验人性,人性真的经不起考验! 下述内容多为个人见解，难免会犯学术上的错误，欢迎指正。","text":"永远不要去尝试考验人性,人性真的经不起考验! 下述内容多为个人见解，难免会犯学术上的错误，欢迎指正。 我可能有一天会不与代码打交道，但我这一生不可能不与人打交道，这是避免不了的。这也大大激发了了我对人性理解的兴趣，各类学科里面与人性关联度最高的，又属心理学最甚。为了防止有些人说我以偏概全，说还有某某圣人并非如此，某某大贤已经四大皆空，无欲无求，考验他们的人性纯粹多此一举。我只说大多数情况下的心理状态是如何如何。因为绝大多数人都只是普通人，大部分人既不是圣人，也不是恶人，只是一个普通人，你可以想想看你生活到现在遇到的人，是不是大多和你一样，有自己的欲望和所求，有自己的弱点和困惑。既然是普通人，那么面对各种压力或者说诱惑，不说他真实表现如何，你觉得他的内心想法是如何的呢？ 先来看看人性是什么，字面意思我觉得就是指人的本性，也就是请抛开各种约束，诸如道德，法律等等，人的心理表现已经相对应会做出的行为表现。百度百科的解释分了狭义和广义两种： 狭义上是指人的本质心理属性，也就是人之所以为人的那一部分属性，是人与其它动物相区别的属性；广义上是指人普遍所具有的心理属性，其中包括人与其它动物所共有的那部分心理属性。无论是人的本质心理属性，还是人与动物所共有的属性，由于它们都是人所共有的心理属性，那么这种属性也就不可能是后天的结果，只能是人类天性，属于无条件反射。 我们可以看到不论是狭义还是广义，都是人所共有的心理属性，也就是说指的是先天的，无条件的反射。所以我在之前就提到了，既然是讲人性，就不要将各种外在约束引进来，包括教育，各种行为规范，道德准则等等。因为在这些条件下做出的表现大多并不属于真正的人性表现。是经过了包装的。上述提到的定义其实也就指向了人性的本质，这里其实也引出了关于人性一直以来存在的贯穿于东西方世界的争论，人性本善还是本恶？中国古代关于这个问题一直争论不休，基本四中观点都涵盖了：包括孟子的性善论，认为人生来即有恻隐、善恶、辞让、是非四种“善端”，扩而充之，便可形成仁、义、礼、智的善性。荀子的性恶论，认为“人之性恶，其善伪也。”（《荀子·性恶》）善性是后天人为的。性无善无恶论，这包括：告子的“性无善无不善”论，认为“生之谓性”，“食色，性也”；性有善有恶论，这包括先秦世硕等的有善有恶论，汉杨雄的性善恶混论，董仲舒等的性三品论等：杨雄认为“人之性也，善恶混，修其善则为善人，修其恶则为恶人”；明清之际王夫之的性“日生日成”论，认为人性绝非在“初生之顷”就定型，一成不易，而是随着环境和教养的不同，“性屡移而异”，“未成可成，已成可革”，认为人性是可以培养和不断完善的；北宋的司马光的人性的先天不等论，司马光认为人生来在人性善恶上就先天不平等，无论圣人还是愚人善恶都是兼而有之，只是有些在善性上会占优势，有些人在恶性上会占优势。 人性最大的一个特点就是复杂性，因此首先我不认同纯粹的人性本恶或者性本善，我的观点就是有善有恶论，只不过是在恶性上占优势还是在善性上占优势因人而异。为什么我说复杂是人性的特点，这其实是很好理解，你看过很多真正出色艺术作品，小说也好，电影也好，电视剧也一样，真正塑造人物形象出色的，往往都是十分立体的人物形象。不像很多常规意义上的，哦，那谁谁谁是个好人，思想端庄正直，那谁谁谁是个坏人，无恶不作。一个人也许他不贪财，但他不一定不好色；一个人也许不好色，但他不一定不慕名；一个人也许不慕名，但他不一定不求权……同样的，一个贪财好色之人也可能重情重义，一个恶贯满盈之人也可能诚实有信，一诺千金。抗日战争时期，有一大波被人唾骂的汉奸，你能想象在这之前，这当中也有人做出过堪称为民族英雄的壮举。生活中人间人嫌弃的一个猥琐男，用钱各种抠门，色眯眯的眼睛不停在那些漂亮女生身上来回移动的家伙，怕是没几个人愿意和他交往，但是当一个同学得了绝症，竟然只有这个人拿出了自己几乎全部的几千块钱积蓄帮助他。 和复杂性关联比较大的一个特点就是变化性，也就是说人性不是一成不变的，而是可以一直变化着的。这一点说起来或许要困难不少。不是都说了人性是先天性的吗，是人所共有的生理，心理属性吗？难道是你通过教育，通过感化就能改变得了的吗？我认为是可变的，只是程度不同。我在之前提过，我支持的观点是人性有善有恶论，无非每个人善恶的比重不同，在成长过程中，可能一件不经意的小事，但对当事人却造成了极大的震撼，就是这份份震撼，不知不觉间就撼动了在他内心深处的善恶比重。看过武侠小说的人应该遇到过不少这种情况，一个一开始冷酷无情，杀人如麻的杀手为何在后期竟然渐渐放下了恶念，开始走自己的自我救赎之路？一个原先气质轩昂，众人称赞的武林正派人士，为何后期会走上背信弃义，追名逐利的道路？这些人都出现了变化，而这种变化往往都是有引子的。那个杀人如麻的冷血家伙可能有了温柔体贴的妻子，可爱聪慧的孩子，有了一个令人羡慕的美满家庭，他不想自己的亲人的命运因为自己而走上绝路，自然要做出内心的博弈。 人性另一个逃不开的特点就是自利性。当我提到自利，利己这样的字眼，很多人可能无意中就想到了阴暗面去，这又容易出问题，自利实在是太正常太普遍了，自利绝对不是错，不希望很多人想歪了。很多学者批判现在的学生一个个都是精致的利己主义者，这种批判是否合乎情理呢，或许他们是想说现在的人少了太多奉献精神，牺牲精神，集体精神。但这种批判从某个角度是不合人性的。人性本就是利己的，这是无可辩驳的，而且利己其实不是什么错，这才是真实人性的展现，这反倒有助于社会发展，进步，只要能够正视这样的本性，你想想看专制统治时期，统治者会让这种利己的思想得到发展吗？统治者只会想尽办法巩固自己的统治地位，让底层民众为皇族服务，以为皇族做出贡献为荣。利己心只得压抑着，过度放大显然就漏了马脚，因为这么做往往会触碰到统治阶级的蛋糕，这可是要杀头的哦。 除了自利性，还有就是普遍性，这我在最开头就说过了，定义里面也讲明了，人性人性，不就是人所共有的本性吗。既然如此，不论你是国家领袖，还是平民百姓；不论你是大学者，大教授，还是普通学生，职场白领，都有着许多共性的人性展露。你看看贪污腐败的问题，上到国务院高层，下到乡镇级村委，纵观历史各朝，哪朝哪代是没有贪污腐败现象的？这里其实展现了很好的人性问题。封建时期腐败问题严重，当然很大一部分是制度问题，纯粹让人性背锅就过分了。古代官场上的腐败，腐败之广，腐败之难治等等，都体现了人性的普遍性，自利性，贪婪性，很多大臣已经做到了一人之下，万人之上，为什么还是要贪污，要知道人性的贪婪可不是那么容易满足的哦。官场上的权臣之术，勾心斗角，权利角逐，无一不是人性的外在表现，帝王有着自己的野心，大臣打着自己的算盘，你想着捞够名和利就功成身退，我想着要你鞠躬尽瘁死而后已。 人性还有一个很好的表现常常展现的淋漓尽致，那就是性欲望，性欲很显然的，是来自内在本源驱动的。但是人类文化的发展，需要对性欲加工，性欲毫无限制的表现很多人认为是趋于兽性的，我们需要爱情来掩盖性欲，我们需要夫妻制来限制性欲，这都是人类文化前进的需求。但人的性与本身至今还是如初，不论你是否已婚，是否有了恋人，当一个充满魅惑的女子在你面前，往往还是能够勾起你本能的性欲，但是道德准则，爱情准则，法律准则告诫你，好好收起你内心的性欲吧，你是有妻子的，有家室的人了。当然也还是会有人出问题，出轨的现象有不少，这里当然也不能全让人性背锅，也许感情变了，也许不爱了，但也许真的只是一时的性欲冲昏了头脑。 人性的复杂让我不可能用几段文字将其介绍完尽，回过头，来看看很多人喜欢考验人性结果最后自讨苦吃的结局。这种事还是少做比较好，来看看考验人性的本质，既然你想要考验人性，那么其实你多半想要考验的其实是人性的阴暗面，也就是常常被人们藏起来的那一面。我说人性是有善有恶的，但你既然指的是考验，我想你总不会是想看看对方到底还能有多善良，多忠诚，多完美无缺，你想考验一下对方会不会背叛你，对方会不会不为名利所动，对方会不会不为美色所动。你想知道他能不能抗住自己的人性阴暗面，而不是想看看对方人性的阳光面有多美好，多善良。另外既然你说了是考验，那么本质上带有欺骗性，你想要看看对方在尽可能没有约束的环境下会做出何样的的选择。绝大多数人是普通人，普通人的定力又是相当有限，有了钱，想要更多，这才是人性，而不是知足常乐，有了恋人，想要长得更漂亮，身材更火辣，更温柔的对象，这才是人性；已经步入小康，想要往更高阶级爬，这才是人性；胜利了而骄傲，失败了而气馁，这才是人性。当你选择了考验，发现对方不过如此你又能如何，再说既然是欺骗，对方做出了遵从本性的选择实在是情理之中，你只能失望而归。生活已经如此艰难，你又何苦再让对方再人性的挣扎面前多几分纠结，最后甚至闹得不欢而散，好好珍惜对方为了你已经克服了人性的阴暗面吧，何苦还要在用欺骗的手法逼出人性的另一面呢，人性如何，由人性的普遍性可知大家很多时候都是心知肚明的。当你想要考验对方的时候，麻烦你先认真想想自己的本性如何，当真在七情六欲面前能够自控自如，收放自如？","categories":[{"name":"随笔","slug":"随笔","permalink":"http://huangyiblog.com/categories/随笔/"}],"tags":[]},{"title":"如何为Nginx服务器配置ssl证书","slug":"如何为Nginx服务器配置ssl证书","date":"2018-11-21T13:14:42.000Z","updated":"2018-11-21T14:47:31.960Z","comments":true,"path":"业务开发/如何为Nginx服务器配置ssl证书/","link":"","permalink":"http://huangyiblog.com/业务开发/如何为Nginx服务器配置ssl证书/","excerpt":"","text":"如何为Nginx服务器配置ssl证书&emsp;&emsp;我前不久才把自己的hexo博客部署到阿里云服务器上，买的学生机LAMP6.0.1,操作系统是centos，部署成功后就去申请备案，备案前期的资料审核还是快的，最后一步管局审核写着不超过20天，结果真的过了20天才发信息来审核通过…&emsp;&emsp;之前的审核过程中，你的域名是不能进行访问，只能通过IP地址访问网站。审核通过后你可以通过http进行访问,但是不能通过进行https:进行访问。所以我们先来看看这两者的区别。 http与https的基本定义HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 http与https的区别HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，这就是https的诞生。阿里云官网的回答 HTTP是过去很长一段时间我们经常用到的一种传输协议。HTTP协议传输的数据都是未加密的，这就意味着用户填写的密码、账号、交易记录等机密信息都是明文，随时可能被泄露、窃取、篡改，从而被黑客加以利用，因此使用HTTP协议传输隐私信息非常不安全。 HTTPS是一种基于SSL协议的网站加密传输协议，网站安装SSL证书后，使用HTTPS加密协议访问，可激活客户端浏览器到网站服务器之间的SSL加密通道(SSL协议)，实现高强度双向加密传输，防止传输数据被泄露或篡改。简单讲，HTTPS=HTTP+SSL，即HTTPS是HTTP的安全版。 HTTPS加密、加密、及验证过程，如下图所示： 按照网上博客的资料，两者主要有以下具体区别：1、HTTPS更安全：HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议的信息明文传输安全； 2、HTTPS需要申请证书：HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费，费用大概与.com域名差不多，每年需要大约几十元的费用。而常见的HTTP协议则没有这一项； 3、端口不同：HTTP使用的是大家最常见的80端口，而HTTPS连接使用的是443端口； 4、状态不同：HTTP的连接很简单，是无状态的。而HTTPS协议是SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全； 为Nginx服务器配置ssl证书具体步骤一：购买并申请免费证书 前往阿里云域名控制台–&gt;进入域名管理–&gt;申请免费开启ssl证书这个过程比较快，一般申请成功后不需要多久证书就会发到你的证书控制台。在证书控制台下载Nginx版本证书，下载到本地的是一个压缩文件，解压后里面包含.pem文件是证书文件，.key文件是证书的私钥文件（申请证书时如果没有选择系统创建CSR，则没有该文件）。 二、进入服务器配置Nginx.conf按照官方文档，我们首先进入服务器的Nginx目录下，新建一个目录cert1mkdir cert 目录建完以后就需要把你之前下载的证书解压后的文件都拷贝到该目录下面。从本地拷贝文件到远程服务器可以用scp命令1scp -r /Users/study/xxxxx root@xxx:/etc/nginx/cert 我当时没注意，结果直接把整个文件夹给拷进去了，这样一来等会编辑文件路径的时候就不能忘了修改。拷贝结束后就可以编辑Nginx.conf文件进行配置。1vim nginx.conf 1234567891011121314151617server &#123; listen 443; server_name localhost; ssl on; root html; index index.html index.htm; ssl_certificate cert/a.pem; ssl_certificate_key cert/a.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root html; index index.html index.htm; &#125;&#125; 我主要提几个初次接触的小白容易碰到的问题： include /etc/nginx/default.d/*.conf;这一行不需要取消注释 server_name 可以改为你自己的域名 location/{}里面的root注意要填写你当时配置的项目位置。 配置好以后保存并退出。之后重新加载并启动nginx 123nginx -s reloadsystemctl restart nginx.service 这里很多人一开始可能会出现启动失败的错误，这时不要慌，我的建议是最好学会查看日志文件，看看命令行提示报了什么错。1nginx -t 我碰到过的有一种是属于80端口被某个进程占用，当时我是直接强制杀死该进程解决的。其他启动失败的原因多数是你nginx.conf文件配置出错了，比如如法错误，多了什么或少了什么。我当时启动成功后采用https方式访问域名，结果一直都是显示Nginx welcome的首页面，这里其实就是我之前提到过的location/{}里面写错了。当时还有点慌，因为我不记得我把自己的hexo放在哪里了，但还好，把Nginx.conf往上翻就能找到我以前配置过的hexo的root信息，直接复制下来即可。 到这里，证书配置基本就完成了。","categories":[{"name":"业务开发","slug":"业务开发","permalink":"http://huangyiblog.com/categories/业务开发/"}],"tags":[]},{"title":"普通人如何稳固对自我价值的认同感","slug":"普通人如何稳固对自我价值的认同感","date":"2018-11-07T06:01:18.000Z","updated":"2018-11-07T07:35:06.232Z","comments":true,"path":"随笔/普通人如何稳固对自我价值的认同感/","link":"","permalink":"http://huangyiblog.com/随笔/普通人如何稳固对自我价值的认同感/","excerpt":"","text":"普通人自我认同感很低怎么办？&emsp;&emsp;最近又到了清华本科特将评选的日子，看了他们的简历，众多网友耐不住了。纷纷调侃“神仙打架”又开始了。&emsp;&emsp;不过毕竟神仙们打架对我们这些普通人影响其实并不是很大，毕竟距离太远了（指实力上的距离）。大多数人自我认同感低，其实还是因为身边的人，再加上各种网文贩卖焦虑，比如之前的某某单车创始人企业被收购，90后已经实现财务自由。于是有了你已被同龄人抛弃了之类的…在目前经济为王的社会里，各种浮躁的心态层出不穷，不论是在校的学生，还是在企业里的白领，似乎无时无刻不在焦虑着。为什么焦虑，因为怀疑，因为对自我价值的怀疑，导致对自己所做的努力，所做的事情同样产生怀疑。&emsp;&emsp;首先焦虑是正常的，对自己有所怀疑也是正常的。但注意我标题注明的是你几乎已经怀疑过了度。也就是说你甚至已经有些不认同自我价值了。到了这一步，问题其实已然不小。我想写这篇随笔，自然不是因为空想就想到了这么个话题。而是我自己就属于迷茫，不自信的一类人中的一个典型。不知道解决方案，但是写这篇随笔可以让我反思，让我平视，然后再次让自己正常的融入到学习生活中去。能达到这一点就足够。&emsp;&emsp;不同年龄段的人烦恼各不相同，但心态缺失类似的。我正处于学生时代的后期了，倘若不读研，那么在学校的日子几乎按着指头数也能数过来了。学校里终究还只是个象牙塔，与社会的庞杂相比还是相对单纯的多了，至少涉及物质层面的问题会少很多。说撑了无非就是些各种奖学金，助学金之类的。当然，不排除很多人爱慕虚荣，喜欢攀比。许多人的焦虑可能更多来自于学习。学渣与学霸之间的爱恨情仇似乎是学生时代过不去的一道坎也。当你看到身边的某某学霸又拿了个竞赛大奖，某某保研到了国内C9高效，某某某还在纠结于几个知名大厂的offer该选哪个时，你可能会有些触动，你可能还不知道自己想干嘛，毕业了工作能找到吗？上述几个例子自然是少数人，但是当你看到自己的同学如此优秀，你应该怀抱什么样的心态？嫉妒？自卑？蔑视？这里其实已经体现了自我认同感偏低的外因，那就是身边的人光芒四射，你找不到自己了。&emsp;&emsp;有一点还是要明确。我是相信存在智商碾压这回事的。努力确实是个好东西，但是收获未必如你所期望的，毕竟这个过程还得乘上个系数，不然就不存在我在最开头提到的“神仙打架的事情”了。那么好，如今你可能和我一样有些焦虑，有些自我怀疑，害怕自己和身边的神仙差距越来越大，怎么处理。在此之前，你或许也还算努力吧，上课认真听讲，课后也会去翻翻书，你也为了目标有所付出。但是这离你想要的生活并未接近多少。再想想，要不随大流，一起开几把黑，打打王者，看看小说，让自己过得轻松点不行么？嘻嘻，当然没问题，而且要注意，打王者，看小说等等操作与我的问题并不矛盾，很简单，玩游戏就会影响自我认同感吗？没啥关系吧？刚刚前几天LG还拿了世界总决赛冠军呢，多少高校宿舍，朋友圈里的男同胞在自豪的呐喊。那么问题在哪呢？如果这么想，反正我这么菜，还不如上课开开黑，让自己过得舒坦点何乐而不为。这里有个前提，你默认了自己是个菜鸟(自黑的除外)，你从心底里认为了自己不是个优秀的人，即使努力了也是菜鸟一枚，这就有了问题。你并不怎么认同自己，导致你不愿为了些什么东西制定个小计划，小目标什么的，持之以恒的去做点什么。这就糟糕了。&emsp;&emsp;当你开始转变，开始有所努力，慢慢认同自己的时候，你可能一不当心就陷入了另一个误区。那就是自我欺骗。你开始渐渐相信自己其实也很优秀，自己的存在不说对很多人，但对身边的人也还有点价值。于是你开始努力学习，认真生活，你希望让自己变得更加优秀，你希望放大自己的价值。你可能每天都有在刷算法题，你可能每天都在看技术书学习。然而过了段时间，你发现你刷了很多题，但问你一个算法原理你却还是云里雾里，你看了很多课外书，但问你个知识点你却是两眼发呆。你以为每天都在努力，那么自然每天都在收获，结果却是在原地踏步。这就会让你产生盲目的自我认同感。我们拿阅读技术书举例。你读过这本书，并不代表你读懂了，你读懂一个技术点，并不代表你会用了，你已经能够实践了，能够用了，并不代表你已经会变通了，因为你不了解它的底层是什么原理，只知道代码这么写会产生这样的效果。&emsp;&emsp;当你发现了误区，你又开始慢慢转变，你希望让假懂慢慢变成真懂，你希望自己不是假优秀，而是确实肚子里有点货，，慢慢慢慢，可能情况就会有所好转，只要能一步步走上正轨，那么对自我价值的认同感自然也就慢慢上来了。到后面，或许会这么想，“神仙”们的确很厉害，但我在陆地上当个”将军”也不错，“马云、王健林”们的确有钱，而我虽然实现不了财务自由，但也勉强够用了。有勇气平视大家，才能交到好朋友哦！","categories":[{"name":"随笔","slug":"随笔","permalink":"http://huangyiblog.com/categories/随笔/"}],"tags":[]},{"title":"回顾自己部署hexo博客的血泪史","slug":"回顾自己部署hexo博客的血泪史","date":"2018-10-29T14:52:02.000Z","updated":"2018-12-25T07:48:02.392Z","comments":true,"path":"随笔/回顾自己部署hexo博客的血泪史/","link":"","permalink":"http://huangyiblog.com/随笔/回顾自己部署hexo博客的血泪史/","excerpt":"回顾下自己使用hexo博客踩过的坑 从一开始接触hexo博客到现在也过去好几个月了，在很多大佬看来搭建部署个个人博客是个很小儿科的事情，但对我这样一个菜鸟来说陆陆续续的几乎是采坑无数，现在回想起来都是泪啊，尤其是碰到一些bug，百度谷歌都找不到你想要的解答时，真的绝望的感觉。我这次虽然是坐个总结，但时间过去很久了，一些具体的bug，以及处理代码我就不写出来了，所以如果你想在这里看到一些实操干货的话，可能要失望了，毕竟我写的不是教程。 我使用hexo博客主要经历了如下几个阶段： 下载hexo，选择主题，编辑配置文件，部署到GitHub 想优化主题，自定义了一些css样式，加入了一些插件 后面换了电脑，想要在多终端协同管理hexo 纠结于GitHub pages 访问速度不给力，考虑CDN，最后还是想部署到阿里云服务器。","text":"回顾下自己使用hexo博客踩过的坑 从一开始接触hexo博客到现在也过去好几个月了，在很多大佬看来搭建部署个个人博客是个很小儿科的事情，但对我这样一个菜鸟来说陆陆续续的几乎是采坑无数，现在回想起来都是泪啊，尤其是碰到一些bug，百度谷歌都找不到你想要的解答时，真的绝望的感觉。我这次虽然是坐个总结，但时间过去很久了，一些具体的bug，以及处理代码我就不写出来了，所以如果你想在这里看到一些实操干货的话，可能要失望了，毕竟我写的不是教程。 我使用hexo博客主要经历了如下几个阶段： 下载hexo，选择主题，编辑配置文件，部署到GitHub 想优化主题，自定义了一些css样式，加入了一些插件 后面换了电脑，想要在多终端协同管理hexo 纠结于GitHub pages 访问速度不给力，考虑CDN，最后还是想部署到阿里云服务器。 一开始和很多人一样活跃于博客园，ＣＳＤＮ等第三方博客平台，那是还是大学刚开学的时候吧，还不怎么写博客，到了后面偶尔也学一些大佬写点题解啥的，但也并不积极。到了大二，学的东西、课程越来越多，内容越积越多，但显而易见的是，我们不可能记住所有内容，如何有效的总结知识点，最好将书上的变成自己的，如何深入理解，如何提升自己的写作水平，总的来说，写博客还是一个不错的提升自己的方式。可这时，可能是想追求个性，想有一个自己的个人博客，当时主要就想到了ＷｏｒｄＰｒｅｓｓ和ｈｅｘｏ，但是用ＷｏｒｄＰｒｅｓｓ还是要买域名和云服务器，虽说阿里云和腾讯云等服务商对学生的优惠力度都很大，但我最初并不是很想花钱，于是选择了ｈｅｘｏ。选择ｈｅｘｏ其实也有很多好处，帮我入门了ｇｉｔ和ＧｉｔＨｕｂ。决定以后，边去网上找各种教程，下载ｎｏｄｅ、ｈｅｘｏ、ｎｅｘｔ主题等等，之后配置文件，然后ｈｅｘｏ ｎｅｗ ｐｏｓｔ，ｈｅｘｏ ｓ，测试效果，这个过程中，出过一些小问题，但最后都能够成功部署，只是有一个小ｂｕｇ。部署成果后，导航栏的几个主要图标无法正常显示，我一直不明白到底是哪里出了问题，因为每一步都是按照网上的教程操作的，谷歌了好久也没解决。当时没辙，我就去问了我们的ｗｅｂ老师，然而老师说他也没搞过这个，所以并不了解，但是还是给出了建议，因为大部分ｂｕｇ，９９％前人肯定都遇到过，可以先去谷歌百度搜，实在不行可以去知乎等社区提问。我后面就去知乎发表提问，并要求了几位内行人回答，期初也没得到我想要的解答，但几天过去，总算是等来了我想要的。问题其实很简单，还是配置文件上没有填正确，之所以没有填正确。有两个主要原因：１版本问题，２自己不注意看官方注释。首先网上给出的教程并没有问题，但我完全照搬就出了问题，因为他们针对的版本与我再用的版本并不一样，而恰好我的版本在导航栏配置哪里格式有所区别，导致最后图标无法正常显示。总之，倒腾了半天，最后总算还顺利，我发布了自己的第一篇博客并且成功部署到了ＧｉｔＨｕｂ，网页上也能正常浏览。 我当时选择的是ｎｅｘｔ主题，我很喜欢这样简约大方的风格，大量留白，不花里胡哨，同时也能够满足我的需求，我只想写写东西，这样的就已经足够。但是还不够，我想往里面加点东西，改点东西。这个过程，也很心累，因为我前端没好好学，而页面设计这方面涉及的主要都是前端的点。我修改了一些样式，字体，颜色什么的，接了网易云嵌入式链接，开头评论功能，增加友链，用七牛做图床等等，总之就是各种折腾。有时看了自己改的很不满意又得想办法改回去。这个过程有一点很重要，就是了解ｈｅｘｏ主题的整体框架配置，知道哪个文件夹，哪个文件主要是负责哪一块的！ 后面我买了台二手ＭＢＰ，想在这台电脑上也能管理发布ｈｅｘｏ博客，于是又想办法，在网上各种搜教程，如何在两台电脑上管理ｈｅｘｏ。最后的解决方案是利用ＧｉｔＨｕｂ分支，新建一个分支，然后将原电脑上所需的本地文件拷到新电脑，在新电脑上把内容ｐｕｓｈ到相应分支。这个过程也很不容易，主要是我不怎么理解ＧｉｔＨｕｂ的分支操作，哎，但还算好吧，没有花太多时间。 又过了一段时间，随之我发布的博客内容越来越多，而ＧｉｔＨｕｂ ｐａｇｅｓ的访问速度又不稳定，有时还很令人纠结，这我就受不了了，我想着怎么才能加速访问，比较ＧｉｔＨｕｂ是国外的服务器，虽然免费给你一定空间使用，但访问速度我真的不满意。网上有说把博客再部署到ＣＯＤｉｎｇ上面的，也有说用ＣＤＮ的，我考虑过ＣＤＮ，当时选的是加速乐，但是生效要很久，我也没测试效果如何。最后想着趁现在自己还是学生，干脆去阿里云买个云服务器得了。服务器买了以后，问题又来了，如何将本地博客迁移到云服务器上了，这个过程有时让我掉了一堆头发。一开始就出了问题，按照网上的教程，我装好ｎｏｄｅ，ｇｉｔ，ｈｅｘｏ，Ｎｇｉｎｘ等等所需的软件，但是当我启动Ｎｇｉｎｘ的时候一直出错，无法启动，最初人物是自己在编辑．ｃｏｎｆ文件的时候可能哪里多了分号点号啥的，一直没搞清楚问题是啥，到后面干脆重置了虚拟机，将各种软件重新装了一遍。这是再次启动Ｎｇｉｎｘ，还是启动不了，真是崩溃的心都有了，没辙，只好按照命令行的提示，查看日志提示是哪里有ｂｕｇ，你别说，我这种菜鸟一开始看提示都还不大看得懂，只好又将提示代码复制到谷歌搜解答，但是这还不能马上搜到，因为有些时候一段提示信息可能会对应一堆可能的ｂｕｇ，但我这次还算运气可以吧。最后的结论是我的服务器上８０端口ｈｔｔｐｄ被占用，也就是说Ａｐａｃｈｅ和Ｎｇｉｎｘ不能同时启用吧，之后便停用８０端口，然后重新加载Ｎｇｉｎｘ，在游览器输入服务器ＩＰ，总算是见到了ｗｅｌｃｏｍｅ的页面了，松了一口气呀。之后要做的就是新建ｇｉｔ库，配置ｇｉｔｈｏｏｋｓ，配置Ｎｇｉｎｘ的ｓｅｒｖｅｒ的ｌｏｃａｔｉｏｎ等等，然后修改本地ｈｅｘｏ的．ｃｏｎｆｉｇ文件，然后将博客部署到服务器上。到这里你在输入ＩＰ到游览器便能够看到你的博客了。 上面就是我倒腾ｈｅｘｏ的主要历程，但是还有个问题要讲下，那就是域名，域名我很早就买了，也是在阿里云上买的，当时就是解析到了ＧｉｔＨｕｂ的ＸＸＸ．ｇｉｔｈｕｂ．ｉｏ，这样输入域名也能访问我的博客，另外由于访问的是国外服务器，所以我的域名也没有备案，换句话说，其实我也备不了案，因为我没有买服务器，也就没有备案服务号。后来我买了服务器就想着干脆也去备案下吧．．结果一开始我就觉得好烦，得我自己去打印核验单邮寄到贵州，还得用阿里云的幕布拍照，总觉得麻烦。现在还在备案中．．．","categories":[{"name":"随笔","slug":"随笔","permalink":"http://huangyiblog.com/categories/随笔/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://huangyiblog.com/tags/Github/"}]},{"title":"Java容器概述","slug":"Java容器概述","date":"2018-10-22T08:39:48.000Z","updated":"2018-12-19T15:13:02.005Z","comments":true,"path":"语言/Java容器概述/","link":"","permalink":"http://huangyiblog.com/语言/Java容器概述/","excerpt":"Java容器(Container)什么是容器？容器可以管理对象的生命周期、对象与对象之间的依赖关系。直白点说容器就是一段Java程序，能够帮助你管理对象间的关系，而不需要你自行编写程序处理。维基百科定义： 在计算机科学中，容器是指实例为其他类的对象的集合的类、数据结构、[1][2]或者抽象数据类型。换言之，它们以一种遵循特定访问规则的系统的方法来存储对象。容器的大小取决于其包含的对象（或元素）的数目。潜在的不同容器类型的实现可能在空间和时间复杂度上有所差别，这使得在给定应用场景中选择合适的某种实现具有灵活性。","text":"Java容器(Container)什么是容器？容器可以管理对象的生命周期、对象与对象之间的依赖关系。直白点说容器就是一段Java程序，能够帮助你管理对象间的关系，而不需要你自行编写程序处理。维基百科定义： 在计算机科学中，容器是指实例为其他类的对象的集合的类、数据结构、[1][2]或者抽象数据类型。换言之，它们以一种遵循特定访问规则的系统的方法来存储对象。容器的大小取决于其包含的对象（或元素）的数目。潜在的不同容器类型的实现可能在空间和时间复杂度上有所差别，这使得在给定应用场景中选择合适的某种实现具有灵活性。 Java内部的容器类Java内部的容器类主要分为两类：Collection(集合)与Map(图) Collection Set HashSet 基于哈希表实现，底层使用HashMap来保存所有元素。 不能保证迭代顺序 允许使用null元素 LinkedHashSet LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承于HashSet。 内部使用双向链表维护插入顺序。 TreeSet 基于（TreeMap）红黑树实现 TreeSet非同步，线程不安全 TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。 List ArrayList 实现 List 接口、底层使用数组保存所有元素。 相当于动态数组，支持动态扩容。 不同步 vector Vector 可以实现可增长的对象数组。 Vector 实现 List 接口，继承 AbstractList 类，同时还实现RandmoAccess 接口，Cloneable 接口 Vector 是线程安全的 LinkedListLinkedList 是基于链表实现的（通过名字也能区分开来），所以它的插入和删除操作比 ArrayList 更加高效。但也是由于其为基于链表的，所以随机访问的效率要比 ArrayList 差。 Queue LinkedList可以用于实现双向队列 PriorityQueue通过二叉小顶堆实现，可以用一棵完全二叉树表示。可以用于实现优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。 Map(用于映射（键值对）问题处理) HashMap HashMap根据键的HashCode来实现，访问速度较快，遍历顺序并不确定。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。 HashMap线程不安全，也就是说任意时刻可以有多个线程同时写HashMap，所以可能会导致数据的不一致。 如何确保线程安全？可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 HashTable HashTable是遗留类，多数功能与HashMap类似，继承自Dictionary类。 HashTable是线程安全的。也就是说任意时刻只有一个线程能够写HashTable。 HashTable的并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。 LinkedHashMap基于哈希表和链表实现，借助双向链表确保迭代顺序是插入的顺序。 TreeMap 基于红黑树实现 默认按照键值得升序进行排序。 在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。","categories":[{"name":"语言","slug":"语言","permalink":"http://huangyiblog.com/categories/语言/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://huangyiblog.com/tags/Java/"}]},{"title":"支持推理小说家紫金陈","slug":"支持推理小说家紫金陈","date":"2018-10-19T06:29:55.000Z","updated":"2019-04-27T12:58:05.437Z","comments":true,"path":"阅读/支持推理小说家紫金陈/","link":"","permalink":"http://huangyiblog.com/阅读/支持推理小说家紫金陈/","excerpt":"紫金陈主要作品 《推理之王1：无证之罪》（2014年实体书出版） 《推理之王2：坏小孩》（2014年实体书出版） 《推理之王3：长夜难明》（2017年出版） 《浙大夜惊魂》（2010年出版改名《禁忌之地》） 《谋杀官员1》（2012年） 《谋杀官员2：化工女王的逆袭》（2012年） 《谋杀官员3：物理教师的时空诡计》（2013年1月更新完） 《谋杀官员4：代上帝之手(完结)》（2013年） 因为我自己主要就阅读了他的上述作品，所以其他书没有全都一一例举。","text":"紫金陈主要作品 《推理之王1：无证之罪》（2014年实体书出版） 《推理之王2：坏小孩》（2014年实体书出版） 《推理之王3：长夜难明》（2017年出版） 《浙大夜惊魂》（2010年出版改名《禁忌之地》） 《谋杀官员1》（2012年） 《谋杀官员2：化工女王的逆袭》（2012年） 《谋杀官员3：物理教师的时空诡计》（2013年1月更新完） 《谋杀官员4：代上帝之手(完结)》（2013年） 因为我自己主要就阅读了他的上述作品，所以其他书没有全都一一例举。 一提到推理小说，估计很多人又想到了我们的邻居－－岛国日本，推理小说早期兴起于欧美，后来在日本也有了极大的发展。平时我们读的很多推理或者侦探小说相比大多都是欧美或者日本的作品比较多吧。著名的作者比如美国的埃德加·爱伦·坡，英国的阿加莎·克里斯蒂，日本的江川户乱步、东野圭吾等都是推理小说界的大神，不仅高产还高质量，我已开始读的也是日本的推理小说比较多。大一看了几本东野大神的作品后无意中接触到了国内紫金陈写的《无证之罪》，顿时来了兴趣，陆陆续续的也看了他的一些代表作，就我个人而言还是蛮喜欢他的推理作品，虽然不像有些大神那么高产，也不是每一本都布局十分巧妙，但吸引人的点还是很多的。 我已开始接触《无证之罪》后就顺便看完了他的推理之王系列的另外两本，《坏小孩》与《长夜难明》，之后又看了他较早的几部作品，从《浙大惊魂夜》（后来再版改名为《禁忌之地》）到《谋杀官员系列》，可以看出作者在每部作品的布局构思上都花了很大心思。紫金陈本名陈徐，毕业于浙江大学，主要走的是社会派本格推理路线，比如《谋杀官员系列》就是他的本格推理代表作。他的作品里的主要人物背景很多也是浙大毕业的校友，至于社会背景大多在以浙江各个市为模板进行创作。《无证之罪》很多人会拿来与东野圭吾的《嫌疑人Ｘ的献身》进行对比，认为在情节完善和人物塑造等方面还有很多不足之处，作者融入中国社会的背景，但同样是一位高智商大神为了帮助失误犯了罪的可怜人摆脱警察的故事。《坏小孩》的故事我大都忘了，比较早看的一本，其实说起来推理之王系列我最推崇的是《长夜难明》，他的说我也就这本买过实体说。不过说起来《长夜难明》或许并算不上推理吧，情节也不悬疑，只能说属于社会派推理比较好，但反映的社会问题还是很沉重的，虽然是小说，但现实生活中有没有类似的案情或者更为残酷的事实恐怕很难说，或许黑暗一直存在只是没有笼罩在你身上罢了。很多人应该看过韩国的一部电影《熔炉》，内容很沉重，在韩国法律界社会界都引起了极大的反响。《长夜难明》反应了类似的社会法律问题，书中直至结局也没能揪出幕后大老虎，尽管已经有人为此献出了生命的代价，但是在权利的悬殊面前你很难立马冲破黑暗。甚至很有可能一味的付出却给自己带来了毁灭的报复。总感觉现实中这么正义凛然的人很少，大家内心都有自己的想法，为什么要为了不相干的人去得罪人，做吃力不讨好的事？但如果人人都这么想，那些弱势群体就一直被压榨下去吗？ 《谋杀官员系列》也不是每本都很精彩，有很多欠缺的地方还是明显的，尽管作为推理小说，或许不是非得文笔一流，但文笔不足的间接影响就是导致了人物造型，性格塑造方面不够鲜活，包括一些悬疑的点也很牵强。另外第二部和第四部都写到了屌丝对女神的爱，我就想说作者就不能放过广大屌丝吗，另外我想着尽管矮穷丑，但好歹是浙大高材生至于这么自卑吗，还是真的爱得真切，无法自拔。第四部结尾的有点牵强，竟然又扯出来了同性恋，但好在不是个完美的结尾，最后提到女神骆慧慧的孩子既不是李卫平也不是王红名的时候，估计很多人也蒙了，人性的复杂也只在这种时刻才能感受到。第二部又是一个单相思的家伙为了自己喜欢的人不惜付出一切为她犯罪，书名《化工女王的逆袭》估计误导了很多人，一直以为所谓的“同伙”就是化工女甘佳宁，结果这只是个幌子，但是“同伙”这个点设计的还是比较好的。另外这部反映的官场腐败等政治问题也挺厉害的，官场的腐败从上到下，从一手遮天的大老虎到仗势欺人的看家狗都让人不寒而栗，权利没有约束是很恐怖的。 我一般看这种推理小说并不怎么较真，不会太计较情节上的漏洞，除非是太明显的，毕竟自己只是个门外汉，娱乐为主哈哈。上述几本书看完倒也没花掉我多少时间，想想自己书架上的几本技术方面的恐龙📚，我内心就拔凉拔凉了，若是真想一本本从头看到尾，我又能吸收到少呢．．．","categories":[{"name":"阅读","slug":"阅读","permalink":"http://huangyiblog.com/categories/阅读/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://huangyiblog.com/tags/小说/"}]},{"title":"谈谈一部争议较大的日漫《缘之空》","slug":"谈谈一部争议较大的日漫《缘之空》","date":"2018-10-16T08:33:45.000Z","updated":"2018-12-19T15:13:23.344Z","comments":true,"path":"影音/谈谈一部争议较大的日漫《缘之空》/","link":"","permalink":"http://huangyiblog.com/影音/谈谈一部争议较大的日漫《缘之空》/","excerpt":"我先给出自己的主要观点： 我不认为悠是渣男，恰恰相反，整部番里我觉得悠才是内心最纠结的可怜人。 我不支持兄妹乱伦的爱情，但我相信可能会有这样真实的感情。 我支持平行世界的剧情设计。 对我而言这部番吸引我的是BGM。 我不赞同有人纯粹拿这部番当里番来看，我不觉得这是部里番。 我不相信柏拉图式的爱情，完全没有性的爱情我觉得不存在。","text":"我先给出自己的主要观点： 我不认为悠是渣男，恰恰相反，整部番里我觉得悠才是内心最纠结的可怜人。 我不支持兄妹乱伦的爱情，但我相信可能会有这样真实的感情。 我支持平行世界的剧情设计。 对我而言这部番吸引我的是BGM。 我不赞同有人纯粹拿这部番当里番来看，我不觉得这是部里番。 我不相信柏拉图式的爱情，完全没有性的爱情我觉得不存在。 日本动漫产业一直以来都是其他国家难以匹敌的一块，我平时看的动漫虽然不能说很少吧，但多是完全谈不上，你可能无法想象一些宅男腐女追番有多么疯狂，其实在其他方面我也是这种状况，看书，看电影，似乎各种都有所投入，但都只是了解很少一部分。动漫能吸引人主要有几个点：剧情、画风、配音、ＢＧＭ。有时我是真佩服那些声优和作曲家，明明剧情狗血的要命，也能让我感动起来．．．我这次想写关于缘之空的故事，其实是因为三轮学创作的ｂｇｍ太好听了（×……————……×） 嘻嘻…… 缘之空算是一部比较早期的作品了，是根据游戏改变过来的。当初游戏本就是分线路展开剧情的。所以后面改编成动画采用平行世界也没什么好奇怪的。游戏里主要有５条线，分别是宆悠线（也就是争议最大的兄妹线）、奈绪线、一叶线、悠瑛线、班长线。不过动漫里好像把班长那条线去掉了，只讲述了４条线。首先我们先来科普下平行世界的问题，我是在看之前就已经了解了剧情的构造，所以很多地方并不会觉得很奇怪或是难以理解。百度百科的定义如下：多元宇宙是一个理论上的无限个或有限个可能的宇宙的集合，包括了一切存在和可能存在的事物：所有的空间、时间、物质、能量以及描述它们的物理定律和物理常数。多元宇宙所包含的各个宇宙被称为平行宇宙（parallel universes）。好吧说实话我没怎么看明白，平行世界是否存在我也不知道，我这种物理渣渣还是就不要太纠结于这个了，一部动漫而已，太较真吃不消。按照字面意思来理解，缘之空其实就是讲述了男主悠在不同宇宙和一群相同的人之间发生的不同的故事。有和穹之间的故事，和奈绪之间的故事，和一叶之间的故事，还有瑛。 也许是改编成动漫时衔接的处理有些瑕疵，很多人认为悠是个渣男，脚踩都不止两只船了，可其实按照剧情设计，悠并没有脚踩两只船，他有同时在和两个女生交往吗？他有花心般的欺骗吗？和其他几个女生的交集更像是普通中学少男少女的青涩的爱情，只是到后来悠才意识的自己真正喜欢的是谁。穹妹给人的感觉有种红楼梦里林黛玉的影子，柔弱，多病，少话，内心却又感情丰富，有脾气有个性。这双胞胎兄妹的父母死于交通事故，两人相依为命，一起来到了祖父曾经生活过的奥木尔町生活，也是在这里发生了一系列的故事。 穹悠线饱受争议，就是因为双胞胎兄妹之间产生了情愫并甚至接受这样的情感。现实生活中包括我自己，想必很多人也是一样，很难想象或者说理解亲兄妹之间怎么能萌生出爱情的火花呢，从小一起长大。不知道你们有没有了解过韦斯特马效应，韦斯特马效应由芬兰人类学家爱德华·韦斯特马克在他的著作《The History of Human Marriage》（人类婚姻史）中提出，指出两个早年共同长大的儿童在成年后通常不会对彼此产生性吸引力：有血缘关系者也会存在亲缘监测机制（亲缘监测机制异常除外，三代以内越近越明显。）来保护；无血缘关系者由于生活在一起或可不会成年后产生性吸引；出生后六年的成长环境是一个关键时间点，其间生活在一起二者性吸引几率全会大大降低。但穹和悠却并不满足韦斯特马效应的前提，之前穹生病，兄妹二人长时间并未生活在一起，但突然间双亲离世，两人再次相遇，也许真有可能产生喜欢的情愫也说不定。但是兄妹恋终究是不被人认可的，所以可以感受悠的挣扎，悠和穹不一样，穹什么都不在乎，在乎的只有悠而已，悠作为哥哥，需要负起的应当是父亲般的责任，但却喜欢上了自己的妹妹，说出来谁能接受，不光会被人以异样的眼光看待，也没有做好一个哥哥的本分。动漫最后的处理是两人从湖中死里逃生最后一起移居他乡。我不知道这样的结局如何，如何确实互相爱慕，即使是兄妹，那么该不该在一起呢？我不知道，我不支持乱伦恋，但真实的感情并不能由外力改变，这是我相信的。 最后关于尺度问题，的确，这部动漫里有一些暴露的镜头，但我个人觉得并不过分，如果是爱情的话，这本也就是爱情的一部分，何必去特意躲闪。我大一暑假花了很长时间看完《金瓶梅》，好吧，我没那么纯洁，做不到看金瓶梅看出圣经来，但还是不否认这是一部伟大的文化作品，很多人认为金瓶梅的格调不如红楼梦，红楼梦当之无愧是我国古典文学的巅峰，但如果仅仅只是因为一个重点讲情、一个重点讲欲来评判高低那就太不公平了。缘之空很多人还是无法接受的，被禁我觉得也正常，有时也不能一天到晚黑广电，从国家层面来说，还是需要宣扬社会主义核心价值观比较好~~","categories":[{"name":"影音","slug":"影音","permalink":"http://huangyiblog.com/categories/影音/"}],"tags":[{"name":"动漫","slug":"动漫","permalink":"http://huangyiblog.com/tags/动漫/"}]},{"title":"如何在Windows和Mac平台上协同管理hexo博客","slug":"如何在Windows和Mac平台上协同管理hexo博客","date":"2018-10-10T09:12:56.000Z","updated":"2018-12-19T15:13:02.360Z","comments":true,"path":"业务开发/如何在Windows和Mac平台上协同管理hexo博客/","link":"","permalink":"http://huangyiblog.com/业务开发/如何在Windows和Mac平台上协同管理hexo博客/","excerpt":"如何在多台电脑协同管理hexo博客我很早就想搞个个人博客，其实写博客主要有3种选择： 1 在第三方平台注册账号，直接在平台上写作并发布，例如博客圆，CSDN，新浪，网易等,这种方式最简单方便。 2 自己搭建博客。这种看个人需求，能力强的，可以完全前后端都自己代码实现，但大多数人一般也是直接采用模版的，简单省事。不过自己搭建的话需要去云服务商购买域名和云服务器，服务器的话学生优惠还是比较大的，阿里云，腾讯云上面都能买。 3 利用GitHub pages和hexo搭建静态博客，本地编写md文件，然后部署到github转化为html，相当于是托管于github。这种方法至少不用花钱买服务器，当然，你要是想绑定域名的话也可以照样去云服务商买一个，然后绑定到你的XXX.github.io上面。","text":"如何在多台电脑协同管理hexo博客我很早就想搞个个人博客，其实写博客主要有3种选择： 1 在第三方平台注册账号，直接在平台上写作并发布，例如博客圆，CSDN，新浪，网易等,这种方式最简单方便。 2 自己搭建博客。这种看个人需求，能力强的，可以完全前后端都自己代码实现，但大多数人一般也是直接采用模版的，简单省事。不过自己搭建的话需要去云服务商购买域名和云服务器，服务器的话学生优惠还是比较大的，阿里云，腾讯云上面都能买。 3 利用GitHub pages和hexo搭建静态博客，本地编写md文件，然后部署到github转化为html，相当于是托管于github。这种方法至少不用花钱买服务器，当然，你要是想绑定域名的话也可以照样去云服务商买一个，然后绑定到你的XXX.github.io上面。 现在假设你已经在之前的Windows平台上搭好了hexo博客，并且能够正常部署运行。但因为需要，你要在另一台Mac系统的电脑上也能够管理你的hexo博客，可以利用Git分支来实现。 在另一设备上管理博客 配置好环境 安装Node.js 安装Git 安装hexonode.js可以直接去官网下载相应的匹配版本，Git的话，如果你的电脑安装是Mac并且安装了xcode，那么便不用再重新安装，xcode里便已经装有Git。 配置GitHub的SSH key在新电脑上使用GitHub都需要先进行SSH key的配置，来获得GitHub的权限，以便本地和服务器之间数据的连接。 先测试你的电脑上是否已有ssh密钥,打开终端输入：1cd ~/.ssh 如果没有，则进入下一步，生成ssh key1ssh-keygen -t rsa -C &quot;邮件地址&quot; 将你的ssh key复制到GitHub上，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：将ssh key复制进去。 最后测试你的ssh是否配置成功1ssh -T git@github.com 具体如何配置hexo博客可以参考：使用hexo快速搭建个人博客 创建分支 进入你的username.github.io仓库主要，新建一个分支，名字可以自定义，下面以hexo为例： 切换到hexo分支，并将该分支设置为默认分支后并保存。 上传配置文件到GitHub 克隆hexo分支将之前新建的分支克隆到本地1git clone -b hexo git@github.com/username/username.github.io 查看当前所在分支是否为新建的hexo分支1git branch 上传部署文件 将你原先电脑里的配置文件拷贝到你的username.github.io文件目录下，这里的拷贝有几个文件或文件夹是必须要拷贝的：拷贝文件时要注意如果你的themes主题文件下下面有.git文件夹，要先将.git文件夹删除，否则主题文件会上传失败，一个GitHub仓库只能有一个.git 12345_config.yml package.json scaffolds/ source/ themes/ 拷贝完以后执行npm install 安装必要的组件 执行如下命令更新分支： 123git add .git commit -m &quot;add new files&quot;git push 测试是否成功可以执行hexo new “post”,hexo s预览是否有效，之后便用hexo d -g上传部署。 使用Mac系统操作hexo命令是要求在最前面加上sudo，否则会报错，提示你权限不足。 master分支和hexo分支各自保存着一个版本，master分支用于保存博客静态资源，提供博客页面供人访问；hexo分支用于备份博客部署文件，供自己维护更新，两者在一个GitHub仓库内也不会有任何冲突","categories":[{"name":"业务开发","slug":"业务开发","permalink":"http://huangyiblog.com/categories/业务开发/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://huangyiblog.com/tags/Github/"}]},{"title":"来普陀山拜观音了","slug":"来普陀山拜观音了","date":"2018-10-04T10:48:41.000Z","updated":"2018-12-19T15:12:55.493Z","comments":true,"path":"随笔/来普陀山拜观音了/","link":"","permalink":"http://huangyiblog.com/随笔/来普陀山拜观音了/","excerpt":"","text":"鉴于中国国情，一直以来我都是十分抵触国庆出游的，原因你懂得。但这次可能有点坐不住了，我姐说要带母亲去泰国旅游，家里没了人，我咋办呀～不行，我也得出去玩，我想了想，恩，爬山挺不错的，我喜欢。然后就去找高中同学商量着一起国庆去爬山。爬什么山呢，浙江附近有名的山还是有不少的，黄山，三清山，庐山，雁荡山．．．这些我都考虑过，后来同学提了句普陀山怎么样，我立马便决定，好，就去普陀山，顺便看看大海，拜拜观音。从后面看来，我的决定还是比较正确的。 那时还没到中秋，我们俩就提前把去舟山的车票，民宿订好了，民宿订的是个混合旅馆，住两晚。国庆景区人山人海，这是一直被人诟病的事实，但我这次总体体验还行，天公作美呀，这两天天气出奇的好，温度适宜，海风凉爽。起初我还有点担心台风的问题，但最后收到预警通知时我们都已经准备返程了。你说运气好不好。当然唯一有点遗憾的就是没去东极岛，我只知道这是韩寒拍后会无期的取景地，中国的第一缕阳光照射的地方，不过东极岛本就不在我的计划范围内，真说遗憾到也谈不上，毕竟是个小岛，而且也远，票都不一定抢的到。 ２号一大早起床，我就屁颠屁颠坐地铁来到杭州东站等大巴，坐着大巴离开杭州后的高速路上都很顺水，没发生什么堵车的问题，一直到了宁波镇海那边，速度有所减缓，真正发生堵车的地方就是在金塘大桥。这座桥是通往舟山的关键道路，也是图中碰到的第一座并且也是最长的一座跨海大桥。当然，比杭州湾跨海大桥要小点。看到大海以后最大的感慨就是为何如此混黄不清，与我心目中蔚蓝色大海相去甚远。但稍微想想，浙江的海应该都是灰黄灰黄的吧，不知道是因为地处钱塘江入海口还是其他原因。但浩瀚的气势还是有的，和我看惯了的千岛湖、西湖完全就是两种风格。进入舟山以后车子就开的较慢了，一路时停时走的来到了舟山普陀区，我当时也不记得自己买了到哪里的车票，结果就一路坐着过了观音大桥来到了朱家尖慈航广场，我一看，这哪行，我们定的民宿是在普陀区大岭下呀，然后有坐上车回程，司机带我们到彩虹广场放我们下来，我就顺便吃了饭再去民宿。 到了民宿后，我们结识了这次出行的第一位室友，聊了几句，发现他和我们一样也是大三学生，是个高高瘦瘦还有些帅气的萧山小伙子。我看到脖子上手臂上通红通红的，估计是被晒成这样的，当时他刚好玩累了回来，一脸虚脱样。他和我们不一样，我们是第一次来舟山，去普陀山拜观音的，他可不是第一次来了，他有两个大学同学是舟山人，这次放假就顺便陪他们来舟山玩两天再回家。到了傍晚，我们都没怎么饿，我就和同学商量着晚上去哪玩，这时萧山小哥说：“听说沈家门那边的鲁家峙大桥夜景挺不错的，我们一起去逛逛吧”，我们也没其他主意，于是在手机地图上查了查鲁家峙大桥的位置，写着距离２.４公里，我们一看，那也没多少路吗，直接走过去就得了。从大岭下出发，我们三人没走多久就遇到了个山洞，没想到这山洞出乎意料的长，我们三一前一后的排成一列，足足走了将近２０分钟才走到另一头，边上时不时几辆电瓶车飞驰而过，让我们老老实实贴着边缘走着，还真是不容易。没多久我们就来到了鲁家峙大桥桥底，上桥还得走个楼梯，从桥上往下望还是挺高的，桥下就是大海，这要掉下去可不是开玩笑的，我也不敢走太边上。我们在桥上赏了赏夜景，吹了吹海风，就返程了，返程我们可吃不消再走回去了，是坐公交回去的。回到民宿后，又和这位萧山小哥聊了聊，他在临安的浙江农林大学学法学，还准备要考研，司法考什么的，他倒是和我们聊起了昨晚和它住一起的室友，他说那位老哥昨晚大半夜的还在打电话，一个劲的拿头撞墙。我们听了一惊，只是咋回事呀，有啥想不开的？原来是被女朋友放了鸽子，放了鸽子还不算，他女朋友还要和他分手，而他早早地订好住宿，昨晚却在那电话里拼了命的求复合，一直闹腾到了大半夜，哎。我们那天也真是累了，第二天还得早起买票去，于是早早就上床休息了。 第二天６点多，我和同学起床吃了碗馄饨后就坐着公交来到慈航广场买船票了，那时还好，虽然已经有不少人在排队了，但还不算夸张，总之我们还是很庆幸自己出发的比较早。从朱家尖到普陀山的普通客船是３０元一人，普陀山进山门票是１８０，我们买了学生票９０元。进山后，我们往左开始游山，依次游览了百花园，观音古洞，磐陀石等，那时人还不多，所以游览起来还是蛮舒服的。普陀山应该也是个佛教圣地，山上寺庙众多，经常看到一些墙上写着喃无哦米投佛，我们一路翻山，来到百步沙，这是个沙滩，我们随即脱了鞋子去沙滩玩了，这时我又想到了天气好的好处，大暑假的你让我在这沙滩上晒太阳我怕是不大吃得消。我们俩走沙滩上都留了好久，捐起裤脚走在海边，看着海浪一波波涌来，但不敢走太里面，万一一不当心海浪盖过膝盖，那我的裤子是得湿透了。这之后已经快中午了，人山人海的架势也有点显现了，我们之后绕到了不肯去观音院和紫竹林，我一开始还以为这紫竹林是一大片竹林呢，结果到了以后半根竹子都没见着…逛了大半天，真事还没干，来普陀山怎么也得拜下南海观音吧，但是当我们到了南海观音雕像时已经是人山人海了，还有不少拿着香在哪虔诚的拜观音，我们就走在人群里，都不知道他们是在拜观音还是在拜我了。 我们的最后一站是南天门，二石壁立如门，所以不要以为南天门真的是扇门，只是三块大石头，两边各一块，顶上一块，状似一扇门，也就是所谓的南天门。南天门逛完后我们便返程了，还真是挺累的，走了大半天的路。 到了晚上，我们又结识了一位新室友，昨晚那位萧山小哥回家去了，今天搬进来了另一位小伙子。这小伙子更有意思，我们一直聊天聊到后半夜都意犹未尽。他也是个大三学生，还和我一样学的是计算机，你说巧不巧，同行遇同行，两眼泪汪汪，我们竟然开始聊起来了学习．．对的，你没听错，我们一开始聊得是学习．．我问他有什么打算，准备走什么方向，他是在江西读书，想考研，以后走算法方向，不过不是ＡＩ算法，而是数据处理那方面的。但我们聊学习没聊多久就转移了话题，你也知道两个学渣聊不出多大花头。我对这位小哥倒是很感兴趣，慢慢慢慢兴致也就上来了，首先，他是新疆人，这就足以勾起我很大好奇心了，平时我可是很少接触到新疆人呢。而且他有些想法我也比较认同。我告诉我们他这次从江西那边过来，先在宁波玩了两天然后又来舟山玩，他已经去了全国很多地方，他对我们说他出去旅游很多时候并不是为了看景点啥的，而是接触各种各样的人，到四处游玩可以让他接触很多没见过的东西，碰到很多不一样的人，这些人都有自己的一些习俗，想法，和他们聊天是件很有意思的事。我们之后聊了很多很多，有关于他中学是谈对象的故事，有关于他一个土豪室友的故事，还有很多关于新疆的故事，我们俩真是第一次听说新疆竟然是这样的。据他说新疆治安那时真的厉害，目标就是震慑一些犯罪分子，恐怖分子。记得之前发生了一件什么事，整个新疆整整半年停网停通讯，当然他没具体说什么事，毕竟属于机密事件，我也不敢乱写，不然得惹上不小麻烦。而且他们那边你可不能偷偷翻墙，一翻墙你就得接受“教育”了．．．总是我们各种瞎扯，时不时发点感慨，哇，土豪的世界我理解不了，哇，新疆竟然发生过这种事，我们听来就更听故事似的。 最后大家都累了，便熄灯安稳入睡了。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://huangyiblog.com/categories/随笔/"}],"tags":[{"name":"旅游记","slug":"旅游记","permalink":"http://huangyiblog.com/tags/旅游记/"}]},{"title":"腾讯精选50题146. LRU缓存机制","slug":"腾讯精选50题146-LRU缓存机制","date":"2018-08-25T08:44:21.000Z","updated":"2019-09-02T05:01:36.376Z","comments":true,"path":"题解集/腾讯精选50题146-LRU缓存机制/","link":"","permalink":"http://huangyiblog.com/题解集/腾讯精选50题146-LRU缓存机制/","excerpt":"","text":"题目描述运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例: LRUCache cache = new LRUCache( 2 / 缓存容量 / ); cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 该操作会使得密钥 2 作废cache.get(2); // 返回 -1 (未找到)cache.put(4, 4); // 该操作会使得密钥 1 作废cache.get(1); // 返回 -1 (未找到)cache.get(3); // 返回 3cache.get(4); // 返回 4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lru-cache著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析设计LRU缓存机制我们一般可以想到使用Java里面现成的LinkedHashMap数据结构，LinkedHashMap继承自HashMap，具有和HashMap一样的快速查找特性，同时内部维护了一个双向链表，用来维护插入顺序或LRU顺序。而这就是题目所要求的吧。具体实现： 可以设定最大缓存空间 为capacity； 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序，一般默认为false，属于插入顺序； 覆盖 removeEldestEntry() 方法实现，在节点多于 capacity 就会将最近最久未使用的数据移除。 具体代码1234567891011121314151617181920212223package thread;import java.util.LinkedHashMap;import java.util.Map;public class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt; &#123; private Map&lt;Integer, Integer&gt; map; public LRUCache(int capacity) &#123; map = new LinkedHashMap&lt;Integer, Integer&gt;(capacity, 0.75f, true)&#123; protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; capacity; &#125; &#125;; &#125; public int get(int key) &#123; return map.getOrDefault(key, -1); &#125; public void put(int key, int value) &#123; map.put(key, value); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536class LRUCache &#123; private int cap; private Map&lt;Integer, Integer&gt; map = new LinkedHashMap&lt;&gt;(); public LRUCache(int capacity) &#123; this.cap = capacity; &#125; public int get(int key) &#123; if(map.keySet().contains(key)) &#123; int value = map.get(key); map.remove(key); map.put(key, value); return value; &#125; return -1; &#125; public void put(int key, int value) &#123; if(map.keySet().contains(key)) &#123; map.remove(key); &#125; else if(map.size() == cap) &#123; Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator = map.entrySet().iterator(); iterator.next(); iterator.remove(); &#125; map.put(key, value); &#125;&#125;/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */","categories":[{"name":"题解集","slug":"题解集","permalink":"http://huangyiblog.com/categories/题解集/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://huangyiblog.com/tags/LeetCode/"}]},{"title":"红顶商人胡雪岩","slug":"红顶商人胡雪岩","date":"2018-07-06T10:51:46.000Z","updated":"2019-12-22T12:11:11.108Z","comments":true,"path":"阅读/红顶商人胡雪岩/","link":"","permalink":"http://huangyiblog.com/阅读/红顶商人胡雪岩/","excerpt":"","text":"期末考试最后一考完，吃完午饭，我便急匆匆出了校门，来到学校边上的新生公交站，冒着烈日等公交，当时太阳倒不算狠毒，但着实闷热得很。上午考的概率论很不理想，一道分值最高的计算题明明是送分题却让我看走眼，死心眼的以为老师出错题了，我已经不止一次考完交了卷才发觉自己犯了傻，但事后纠结自知已无用，也就将其抛之脑后罢了。额头上汗一滴滴的往下流，但也只能忍一忍了，因为早就计划好去一个地方参观参观－－胡雪岩故居。 以前一直没有意识到胡雪岩故居就在河坊街边上，因此即使路过怕是也没怎么在意，但这次想到要专门去访一访也并不是没有缘由的。我大学过的平平淡淡，唯一做的一件事就是养成了读书的习惯，纸质书也好，ｋｉｎｄｌｅ也好，一天不去读个及章节反倒不舒服了。最近一直在读的就是高阳写的《胡雪岩全传》，但有一点我也清楚，这毕竟只是小说，不可能与历史完全相合，因为关于胡雪岩的很多事迹其实本也就无法考证了，因此我也就只谈谈小说里的胡雪岩好了。说起来，读这种小说会让我有一种亲切感，一方面根据真人真事改编，另一方面，故事背景就发生在杭州，浙江一带，作为一个杭州人，哪怕读到一些地名倒也不会陌生。从书中的描述上来看，我对胡雪岩的佩服还是多过反感的，他身上有很多我所极欠缺的品质，总之作为一个商人，他几乎具备了商人所需的大部分优秀品质，被世人尊为商圣也不是毫无来由的。智商极高，于是不慌不乱，脑袋转动极快，一有了思路便快准狠的下手，不光快，而且严峻形势下还能考虑到方方面面，极为严谨不苟。 另一方面，牛逼的就是他的为人处世实在是老到精炼，无论官场，商场，帮派各种地方都混得开，交际甚广。朋友不光多，而且重情重义，绝不都是一帮狗肉朋友！他对自己到算是有很清楚的认识，对做官没兴趣，知道自己生来就是做生意的，不做生意皮就痒痒。关于他做人打交道的漂亮之处，我就举一个例子好了。那是在红顶商人那部里面张太太说的一件事，这位张太太也就是那位钱庄的伙计张胖子的夫人，张胖子后来由于自己的雇主翻脸不认人，到上海开了家杂货店，与红红火火的胡雪岩比起来了算是落魄了，但胡雪岩还是想拉他一把，与他合伙开钱庄，这时张太太透露了多年前的一件事，那时胡雪岩被赶出钱庄，正是穷困潦倒之际，有一天竟跑来找张太太借钱，一问不为别的，还是为了朋友，当时胡雪岩一位朋友重病，急需买药治疗，穷的叮当响的胡雪岩依旧想办法为其筹钱，当时拿了自己的一枚戒指作抵押问张太太借了5两银子，说道“这枚戒指市面上也就值1两，但是我母亲留给我的，所以也看的比较贵重”，后来钱当然退了，但胡雪岩并没有把戒指收回去，因为“今日的5两与当时的5两怎可同日而语”。一件小事，或者一次小小的谈话，可以看出他做人的漂亮之处，因此交际圈拉得开也不是完全没道理的。 当然，他的有些做法在很多人眼中倒并不算光彩，但他经商的能力确实是黑不掉的。从一个一穷二白的小伙计，到王有龄的知遇之恩，30年间平步青云，扶摇直上，甚至到了富可敌国，但悲剧性的一幕确实无法善终，最后一切在眨眼间竟就烟雾般消散，自己一生的经营毁于一旦，几日后抑郁而终，实在凄凉。这道又让我想起来了红楼梦里的贾府，繁华到幻灭，也就是一瞬间的事，简直让人分不清真假。他在元宝街的旧居总体还算方正，在我看来是挺大的了，正门进去假山林立，内湖内桥搭配得当，溶洞内也可方便出入，有许多珍贵的植物，谷物，包括厨房的摆设，都一点点映射出当日清末大户人家的生活景象，几圈逛下来累了，边找了个阴凉处木凳下坐了坐，闲暇之余顺便又看了一章节的小说，总体还算惬意。这里插一句，读书的时候出去逛逛真的不错，至少带着学生证门票可以半价。出了旧居，我便不行来到了另一处与胡雪岩有关的地方，想必你也已经猜到了，胡庆余堂，“大善人胡雪岩”开药店的初心就是想在后世留个好名，这点想必他倒可以知足了，当年威风江浙的胡道台，给人留下的胡庆余堂着实是一笔珍贵的财富。胡庆余堂至今在杭州还有多家门店，每天来看病的人络绎不绝，今天还碰巧有位带着几个老外在胡庆余堂博物馆做介绍的。百年过去，关于这位胡老爷的故事也都成了历史，就让我对这位杭州的实干家表示一份敬意吧，至少一生短暂，他没有稀里糊涂的就浪费过去了。","categories":[{"name":"阅读","slug":"阅读","permalink":"http://huangyiblog.com/categories/阅读/"}],"tags":[{"name":"文学","slug":"文学","permalink":"http://huangyiblog.com/tags/文学/"}]},{"title":"《追随》","slug":"《追随》","date":"2018-06-20T10:03:12.000Z","updated":"2018-10-14T08:51:36.029Z","comments":true,"path":"影音/《追随》/","link":"","permalink":"http://huangyiblog.com/影音/《追随》/","excerpt":"","text":"我之前一直没有写影评的习惯，看完电影，好就是好，烂就是烂，或喜、或悲、或震撼、或沉思，总之看完也就过去了，也不敢妄加品论，以免误导他人。但最近慢慢开始养成了写观后感的习惯，针对自己喜欢的，格调比较高的，或多或少结合自己的理解想写点感受。包括阅读也是，读书笔记是我向来忽略的一点，但这其实相当重要，倘若你想加深理解的话。 我平时看电影，很少会关注导演的信息，但这次确实不得不提一下这部《追随》的导演－－克里斯托弗·诺兰。网上一搜，才发现他的电影我都已经看过不下１０部，其中有很多都是被我奉为经典的作品。 《追随》1996年，诺兰拍了首部故事片《跟踪》。电影描述了一位作家逐渐成为一个跟踪癖的故事。电影完全不按事件发生顺序呈现，观众不得不随主角一起拼接情节碎片以了解当时究竟发生了什么。 《记忆碎片》2000年电影《记忆碎片》票房仍属上乘，并被称为邪典之作，获金球奖和奥斯卡奖的最佳编剧奖提名。 《蝙蝠侠》三部曲 《致命魔术》 2006年10月20日发行的《致命魔术》改编自克里斯托弗·普雷斯特（Christopher Priest）的同名小说，是关于19世纪两个互为对手的魔术师的故事。 《盗梦空间》一部科幻悬疑片，片中梦中梦的剧情着实很吸引人。 《星际穿越》 2014年的《星际穿越》讲述一队探险者根据当代重力及天体权威物理学家基普·索恩的理论，突破科学极限、穿越“虫洞”来寻找适合人类生存的星球的冒险故事。 《敦刻尔克》故事改编自著名的二战军事事件“敦克尔克大撤退”。二战初期，40万的英法盟军被敌军围困于敦刻尔克的海滩之上，面对敌军步步逼近的绝境，他们不得不为自己的命运背水一战，才有可能活着回家。 以上列举了几部我看过的诺兰的作品，基本符合时间线，看过的人想必也就可以想象诺兰一步步的封神之路是怎么走过来的。 《追随》是诺兰的导演处女作。由诺兰自编自导，杰里米·西奥伯德、亚历克斯·霍、露西·拉塞尔等人主演的惊悚片。 剧情梗概－－女主角是一个黑帮老大的情妇 。此黑帮老大某天在情妇家中杀掉了一个人，情妇家中的地毯上留下了血迹，情妇把地毯藏了起来，并且以此勒索黑帮老大。这是整个事情的起因。老大无法忍受情妇的勒索，派出假名叫柯布的杀手去解决这个麻烦，并且要求了杀人手法和地点（用锤子，在情妇家）。 “在很长时间里，我都是一个人生活。这种生活变得越来越孤单，并且乏味。一整天无事可做，就那么呆着。从那时起，我开始尾随别人”，影片以此开头，引入了男主，一个无业游民，一个幻想成为作家的作家，一个孤独的男人。诺兰着眼于剧情的连环与绕圈，他希望给观众一种走入迷宫的感觉，他曾说：“我决定以这种方式来组织我的故事，将重点放在观众对每一个新的场景不可能有完全的理解上，就像它是第一次被人们看到一样。”要做到这一点，影片的布局就不能简单处理，不能让观众在几分钟内看破剧情，然后感叹一波无趣。 说实话，我有点难以理解比尔的做法，或许是因为我没亲眼见过生活中真正由于这种原因尾随他人的人吧。孤独人我见过不少，迷茫的人，事业不顺的人身边一抓一大把，但是像比尔这样的，据他自己说尾随他人是为了寻找发现写作的素材，多么冠冕堂皇的一个理由，事实真的如此吗，对于他的追随动机也是我很好奇的一点。试想一下，一个极端孤独的年轻人，一个缺乏社交的可怜虫，心理扭曲而萌生了尾随陌生人的想法，甚至为自己的尾随做出了规范，要求随机性等等，这里其实涉及到了人性的方面，心理学的方面，我相信他和有些孤独的人不同，他是否是自己内心主动排斥社交？还是真正的社交无能？同时他又有着极强的好奇心，好奇他人的生活。他的行为毫无以为已然涉及到了犯罪，尽管他并无恶意，并无功利之心。 在剧情方面，电影围绕骗中骗，连环展开。之前提到了比尔，一个心理怪异的尾随狂，原本一切都没什么异常，他继续他的尾随就行了，但有一天，他对柯布发生了兴趣，也就是从那一刻起他已然落入陷阱，柯布是一位反侦察高手，一番观察与交谈，便已将比尔当做自己的棋子，为自己的任务开路。两人仿佛志同道合，开始一同作案，一起入室行窃，目的却不是钱，而是“人”，同时柯布开始传授比尔作案技巧，让比尔一步步模仿自己，然后成为自己的替罪羊。行窃过程中柯布有些偷窃心得倒是挺有意思的。第一个，盒子，他发现很多屋主都会有一个小盒子，里面不会放什么值钱的物品，但往往都是些私人物品，但却能折射出关于主人的真实世界。盒子一般是个鞋盒，放着自己私密的小东西。偷盗的哲学在于，丢了东西，才意识到拥有过。还有一个，当比尔被值钱行窃过的主人对视时，慌张不已的样子，柯布却来了句“虽然你行的是鸡鸣狗盗之事，但也不用摆出一副鸡鸣狗盗之相”．．． 慢慢慢慢，比尔在柯布的诱导下开始接触了金发女郎，当然也对她的房间行窃过。金发女郎是一位黑道大佬的情人，但比尔却一步步爱上了他，因为爱上，导致最后完全深陷泥潭而无法逃脱。他不知道，金发女郎和柯布其实暗中早已认识，沟通，此二人希望设局，找一位替罪羊，为自己脱罪，而这只可怜的替罪羊自然就是比尔，没有比他更好的选择了。而金发女郎自以为自己也是设局者，却不知其实自己也是一只可怜的羔羊。也是从一开始，金发女郎便已经是柯布的目标了，只是未能察觉。诺兰就是围绕这样一个剧情展开环式叙述，加深悬疑层次，用故事吸引了一大波影迷。只是这样的一个连环计在我看来似乎还是牵强了点，在逻辑上的严密感不是足够的强大，我只能默认是剧情需要了。当然了，对内容与真实的要求我想应该也不是诺兰最看重的，诺兰介绍自己时也曾提到“我不仅是一名导演，更是一个拥有奇想的人”。想来也是，如若没有一个奇思妙想，脑洞打开的头脑，怎么能编出令人赞叹不已的一部部神作。","categories":[{"name":"影音","slug":"影音","permalink":"http://huangyiblog.com/categories/影音/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://huangyiblog.com/tags/电影/"}]},{"title":"《无题》北岛","slug":"《无题》北岛","date":"2018-06-17T07:55:29.000Z","updated":"2018-10-14T08:45:59.116Z","comments":true,"path":"阅读/《无题》北岛/","link":"","permalink":"http://huangyiblog.com/阅读/《无题》北岛/","excerpt":"","text":"对于世界 我永远是个陌生人 我不懂它的言语 他不懂我的沉默 我们交换的 只是一点轻蔑 如同相逢在镜子里 对于自己 我永远是个陌生人 我畏惧黑暗 却用身体挡住了 那唯一的灯 我的影子是我的情人 心是仇敌 北岛的诗集里面，这首是我蛮喜欢的一首。 我爱诗愛词，爱李白的浪漫豪放，爱杜甫的忧国忧民，我爱古典诗，我也爱现代诗。 我遗憾，我遗憾自己的无才无能，遗憾自己不能像诗人般脱口成诗，吟唱古今。 “对于世界，我永远是个陌生人”，难道不是吗，地球没了我照样转，世界没了我，并不会就此停滞。我只是个路人，和所有人一样，来这世上走一遭，来看看这世界，尽管世界不会记得我来过。 “我们交换的，只是一点轻蔑，如同相逢在镜子里”我无法容忍这狭隘、势利的世界，世界眼中又何曾有过我，互相的轻蔑吧。 “我畏惧黑暗，却用身体挡住了，那唯一的灯”我的矛盾，我的孤独，哎，我不愿与这世界妥协，不愿与自己妥协，让我独自挣扎吧，让我独自探索吧。","categories":[{"name":"阅读","slug":"阅读","permalink":"http://huangyiblog.com/categories/阅读/"}],"tags":[{"name":"诗歌","slug":"诗歌","permalink":"http://huangyiblog.com/tags/诗歌/"}]},{"title":"看不见的客人","slug":"看不见的客人","date":"2018-06-04T08:59:45.000Z","updated":"2018-10-14T08:49:26.883Z","comments":true,"path":"影音/看不见的客人/","link":"","permalink":"http://huangyiblog.com/影音/看不见的客人/","excerpt":"","text":"昨晚看的一部电影《看不见的客人》，比我预想中的要好得多。其实和之前看的一部《控方证人》有异曲同工之处，但还是不得不承认这部剧的剧本够精彩。影片的主线围绕着一位律师和男主的谈话展开，一次次叙述的转变，层层反转，层层递进，吸引着观众紧跟节奏，直至结尾，真相揭露，给人豁然一击，人心叵测，人性慎测，莫过于此。 为什么说情节，布局十分巧妙。暂且撇开律师是死者母亲假扮这一点，说实话，在影片结尾这位母亲摘下假发，取下隐形镜片之前，我并没有看出来这位律师就是由死者母亲假扮的，当然，若是结合之前的一些对话以及言行，确实有很多地方与之相呼应，不然很难理解一位普通的花钱请来办事的普通律师会有很多奇怪的表现。例如，他为何一开始将一枚时钟摆在桌子上，表明只有３个小时的对话时间。另外，提现这部剧不是一部脑残剧的很大一点，便是这部剧剧情能吸引观众一步步深入，而不是一眼就让你看透结局。如何做到这一点的呢？首先影片是以律师和男主两人之间的对话展开的，这场对话实际上在我看来就是一场审判，一场拷问，关乎人性，关乎讽刺。因为对话的一方其实已经知道真相，而另一方却仍旧在重重伪装。而这位律师要做的便是层层诱导，让男主亲口一部部走入律师的陷阱，直至说出全部真相。剧情优秀的电影会让人觉得这是经得住推敲的，而这部电影恰好就是一部逻辑十分严密的电影。男主和律师其实是在进行一场博弈，尽管律师已经得知大部分真相，但她的目的是为了证据，他需要男主亲口说出自己的罪行，但显然，对男主这样一个内心防线严密的人来说这不是一件容易的事，他一次次叙述，一次次被律师推翻，就是想掩盖真相。你会发现，男主的每一次叙述，叙述中加入情节展现，你会发现竟然都是合情合理的，由此可以想象他的心理防线多么巨大，换言之，他的自私自利，泯灭良知已经到了何种程度。 接下来来看看男主的叙述，第一步，撇开车祸，撇开一切罪行喊冤，说明了自己在一个酒店莫名被人栽赃了，有人杀人劫财，并且嫁祸给他，一场密室杀人，所有证据都指向他，百口莫辩。然而，这场叙述不到10分钟就结束了，这样的话，律师简直听都不想听，于是让他别再浪费时间了，把该说的说出来才有辩护成功的希望，慢慢，男主有点服软，开始了他的第二个版本的叙述，这一次，他讲矛头指向了他的情人，劳拉。总之，他绝不会轻易说出自己的黑暗面，毕竟，他可是众人眼中的精英，万众瞩目，事业有成的成功企业家。男主将黑暗面加在了自己的情人劳拉身上，表明自己是身不由己，一时糊涂，听了情人劳拉的怂恿犯下大错，包括后面对死于车祸的男孩的陷害。然而律师一直不停的强调，注重细节，细节能救你，同时也能要了你的命。之后，男主一步步走入律师的圈套。最后，男主发现中计的时候，那种表情，绝对是被拷问后的表情，是被人对灵魂深深的拷问！让人难以想象的是男主为了自己所谓的前途竟然可以不择手段到这种程度，后面得知他的情人内心愧疚难安的了焦虑症，希望男主拿钱弥补死去男孩的父母并告知他们男孩尸体的位置，没想到男主一念之下杀了劳拉，更令人难以容忍的是，他在得知出了车祸的男孩还有一口气之时，他不是尽力去挽救，而是用力盖上了后备箱，视而不见，将车沉入湖底，实在难以想象但凡有一点良知的人能做得如此心狠手辣。 影片的讽刺方面直指一些现实社会中的“精英”，“名流”，尽管光环四射，衣着光鲜亮丽，成功，优秀都是他们的代名词，然而，有的人却被这些身外之物完全束缚了，私欲无限膨胀，完全以自我为中心，视他人如蝼蚁，视生命如蝼蚁，什么？出事了，我的前途怎么办，我的妻子女儿怎么办，我的事业刚刚达到巅峰，我怎能在这时出问题，一切都得为我开路，不能被这些碍手碍脚的家伙挡住我的美好前程。 另外，这部电影的正面主角，便是死者父母，用一句话来形容他们的内心“当你失去了至爱之人，便已无所畏惧”。他们为了给自己无辜的儿子，给死去的劳拉讨回一个公道，与男主不断周旋，收集各种资料，以谎言制服谎言，这也成就了这部电影最大的一个反转，长时间与恶龙搏斗，自身也会如同恶龙般强大，无所畏惧。 人心莫测，莫过于此，对《看不见的客人》而言，电影的画龙点睛之笔并不在于悬疑，更在于它深攫以了谎言这一人类用来满足自我私欲的本质，并在最后用打动人心的情感完成了这一内在的升华。","categories":[{"name":"影音","slug":"影音","permalink":"http://huangyiblog.com/categories/影音/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://huangyiblog.com/tags/电影/"}]},{"title":"190. 颠倒二进制位","slug":"190-颠倒二进制位","date":"2018-05-31T07:12:06.000Z","updated":"2018-12-19T15:12:55.588Z","comments":true,"path":"题解集/190-颠倒二进制位/","link":"","permalink":"http://huangyiblog.com/题解集/190-颠倒二进制位/","excerpt":"","text":"颠倒给定的 32 位无符号整数的二进制位。 示例:1234输入: 43261596输出: 964176192解释: 43261596 的二进制表示形式为 00000010100101000001111010011100 ， 返回 964176192，其二进制表示形式为 00111001011110000010100101000000 。 进阶:如果多次调用这个函数，你将如何优化你的算法？ 方法一：遍历整数的所有位。 如果第i个位置的一个位置在I / P编号中。然后将该位设置为（NO_OF_BITS - 1） - i in o / p。 NO_OF_BITS是给定数字中存在的位数。12345678910111213141516class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; unsigned int NO_OF_BITS = sizeof(n) * 8; unsigned int reverse_num = 0, i, temp; for (i = 0; i &lt; NO_OF_BITS; i++) &#123; temp = (n &amp; (1 &lt;&lt; i)); if(temp) reverse_num |= (1 &lt;&lt; ((NO_OF_BITS - 1) - i)); &#125; return reverse_num; &#125;&#125;; 时间复杂度：O(logn)空间复杂度：O(1)方法二：保持reversenum每一位与给定num相等直到num变成0，之后反向移动剩余的位123456789101112131415161718class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; unsigned int count = sizeof(n) * 8 - 1; unsigned int reverse_num = n; n &gt;&gt;= 1; while(n) &#123; reverse_num &lt;&lt;= 1; reverse_num |= n &amp; 1; n &gt;&gt;= 1; count--; &#125; reverse_num &lt;&lt;= count; return reverse_num; &#125;&#125;; 时间复杂度：O(logn)空间复杂度：O(1)","categories":[{"name":"题解集","slug":"题解集","permalink":"http://huangyiblog.com/categories/题解集/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://huangyiblog.com/tags/LeetCode/"}]},{"title":"卖米","slug":"卖米","date":"2018-05-30T00:16:57.000Z","updated":"2019-04-27T13:56:13.890Z","comments":true,"path":"阅读/卖米/","link":"","permalink":"http://huangyiblog.com/阅读/卖米/","excerpt":"","text":"01《卖米》作者飞花，原名张培祥，1979年，出生于湖南醴陵一个山区农民家庭。自小于贫寒中刻苦学习，1997年考入北京大学法学院，2001年攻读法学硕士。2003年非典期间，年仅24岁的张培祥就已身患白血病离开了人世。 天刚蒙蒙亮，母亲就把我叫起来了：“琼宝，明天是这里的场，咱们担点米到场上卖了，好弄点钱给你爹买药。” 我恍恍惚惚展开双眼，看看窗外，日头还没出来呢。我真实太困，又在床上赖了一会儿。 近邻传来父亲的咳嗽声，母亲在厨房忙在世，饭菜的喷鼻气夹杂着淡淡的油烟味飘过去，渐渐遣散了我的睡意。我坐起来，穿好衣服，开端铺床。 “姐，我也跟你们一同去赶场好不好？你买冰棍给我吃！” 弟弟顶着一头睡得乱蓬蓬的头发跑到我房里来。 “毅宝，你不要去，你留在家里放水。”近邻传来父亲的声响，同化着几声咳嗽。 弟弟有些不甘愿地冲近邻说：“爹，天气这么热，你自个昨天才中了暑，今天又叫我去，就不怕我也中暑！” “人怕热，庄稼不怕？都不去放水，地都干了，禾都死了，一家人喝东南风去？”父亲一动气，咳嗽得更加凶猛了。 弟弟冲我吐吐舌头，扮了个鬼脸，就到父亲房里去了。 只听见父亲开端叮嘱他怎样放水，去哪个塘里引水，先放哪丘田，哪几个中央要特别注意他人来截水，等等。 02吃过饭，弟弟就找着父亲常用的那把锄头出去了。我和母亲开始往谷箩里装米，装完后先称了一下，一担八十多斤，一担六十多斤。 我说：“妈，我挑重的那担吧。” “你学生妹子，肩膀嫩，还是我来。” 母亲说着，一哈腰，把那担重的挑起来了。 我挑起那担轻的，跟着母亲出了门。 “路上当心点！我们家的米好，别廉价卖了！”父亲披着衣服站在门口吩咐道。 “晓得了。你快回床上躺着吧。”母亲困难地把头从扁担旁边扭过去，吩咐道，“饭菜在锅里，半夜你叫毅宝热一下吃！” 赶场的中央离我家大约有四里路，我和母亲挑着米，在窄窄的田间巷子上走走停停，足足走了一个钟头才到。场上的人曾经不少了，咱们赶忙找了一块旷地，把担子放上去，把扁担放在地上，两个人坐在扁担上，拿凉帽扇着。 一大早就这么热，中午就更不得了，我忍不住替弟弟担忧起来。 他去放水，是要在里头晒上一成天的。 我往周围看了看，发现场上有很多人卖米，莫非他们都等着用钱？ 场上的人大都眼生，都是附近十里八里的同乡，人家也是耕田的，谁会来买米呢？ 我问母亲，母亲说：“有专门的米商人会来收米的。他们开了车到乡间来赶场，收了米，拉到城里去卖，能挣好些哩。” 我说：“凭什么都给他们挣？咱们也拉到城里去卖好了！”其实自个也晓得不过是气话。 果真，母亲说：“我们这么一点米，又没车，真弄到城里去卖，挣的钱还不敷路费呢！早先你爹身体好的时刻，自个挑着一百来斤米进城去卖，隔几天去一趟，倒比较划算一点。” 我不由心里一紧，疼爱起父亲来。从家里到城里足足有三十多里山路呢，他挑着那么重的担子走着去，该何等辛劳！就为了多挣那几个钱，把人累成这样，多不值啊！但又有什么方法呢？家里除了种地，也没其余收入，不卖米，拿什么钱供我和弟弟上学？ 我想着这些，心里一阵阵忧伤起来。看看旁边的母亲，头发有些花白了，黑黝黝的脸上爬上了好多皱纹，脑门上密密麻麻都是汗珠，眼睛有些红肿。 “妈，你喝点水。” 我把水壶递过来，拿凉帽替她扇着。 03米商人们终于开着车来了。他们四处看着卖米的人，走过来细心看米的成色，还把手插进米里，抓上一把米细看。 “一块零五。” 米商人开价了。 卖米的似乎嫌太低，想还价讨价。 “不讨价，一口价，爱卖不卖！” 米商人立场很强硬，究竟，满场都是卖米的人，只有他们是买家，不趁机压价，更待何时？ 母亲留意着那里的情形说：“一块零五？也太廉价了。上场还卖到一块一呢。” 正说着，有个米商人朝咱们这边走过来了。 他把手插进大米里，抓了一把出来，迎着阳光细看着。 “这米好咧！又白又匀净，又筛得洁净，一点沙子也没有！”母亲堆着笑，语气里有几分骄傲。 确实，我家的米比场上其他人卖的米都好。 那人点了摇头，说：“米是好米，不过这几天城里涨价，再好的米也卖不出好价前来。一块零五，卖不卖？” 母亲摇摇头：“这也太廉价了吧？上场还卖一块一呢。再说，你是识货的，一分钱一分货，我这米一定好过别家的！” 那人又看了看米，犹疑了一下，说：“原本都是一口价，不许还的，看你们家米好，我加点，一块零八，怎样样？” 母亲照样摇头：“不可，咱们家这米，少说也要卖到一块一。你再加点？” 那人冷笑一声，说：“明天一定卖不出一块一的行情，我出一块零八你不卖，等会散场的时刻你一块零五都卖不出去！” “卖不出去，我们再担回家！”那人的立场激恼了母亲。 “那你就等着担回家吧。”那人冷笑着，丢下这句话走了。 04我在旁边听着，心里算着：一块零八到一块一，每斤才差两分钱。 这里一共150斤米，总共也就三块钱的事情，路这么远，何须再挑回去呢？ 我的肩膀还在痛呢。 我悄悄对母亲说：“妈，一块零八就一块零八吧，横竖也就三块钱的事。再说，还等着钱给爹买药呢。” “那哪行？”母亲似乎有些生气了，“三块钱不是钱？再说了，也不单是几块钱的事，经商也得讲点良知，我们辛辛苦苦种出来的米，质量也好，哪能这么贱卖了？” 我不敢再说。 我晓得耕田有何等累。 光说炎天放水，不就把爹给病倒了？ 弟弟也才十一二岁的毛孩子，还不得找着锄头去放水！ 究竟，这是一家人的生计啊！ 又有几个米商人过去了，他们也都只出一块零五。有一两个出到一块零八，也不愿再加。 母亲依然不愿卖。 看看人逐渐少了，我有些焦急了。 母亲必然也很心急吧，我想。 “妈，你去那里树下凉爽一下吧！”我说。 母亲一边擦汗，一边摇头：“不可。我走开了，来人买米怎样办？你又不会讨价！” 我有些羞愧。 “百无一用是书生”，固然在学校里功课好，但这些事情上就比母亲差远了。 又有好些人来买米，由于我家的米实在是好，人人都过去看，但谁也不愿出到一块一。 看看日头到头顶上了，我感觉肚子饿了，便拿出带来的饭菜和母亲一同吃起来。 母亲吃了两口就不吃了，我晓得她是担忧米卖不出去，心里焦急。 母亲叹了口气：“还不晓得卖得掉卖不掉呢。” 我趁机说：“不然就廉价点卖好了。” 母亲说：“我心里有数。” 05下午人更少了，日头又毒，谁情愿在场上晒着呢。 看看母亲，衣服都粘在背上了，乌黑的脸上也显露出晒红的印迹来。 “妈，我替你看着，你去溪里泡泡去。” 母亲照样摇头：“不行，我有风湿，不能在凉水里泡。你怕热，去那里树底下躲躲好了。” “不必，我不怕晒。” “那你去买根冰棍吃好了。” 母亲说着，从兜里掏出两毛钱零钱来。 我最喜好吃冰棍了，特别是那种叫“葡萄冰”的最好吃，也不贵，两毛钱一根。 但我今天忽然不想吃了：“妈，我不吃，喝水就行。” 最热的时候也过来了，转眼快散场了。 卖杂货的小贩开始降价甩卖，卖菜，卖西瓜的也都呼喊着：“散场了，廉价卖了！” 我四处看看，场上已经没有几个卖米的了，大部分人已经卖完回去了。 母亲也焦急起来，一焦急，汗就出得越多了。 终于有个米贩子过来了：“这米卖不卖？一块零五，不论价！” 母亲说：“你看我这米，多好！上场还卖一块一呢……” 不等母亲说完，那人就不耐性地说：“行情不同了！想卖一块一，你就等着往回担吧！” 奇怪的是，母亲没有生气，反而堆着笑说：“那，一块零八，你要不要？” 那人从鼻子里哼了一声，说：“你这个价钱，不是开场的时候也难卖出来，如今都散场了，谁买？做梦吧！” 母亲的脸一会儿白了，动着嘴唇，但什么也没说。 一旁的我不由得插嘴了：“不买就不买，谁稀罕？不买你就别站在这里挡道！” “哟，大妹子，你别这么大火气。” 那人冷笑着说，“留着点力气等会把米担回去吧！” 等那人走了，我不由得抱怨母亲：“开场的时候人家出一块零八你不卖，这会好了，人家还不愿意买了！” 母亲似乎有些羞愧，但并不愿认错：“本来嘛，一分钱一分货，米是好米，哪能贱卖了？出门的时候你爹不还叮嘱叫卖个好价钱？” “你还说爹呢！他病在家里，指着这米换钱买药治病！人要紧还是钱要紧？” 母亲似乎没有话说了，等了一会儿，低声说：“一会儿人家出一块零五也卖了吧。” 可是再没有人来买米了，米贩子把买来的米装上车，开走了。 06散场了，我和母亲晒了一天，一颗米也没卖出来。 “妈，走吧，回去吧，别愣在那儿了。” 我收拾好毛巾、水壶、饭盒，催促道。 母亲踌躇着，终于起了身。 “妈，我来挑重的。” “你先生妹子，肩膀嫩……” 不等母亲说完，我已经把那担重的挑起来了。 母亲也没有再说什么，挑起那担轻的跟在我后面，踏上了回家的路。 肩上的担子好沉，我只感觉压着一座山似的。 忽然脚下一滑，我差点摔倒。 我赶忙把剩下的力气都用到腿上，好不容易站稳了，但肩上的担子还是倾斜了一下，洒了好多米出来。 “啊，怎么搞的？”母亲也放下担子走过来，嘴里说，“我叫你不要挑这么重的，你偏不听，这不是洒了。多惋惜！真是败家精！” 败家精是母亲的口头禅，我和弟弟干了什么坏事她老是这么数落我们。 但今天我感觉格外委屈，也不晓得为什么。 “你在这等会儿，我回家去拿个簸箕来把地上的米扫进去。浪费了多可惜！拿回去能够喂鸡呢！”母亲也不问我扭伤没有，只顾心疼洒了的米。 我晓得母亲的脾性，她素来是“刀子嘴，豆腐心”的，虽然也心疼我，嘴里却非要骂我几句。 想到这些，我也不委屈了。 “妈，你回去还要往返走个六七里路呢，时候也不早了。”我说。 “那地上的米怎样办？” 我心血来潮，把头上的凉帽摘下来：“装在这里边好了。” 母亲笑了：“还是你脑子活，学生妹子，机灵。” 说着，我们便蹲下身子，用手把洒落在地上的米捧起来，放在凉帽里，然后把凉帽顶朝下放在谷箩里，便挑着米持续往家赶。 回抵家里，弟弟曾经回来了，母亲便忙着做晚饭，我跟父亲申报卖米的经过。 父亲听了，也没埋怨母亲，只说：“那些米贩子也太黑了，城里都卖一块五呢，把价压这么低！这么挣庄稼人的血汗钱，太没良心了！” 我说：“爹，也没给你买药，怎样办？” 父亲说：“我原本就说不用买药的嘛，过两天就好了，花那个冤枉钱做什么！” 早晨，父亲咳嗽得更凶猛了。 母亲对我说：“琼宝，今天是转步的场，我们辛劳一点，把米挑到那里场上去卖了，好给你爹买药。” “转步？那多远，十几里路呢！”我想到那漫长的山路，不由有些发怵。 “明天你们少担点米去。每人担50斤就够了。”父亲说。 “那明天可不要再卖不掉担回来哦！”我说，“十几里山路走个往返，还挑着担子，可不是说着玩的！” “不会了不会了。”母亲说，“今天一块零八也好，一块零五也好，总之都卖了！” 母亲的话里有很多辛酸和无奈的意思，我听得出来，但不晓得怎样抚慰她。 我自个心里也很忧伤，有点想哭。 我想，别让母亲看见了，要哭就躲到被子里哭去吧。 可我真是太累啦，头刚刚挨到枕头就睡着了，睡得又香又甜。 注：《卖米》曾取得北京大学首届校园原创文学大赛一等奖。然而，在颁奖现场，获奖者并没有出现，而是由她的同窗们在寄予哀思，那氛围已经不是在颁奖，而是在开追悼会了。一时间，缄默掩盖了北大的整个阳光大厅。至此，我才晓得获奖者在一年前就已身患白血病离开了人世。 你来人间一趟，总要看看太阳。","categories":[{"name":"阅读","slug":"阅读","permalink":"http://huangyiblog.com/categories/阅读/"}],"tags":[{"name":"文学","slug":"文学","permalink":"http://huangyiblog.com/tags/文学/"}]},{"title":"红黑树简介","slug":"红黑树简介","date":"2018-05-29T08:27:17.000Z","updated":"2019-12-22T12:16:07.243Z","comments":true,"path":"算法和数据结构/红黑树简介/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/红黑树简介/","excerpt":"","text":"红黑树简介红黑树（Red Black Tree）是一种自平衡的二叉查找树，它是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树。后来，在1978年被Leo J.Guibas和Robert Sedgewick修改为如今的“红黑树”。红黑树应用非常广泛，比如C++ STL库中的map和Java中的TreeMap、HashMap都是基于红黑树红黑树结构实现的。近年来，红黑树也常在面试中被问到。因此，掌握红黑树数据结构是非常必要的。 红黑树的性质普通的二叉查找树在极端的情况下可退化成链表，此时的查找效率会比较低下。为了避免这种情况，就出现了一些自平衡的查找树，比如AVL、红黑树等。这些自平衡的查找树通过定义一些性质，将任意结点的左右子树高度差控制在固定范围内，以达到平衡状态。红黑树需要满足如下五条性质： 节点是红色或者黑色在树里面的结点不是红色就是黑色，没有其他颜色，这也就是红黑树的由来 根节点是黑色根节点总是黑色的，不能为红。 每个叶节点（NULL或空节点）是黑色NULL节点是个空节点，并且是黑色的。 每个红色节点的两个子节点都是黑色的连续的两个节点的意思就是父节点与子节点不能是连续的红色 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）从根节点到每一个NULL节点的路径中，都包含了相同数量的黑色节点。 这五条性质约束了红黑树，可以通过数学来证明，满足这五条性质的二叉树，就可以保证任意节点到其每个叶子节点路径最长不会超过最短路径的2倍。证明如下： 当某条路径最短时，这条路径比如都是黑色节点构成。当某条路径长度最长时，这条路径必然是由红色和黑色节点相间构成（性质4限定了不能出现两个连续的红色节点）。而性质5又限定了从任一节点到其每个叶子节点的所有路径必须包含相同数量的黑色节点。此时，在路径最长的情况下，路径上红色节点数量 = 黑色节点数量。该路径长度为黑色节点数量的2倍，也就是最短路径长度的2倍。 红黑树的操作红黑树的基本操作与其他树的操作一样，有查找、插入和删除等操作。由于查找与其他树的操作一样，比较简单，而插入、删除操作比较复杂，这里主要就是接受插入、删除操作。 1.旋转操作由于插入、删除的过程中都要涉及到旋转，这里首先介绍一下旋转这个基本操作。旋转操作分为左旋转和右旋转 左旋左旋的过程是将节点x的右子树绕节点x逆时针旋转，使得节点x的右子树成为x的父亲，同时修改修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 右旋右旋的过程是将节点x的左子树绕x顺时针旋转，使得节点x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 2.插入操作红黑树的插入过程和二叉查找树的插入过程基本类似，不同的地方在于，红黑树插入新节点后，需要进行调整，以满足红黑树的性质。在讨论红黑树的插入操作之前必须要明白，任何一个即将插入的新节点的初始颜色都为红色。原因很简单，引入插入黑色的节点会增加某条路径上黑节点的数目，从而导致整棵树黑高度的不平衡。但如果插入的节点是红色的，此时所有路径上的黑色节点数量不变，仅可能会出现两个连续的红色节点的情况。这种情况下，通过变色和旋转进行调整即可，比插入黑色的简单多了。 红黑树的插入可能遇到如下几种情况： 情况1：当插入的节点是根节点时，直接涂黑即可； 情况2：当要插入的节点的父节点是黑色的时候，这个时候插入一个红色的节点并没有对这五个性质产生破坏。所以直接插入不用在进行调整操作。 情况3：如果要插入的节点的父节点是红色且叔叔节点也是红色。由于父节点和插入的节点都是红色，所以性质4被打破，此时需要进行调整。在这种情况下，先将父节点和叔叔节点的颜色染成黑色，再让祖父结点染成红色。此时经过祖父结点的路径上的黑色节点数量不变，性质5仍然满足。但需要注意的是祖父节点被染成红色后，可能会和它的父节点形成连续的红色节点，此时需要递归向上调整。 情况4：当要插入的父节点为红色，叔叔节点为黑色。此时需要对父节点进行左旋，然后按照情况5进行处理（注：这里要插入的节点有可能是调整后的其它节点，这里我们理解父节点为插入节点而转到情况5）。 情况5：当要插入的父节点为红色，叔叔节点为黑色。插入节点是父节点的左孩子，且父节点是祖父节点的左孩子。此时对祖父节点进行右旋，并将祖父节点和父节点进行互换颜色。这时候满足了红黑树的全部性质。 3.删除操作相对于插入操作，红黑树的删除操作更为复杂。同样，这里我们也分为几种情况进行分析： 情况1：当被删除元素为红时，对五条性质都没有什么影响，直接删除即可。 情况2：当被删除元素为黑且为根节点时，直接删除。 情况3：当被删除元素为黑，且有一个右子节点为红时，将右子节点涂黑放到被删除元素的位置，如图： 情况4：当被删除元素为黑，且兄弟节点为黑，兄弟节点两个孩子也为黑，父节点为红，此时，交换兄弟节点与父节点的颜色；NULL元素是指每个叶节点都是两个空的元素，颜色为黑的NULL元素，需要他的时候就可以把它看成两个黑元素，不需要的时候就可以忽视它。 情况5：当被删除的元素为黑、并且为父节点的左支，且兄弟颜色为黑，兄弟的右支为红色，这个时候需要交换兄弟与父亲的颜色，并把富且涂黑、兄弟的右支涂黑，并以父节点为中心左转。 情况6：当被删除元素为黑、并且为父节点的左支，且兄弟颜色为黑，兄弟的左支为红色，这个时候需要先把兄弟与兄弟的左子节点颜色互换，进行右转，然后就变成了情况5一样，在按照情况5进行旋转。 情况7：当被删除元素为黑且为父元素的右支时，跟情况5、情况6互为镜像。 情况8：当被删除的元素为黑，且父父元素的左支，兄弟节点为红色的时候，需要交换兄弟节点与父节点的颜色，以父节点进行左旋，就变成了情况4，再按照情况四进行操作即可。","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"树状数组","slug":"树状数组","date":"2018-05-21T05:59:31.000Z","updated":"2018-10-09T14:43:20.692Z","comments":true,"path":"算法和数据结构/树状数组/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/树状数组/","excerpt":"","text":"lowbit运算lowbit运算属于二进制的一个经典应用：lowbit(x) = x &amp; (-x) 整数在计算机中一般采用的是补码存储，而把一个补码表示的整数x变成其相反数-x的过程相当于把x的二进制的每一位都取反，然后末位+1.这又等价于直接把x的二进制最右边的1左边的每一位都取反。 所以lowbit(x) = x &amp; (-x)其实就是取x的二进制最右边的1和它右边所有0.lowbit(x)也可以理解为能整除x的最大2的幂次。 树状数组及其应用例题导入：给出一个整数序列A，元素个数为N(N&lt;=10^5),接下来查询K次（K&lt;=10^5）,每次查询将给出一个正整数（x）(x&lt;=N),求前x个整数之和。 一般做法是开一个sum数组，其中sum[i]表示前i个整数之和（数组下标从1开始），这样sum数组就可以在输入N个整数时就预处理出来。接着每次查询前x个整数之和时，输出sum[x]就行。每次查询复杂度为O(1),查询总复杂度为O(K) 问题升级：假设在查询的过程中可能随时给第x个整数加上一个整数v，要求在查询中能实时输出前x个整数之和（更新操作和查询操作的次数总和为K次）。若按照原先的思路，操作的总复杂度会达到O(KN). BIT树状数组解法树状数组其实仍然是一个数组，是一个用来记录和的数组，只不过它存放的不是前i个整数之和，而是在i号位之前（含i号位）lowbit(i)个整数之和。用数组C表示树状数组，其中C[i]存放数组A中i号位之前lowbit(i)个元素之和，C[i]和覆盖长度为lowbit(i)lowbit(i)是2的幂次 树状数组的下标必须从1开始 设计函数getSum(x) ,返回前x个数之和A[i]+……+A[x]1234567int getSum(int x)&#123; int sum = 0; for(int i=x;i&gt;0;i-=lowbit(i))&#123; sum+=c[i]; &#125; return sum;&#125; 设计函数update(x,y),实现将第x个数加上一个数v的功能，即A[x]+=v.12345void updata(int x,int v)&#123; for(int i=x;i&lt;=N;i+=lowbit(i))&#123; c[i]+=v; &#125;&#125; 树状数组经典应用统计序列中在元素左边比该元素小的元素个数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cstring&gt;const int maxn = 100010;#define lowbit(i) ((i)&amp;(-i))int c[maxn];void update(int x,int v)&#123; for(int i=x;i&lt;maxn;i+=lowbit(i))&#123; c[i]+=v; &#125;&#125;int getSum(int x)&#123; int sum = 0; for(int i=x;i&gt;0;i-=lowbit(i))&#123; sum+=c[i]; &#125; return sum;&#125;int main()&#123; int n,x; scanf(\"%d\",&amp;n); memset(c,0,sizeof(c)); for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;x); update(x,1); printf(\"%d\\n\",getSum(x-1)); &#125; return 0;&#125;离散化代码#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100010;#define lowbit(i) ((i)&amp;(-i))struct Node&#123; int val; int pos;&#125;temp[maxn];int A[maxn];int c[maxn];void update(int x,int v)&#123; for(int i=x;i&lt;maxn;i+=lowbit(i))&#123; c[i]+=v; &#125;&#125;int getSum(int x)&#123; int sum = 0; for(int i=x;i&gt;0;i-=lowbit(i))&#123; sum+=c[i]; &#125; return sum;&#125;bool cmp(Node a,Node b)&#123; return a.val&lt;b.val;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); memset(c,0,sizeof(c)); for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;temp[i].val); temp[i].pos=i; &#125; sort(temp,temp+n,cmp); for(int i=0;i&lt;n;i++)&#123; if(i==0||temp[i].val!=temp[i-1].val)&#123; A[temp[i].pos] = i+1; &#125;else&#123; A[temp[i].pos] = A[temp[i-1].pos]; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; update(A[i],1); printf(\"%d\\n\",getSum(A[i]-1)); &#125; return 0;&#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"余光中的诗","slug":"余光中的诗","date":"2018-05-20T04:46:22.000Z","updated":"2018-10-14T08:55:19.486Z","comments":true,"path":"阅读/余光中的诗/","link":"","permalink":"http://huangyiblog.com/阅读/余光中的诗/","excerpt":"","text":"我会爱上现代诗，很大程度上有余先生的功劳；而我会关注到余先生，很大程度上是我一位高中同学的功劳。先生是在17年12月走的，得知消息后，内心还是有些伤感，但很快也就释然，相信先生定然是坦然且无遗憾地离开了我们。和很多朋友一样，了解到先生还是因为学校教材里收录了的他的作品，一首《乡愁》，便传遍了大江南北，一篇散文《听听那冷雨》，让人惊叹，原来是可以这么唱，散文可以这么写。梁实秋曾评价余光中，右手写诗，左手写散文，成就之高，一时无两。但之后我并未再去深入了解先生的作品，直到高三。班里有位大高个，是我在高中认识并结交的为数不多的好友之一，大家都叫他发哥，估计是身材魁梧的原因吧。可你绝对想不到，这家伙外表粗犷，内心却极其细腻，他很爱读书和摄影。猛虎细嗅蔷薇的感觉，用来形容他再适合不过了。记得高三班里面，的确，每个人座位里，抽屉里全都堆满了书，但几乎全是辅导书，模拟题，这时，发哥时不时拿在手里细细品味的一本《余光中散文诗集》就吸引了我的注意力，我笑嘻嘻地求他借我也看看，温暖的发哥自然不会拒绝，就这样，我一点点地了解到了先生更多的作品。如今先生走了，我不知该怎么还念他，于是又拿起了当年买的他的一本诗集翻看阅读着，顺便摘录几篇自己很喜欢的，与大家共品。绝色美丽而善变的巫娘，那月亮翻译是她的特长却把世界译走了样把太阳的鎔金译成了流银把烈火译成了冰而且带点薄荷的风味凡尝过的人都说译文是全不可靠但比起原文来呢却更加神秘，更加美雪是另一位唯美的译者存心把世界译错或者译对，诗人说只因原文本来就多误所以每当雪姑乘著六瓣的降落伞在风里飞旋地降临这世界一夜之间比革命更彻底竟变得如此白净若逢新雪初霁，满月当空下面平铺著皓影上面流转著亮银而你带笑地向我步来月色与雪色之间你是第三种绝色不知月色加反光的雪色该如何将你的本色——已经够出色的了合译成更绝的艳色？ 寻李白痛饮狂歌空度日 飞扬跋扈为谁雄那一双傲慢的靴子至今还落在高力士羞愤的手里，人却不见了把满地的难民和伤兵把胡马和羌笛交践的节奏留给杜二去细细的苦吟自从那年贺知章眼花了认你做谪仙，便更加佯狂用一只中了魔咒的小酒壶把自己藏起来，连太太也寻不到你怨长安城小而壶中天长在所有的诗里你都预言会突然水遁，或许就在明天只扁舟破浪，乱发当风而今，果然你失了踪树敌如林，世人皆欲杀肝硬化怎杀得死你酒入豪肠，七分酿成了月光余下的三分啸成剑气绣口一吐，就半个盛唐从开元到天宝，从洛阳到咸阳冠盖满途车骑的嚣闹不及千年后你的一首水晶绝句轻叩我额头当地一弹挑起的回音一贬世上已经够落魄再放夜郎毋乃太难堪至今成谜是你的籍贯陇西或山东，青莲乡或碎叶城不如归去归哪个故乡凡你醉处，你说过，皆非他乡失踪，是天才唯一的下场身后事，究竟你遁向何处猿啼不住，杜二也苦劝你不住一回头囚窗下竟已白头七仙、五友，都救不了你了匡山给雾锁了，无路可入仍炉火未纯青，就半粒丹砂怎追蹑葛洪袖里的流霞樽中月影，或许那才是你故乡常得你一生痴痴地仰望而无论出门向东哭，向西哭长安却早已陷落这二十四万里的归程也不必惊动大鹏了，也无须招鹤只消把酒杯向半空一扔便旋成一只霍霍的飞碟诡绿的闪光愈转愈快接你回传说里去 今生今世我最忘情的哭声有两次一次，在我生命的开始一次，在你生命的告终第一次，我不会记得是听你说的第二次，你不会晓得我说也没用但这两次哭声的中间有无穷无尽的笑声一遍一遍又一遍回荡了整整30年你都晓得，我都记得 乡愁小时候 乡愁是一枚小小的邮票 我在这头 母亲在那头 长大後 乡愁是一张窄窄的船票 我在这头 新娘在那头 後来啊 乡愁是一方矮矮的坟墓 我在外头 母亲在□头 而现在 乡愁是一湾浅浅的海峡 我在这头 大陆在那头 等你，在雨中等你，在雨中，在造虹的雨中蝉声沉落，蛙声升起一池的红莲如红焰，在雨中 你来不来都一样，竟感觉每朵莲都像你尤其隔着黄昏，隔着这样的细雨 永恒，刹那，刹那，永恒等你，在时间之外，在时间之外，等你，在刹那，在永恒 如果你的手在我的手里，此刻如果你的清芬在我的鼻孔，我会说，小情人 诺，这只手应该采莲，在吴宫这只手应该摇一柄桂浆，在木兰舟中 一颗星悬在科学馆的飞檐耳坠子一般的悬着瑞士表说都七点了忽然你走来 步雨后的红莲，翩翩，你走来像一首小令从一则爱情的典故里你走来 从姜白石的词里，有韵地，你走来 白玉苦瓜似醒似睡，缓缓的柔光里似悠悠醒自歉年的大寐一只瓜从从容容在成熟一只苦瓜，不再是色苦日磨月磋琢出深孕的清莹看茎须缭绕，叶掌抚抱哪一年的丰收想一口要吸尽古中国喂了又喂的乳浆完满的圆腻啊酣然而饱那触角，不断向外膨胀充实每一粒酪白的葡萄直到瓜尖，仍翘着当日的新鲜 茫茫九州只缩成一张舆图小时候不知道将它叠起一任摊开那无穷无尽硕大似记忆母亲，她的胸脯你便向那片肥沃匍匐用蒂用根索她的恩液苦心的慈悲苦苦哺出不幸呢还是大幸这婴孩钟整个大陆的爱在一只苦瓜皮鞋踩过，马蹄踩过重吨战车的履带踩过一丝伤痕也不曾留下 只留下隔玻璃这奇迹难信犹带着后土依依的祝福在时光以外奇异的光中熟着，一个自足的宇宙饱满而不虞腐烂，一只仙果不产生在仙山，产在人间久朽了，你的前身，唉，久朽为你换胎的那手，那巧腕千眄万睐巧将你引渡笑对灵魂在白玉里流转一首歌，咏生命曾经是瓜而苦被永恒引渡，成果而甘 1974.2.11 下次的约会当我死时，你的名字，如最后一瓣花自我的唇上飘落。你的手指是一串串钥匙，玲玲珑珑握在我手中，让我开启让我豁然开启，哪一扇门？ 握你的手而死是幸运的听你说，你仍爱我，听你说凤凰死后还有凤凰春天死后还有春天，但至少有一个五月曾属于我们 每一根白发仍为你颤抖，每一根潇骚都记得旧时候，记得你踩过的地方绽几朵红莲你立的地方喷一株水仙你立在风中，裙也翩翩，发也翩翩 覆你的耳朵于我的胸膛听我的心说，它倦了，倦了它已经逾龄，为甄甄啊甄甄它跳得太强烈，跳得太频爱情给它太重的负荷，爱情 爱情的一端在此，另一端在原始。 上次约会在蓝田再上次，在洛水之滨在洪荒，在沧海，在星云的叆叆在记忆啊记忆之外，另一端爱情 下次的约会在何处，在何处？你说呢，你说，我依你（你可相信轮回，你可相信？）死亡的黑袖挡住，我看不清楚，可是嗯，我听见了，我一定去 听听那冷雨惊蛰一过，春寒加剧。先是料料峭峭，继而雨季开始，时而淋淋漓漓，时而淅淅沥沥，天潮潮地湿湿，即连在梦里，也似乎有把伞撑着。而就凭一把伞，躲过一阵潇潇的冷雨，也躲不过整个雨季。连思想也都是潮润润的。每天回家，曲折穿过金门街到厦门街迷宫式的长巷短巷，雨里风里，走入霏霏令人更想入非非。想这样子的台北凄凄切切完全是黑白片的味道，想整个中国整部中国的历史无非是一张黑白片子，片头到片尾，一直是这样下着雨的。这种感觉，不知道是不是从安东尼奥尼那里来的。不过那—块土地是久违了，二十五年，四分之一的世纪，即使有雨，也隔着千山万山，千伞万伞。十五年，一切都断了，只有气候，只有气象报告还牵连在一起，大寒流从那块土地上弥天卷来，这种酷冷吾与古大陆分担。不能扑进她怀里，被她的裙边扫一扫也算是安慰孺慕之情吧。 这样想时，严寒里竟有一点温暖的感觉了。这样想时，他希望这些狭长的巷子永远延伸下去，他的思路也可以延伸下去，不是金门街到厦门街，而是金门到厦门。他是厦门人，至少是广义的厦门人，二十年来，不住在厦门，住在厦门街，算是嘲弄吧，也算是安慰。不过说到广义，他同样也是广义的江南人，常州人，南京人，川娃儿，五陵少年。杏花春雨江南，那是他的少年时代了。再过半个月就是清明。安东尼奥尼的镜头摇过去，摇过去又摇过来。残山剩水犹如是，皇天后土犹如是。纭纭黔首、纷纷黎民从北到南犹如是。那里面是中国吗？那里面当然还是中国永远是中国。只是杏花春雨已不再，牧童遥指已不再，剑门细雨渭城轻尘也都已不再。然则他日思夜梦的那片土地，究竟在哪里呢？ 在报纸的头条标题里吗？还是香港的谣言里？还是傅聪的黑键白键马恩聪的跳弓拨弦？还是安东尼奥尼的镜底勒马洲的望中？还是呢，故宫博物院的壁头和玻璃柜内，京戏的锣鼓声中太白和东坡的韵里？ 杏花，春雨，江南。六个方块字，或许那片土就在那里面。而无论赤县也好神州也好中国也好，变来变去，只要仓颉的灵感不灭，美丽的中文不老，那形象那磁石一般的向心力当必然长在。因为一个方块字是一个天地。太初有字，于是汉族的心灵他祖先的回忆和希望便有了寄托。譬如凭空写一个“雨”字，点点滴滴，滂滂沱沱，淅淅沥沥，一切云情雨意，就宛然其中了。视觉上的这种美感，岂是什么rain也好pluie也好所能满足？翻开一部《辞源》或《辞海》，金木水火土，各成世界，而一入“雨”部，古神州的天颜千变万化，便悉在望中，美丽的霜雪云霞，骇人的雷电霹雹，展露的无非是神的好脾气与坏脾气，气象台百读不厌门外汉百思不解的百科全书。 听听，那冷雨。看看，那冷雨。嗅嗅闻闻，那冷雨，舔舔吧，那冷雨。雨在他的伞上这城市百万人的伞上雨衣上屋上天线上，雨下在基隆港在防波堤海峡的船上，清明这季雨。雨是女性，应该最富于感性。雨气空而迷幻，细细嗅嗅，清清爽爽新新，有一点点薄荷的香味，浓的时候，竟发出草和树林之后特有的淡淡土腥气，也许那竟是蚯蚓的蜗牛的腥气吧，毕竟是惊蛰了啊。也许地上的地下的生命也许古中国层层叠叠的记忆皆蠢蠢而蠕，也许是植物的潜意识和梦紧，那腥气。 第三次去美国，在高高的丹佛他山居住了两年。美国的西部，多山多沙漠，千里干旱，天，蓝似安格罗萨克逊人的眼睛，地，红如印第安人的肌肤，云，却是罕见的白鸟，落基山簇簇耀目的雪峰上，很少飘云牵雾。一来高，二来干，三来森林线以上，杉柏也止步，中国诗词里“荡胸生层云”或是“商略黄昏雨”的意趣，是落基山上难睹的景象。落基山岭之胜，在石，在雪。那些奇岩怪石，相叠互倚，砌一场惊心动魄的雕塑展览，给太阳和千里的风看。那雪，白得虚虚幻幻，冷得清清醒醒，那股皑皑不绝一仰难尽的气势，压得人呼吸困难，心寒眸酸。不过要领略“白云回望合，青露入看无”的境界，仍须来中国。台湾湿度很高，最饶云气氛题雨意迷离的情调。两度夜宿溪头，树香沁鼻，宵寒袭肘，枕着润碧湿翠苍苍交叠的山影和万缀都歇的俱寂，仙人一样睡去。山中一夜饱雨，次晨醒来，在旭日未升的原始幽静中，冲着隔夜的寒气，踏着满地的断柯折枝和仍在流泻的细股雨水，一径探入森林的秘密，曲曲弯弯，步上山去。溪头的山，树密雾浓，蓊郁的水气从谷底冉冉升起，时稠时稀，蒸腾多姿，幻化无定，只能从雾破云开的空处，窥见乍现即隐的一峰半堑，要纵览全貌，几乎是不可能的。至少上山两次，只能在白茫茫里和溪头诸峰玩捉迷藏的游戏。回到台北，世人问起，除了笑而不答心自问，故作神秘之外，实际的印象，也无非山在虚无之间罢了。云绦烟绕，山隐水迢的中国风景，由来予人宋画的韵味。那天下也许是赵家的天下，那山水却是米家的山水。而究竟，是米氏父子下笔像中国的山水，还是中国的山水上只像宋画，恐怕是谁也说不清楚了吧？ 雨不但可嗅，可亲，更可以听。听听那冷雨。听雨，只要不是石破天惊的台风暴雨，在听觉上总是一种美感。大陆上的秋天，无论是疏雨滴梧桐，或是骤雨打荷叶，听去总有一点凄凉，凄清，凄楚，于今在岛上回味，则在凄楚之外，再笼上一层凄迷了，饶你多少豪情侠气，怕也经不起三番五次的风吹雨打。一打少年听雨，红烛昏沉。再打中年听雨，客舟中江阔云低。三打白头听雨的僧庐下，这更是亡宋之痛，一颗敏感心灵的一生：楼上，江上，庙里，用冷冷的雨珠子串成。十年前，他曾在一场摧心折骨的鬼雨中迷失了自己。雨，该是一滴湿漓漓的灵魂，窗外在喊谁。 雨打在树上和瓦上，韵律都清脆可听。尤其是铿铿敲在屋瓦上，那古老的音乐，属于中国。王禹的黄冈，破如椽的大竹为屋瓦。据说住在竹楼上面，急雨声如瀑布，密雪声比碎玉，而无论鼓琴，咏诗，下棋，投壶，共鸣的效果都特别好。这样岂不像住在竹和筒里面，任何细脆的声响，怕都会加倍夸大，反而令人耳朵过敏吧。 雨天的屋瓦，浮漾湿湿的流光，灰而温柔，迎光则微明，背光则幽黯，对于视觉，是一种低沉的安慰。至于雨敲在鳞鳞千瓣的瓦上，由远而近，轻轻重重轻轻，夹着一股股的细流沿瓦槽与屋檐潺潺泻下，各种敲击音与滑音密织成网，谁的千指百指在按摩耳轮。“下雨了”，温柔的灰美人来了，她冰冰的纤手在屋顶拂弄着无数的黑键啊灰键，把晌午一下子奏成了黄昏。 在古老的大陆上，千屋万户是如此。二十多年前，初来这岛上，日式的瓦屋亦是如此。先是天黯了下来，城市像罩在一块巨幅的毛玻璃里，阴影在户内延长复加深。然后凉凉的水意弥漫在空间，风自每一个角落里旋起，感觉得到，每一个屋顶上呼吸沉重都覆着灰云。雨来了，最轻的敲打乐敲打这城市。苍茫的屋顶，远远近近，一张张敲过去，古老的琴，那细细密密的节奏，单调里自有一种柔婉与亲切，滴滴点点滴滴，似幻似真，若孩时在摇篮里，一曲耳熟的童谣摇摇欲睡，母亲吟哦鼻音与喉音。或是在江南的泽国水乡，一大筐绿油油的桑叶被啮于千百头蚕，细细琐琐屑屑，口器与口器咀咀嚼嚼。雨来了，雨来的时候瓦这幺说，一片瓦说千亿片瓦说，说轻轻地奏吧沉沉地弹，徐徐地叩吧挞挞地打，间间歇歇敲一个雨季，即兴演奏从惊蛰到清明，在零落的坟上冷冷奏挽歌，一片瓦吟千亿片瓦吟。 在旧式的古屋里听雨，听四月，霏霏不绝的黄梅雨，朝夕不断，旬月绵延，湿黏黏的苔藓从石阶下一直侵到舌底，心底。到七月，听台风台雨在古屋顶上一夜盲奏，千层海底的热浪沸沸被狂风挟挟，掀翻整个太平洋只为向他的矮屋檐重重压下，整个海在他的蝎壳上哗哗泻过。不然便是雷雨夜，白烟一般的纱帐里听羯鼓一通又一通，滔天的暴雨滂滂沛沛扑来，强劲的电琵琶忐忐忑忑忐忐忑忑，弹动屋瓦的惊悸腾腾欲掀起。不然便是斜斜的西北雨斜斜刷在窗玻璃上，鞭在墙上打在阔大的芭蕉叶上，一阵寒潮泻过，秋意便弥湿旧式的庭院了。 在旧式的古屋里听雨，春雨绵绵听到秋雨潇潇，从少年听到中年，听听那冷雨。雨是一种单调而耐听的音乐是室内乐是室外乐，户内听听，户外听听，冷冷，那音乐。雨是一种回忆的音乐，听听那冷雨，回忆江南的雨下得满地是江湖下在桥上和船上，也下在四川在秧田和蛙塘，—下肥了嘉陵江下湿布谷咕咕的啼声，雨是潮潮润润的音乐下在渴望的唇上，舔舔那冷雨。 因为雨是最最原始的敲打乐从记忆的彼端敲起。瓦是最最低沉的乐器灰蒙蒙的温柔覆盖着听雨的人，瓦是音乐的雨伞撑起。但不久公寓的时代来临，台北你怎么一下子长高了，瓦的音乐竟成了绝响。千片万片的瓦翩翩，美丽的灰蝴蝶纷纷飞走，飞入历史的记忆。现在雨下下来下在水泥的屋顶和墙上，没有音韵的雨季。树也砍光了，那月桂，那枫树，柳树和擎天的巨椰，雨来的时候不再有丛叶嘈嘈切切，闪动湿湿的绿光迎接。鸟声减了啾啾，蛙声沉了咯咯，秋天的虫吟也减了唧唧。七十年代的台北不需要这些，一个乐队接一个乐队便遣散尽了。要听鸡叫，只有去诗经的韵里找。现在只剩下一张黑白片，黑白的默片。 正如马车的时代去后，三轮车的伕工也去了。曾经在雨夜，三轮车的油布篷挂起，送她回家的途中，篷里的世界小得多可爱，而且躲在警察的辖区以外，雨衣的口袋越大越好，盛得下他的一只手里握一只纤纤的手。台湾的雨季这么长，该有人发明一种宽宽的双人雨衣，一人分穿一只袖子此外的部分就不必分得太苛。而无论工业如何发达，一时似乎还废不了雨伞。只要雨不倾盆，风不横吹，撑一把伞在雨中仍不失古典的韵味。任雨点敲在黑布伞或是透明的塑胶伞上，将骨柄一旋，雨珠向四方喷溅，伞缘便旋成了一圈飞檐。跟女友共一把雨伞，该是一种美丽的合作吧。最好是初恋，有点兴奋，更有点不好意思，若即若离之间，雨不妨下大一点。真正初恋，恐怕是兴奋得不需要伞的，手牵手在雨中狂奔而去，把年轻的长发的肌肤交给漫天的淋淋漓漓，然后向对方的唇上颊上尝凉凉甜甜的雨水。不过那要非常年轻且激情，同时，也只能发生在法国的新潮片里吧。 大多数的雨伞想不会为约会张开。上班下班，上学放学，菜市来回的途中。现实的伞，灰色的星期三。握着雨伞。他听那冷雨打在伞上。索性更冷一些就好了，他想。索性把湿湿的灰雨冻成干干爽爽的白雨，六角形的结晶体在无风的空中回回旋旋地降下来。等须眉和肩头白尽时，伸手一拂就落了。二十五年，没有受故乡白雨的祝福，或许发上下一点白霜是一种变相的自我补偿吧。一位英雄，经得起多少次雨季？他的额头是水成岩削成还是火成岩？他的心底究竟有多厚的苔藓？厦门街的雨巷走了二十年与记忆等长，—座无瓦的公寓在巷底等他，一盏灯在楼上的雨窗子里，等他回去，向晚餐后的沉思冥想去整理青苔深深的记忆。 前尘隔海。古屋不再。听听那冷雨。","categories":[{"name":"阅读","slug":"阅读","permalink":"http://huangyiblog.com/categories/阅读/"}],"tags":[{"name":"诗歌","slug":"诗歌","permalink":"http://huangyiblog.com/tags/诗歌/"}]},{"title":"完全背包","slug":"完全背包","date":"2018-05-16T11:45:25.000Z","updated":"2018-10-09T14:43:20.689Z","comments":true,"path":"算法和数据结构/完全背包/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/完全背包/","excerpt":"","text":"完全背包问题有n种物品，每种物品的单件重量为w[i],价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，使得背包内物品的总价值最大。其中每种物品都有无穷件。 完全背包与01背包的唯一区别：完全背包的物品数量每种有无穷件，而01背包的物品数量每种只有1件。 令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值 对每种物品有两种策略： 不放第i件物品，那么dp[i][v] = dp[i-1][v] 放第i件物品。dp[i][v] = dp[i][v-w[i]]+c[i]由此得出状态转移方程：**dp[i][v] = max(dp[i-1][v],dp[i][v-w[i]]+c[i]) (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V)** 边界：dp[0][v] = 0(0&lt;=v&lt;=V) 改写成一维形式：**dp[v] = max(dp[v],dp[v-w[i]]+c[i]) (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V)** 边界：dp[v] = 0(0&lt;=v&lt;=V) 12345for(int i=1;i&lt;=n;i++)&#123; for(int v=w[i];v&lt;=V;v++)&#123; dp[v] = max(dp[v],dp[v-w[i]]+c[i]); &#125;&#125; 常见dp问题的模型总结 最大连续子列和令dp[i]表示以A[i]作为末尾的连续序列的最大和。 最长不下降子序列（LIS）令dp[i]表示以A[i]结尾的最长不下降子序列长度 最长公共子序列（LCS）令dp[i][j]表示字符串A的i号位和字符串B的j号位之前的LCS长度 最长回文子串令dp[i][j]表示S[i]至S[j]所表示的子串是否是回文子串 数塔dp令dp[i][j]表示从第i行第j个数字出发的到达最底层的所有路径上所能得到的最大和 DAG最长路令dp[i]表示从i号顶点出发能获得的最长路径长度 01背包令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值 完全背包令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"01背包","slug":"01背包","date":"2018-05-16T11:45:01.000Z","updated":"2018-12-19T14:03:41.874Z","comments":true,"path":"算法和数据结构/01背包/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/01背包/","excerpt":"","text":"01背包问题有n件物品，每件物品的重量为w[i]，价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，使得背包内物品的总价值最大。其中每件物品都只有1件。样例：123455 8 //n,v3 5 1 2 2 //w[i]4 5 2 1 3 //c[i] 暴力枚举的想法枚举每一件物品放或者不放进背包，显然每件物品都有两种选择，因此n件物品就有2^n种情况，显然不是理想的解决方案 动态规划解法时间复杂度为O(nV) 令dp[i][v]表示前i件物品（1&lt;=i&lt;=n,0&lt;=v&lt;=V）恰好装入容量为v的背包中所能获得的最大价值。 考虑对第i件物品的选择策略，有两种策略： 不放第i件物品，那么问题转化为前i-1件物品恰好装入容量为v的背包中所能获得的最大价值，即dp[i-1][v] 放第i件物品，那么问题转化为前i-1件物品恰好装入容量为v-w[i]的背包中所能获得的最大价值，即dp[i-1][v-w[i]]+c[i] 由此得出状态转移方程： dp[i][v] = max{dp[i-1][v],dp[i-1][v-w[i]]+c[i]} (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V) 边界： dp[0][v] = 0(0&lt;=v&lt;=V)（即前0件物品放入任何容量为v的背包中都只能获得价值0） 12345for(int i=1;i&lt;=n;i++)&#123; for(int v=w[i];v&lt;=V;v++)&#123; dp[i][v] = max(dp[i-1][v],dp[i-1][v-w[i]]+c[i]); &#125;&#125; 这段代码时间复杂度与空间复杂度均为O(nV),其中时间复杂度无法优化，但空间复杂度可以优化的关键在于开一个一维数组dp[v]，枚举方向改变为i从1到n，v从V到0（逆序） 状态转移方程： dp[v] = max{dp[v],dp[v-w[i]]+c[i]} (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V) 12345for(int i=1;i&lt;=n;i++)&#123; for(int v=V;v&gt;=w[i];v--)&#123; dp[v] = max(dp[v],dp[v-w[i]]+c[i]); &#125;&#125; 此时空间复杂度为O(V)说明：如果是二维数组存放，v的枚举顺序或逆序皆可；但如果用一维数组存放，v的枚举必须为逆序 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100;const int maxv = 1000;int w[maxn],c[maxn],dp[maxv];int main()&#123; int n,V; scanf(\"%d%d\",&amp;n,&amp;V); for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;w[i]); &#125; for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;c[i]); &#125; for(int v=0;v&lt;=V;v++)&#123; dp[v] = 0; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int v=V;v&gt;=w[i];v--)&#123; dp[v] = max(dp[v],dp[v-w[i]]+c[i]); &#125; &#125; int max = 0; for(int v=0;v&lt;=V;v++)&#123; if(dp[v]&gt;max)&#123; max = dp[v]; &#125; &#125; printf(\"%d\\n\",max); return 0;&#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"最长回文子串","slug":"最长回文子串","date":"2018-05-15T06:40:37.000Z","updated":"2018-10-09T14:43:20.692Z","comments":true,"path":"算法和数据结构/最长回文子串/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/最长回文子串/","excerpt":"","text":"最长回文子串问题描述：给出一个字符串S，求S的最长回文子串的长度。 暴力解法枚举子串的两个端点i和j，判断[i,j]区间内的子串是否回文。其中枚举端点需要O(n^2),判断回文需要O(n)因此总的复杂度为O(n^3) 动态规划解法时间复杂度为O(n^2)令dp[i][j]表示S[i]至S[j]所表示的子串是否是回文子串，是则为1，不是为0.根据S[i]是否等于S[j]，将转移情况分为两类： 若S[i]==S[j]，只要S[i+1]到S[j-1]是回文子串，那么S[i]到S[j]就是回文子串；否则，就不是。 若S[i]!=S[j]那么S[i]到S[j]一定不是回文子串。由此得出状态转移方程： dp[i][j]= dp[i+1][j-1],S[i]==S[j] 0,S[i]!=S[j]边界：dp[i][i] = 1,dp[i][i+1] = (S[i]==S[i+1)?1:0 但是不能按照i和j从小到大进行枚举子串两个端点然后更新dp[i][j]，因为无法保证dp[i+1][j-1]已经被计算过，从而无法得到正确的dp[i][j] 由于边界表示的是长度为1和2的子串，且每次转移时都对子串的长度减1，因此考虑按子串的长度和子串的初始位置进行枚举即第一遍将长度为3的子串的dp值全部求出，第二遍通过第一遍结果计算长度为4的子串的值12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;cstring&gt;const int maxn = 1010;char S[maxn];int dp[maxn][maxn];int main()&#123; gets(S); int len = strlen(S),ans = 1; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;len;i++)&#123; dp[i][i] = 1; if(i&lt;len-1)&#123; if(S[i]==S[i+1])&#123; dp[i][i+1] = 1; ans = 2; &#125; &#125; &#125; for(int t=3;t&lt;=len;t++)&#123; for(int i=0;i+t-1&lt;len;i++)&#123; int j = i+t-1; if(S[i]==S[j]&amp;&amp;dp[i+1][j-1]==1)&#123; dp[i][j] = 1; ans = t; &#125; &#125; &#125; printf(\"%d\\n\",ans); return 0;&#125; 字符串哈希+二分解法时间复杂度为O(nlogn)对给定的字符串str，可以先求出其字符串hash数组h1，然后再将str反转，求出反转字符串rstr的hash数组h2，接着按回文串的奇偶情况讨论 回文串的长度是奇数：枚举回文中心点i，二分子串的半径k，找到最大的使子串[i-k,i+k]是回文串的k。 回文串的长度是偶数：枚举回文空隙点，令i表示空隙左边第一个元素的下标，二分子串的半径k，找到最大的使子串[i-k+1,i+k]是回文串的k。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const ll mod = 1000000007;const ll p = 10000019;const ll maxn = 200010;ll powp[maxn],h1[maxn],h2[maxn];void init()&#123; powp[0] = 1; for(int i=1;i&lt;maxn;i++)&#123; powp[i] = (powp[i-1]*p)%mod; &#125;&#125;void calh(ll h[],string &amp;str)&#123; h[0] = str[0]; for(int i=1;i&lt;str.length();i++)&#123; h[i] = (h[i-1]*p+str[i])%mod; &#125;&#125;int calSingleSubh(ll h[],int i,int j)&#123; if(i==0) return h[j]; return ((h[j]-h[i-1]*powp[j-i+1])%mod+mod)%mod;&#125;int binarySearch(int l,int r,int len,int i,int isEven)&#123; while(l&lt;r)&#123; int mid = (l+r)/2; int h1l = i-mid+isEven,h1r = i; int h2l = len-1-(i+mid),h2r = len-1-(i+isEven); int hashl = calSingleSubh(h1,h1l,h1r); int hashr = calSingleSubh(h2,h2l,h2r); if(hashl!=hashr) r=mid; else l=mid+1; &#125; return l-1;&#125;int main()&#123; init(); string str; getline(cin,str); calh(h1,str); reverse(str.begin(),str.end()); calh(h2,str); int ans = 0; for(int i=0;i&lt;str.length();i++)&#123; int maxlen = min(i,(int)str.length()-1-i)+1; int k = binarySearch(0,maxlen,str.length(),i,0); ans = max(ans,k*2+1); &#125; for(int i=0;i&lt;str.length();i++)&#123; int maxlen = min(i+1,(int)str.length()-1-i)+1; int k = binarySearch(0,maxlen,str.length(),i,1); ans = max(ans,k*2); &#125; printf(\"%d\\n\",ans); return 0;&#125; Manacher算法时间复杂度为O(n)算法分析：由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。 举个例子：s=”abbahopxpo”，转换为s_new=”$#a#b#b#a#h#o#p#x#p#o#”（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文abba和一个奇回文opxpo，被转换为#a#b#b#a#和#o#p#x#p#o#，长度都转换成了奇数。 定义一个辅助数组int p[]，其中p[i]表示以 i 为中心的最长回文的半径p[i] - 1正好是原字符串中最长回文串的长度。 设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。 假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么：12if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); 2 * id - i为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快查找。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;void findBMstr(string&amp; str)&#123; int *p = new int[str.size() + 1]; memset(p, 0, sizeof(p)); int mx = 0, id = 0; for(int i = 1; i &lt;= str.size(); i++) &#123; if(mx &gt; i) &#123; p[i] = (p[2*id - i] &lt; (mx - i) ? p[2*id - i] : (mx - i)); &#125; else &#123; p[i] = 1; &#125; while(str[i - p[i]] == str[i + p[i]]) p[i]++; if(i + p[i] &gt; mx) &#123; mx = i + p[i]; id = i; &#125; &#125; int max = 0, ii; for(int i = 1; i &lt; str.size(); i++) &#123; if(p[i] &gt; max) &#123; ii = i; max = p[i]; &#125; &#125; max--; int start = ii - max ; int end = ii + max; for(int i = start; i &lt;= end; i++) &#123; if(str[i] != '#') &#123; cout &lt;&lt; str[i]; &#125; &#125; cout &lt;&lt; endl; delete p;&#125;int main()&#123; string str = \"12212321\"; string str0; str0 += \"$#\"; for(int i = 0; i &lt; str.size(); i++) &#123; str0 += str[i]; str0 += \"#\"; &#125; cout &lt;&lt; str0 &lt;&lt; endl; findBMstr(str0); return 0;&#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"最长公共子序列","slug":"最长公共子序列","date":"2018-05-14T07:47:17.000Z","updated":"2018-10-09T14:43:20.691Z","comments":true,"path":"算法和数据结构/最长公共子序列/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/最长公共子序列/","excerpt":"","text":"最长公共子序列最长公共子序列问题描述：给定两个字符串（或数字序列）A和B,求一个字符串，使得这个字符串是A和B的最长公共部分（子序列可以不连续） 暴力解法设字符串A和B的长度分别是n和m，那么对两个字符串中的每个字符，分别有选与不选两个决策，而得到子序列后比较两个子序列是否相同有需要O(max(m,n))，这样总的复杂度就会达到O(2^(m+n)*max(m,n))，无法承受较大数据 动态规划解法令dp[i][j]表示字符串A的i号位和字符串B的j号位之前的LCS长度（下标从1开始）两种决策如下： 若A[i]==B[j]则字符串A与字符串B的LCS增加了1位，即dp[i][j]=dp[i-1][j-1]+! 若A[i]!=B[j]，则字符串A的i号位和字符串B的j号位之前的LCS无法延长，因此dp[i][j]将会继承dp[i-1][j]与dp[i][j-1]z中的较大值，即dp[i][j]= max{dp[i-1][j],dp[i][j-1]} 由此可以得到状态转移方程：dp[i][j]= dp[i-1][j-1]+1,A[i]==B[j] max{dp[i-1][j],dp[i][j-1]},A[i]!=B[j]边界：dp[i][0]=dp[0][j]=0(0&lt;=i&lt;=n,0&lt;=j&lt;=m)时间复杂度为O(nm)12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 100;char A[N],B[N];int dp[N][N];int main()&#123; int n; gets(A+1);//从下标为1开始读入 gets(B+1); int lenA = strlen(A+1); int lenB = strlen(B+1); for(int i=0;i&lt;=lenA;i++)&#123; dp[i][0] = 0; &#125; for(int j=0;j&lt;=lenB;j++)&#123; dp[0][j] = 0; &#125; for(int i=1;i&lt;=lenA;i++)&#123; for(int j=1;j&lt;=lenB;j++)&#123; if(A[i]==B[j])&#123; dp[i][j] = dp[i-1][j-1]+1; &#125;else&#123; dp[i][j] = max(dp[i-1][j],dp[i][j-1]); &#125; &#125; &#125; printf(\"%d\\n\",dp[lenA][lenB]); return 0;&#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"最长不下降子序列","slug":"最长不下降子序列","date":"2018-05-14T07:25:42.000Z","updated":"2018-10-09T14:43:20.691Z","comments":true,"path":"算法和数据结构/最长不下降子序列/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/最长不下降子序列/","excerpt":"","text":"最长不下降子序列LIS问题：在一个数字序列中，找到一个最长的子序列（可以不连续），使得这个子序列是不下降的 原始方法枚举每种情况，即对于每个元素有取和不取两种选择，然后判断序列是否为不下降序列。如果是不下降序列，则更新最大长度，直到枚举完所有情况并得到最大长度。但这种做法时间复杂度将达到O(2^n)显然不可取 动态规划解法用dp[i]表示以A[i]结尾的最长不下降子序列长度，则A[i]有两种情况 如果存在A[i]之前的元素Aj，使得A[j]&lt;=A[i]且dp[j]+1&gt;dp[i]（即把A[i]跟以A[j]结尾的LIS后面时能比当前以A[i]结尾的LIS长度更长），那么就把A[i]跟在以A[j]结尾的LIS后面，形成一条更长的不下降子序列，（令dp[i]=dp[j]+1） 如果A[i]之前的元素都比A[i]大，那么A[i]就只好自己形成一条LIS,但是长度为1，即这个子序列里面只有一个A[i] 最后以A[i]结尾的LIS长度就是上述两点中能形成的最大长度 由此写出状态转移方程：dp[i] = max{1,dp[j]+1}(j=1,2,…i-1&amp;&amp;A[j]&lt;A[i])边界dp[i] = 1(1&lt;=i&lt;=n)整体复杂度为O(n^2)123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 100;int A[N],dp[N];int main()&#123; int n; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;A[i]); &#125; int ans = -1; for(int i=1;i&lt;=n;i++)&#123; dp[i] = 1; for(int j=1;j&lt;i;j++)&#123; if(A[i]&gt;=A[j]&amp;&amp;(dp[j]+1&gt;dp[i]))&#123; dp[i] = dp[j]+1; &#125; &#125; ans = max(ans,dp[i]); &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"最大连续子列和","slug":"最大连续子列和","date":"2018-05-13T03:57:35.000Z","updated":"2018-10-09T14:43:20.691Z","comments":true,"path":"算法和数据结构/最大连续子列和/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/最大连续子列和/","excerpt":"","text":"最大连续子列和问题给定一个数字序列A1，A2，……An,求i，j(1&lt;=i&lt;=j&lt;=n),使得Ai+….Aj最大，输出这个最大和。 方法一：暴力枚举枚举左端点和右端点（即枚举i和j），需要O(n^2)的复杂度，求和有需要O(n)的复杂度，因此总复杂度为O(n^3) 方法二：预处理记录前缀和记S[i] = A[0]+A[1]….+A[i],这样A[i]+…+A[j] = S[j]-S[i-1];该计算的复杂度为O(1),但总的时间复杂度为O(n^2) 方法三：动态规划动态规划问题的核心与难点其实就在于确定状态和状态转移方程，以及边界分析。步骤一：确定状态令状态dp[i]表示以A[i]作为末尾的连续序列的最大和，因此所求最大和便是dp[0],dp[1],dp[2]…dp[n-1]中的最大值。步骤二：确定状态转移方程，求dp数组以A[i]结尾的连续序列只有两种情况 这个最大和的连续序列只有一个元素，即以A[i]开始，以A[i]结尾 这个最大和的连续序列有多个元素，即以A[p]开始，A[i]结尾第一种情况，最大和就是A[i]第二种情况，最大和是dp[i-1]+A[i]所以可以得到状态转移方程dp[i] = max{A[i],dp[i-1]+A[i]}边界为dp[0] = A[0]时间复杂度为O(n)12345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 10010;int a[maxn],dp[maxn];int main()&#123; int n; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;a[i]); &#125; dp[0] = a[0]; for(int i=1;i&lt;n;i++)&#123; dp[i] = max(a[i],dp[i-1]+a[i]); &#125; int k = 0; for(int i=1;i&lt;n;i++)&#123; if(dp[i]&gt;dp[k])&#123; k = i; &#125; &#125; printf(\"%d\\n\",dp[k]); return 0;&#125; 状态的无后效性状态的无后效性是指：当前状态记录了信息，一旦当前状态确定，就不会再改变，且未来的决策只能在已有的一个或若干个状态的基础上进行，历史信息只能通过已有的状态去影响未来的决策。","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"拓扑排序","slug":"拓扑排序","date":"2018-05-11T13:09:24.000Z","updated":"2018-10-09T14:43:20.691Z","comments":true,"path":"算法和数据结构/拓扑排序/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/拓扑排序/","excerpt":"","text":"有向无环图如果一个有向图的任意顶点都无法通过一些有向边回到自身，那么称这个有向图为有向无环图。 拓扑排序拓扑排序是将有向无环图G的所有顶点排成一个线性序列，使得对图G中的任意两个顶点u，v，如果存在边u-&gt;v,那么在序列中u一定在v前面。该序列被称为拓扑序列。求解拓扑序列： 定义一个队列q,并把所有入度为0的结点加入队列 取队首结点，输出。然后删去所有从它出发的边，并令这些边到达的顶点的入度减1，如果某个顶点的入度减为0，则将其加入队列。 反复进行2操作，直到队列为空。如果队列为空时入队的结点数目恰好为n，说明拓扑排序成功，图G为有向无环图；否则，拓扑排序失败，图G中有环。 123456789101112131415161718192021222324252627vector&lt;int&gt; G[maxv];int n,m,inDegree[maxv];bool topologicalSort()&#123; int num = 0; queue&lt;int&gt; q; for(int i=0;i&lt;n;i++)&#123; if(inDegree[i]==0)&#123; q.push(i); &#125; &#125; while(!q.empty())&#123; int u = q.front(); printf(\"%d \",u); q.pop(); for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; inDegree[v]--; if(inDegree[v]==0)&#123; q.push(v); &#125; &#125; G[u].clear(); num++; &#125; if(num==n) return true; else return false;&#125; 用拓扑排序可以判断一个給定的图是否为有向无环图。","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"最小生成树","slug":"最小生成树","date":"2018-05-10T12:21:08.000Z","updated":"2018-10-09T14:43:20.691Z","comments":true,"path":"算法和数据结构/最小生成树/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/最小生成树/","excerpt":"","text":"最小生成树最小生成树（MST）是在一个給定的无向图G(v,e)中求一棵树T，使得这棵树拥有图G中的所有顶点，且所有边都是来自图G中的边，并且满足整棵树的边权之和最小。 三个重要性质 最小生成树是树，因此其边数等于顶点数减1，且树内一定不会有环。 对給定的图G（v,e），其最小生成树可以不唯一，但其边权之和一定是唯一的。 由于最小生成树是在无向图中生成的，因此其根结点可以是这棵树上的任意一个结点，于是，如果题目中涉及最小生成树本身的输出，为了让最小生成树唯一，一般都会直接给出根结点。 求最小生成树一般有两种算法，即prim算法和kruskal算法。这两种算法均采用了贪心的思想。 prim算法基本思想：对图G（v，e）设置集合s，存放已被访问的顶点，然后每次从集合v-s中选择与集合s的最短距离最小的一个顶点（记为u）访问并加入集合s。之后，令顶点u为中介点，优化所有从u能到达的顶点v与集合s之间的最短距离。这样的操作执行n次，直到集合s已包含所有顶点。其实思路与Dijstra算法类似。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const int maxv = 1000;const int inf = 0x3f3f3f3f;//邻接矩阵写法int n,g[maxv][maxv];int d[maxv];bool vis[maxv] = &#123;false&#125;;int prim()&#123;//默认0为初始点，返回最小生成树边权之和 fill(d,d+maxv,inf); d[0] = 0; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int u=-1,minm = inf; for(int j=0;j&lt;n;j++)&#123; //找到未被访问的顶点中d[]最小的 if(vis[j]==false&amp;&amp;d[j]&lt;minm)&#123; u = j; minm = d[j]; &#125; &#125; //找不到小于inf的d[u],则剩下的顶点和集合s不连通 if(u==-1) return -1; vis[u] = true; ans+= d[u]; for(int v=0;v&lt;n;v++)&#123;//v未被访问&amp;&amp;u能到达v&amp;&amp;以u为中介点可以使v离集合s更近 if(vis[v]==false&amp;&amp;g[u][v]!=inf&amp;&amp;g[u][v]&lt;d[v])&#123; d[v] = g[u][v]; &#125; &#125; &#125; return ans;&#125;//邻接表写法struct Node&#123; int v,dis;&#125;;vector&lt;Node&gt; Adj[maxv];int n;int d[maxv];bool vis[maxv] = &#123;false&#125;;int prim()&#123; fill(d,d+maxv,inf); d[0] = 0; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int u=-1,minm = inf; for(int j=0;j&lt;n;j++)&#123; if(vis[j]==false&amp;&amp;d[j]&lt;minm)&#123; u = j; minm = d[j]; &#125; &#125; if(u==-1) return -1; vis[u] = true; ans+ = d[u]; for(int j=0;j&lt;Adj[u].size();j++)&#123; int v=Adj[u][j].v; if(vis[v]==false&amp;&amp;Adj[u][j]&lt;div)&#123; d[v] = g[u][[v]; &#125; &#125; &#125; return ans;&#125; kruskal算法kruskal算法采用的是边贪心的策略基本思想：在初始状态时隐去图中的所有边，这样图中每个顶点都自成一个连通块。之后执行如下步骤： 对所有边按边权从小到大排序 按边权从小到大测试所有边，如果当前测试边所连接的两个顶点不在同一个连通块中，则把这条测试边加入到当前最小生成树中；否则，将边舍弃 执行步骤2，直到最小生成树中的边数等于总顶点数减1或是测试完所有边时结束。当结束时如果最小生成树的边数小于总顶点数减1，说明该图不连通。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct edge&#123; int u,v; int cost;//边权&#125;e[maxe];bool cmp(edge a,edge b)&#123; return a.cost&lt;b.cost;&#125;伪代码int kruskal()&#123; 令最小生成树的边权之和为ans，最小生成树的当前边数为Num_Edge; 将所有边按边权从小到大排序; for(从小到大枚举所有边)&#123; if(当前测试边的两个端点在不同的连通块中)&#123; 将该测试边加入最小生成树中; ans+=测试边的边权; 最小生成树的当前边数为Num_Edge+1; 当边数Num_Edge等于顶点数减1时结束循环; &#125; &#125; return ans;&#125;其中 并查集可以通过查询两个结点所在集合的根结点是否相同来判断他们是否在同一个集合而只要把测试边的两个端点所在集合合并，就能达到将边加入最小生成树的效果int father[n];int findfather(int x)&#123; &#125;int kruskal()&#123; int ans = 0,Num_Edge = 0; for(int i=1;i&lt;=n;i++)&#123; father[i] = i; &#125; sort(e,e+m,cmp); for(int i=0;i&lt;m;i++)&#123; int fau = findfather(e[i].u); int fav = findfather(e[i].v); if(fau!=fav)&#123; father[fau] = fav; ans += e[i].cost; Num_Edge++; if(Num_Edge==n-1) break; &#125; &#125; if(Num_Edge!=n-1) return -1; else return ans;&#125; kruskal算法的时间复杂度主要来源于对边进行排序所以其时间复杂度为O(eloge)综合来看：如果是稠密图（边多），则用prim算法；如果是稀疏图（边少），则用kruskal算法","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"最短路问题","slug":"最短路问题","date":"2018-05-09T11:45:53.000Z","updated":"2018-10-09T14:43:20.691Z","comments":true,"path":"算法和数据结构/最短路问题/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/最短路问题/","excerpt":"","text":"最短路径最短路径是图论中的一个经典问题：给定图G(v,e)，求一条从起点到终点的路径，使得这条路径上经过的所有边的边权之和最小。 即解决如下问题：对任意给出的图G（v，e）和起点s，终点t，如何求从s到t的最短路径解决最短路径的常用算法有Dijkstra算法、Bellman-Ford算法，SPFA算法和Floyd算法 Dijstra算法Dijstra算法用来解决单源最短路问题，即给定图G和起点s，通过算法得到s到达其他每个顶点的最短距离。基本思想：对图G（v，e）设置集合s，存放已被访问的顶点，然后每次从集合v-s中选择与起点s的最短距离最小的一个顶点（记为u），访问并加入集合s。之后，令顶点u为中介点，优化起点s与所有从u能到达的顶点v之间的最短距离。这样的操作执行n次，直到集合s已包含所有顶点。算法策略：设置集合s存放已被访问的顶点，然后执行n次下面的两个步骤 每次从集合v-s中选择与起点s的最短距离最小的一个顶点（记为u），访问并加入集合s 之后，令顶点u为中介点，优化起点s与所有从u能到达的顶点v之间的最短距离 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071伪代码Dijkstra(G,d[],s)&#123; 初始化; for(循环n次)&#123; u = 使d[u]最小的还未被访问的顶点的标号; 记u已被访问; for(从u出发能到达的所有顶点v)&#123; if(v未被访问&amp;&amp;以u为中介点使s到顶点v的最短距离d[v]更优)&#123; 优化d[v]; &#125; &#125; &#125;&#125;//邻接矩阵版const maxv = 1000;const int inf = 0x3fffffff;int n,G[maxv][maxv];int d[maxv];bool vis[maxv]=&#123;false&#125;;void Dijstra(int s)&#123; fill(d,d+maxv,inf);//fill函数将整个d数组赋值为inf d[s] = 0; for(int i = 0;i &lt; n; i++)&#123; int u = -1,minm = inf; for(int j = 0; j&lt;n; j++)&#123; if(vis[j]==false&amp;&amp;d[j]&lt;minm)&#123; u=j; minm = d[j]; &#125; &#125; if(u==-1) return ; vis[u] = true; for(int v = 0;v&lt;n;v++)&#123; if(vis[v] == false&amp;&amp;G[u][v]!=inf&amp;&amp;d[u]+G[u][v]&lt;d[v])&#123; d[v] = d[u]+G[u][v]; &#125; &#125; &#125;&#125;//邻接表版struct Node&#123; int v,dis; &#125;;vector&lt;Node&gt; Adj[maxv];int n;int d[maxv];bool vis[maxv] = &#123;false&#125;;void Dijstra(int s)&#123; fill(d,d+maxv,inf); d[s] = 0; for(int i=0;i&lt;n;i++)&#123; int u=-1,minm=inf; for(int j=0;j&lt;n;j++)&#123; if(vis[j]==false&amp;&amp;d[j]&lt;minm)&#123; u=j; minm=d[j]; &#125; &#125; if(u==-1) return; vis[u] = true; for(int j=0;j&lt;Adj[u].size();j++)&#123; int v = Adj[u][j].v; if(vis[v]==false&amp;&amp;d[u]+Adj[u][j].dis&lt;d[v])&#123; d[v] = d[u] + Adj[u][j].dis; &#125; &#125; &#125;&#125; Bellman-Ford算法Dijstra算法可以很好地解决无负权图的最短路径问题，但如果出现了负权边，Dijstra算法会失效。Bellman-Ford和Dijstra一样，也可以解决单源最短路径问题，同时能处理有负权边的情况。 由于Bellman-Ford算法需要遍历所有边，所以使用邻接表会比邻接矩阵方便1234567891011121314151617181920212223242526272829303132struct Node&#123; int v,dis;//v为邻接边的目标顶点，dis为邻接边的边权&#125;;vector&lt;Node&gt; Adj[maxv]; //图G的邻接表int n;//n为顶点数，maxv为最大顶点数int d[maxv]; //起点到达各边的最短路径长度bool Bellman(int s)&#123; fill(d,d+maxv,inf); d[s]=0; for(int i=0;i&lt;n-1;i++)&#123; for(int u=0;u&lt;n;u++)&#123; for(int j=0;j&lt;Adj[u].size();j++)&#123; int v=Adj[u][j].v; int dis=Adj[u][j].dis; if(d[u]+dis&lt;d[v])&#123; d[v]=d[u]+dis; &#125; &#125; &#125; &#125; // 以下为判断负环的代码 for(int u=0;u&lt;n;u++)&#123; for(int j=0;j&lt;Adj[u].size();j++)&#123; int v=Adj[u][j].v; int dis=Adj[u][j].dis; if(d[u]+dis&lt;d[v])&#123; return false; &#125; &#125; &#125; return true;&#125; 由于Bellman-Ford算法的时间复杂度达到了O(ve),这并不如意，所以需要进行优化，Bellman-Ford的每轮操作都需要操作所有边，这其中会有大量无意义操作，严重影响了算法性能。由于，只有当某个顶点u的d[u]值改变时，从它出发的邻接点v的d[v]值才有可能被改变。所以可以如下优化：建立一个队列，每次将队首顶点u取出，然后对从u出发的所有边u-&gt;v进行松弛操作，即判断d[u]+length[u-&gt;v]&lt;d[v]是否成立，如果成立，则用d[u]+length[u-&gt;v]覆盖d[v];如果v不在队列中，就把v加入队列。这样操作直到队列为空（说明图中没有从源点可达的负环），或某个顶点的入队次数超过v-1（说明图中存在从源点可达的负环） SPFA算法上述被优化后的算法即为SPFA算法，期望时间复杂度为O(ve)但如果图中有从源点可达的负环，则SPFA的时间复杂度又会退化为O(ve)1234567891011121314151617181920212223242526272829303132vector&lt;Node&gt; ADj[maxv];int n,d[maxv],num[maxv];bool inq[maxv];bool SPFA(int s)&#123; memset(inq,false,sizeof(inq)); memset(num,0,sizeof(num)); fill(d,d+maxv,inf); queue&lt;int&gt; q; q.push(s); inq[s]=true; num[s]++; d[s]=0; while(q.empty())&#123; int u=q.front(); q.pop(); inq[u]=false; for(int j=0;j&lt;Adj[u].size();j++)&#123; int v=Adj[u][j].v; int dis=Adj[u][j].dis; if(d[u]+dis&lt;d[v])&#123; d[v]=d[u]+dis; if(!inq[v])&#123; q.push(v); inq[v]=true; num[v]++; if(num[v]&gt;=n) return false; &#125; &#125; &#125; &#125; return true;&#125; Flord算法Flord算法用来解决全源最短路问题。即对給定的图G（v,e），求任意两点u，v之间的最短路径长度，时间复杂度为O(n^3)所以顶点数要限制约在200以内。用邻接矩阵来实现Flord算法比较合适。123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int inf =0x3f3f3f3f;const int maxv =200;int n,m;int dis[maxv][maxv];void Flord()&#123; for(int k=0;k&lt;n;k++)&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(dis[i][k]!=inf&amp;&amp;dis[k][j]!=inf&amp;&amp;dis[i][k]+dis[k][j]&lt;dis[i][j])&#123; dis[i][j]=dis[i][k]+dis[k][j]; &#125; &#125; &#125; &#125;&#125;int main()&#123; int u,v,w; fill(dis[0],dis[0]+maxv*maxv,inf); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; dis[i][i]=0; &#125; for(int i=0;i&lt;m;i++)&#123; scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); dis[u][v]=w; &#125; Flord(); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; printf(\"%d \",dis[i][j]); &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"图的存储和遍历","slug":"图的存储和遍历","date":"2018-05-04T09:10:20.000Z","updated":"2018-10-09T14:43:20.688Z","comments":true,"path":"算法和数据结构/图的存储和遍历/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/图的存储和遍历/","excerpt":"","text":"图的存储图的存储一般有两种方式：邻接矩阵和邻接表 邻接矩阵设图G(V,E)的顶点标号为0,1，……n-1，则令二维数组G[n][n]的两维分别表示图的顶点标号。即如果G[i][j]等于1，指顶点i和顶点j之间有边，如果G[i][j]等于0，指顶点i和顶点j之间没有边，如果为有权图，则令G[i][j]存放边权。但如果题目中顶点数过大，可能会造成内存超限。 邻接表图的常用储存结构之一，由表头结点和表结点两部分组成，其中表头结点存储图的各顶点，表结点用单向链表存储表头结点所对应顶点的相邻顶点（也就是表示了图的边）。在有向图里表示表头结点指向其它结点（a-&gt;b）,无向图则表示与表头结点相邻的所有结点（a—b） 123456789101112131415161718//表头结点（表示图的顶点） struct vnode&#123; char data; //顶点数据，这里用字符表示 struct arcnode * firstarc; //指针指向第一条边 &#125;; //表结点（表示图的边） struct arcnode&#123; int wt; //权重 int adjvex; //顶点下标 struct arcnode *nextarc; //指针指向下一条边 &#125;; typedef struct arcnode * Arc; //图 struct mgraph&#123; struct vnode vexs[100]; int vexsnum,arcnum; //顶点数，边数 &#125; *g; typedef struct mgraph* Graph; 图的遍历用DFS遍历图沿着一条路径直到无法继续前进，才退回到路径上离当前顶点最近的还存在未访问分支顶点的岔道口，并前往访问那些未访问的分支节点，直至遍历完成 连通分量：在无向图中，如果两个顶点可以互相到达，则称这两个顶点连通，如果图G（V，E）的任意两个顶点都连通，则称图G为连通图，否则，称图G为非连通图，且称其中的极大连通子图为连通分量。 强连通分量：在有向图中，如果两个顶点可以各自通过一条有向路径到达另一个顶点，则称这两个顶点强联通。如果一个图的任意两个顶点都强联通，则称这个图为强连通图；否则这个图为非强连通图，且称其中的极大连通子图为强联通分量。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152伪代码DFS(u)&#123; vis[u]=true; for(从u出发能到达的所有顶点v) if(vis[v]==false) DFS(v);&#125;DFSTrave(G)&#123; for(G的所有顶点u) if(vis[u]==false) DFS(u);&#125;邻接矩阵实现const int maxv=1000;const int inf=1000000;int n,G[maxv][maxv];bool vis[maxv]=&#123;false&#125;;void dfs(int u,int depth)&#123; vis[u]=true; for(int v=0;v&lt;n;v++)&#123; if(vis[v]==false&amp;&amp;G[u][v]!=inf)&#123; dfs(v,depth+1); &#125; &#125;&#125;void dfstrave()&#123; for(int u=0;u&lt;n;u++)&#123; if(vis[u]==false)&#123; dfs(u,1); &#125; &#125;&#125;邻接表实现vector&lt;int&gt; Adj[maxv];int n;bool vis[maxv] = &#123;false&#125;;void dfs(int u,int depth)&#123; vis[u] =true; for(int i=0;i&lt;Adj[u].size();i++)&#123; int v=Adj[u][i]; if(vis[v]==false)&#123; dfs(v,depth+1); &#125; &#125;&#125;void dfstrave()&#123; for(int u=0;u&lt;n;u++)&#123; if(vis[u]==false)&#123; dfs(u,1); &#125; &#125;&#125; 用BFS遍历图类似树的遍历，遍历图需要使用一个队列，通过反复取出队首顶点，将该顶点可到达的未曾加入过队列的顶点全部入队，直到队列为空时遍历结束。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172伪代码BFS(u)&#123; queue q; inq[u]=true; while(q非空)&#123; 取出q的队首元素加以访问; for(从u出发能到达的所有顶点v) if(inq[v]==false)&#123; 将v入队; inq[v]=true; &#125; &#125;&#125;BFSTrave(G)&#123; for(G的所有顶点u) if(inq[u]==false) &#123; BFS(u); &#125;&#125;邻接矩阵实现int n,G[maxv][maxv];bool inq[maxv]=&#123;false&#125;;void BFS(int u)&#123; queue&lt;int&gt; q; q.push(u); inq[u]=true; while(!q.empty())&#123; int u.q.front(); q.pop(); for(int v=0;v&lt;n;v++)&#123; if(inq[v]==false&amp;&amp;G[u][v]!=inf)&#123; q.push(v); inq[v]=true; &#125; &#125; &#125;&#125;void BFSTrave()&#123; for(int u=0;u&lt;n;u++)&#123; if(inq[u]==false)&#123; BFS(q); &#125; &#125;&#125;邻接表实现vector&lt;int&gt; Adj[maxv];int n;bool inq[maxv]=&#123;false&#125;;void BFS(int u)&#123; queue&lt;int&gt; q; q.push(u); inq[u]=true; while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=0;i&lt;Adj[u].size();i++)&#123; int v=Adj[u][i]; if(inq[v]==false)&#123; q.push(v); inq[v]=true; &#125; &#125; &#125;&#125;void BFSTrave()&#123; for(int u=0;u&lt;n;u++)&#123; if(inq[u]==false)&#123; BFS(q); &#125; &#125;&#125; 例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt; using namespace std; typedef struct &#123; int edges[100][100];///邻接矩阵 int n; int e; &#125;graph; bool vis[100];///访问数组 void creategraph(graph &amp;G) &#123; int i,j; int s,t; int v; for(i=0;i&lt;G.n;i++) &#123; for(j=0;j&lt;G.n;j++) &#123; G.edges[i][j]=0;///邻接表初始化 &#125; vis[i]=false;///访问数组初始化 &#125; for(i=0;i&lt;G.e;i++) &#123; cin&gt;&gt;s&gt;&gt;t&gt;&gt;v;///读入顶点数边数和权值 G.edges[s][t]=v;///赋值 &#125; &#125; void dfs(graph G,int v) &#123; int i; printf(\"%d \",v); vis[v]=true;///访问第v个定点，并将访问数组置为true for(i=0;i&lt;G.n;i++) &#123; if(G.edges[v][i]!=0&amp;&amp;vis[i]==false) &#123; dfs(G,i);///如果i未被访问递归调用dfs &#125; &#125; &#125; void bfs(graph G,int v) &#123; queue&lt;int&gt;Q; printf(\"%d \",v); vis[v]=true; Q.push(v); while(!Q.empty()) &#123; int i,j; i=Q.front();///取队头元素 Q.pop();///队头元素出队 for(j=0;j&lt;G.n;j++) &#123;///检查所有邻接点 if(G.edges[i][j]!=0&amp;&amp;vis[j]==false) &#123; printf(\"%d \",j); vis[j]=true; Q.push(j); &#125; &#125; &#125; &#125; int main() &#123; int n,e; while(1) &#123; puts(\"输入图的顶点数和边数：\"); cin&gt;&gt;n&gt;&gt;e; graph G; G.n=n; G.e=e; creategraph(G); puts(\"输出深度优先遍历序列：\"); dfs(G,0); puts(\"\\n\"); creategraph(G); puts(\"输出广度优先遍历序列：\"); bfs(G,0); puts(\"\\n\"); &#125; return 0; &#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"堆的简介","slug":"堆的简介","date":"2018-05-03T11:53:51.000Z","updated":"2018-10-09T14:43:20.688Z","comments":true,"path":"算法和数据结构/堆的简介/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/堆的简介/","excerpt":"","text":"堆的定义与基本操作堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子结点的值。如果父亲结点的值大于或等于孩子结点的值，则称这样的堆为大顶堆，这时每个结点的值都是以它为根结点的子树的最大值；如果父亲结点的值小于或等于孩子结点的值，则称这样的堆为小顶堆，这时每个结点的值都是以它为根结点的子树的最小值。堆一般用于优先队列的实现，优先队列实现默认使用大顶堆。 建堆用数组来存储完全二叉树，则结点就按层序存储于数组中，其中第一个结点存于数组中的1号位，第i号结点的左孩子为2i，右孩子为2i+1建堆采用结点向下调整的方法：如果结点存在，总是将当前结点V与它的左右孩子进行比较，，假如孩子中存在权值比结点V大的，就将其中权值最大的那个孩子结点与结点V交换。交换完毕后继续让结点V和孩子比较，直到结点V的孩子的权值都比结点V的权值小或是结点V不存在孩子结点时间复杂度O(logn)1234567891011121314151617181920212223242526const int maxn=100;int heap[maxn],n=10;//对heap数组在[low,high]范围进行向下调整//low为欲调整结点的数组下标，high为堆的最后一个元素的数组下标void downAdjust(int low,int high)&#123; int i=low,j=i*2; while(j&lt;=high)&#123; if(j+1&lt;=high&amp;&amp;heap[j+1]&gt;heap[j])&#123; i=j+1; &#125; if(heap[j]&gt;heap[i])&#123; swap(heap[j]&gt;heap[i]); i=j; j=i*2; &#125; else&#123; break; &#125; &#125;&#125;//建堆 void createHeap()&#123; for(int i=n/2;i&gt;=1;i--)&#123; downAdjust(i,n); &#125; &#125; 删除堆顶元素1234void deleteTop()&#123; heap[1]=heap[n--]; downAdjust(1,n);&#125; 往堆里添加一个元素12345678910111213141516void UpAdjust(int low,int high)&#123; int i=high,j=i/2; while(j&gt;=low)&#123; if(heap[j]&lt;heap[i])&#123; swap(heap[j],heap[i]); i=j; j=i/2; &#125;else&#123; break; &#125; &#125;&#125;void insert(int x)&#123; heap[++n]=x; UpAdjust(1,n);&#125; 堆排序堆排序是指使用堆结构对一个序列进行排序1234567void heapSort()&#123; createHeap(); for(int i=n;i&gt;1;i--)&#123; swap(heap[i],heap[1]); downAdjust(1,i-1); &#125;&#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"并查集","slug":"并查集","date":"2018-05-02T11:49:07.000Z","updated":"2018-10-09T14:43:20.689Z","comments":true,"path":"算法和数据结构/并查集/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/并查集/","excerpt":"","text":"并查集的定义并查集是一种维护集合的数据结构：合并（Union）、查找（Find）、集合（Set）并查集支持以下两个操作： 合并：合并两个集合 查找：判断两个元素是否在一个集合通过数组即可实现并查集基本操作 初始化 123for(int i=1;i&lt;=n;i++)&#123; father[i]=i;&#125; 查找由于规定同一个集合中只存在一个根结点，因此查找操作就是对給定的结点寻找其根结点的过程实现方式：递推或递归思路：反复寻找父亲结点，直到找到根结点 123456789101112//递推低吗int findFather(int x)&#123; while(x!=father[x])&#123; x=father[x]; &#125; return x;&#125;//递归代码int findFather(int x)&#123; if(x==father[x]) return x; else return findFather(father[x]);&#125; 3.合并合并是指把两个集合合并成一个集合，题目中一般给出两个元素，要求把这两个元素所在集合合并。一般是先判断两个元素是否属于同一集合，只有当两个元素属于不同集合时才合并，而合并的过程一般是把其中一个集合的根结点的父亲指向另一个集合的根结点。思路： 对于給定的两个元素a，b，判断它们是否属于同一集合。可以调用查找函数对这两个元素分别查找根结点，然后判断其根节点是否相同 合并两个集合：在第一步中获得了两个元素的根结点faA和faB，因此只需要把其中一个的父亲结点指向另一个结点。1234567void Union(int a,int b)&#123; int faA=findFather(a); int fab=findFather(b); if(faA!=faB)&#123; father[faA]=faB; &#125;&#125; 并查集产生的每一个集合都是一棵树 路径压缩当题目给出的元素数量很多并且形成一条链，则上述查找函数效率较低，需进行优化把当前查询结点的路径上的所有结点的父亲都指向根结点，查找的时候就不需要一直回溯去找父亲了，查询复杂度降为O(1）转换步骤： 按原先的写法获得x的根结点r 重新从x开始走一遍寻找根结点的过程，把路径上经过的所有结点的父亲全部改为根结点r123456789101112131415161718192021int findFather(int x)&#123; int a=x; while(x!=father[x])&#123; x=father[x]; &#125; while(a!=father[x])&#123; int z=a; a=father[a]; father[z]=x; &#125; return x;&#125;int findFather(int v)&#123; if(v==father[v]) return v; else&#123; int f=findFather(father[v]); father[v]=f; return f; &#125;&#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"平衡二叉树","slug":"平衡二叉树","date":"2018-05-02T11:14:55.000Z","updated":"2018-10-09T14:43:20.689Z","comments":true,"path":"算法和数据结构/平衡二叉树/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/平衡二叉树/","excerpt":"","text":"平衡二叉树的定义当使用序列{1,2,3,4,5}构建二叉查找树，会得到一棵长链条式的树，此时对这棵树中的结点进行查找，时间复杂度会达到O(n)，为了优化数据查询，需要对树的结构进行调整，使树的高度在每次插入元素后仍能保持O(logn)的级别，这样能让查询操作仍然为O(logn)的时间复杂度AVL树仍然是一棵二叉查找树，只是在其基础上增加了平衡要求。即对AVL树的任意结点来说，其左子树与右子树的高度之差的绝对值不超过1，其中左子树和右子树的高度之差称为该结点的平衡因子。只要能随时保证每个结点的平衡因子的绝对值不超过1，AVL的高度就始终能保持O(logn)级别。1234567891011121314151617181920212223242526//结点结构struct node&#123; int v,height; node *lchild,*rchild;&#125;;//生成一个新结点，v为结点权值node* newNode(int v)&#123; node* Node = new node; Node-&gt;v=v; Node-&gt;height=1; Node-&gt;lchild=Node-&gt;rchild=NULL; return Node;&#125;//获取以root为根结点的子树的当前heightint getHeight(node* root)&#123; if(root==NULL) return 0; return root-&gt;height;&#125;//计算结点root的平衡因子int getBalanceFactor(node* root)&#123; return getHeight(root-&gt;lchild)-getHeight(root-&gt;rchild);&#125;//更新结点root的heightvoid UpdateHeight(node* root)&#123; root-&gt;height=max(getHeight(root-&gt;lchild),getHeight(root-&gt;rchild))+1;&#125; 平衡二叉树的基本操作 查找操作类似于二叉查找树，由于AVL树的高度为O(logn)级别，所以查找操作的时间复杂度为O(logn) 12345678910111213void search(node* root,int x)&#123; if(root==NULL)&#123; printf(\"search failed\\n\"); return; &#125; if(x==root-&gt;data)&#123; printf(\"%d\\n\",root-&gt;data); &#125;else if(x&lt;root-&gt;data)&#123; search(root-&gt;lchild,x); &#125;else&#123; search(root-&gt;rchild,x); &#125;&#125; 旋转操作 123456789101112131415161718//左旋void L(node* &amp;root)&#123; node* temp=root-&gt;rchild; root-&gt;rchild=temp-&gt;lchild; temp-&gt;lchild=root; UpdateHeight(root); UpdateHeight(temp); root=temp;&#125;//右旋void R(node* &amp;root)&#123; node* temp=root-&gt;lchild; root-&gt;lchild=temp-&gt;rchild; temp-&gt;rchild=root; UpdateHeight(root); UpdateHeight(temp); root=temp;&#125; 插入操作只要把最靠近插入结点的失衡结点调整到正常，路径上的所有结点就都会平衡在二叉查找树的插入操作基础上从下往上判断结点是否失衡，因此需要在每个insert函数之后更新当前子树高度，并在这之后根据树型是LL型、LR型、RR型、RL型之一来进行平衡操作 123456789101112131415161718192021222324252627void insert(node* &amp;root,int v)&#123; if(root==NULL)&#123; root=newNode(v); return; &#125; if(v&lt;root-&gt;v)&#123; insert(root-&gt;lchild,v); UpdateHeight(root); if(getBalanceFactor(root)==2)&#123; if(getBalanceFactor(root-&gt;lchild)==1)&#123; R(root); &#125;else if(getBalanceFactor(root-&gt;rchild)==1)&#123; L(root-&gt;lchild); R(root); &#125; &#125; &#125;else&#123; insert(root-&gt;rchild,v); UpdateHeight(root); if(getBalanceFactor(root)==-2)&#123; if(getBalanceFactor(root-&gt;rchild)==1)&#123; R(root-&gt;rchild); L(root); &#125; &#125; &#125;&#125; AVL树的建立建立在插入操作的基础上，依次插入n个结点即可 1234567node* Create(int data[],int n)&#123; node* root=NULL; for(int i=0;i&lt;n;i++)&#123; insert(root,data[i]); &#125; return root;&#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"《素媛》与《熔炉》","slug":"《素媛》与《熔炉》","date":"2018-04-29T13:06:34.000Z","updated":"2019-12-22T12:08:51.908Z","comments":true,"path":"影音/《素媛》与《熔炉》/","link":"","permalink":"http://huangyiblog.com/影音/《素媛》与《熔炉》/","excerpt":"","text":"现实依旧残酷 最近看了两部韩国电影，正好五一假期有空，想写点什么。在知乎上看过一个话题，人开始废掉的标志是什么？记得有人答说当一个人沉迷于短期便可轻易获得快感的事物时，有人答说当一个开始拒绝输出的时候便是废掉的开始。我感到恐慌，我意识到尽管一天到晚都在读书，在听歌看电影，在接受各种信息，但我不能一位接收而不输出，其实这也是我搞这个静态博客的初衷。我知道自己文笔不行，但我还是想写点东西，想记录点生活。论文学，读了《红楼梦》便知道什么才是大家之作，这样的奇书需要怎么的积淀才能写就。很明显，一般人都达不到这样的高度，但这并不妨碍我继续输出自己的想法，学编程也一样，当一个人学编程只看书看视频听课，却从不自己不敲代码，那么注定是失败的学习者，而敲代码的过程，其实也就是输出的过程。 回到正题，为什么要把素媛和熔炉放到一起，一个显然的原因就是这两部都是反映未成年人被性侵的黑现实题材，我不清楚是因为自己接触的电影太少，还是不了解国内状况，为什么中国相应的题材电影没有令我印象深刻的，难道我们国家已经社会和谐，大家都生活在了一个幸福美满的国度里了吗，甚至已经没必要在去关注未成年人的成长问题？素媛和熔炉都是根据真实事件改编的电影，韩国在反映黑暗面现实题材的电影方面似乎做得比较好，有些放在国内怕是审批都过不了，两部电影最后的结局让人痛心与无奈，但这也是电影出彩的一个方面之一吧。以往很多电影，剧情发展到后期，基本就是坏蛋绳之以法，恶有恶报。但不得不承认，现实中很多人的恶报来的并没那么快，被害人可能死不瞑目，犯人却依旧逍遥法外的情况并不少，冤判，错判，更恶劣的，权钱交易，有钱有势的才是爹，普通人的生命就如草芥一般。寒假看的红楼梦，其实曹公也写到了很多底层人的生活，起初读红楼梦可能只关注到宝玉、宝钗、黛玉三者恋为主线的少男少女之间的情情爱爱，但这其实就低估了曹公的作品了，从繁华到幻灭，情确实是红楼梦的一大主题，但其实里面写到了很多卑微者的命运，很多人无力反抗这样命运，最终只能认命。 2012年夏天，7岁女童独自在家睡觉，半夜被一男子入室掳走，实施了强奸和殴打，事后该男子用树枝和其他条状硬物捅女童的阴道和肠道，女童被附近的居民发现在一条小河边，当时下着雨，女童重度昏迷，大小便失禁，血肉模糊。送医治疗后经诊断，肠道没有一处完好的地方，手术几乎把肠子全部切除，阴道和肠道中间的部分全部破坏，阴道在外伤的情况下又被粪便感染，子宫受损，也就是说，子宫，阴道，肠道都受到重创，安装了人造肛门之后，终身都要带着便便袋生活，有可能无月经无生育能力。孩子很惨，但凶手抓到后拒不认罪，不赔偿，孩子的父母都是普通老百姓，支付医药费都很困难，一直申诉，一方面是为女儿讨公道，一方面是想得到赔偿给孩子更好的治疗。这就是素媛背后的真实事件，其实比起熔炉，素媛这部电影倒是让人感到更加温暖。影片其实可以注意到很多人物心理、行为等在事发前后发生了巨大的变化。素媛的爸爸就令人感动，在平常日子里，从吃饭时的自顾自，对素媛的生活，学习等等虽不能说毫不在意吧，但确实没花多少心思在自己的女儿身上，事发后，后悔自然无用，但我们看到了一个父亲应有的担当，你能想象一个大男人，在大夏天穿着那种厚厚的卡通套装，只为陪伴在女儿身边，为了接触他，让她开心，安心，试问生活中的父亲都表现的如何？之所以说这部电影暖心，不仅仅是事发家庭成员自身的坚强，当然其实他们也已经到了崩溃的边缘，记得素媛的母亲甚至抱怨，为什么那么多小孩，这种事为什么偏偏发生在自己的女儿身上，我宁愿所有人的小孩都遭受同样的伤害！这其实也是痛苦的一种发泄。 素媛其实除了批判，总体上格调还是偏暖的。其中有很多震撼的地方，尤其是素媛，这个9岁的小女孩竟然能这么懂事，心智竟然已经如此成熟。发生不幸，他仍能想到自己的爸妈，能体会到爸妈的痛苦，甚至知道为自己治病家里要花不少钱，他会内疚。素媛与夙愿，这是一个寓意着希望的女孩，活着就是希望，更何况还能看到她灿烂的笑容。最后判决如此不公，冲动的父亲甚至打算与凶手同归于尽，但就在砸向凶手的瞬间，冲动的父亲被素媛抱住了，她不希望父亲做傻事。事发后，身边的朋友捐款的捐款，素媛的同学也在默默支持着他。这里有个叫荣植的小胖子很可爱，他后面来到素媛的店门口，对他父亲说，当时如果等素媛一起上学，素媛就不会出这种事了，他觉得很自责，然后嚎啕大哭，这是一个小孩的真性情。回到主旋律，还是反映了社会对未成年人的淡漠，素媛其实是一个非常单纯善良的小女孩，即是自己上学迟到了，但不给坏叔叔撑伞却还是于心不忍，注意到这里他只是认为想帮助别人，但实际上身边的人非但没有夸她，反认为是她的错。也许很多人心想，你何苦这么好心，自己都要来不及上课了，还想着别人？另外，事发后还有一帮人很令人淡漠，一帮是那群媒体记者，于他们而言，这是热点，当然得蜂拥往上挤，可是除了采访，他们几乎完全没有顾及当事人的感受。另一帮人就是法庭上那帮家伙了，我很好奇为嫌疑人辩护的律师内心是什么想法，当她对着一个9岁的受害女孩提问时能如此正气？ 而《熔炉》怕是就比较沉重了。完全反应的是人性的黑暗面，格调悲凉而沉重。 《熔炉》，是根据韩国光州一所聋哑学校校长性侵儿童的真实事件改编的电影，真实事件中，从校长到老师共10余人，先后对超过30名聋哑儿童进行性侵，有很多连10岁都还不到。其实小说和电影的改编免不了要进行艺术方面的加工，现实中的黑暗恐怕更是令人难以想象。为什么于我而言，素媛偏向温暖，而熔炉却是令人沉痛。事实上，两者之间的社会危害性的强度也是显然有强弱之分的。素媛里的犯人仅仅只是一个普通的无奈，一个有前科的混混，另外素媛还有很多关系她的人，不仅仅只是她的父母。而熔炉不同，熔炉事件的双方是差距悬殊的，一方是有权有势的聋哑学校校长，另一方很多甚至都是无父无母的残障儿童，在这样差距悬殊的情况下，一旦人性黑暗面涌现，受害的一方是显然并且是毫无还手之力的。影片中孩子们唯一的幸运是遇到了一个好老师，男主和女主为了救孩子确实尽了全力，我影片结尾我们都看到了，罪恶的一方并没有受到相应的处罚，其实这也是很多现实事件的真实写照。倘若，这些孩子一直没有遇到善良的能帮助他们的人，结果又会如何，惨遭毒手的孩子只会继续增加。社会上好人确实不少，但坏人不能说已经没有了，尤其是一些有权有势的坏人克服不了自己人性黑暗的一面，那么造成的后果必然是灾难性的，弱势群体得不到保护，一方面作为法治社会体现了制度上的欠缺，法律不够完善，另一方面，这是一起社会事件，更大程度上反映了集体意识的淡漠。事不关己高高挂起，何苦自讨没趣去得罪哪些大人物呢？越得不到重视，黑暗面便越猖狂，社会也就越畸形。 最后撇开电影，回到自己。说实话，影片中的事件都是我无法想象和体会的，或者说触动可能还不是特别强烈。因为我长这么大，都还算生活在一个相对阳光的环境里，认识了很多人，可以说有好有坏。但其实人性是复杂的，一般碰到的人很少回想小说或电影里讲人性展现的非常露骨，人们可能会不知不觉隐藏自己的某一面。无论怎么说，我接触到的同学，老师，长辈，陌生人，可能这个让你讨厌，那个令你烦恼，但不至于说他是一个坏人，未成年人受到欺凌的事件我遇到过，但也许并没有引起自己的关注，首先那时我自己也是个小孩，因为没碰到很严重的，我会以为他们只是一言不合，打起架来了。从小到大，由于自己多愁善感的性格，可以说是烦恼不断，但困扰自己的无非是些普普通通的小事，人生不如意事十之八九嘛。但如果电影中的事件发生在自己身边，自己会表现为一个怎样的角色，我甚至不敢想，为什么不敢想，因为很可能，如果受害者不是自己的亲人，可能也就是感叹一番，为自己茶余饭后多了点谈资罢了，我真的会去做些什么吗？会作为正义的化身，不顾生死与暗势力反抗吗？至于其他人，可能还在为自己的房贷车贷发愁呢。熔炉的真实事件是涉及到了暗杀的程度，没有勇气，只有一腔热血的你会不会坚持正义？再进步一步，如果受害者是自己或者是自己的亲人，你会怎么做，这时怕是做不到无动于衷了吧？你又能做些什么？注意到，一般受害的往往是弱势群体，也就是你没钱没权没话语权。你相信法庭吗？你相信律师吗？你相信警察吗？不瞎写了，代码还没敲完呢…回见","categories":[{"name":"影音","slug":"影音","permalink":"http://huangyiblog.com/categories/影音/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://huangyiblog.com/tags/电影/"}]},{"title":"葬花词","slug":"葬花词","date":"2018-04-29T04:50:41.000Z","updated":"2019-12-22T12:08:05.834Z","comments":true,"path":"阅读/葬花词/","link":"","permalink":"http://huangyiblog.com/阅读/葬花词/","excerpt":"","text":"程高通行本《葬花吟》 花谢花飞花满天，红消香断有谁怜？ 游丝软系飘春榭，落絮轻沾扑绣帘。 闺中女儿惜春暮，愁绪满怀无释处。 手把花锄出绣帘，忍踏落花来复去。 柳丝榆荚自芳菲，不管桃飘与李飞； 桃李明年能再发，明年闺中知有谁？ 三月香巢已垒成，梁间燕子太无情！ 明年花发虽可啄，却不道人去梁空巢也倾。 一年三百六十日，风刀霜剑严相逼； 明媚鲜妍能几时，一朝漂泊难寻觅。 花开易见落难寻，阶前愁杀葬花人， 独倚花锄泪暗洒，洒上空枝见血痕。 杜鹃无语正黄昏，荷锄归去掩重门； 青灯照壁人初睡，冷雨敲窗被未温。 怪奴底事倍伤神？半为怜春半恼春。 怜春忽至恼忽去，至又无言去未闻。 昨宵庭外悲歌发，知是花魂与鸟魂？ 花魂鸟魂总难留，鸟自无言花自羞； 愿侬此日生双翼，随花飞到天尽头。 天尽头，何处有香丘？ 未若锦囊收艳骨，一抔净土掩风流3。 质本洁来还洁去，强于污淖陷渠沟。 尔今死去侬收葬，未卜侬身何日丧？ 侬今葬花人笑痴，他年葬侬知是谁？ 试看春残花渐落，便是红颜老死时； 一朝春尽红颜老，花落人亡两不知！","categories":[{"name":"阅读","slug":"阅读","permalink":"http://huangyiblog.com/categories/阅读/"}],"tags":[{"name":"诗歌","slug":"诗歌","permalink":"http://huangyiblog.com/tags/诗歌/"}]},{"title":"组合数","slug":"组合数","date":"2018-04-24T06:34:22.000Z","updated":"2018-10-09T14:43:20.694Z","comments":true,"path":"算法和数据结构/组合数/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/组合数/","excerpt":"","text":"例1：求n！中有多少质因子p 直观想法：计算从1~n的每个数各有多少个质因子p，然后将结果累加，时间复杂度为O(nlogn).123456789101112131415161718192021222324int cal(int n,int p)&#123; int ans=0; for(int i=2;i&lt;=n;i++)&#123; int temp=i; while(temp%p==0)&#123; ans++; temp/=p; &#125; &#125; return ans;&#125;///O(logn)的算法int cal(int n,int p)&#123; int ans=0; whil(n)&#123; ans+=n/p; n/=p; &#125; return ans;&#125;int cal(int n,int p)&#123; if(n&lt;p) return 0; return n/p+cal(n/p,p);&#125; 组合数的计算互补性质 即从m个不同元素中取出n个元素的组合数=从m个不同元素中取出 (m-n) 个元素的组合数； 这个性质很容易理解，例如C(9,2)=C(9,7)，即从9个元素里选择2个元素的方法与从9个元素里选择7个元素的方法是相等的。规定：C(n,0)=12.组合恒等式若表示在 n 个物品中选取 m 个物品，则如存在下述公式：C(n,m)=C(n,n-m)=C(n-1,m-1)+C(n-1,m)。 通过定义直接计算12345678910111213long long c(long long n,long long m)&#123; long long ans =1; for(long long i=1;i&lt;=n;i++)&#123; ans*=i; &#125; for(long long i=1;i&lt;=m;i++)&#123; ans/=i; &#125; for(long long i=1;i&lt;=n-m;i++)&#123; ans/=i; &#125; return ans;&#125; 通过递推公式计算12345678910111213141516171819long long res[67][67]=&#123;0&#125;;long long c(long long n,long long m)&#123; if(m==0||m==n) return 1; if(res[n][m]!=0) return res[n][m]; return res[n][m]=c(n-1,m)+c(n-1,m-1);&#125;///打表计算const int n=60;void calc()&#123; for(int i=0;i&lt;=n;i++)&#123; res[i][0]=res[i][i]=1; &#125; for(int i=2;i&lt;=n;i++)&#123; for(int j=0;j&lt;=i/2;j++)&#123; res[i][j]=res[i-1][j]+res[i-1][j-1];///递推计算c(i,j) res[i][i-j]=res[i][j];///c(i,i-j)=c(i,j) &#125; &#125;&#125; 通过定义式的变形计算12345678long long c(long long n,long long m)&#123; long long ans=1; for(long long i=1;i&lt;=m;i++)&#123; ans=ans*(n-m+i)/i; &#125; return ans;&#125; 计算C(n,m)%p通过递推公式计算12345678910111213141516171819递归：int res[1010][1010]=&#123;0&#125;;int c(int n,int m,int p)&#123; if(m==0||m==n) return 1; if(res[n][m]!=0) return res[n][m]; return res[n][m]=(c(n-1,m)+c(n-1,m-1))%p;&#125;递推：void calc()&#123;for(int i=0;i&lt;=n;i++)&#123; res[i][0]=res[i][i]=1;&#125;for(int i=2;i&lt;=n;i++)&#123; for(int j=0;j&lt;=i/2;j++)&#123; res[i][j]=(res[i-1][j]+res[i-1][j-1])%p; res[i][i-j]=res[i][j]; &#125;&#125;&#125; 根据定义式计算123456789int prime[maxn];int c(int ,n,int m,int p)&#123; int ans=1 for(int i=0;prime[i]&lt;=n;i++)&#123; int c=cal(n,prime[i])-cal(m,prime[i])-cal(n-m,prime[i]); ans=ans*binaryPow(prime[i],c,p)%p; &#125; return ans;&#125; 根据定义式的变形计算1234567891011121314151617181920212223242526272829///求c(n,m)%p,且m&lt;p,p为素数int c(int n,int m,int p)&#123; int ans=1; for(int i=1;i&lt;=m;i++)&#123; ans=ans*(n-m+1)%p; ans=ans*inverse(i,p)%p; &#125; return ans;&#125;///求c(n,m)%p,m任意,p为素数int c(int n,int m,int p)&#123; int ans=1,nump=0; for(int i=1;i&lt;=m;i++)&#123; int temp=n-m+i; while(temp%p==0)&#123; nump++; temp/=p; &#125; ans=ans*temp%p; temp=i; while(temp%p==0)&#123; nump--; temp/=p; &#125; ans=ans*inverse(temp,p)%p; &#125; if(nump&gt;0) return 0; else return ans;&#125; Lucas定理1234int Lucas(int n,int m)&#123; if(m==0) return 1; return c(n%p,m%p)*Lucas(n/p,m/p)%p;&#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://huangyiblog.com/tags/C/"}]},{"title":"素数问题","slug":"素数问题","date":"2018-04-18T11:12:48.000Z","updated":"2018-10-09T14:43:20.693Z","comments":true,"path":"算法和数据结构/素数问题/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/素数问题/","excerpt":"","text":"素数 素数又称为质数，是指除了1和本身外，不能被其他数整除的一类数。 素数判断直接遍历循环复杂度为O(n);复杂度为O(sqrt(n))的算法;12345678910111213141516bool isprime(int n)&#123; if(n&lt;=1) return false; int sqr = (int)sqrt(1.0*n); for(int i=2;i&lt;=sqr;i++)&#123; if(n%i==0) return false; &#125; return true;&#125;//简洁写法bool isprime(int n)&#123; if(n&lt;=1) return false; for(int i=2;i*i&lt;=n;i++)&#123; if(n%i==0) return false; &#125; return true;&#125; 素数表的获取思路一： 根据判断素数的方法，直接从1~n进行枚举，若为素数则加入表中，枚举部分复杂度为O(n),判断素数部分复杂度为O(sqrt(n)),所以总复杂度为O(n*sqrt(n)),该算法对于n小于10^5可以承受;12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;math.h&gt;bool isprime(int n)&#123; if(n&lt;=1) return false; int sqr = (int)sqrt(1.0*n); for(int i=2;i&lt;=sqr;i++)&#123; if(n%i==0) return false; &#125; return true;&#125;int prime[101],num=0;bool p[101]=&#123;0&#125;;void Find_Prime()&#123; for(int i=1;i&lt;101;i++)&#123; if(isprime(i)) &#123; prime[num++]=i; p[i]=true; &#125; &#125;&#125;int main()&#123; Find_Prime(); for(int i=0;i&lt;num;i++)&#123; printf(\"%d \",prime[i]); &#125; return 0;&#125; 思路二：埃氏筛法，复杂度为O(nloglogn). 欧拉筛法，复杂度为O(n).素数筛法的关键在于筛字，即从小到大枚举所有数，对每一个素数，筛去它的所有倍数，剩下的均为素数。12345678910111213141516171819202122#include&lt;stdio.h&gt;const int maxn = 101;int prime[maxn],num=0;bool p[maxn]=&#123;0&#125;;//如果i为素数，则p[i]为false,否则，p[i]为truevoid Find_Prime()&#123; for(int i=2;i&lt;maxn;i++)&#123; if(p[i]==false)&#123; prime[num++]=i;//将素数i存入数组 for(int j=i+i;j&lt;maxn;j+=i)&#123;//筛去所有i的倍数，两个循环条件均不能加= p[j]=true; &#125; &#125; &#125;&#125;int main()&#123; Find_Prime(); for(int i=0;i&lt;num;i++)&#123; printf(\"%d \",prime[i]); &#125; return 0;&#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"大整数运算","slug":"大整数运算","date":"2018-04-18T11:10:41.000Z","updated":"2018-10-09T14:43:20.688Z","comments":true,"path":"算法和数据结构/大整数运算/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/大整数运算/","excerpt":"","text":"大整数运算 大整数的含义为：用基本数据类型无法存储其精度的整数，即没有办法用已有的数据类型来表示并计算，而需要去模拟加减乘除的过程， 大整数的存储 使用数组存储，即整数的高位存储在数组的高位，整数的低位存储在数组的低位。由于运算时都是从整数的低位到高位进行枚举， 所以顺序存储与该思维相合。 注意点：当整数按字符串%s读入时是逆位存储的，所以需要反转至另一数组。1234567891011121314151617181920212223242526272829struct bign&#123; int d[1000]; int len; bign()&#123; memset(d,0,sizeof(d)); len = 0; &#125;&#125;;bign change(char str[])&#123; bign a; a.len=strlen(str); for(int i=0;i&lt;a.len;i++)&#123; a.d[i]=str[a.len-i-1]-'0'; &#125; return a;&#125;比较两个bign变量的大小：先判断两者的len大小，如果不相等，以长的为大；如果相等，则从高位到低位进行比较，直到出现某一位不等，结束比较。int compare(bign a,bign b)&#123; if(a.len&gt;b.len) return 1; else if(a.len&lt;b.len) return -1; else&#123; for(int i=a.len-1;i&gt;=0;i--)&#123; if(a.d[i]&gt;b.d[i]) return 1; else if(a.d[i]&lt;b.d[i]) return -1; &#125; return 0; &#125;&#125; 高精度加法对两个数其中的每一位进行加法的步骤：将该位上的两个数字相加，得到的结果取个位数作为该位结果，取十位数作为新的进位1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;string.h&gt;struct bign&#123; int d[1000]; int len; bign()&#123; memset(d,0,sizeof(d)); len = 0; &#125;&#125;;bign change(char str[])&#123; bign a; a.len=strlen(str); for(int i=0;i&lt;a.len;i++)&#123; a.d[i]=str[a.len-i-1]-'0'; &#125; return a;&#125;bign add(bign a,bign b)&#123; bign c; int carry=0;//进位 for(int i=0;i&lt;a.len||i&lt;b.len;i++)&#123; int temp=a.d[i]+b.d[i]+carry; c.d[c.len++]=temp%10; carry=temp/10; &#125; if(carry!=0)&#123; c.d[c.len++]=carry; &#125; return c;&#125;void print(bign a)&#123; for(int i=a.len-1;i&gt;=0;i--)&#123; printf(\"%d\",a.d[i]); &#125;&#125;int main()&#123; char str1[1000],str2[1000]; scanf(\"%s%s\",str1,str2); bign a=change(str1); bign b=change(str2); print(add(a,b)); return 0;&#125;上述写法两个对象都是非负整数，如果有一方是负的，可以在转换到数组这一步时去掉其负号，然后采用高精度减法；如果两个都是负的，就都去掉负号后采用高精度加法，最后加上负号。 高精度减法步骤：对每一步，比较被减位和减位，如果不够减，则令被减位的高位减1，被减位加10在进行减法；如果够减，则直接减。减法后高位可能有多余的0，要除去它们，但也要保证结果至少有一位数。1234567891011121314bign sub(bign a,bign b)&#123; bign c; for(int i=0;i&lt;a.len||i&lt;b.len;i++)&#123; if(a.d[i]&lt;b.d[i])&#123; a.d[i+1]--; a.d[i]+=10; &#125; c.d[c.len++]=a.d[i]-b.d[i]; &#125; while(c.len-1&gt;=1&amp;&amp;c.d[c.len-1]==0)&#123; c.len--; &#125; return c;&#125; 高精度与低精度的乘法步骤：取bign的某位与int型整体相乘，再与进位相加，所得结果的个位数作为该位结果，高位作为新的进位。1234567891011121314bign multi(bign a,int b)&#123; bign c; int carry=0; for(int i=0;i&lt;a.len;i++)&#123; int temp=a.d[i]*b+carry; c.d[c.len++]=temp%10; carry=temp/10; &#125; while(carry!=0)&#123; c.d[c.len++]=carry%10; carry/=10; &#125; return c;&#125; 高精度与低精度的除法步骤：上一步的余数乘以10加上该步的位，得到该步临时的被除数，将其与除数比较：如果不够除，则该位的商为0；如果够除，则商即为对应的商，余数即为对应的余数。最后一步要注意高位可能有多余的0，要去除它们，但也要保证结果至少有一位数。12345678910111213141516bign divide(bign a,int b,int &amp;r)&#123;//r为余数 bign c; c.len=a.len; for(int i=a.len-1;i&gt;=0;i--)&#123; r=r*10+a.d[i]; if(r&lt;b) c.d[i]=0; else&#123; c.d[i]=r/b; r=r%b; &#125; &#125; while(c.len=1&gt;=1&amp;&amp;c.d[c.len-1]==0)&#123; c.len--; &#125; return c;&#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"模式匹配","slug":"模式匹配","date":"2018-04-17T07:57:20.000Z","updated":"2018-10-09T14:43:20.693Z","comments":true,"path":"算法和数据结构/模式匹配/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/模式匹配/","excerpt":"","text":"BF算法1、 BF算法是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串P的第一个字符进行匹配，若相等，则继续比较S的第二个字符和P的第二个字符；若不相等，则比较S的第二个字符和P的第一个字符，其实相当于将整个模式串往后移了一位，依次比较下去，直到得出最后的匹配结果。1234567891011121314151617181920212223242526int BF_Find(string&amp; s,string&amp; t) &#123; int i=0,j=0,count=0;//初始化 while(i&lt;s.size()) //未比较到串尾 &#123; if(s.at(i)==t.at(j)) //继续比较后续字符 &#123; i++; j++; count++;&#125; else //指针后退重新匹配 &#123; i=i-j+1; j=0; count=0; &#125; if(count==t.size()) &#123; cout&lt;&lt;\"BF算法模式匹配成功,起始位置是:\"&lt;&lt;i-count+1&lt;&lt;endl; return (i-count+1); &#125; &#125; cout&lt;&lt;\"字符串匹配失败!\"&lt;&lt;endl; return 0; &#125; KMP算法2、KMP算法与BF算法的区别就在于KMP算法巧妙的消除了指针i的回溯问题，只需确定下次匹配j的位置即可，使得问题的复杂度由O(mn)下降到O(m+n)。 在KMP算法中，为了确定在匹配不成功时，下次匹配时j的位置，引入了next[]数组，next[j]的值表示P[1…j-1]中最长的后缀等于相同字符序列的前缀的长度。 对于next[]数组的定义如下： （1) next[j] = 0（ j = 1）（t1与Si比较不相等时，下一步进行t1与Si+1的比较） （2) next[j] = max(k)（1&lt;k&lt;j且 P[1…k-1]=P[j-k+1,j-1]） {设next[j]=k;(1&lt;k&lt;j) 若tk=tj 则next[j+1]=k+1;即next[j+1]=next[j]+1; 若tk!=tj 则next[j+1]=next[k]+1; } （3) next[j] = 1 (k=1)(不存在相同子串，下一步进行t1与si的比较) 因此KMP算法的思想就是：在匹配过程称，若发生不匹配的情况，则目标串的指针i不变，将模式串的指针j移动到next[j]的位置继续进行匹配；当指针j退至0时，指针i和指针j需同时增加1。也就是说，当发生不匹配的情况，让模式串继续往后移，而移动的位数就是模式串的长度-部分匹配值（最长相同前后缀的长度），因为BF里面每次指针i回溯，会导致符合匹配的字符再一次匹配，增大了时间开销。 求next数组是难点，一般有递推法（用一个while循环）和直接法两种。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt; using namespace std; int BF_Find(string&amp; s,string&amp; t) &#123; int i=0,j=0,count=0;//初始化 while(i&lt;s.size()) //未比较到串尾 &#123; if(s.at(i)==t.at(j)) //继续比较后续字符 &#123; i++; j++; count++;&#125; else //指针后退重新匹配 &#123; i=i-j+1; j=0; count=0; &#125; if(count==t.size()) &#123; cout&lt;&lt;\"BF算法模式匹配成功,起始位置是:\"&lt;&lt;i-count+1&lt;&lt;endl; return (i-count+1); &#125; &#125; cout&lt;&lt;\"字符串匹配失败!\"&lt;&lt;endl; return 0; &#125; void GetNext(string&amp; s,int *next) &#123; int len = s.size(); next[0] = 0; next[1] = 0; int i = 1; while(i &lt; len - 1) &#123; int j = next[i]; while(j &gt; 0 &amp;&amp; s.at(j) != s.at(i)) j = next[j]; if(s.at(j) == s.at(i)) next[i + 1] = j + 1;//根据next的定义推导出公式 else next[i + 1] = j; i++; &#125; &#125; void Getnextval(string &amp; s,int *next) &#123; int i=1; next[1]=0; int j=0; int len=s.size(); while(i&lt;len)&#123; if(j==0||s.at(i)==s.at(j))&#123; ++i;++j; if (s.at(i)!=s.at(j)) next[i]=j; else next[i]=next[j]; &#125; else j=next[j]; &#125; &#125; int KMP_Find(string&amp; s,string&amp;t) &#123; int i=0,j=0; int n =t.size(); int *next = new int[n]; GetNext(t,next); while(i&lt;s.size()&amp;&amp;j&lt;t.size()) //两个串均未比较到串尾 &#123; if((j == 0)||(s.at(i)==t.at(j))) //继续比较后续字符 &#123; i++; j++; &#125; else &#123; j = next[j];//模式串后移 &#125; &#125; if(j==t.size()) &#123; int index=i-t.size()+1; cout&lt;&lt;\"KMP算法：子串从长串的第\"&lt;&lt;index&lt;&lt;\"位开始匹配成功!\"&lt;&lt;endl; return index; &#125; cout&lt;&lt;\"字符串匹配失败!\"&lt;&lt;endl; return 0; &#125; int main() &#123; string str1,str2; cout&lt;&lt;\"请输入主串:\"&lt;&lt;endl; cin&gt;&gt;str1; cout&lt;&lt;\"请输入子串:\"&lt;&lt;endl; cin&gt;&gt;str2; KMP_Find(str1,str2); BF_Find(str1,str2); return 0; &#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"My movie list of 2017","slug":"My-movie-list-of-2017","date":"2018-04-16T08:18:54.000Z","updated":"2018-12-19T15:12:55.494Z","comments":true,"path":"影音/My-movie-list-of-2017/","link":"","permalink":"http://huangyiblog.com/影音/My-movie-list-of-2017/","excerpt":"","text":"17年看过的几部不错的电影 《肖申克的救赎》 《海边的曼彻斯特》 《梦与狂想的王国》 《辛德勒的名单》 《至爱梵高》 《熔炉》 《窃听风暴》 《美丽心灵》 《v字仇杀队》 《忠犬八公的故事》 《春光乍泄》 《钢琴家》 《阿甘正传》 《霸王别姬》 《沉默的羔羊系列》 《蝴蝶效应系列》 《杀人游戏》 《海洋》 《千钧一发》 《源代码》 《超脱》 《猫鼠游戏》 《心迷宫》 《寻梦环游记》 《猫妖记》 《芳华》 《奇幻森林》","categories":[{"name":"影音","slug":"影音","permalink":"http://huangyiblog.com/categories/影音/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://huangyiblog.com/tags/电影/"}]},{"title":"洛神赋","slug":"洛神赋","date":"2018-04-13T06:27:03.000Z","updated":"2019-12-22T12:09:23.913Z","comments":true,"path":"阅读/洛神赋/","link":"","permalink":"http://huangyiblog.com/阅读/洛神赋/","excerpt":"","text":"洛神赋 【作者】曹植 【朝代】魏晋黄初三年，余朝京师，还济洛川。古人有言，斯水之神，名曰宓妃。感宋玉对楚王神女之事，遂作斯赋。其辞曰： 余从京域，言归东藩。背伊阙，越轘辕，经通谷，陵景山。日既西倾，车殆马烦。尔乃税驾乎蘅皋，秣驷乎芝田，容与乎阳林，流眄乎洛川。于是精移神骇，忽焉思散。俯则末察，仰以殊观，睹一丽人，于岩之畔。乃援御者而告之曰：“尔有觌于彼者乎？彼何人斯？若此之艳也！”御者对曰：“臣闻河洛之神，名曰宓妃。然则君王所见，无乃日乎？其状若何？臣愿闻之。” 余告之曰：“其形也，翩若惊鸿，婉若游龙。荣曜秋菊，华茂春松。仿佛兮若轻云之蔽月，飘摇兮若流风之回雪。远而望之，皎若太阳升朝霞；迫而察之，灼若芙蕖出渌波。秾纤得衷，修短合度。肩若削成，腰如约素。延颈秀项，皓质呈露。芳泽无加，铅华弗御。云髻峨峨，修眉联娟。丹唇外朗，皓齿内鲜，明眸善睐，靥辅承权。瑰姿艳逸，仪静体闲。柔情绰态，媚于语言。奇服旷世，骨像应图。披罗衣之璀粲兮，珥瑶碧之华琚。戴金翠之首饰，缀明珠以耀躯。践远游之文履，曳雾绡之轻裾。微幽兰之芳蔼兮，步踟蹰于山隅。 于是忽焉纵体，以遨以嬉。左倚采旄，右荫桂旗。壤皓腕于神浒兮，采湍濑之玄芝。余情悦其淑美兮，心振荡而不怡。无良媒以接欢兮，托微波而通辞。愿诚素之先达兮，解玉佩以要之。嗟佳人之信修，羌习礼而明诗。抗琼［王弟］以和予兮，指潜渊而为期。执眷眷之款实兮，惧斯灵之我欺。感交甫之弃言兮，怅犹豫而狐疑。收和颜而静志兮，申礼防以自持。 于是洛灵感焉，徙倚彷徨，神光离合，乍阴乍阳。竦轻躯以鹤立，若将飞而未翔。践椒涂之郁烈，步蘅薄而流芳。超长吟以永慕兮，声哀厉而弥长。 尔乃众灵杂遢，命俦啸侣，或戏清流，或翔神渚，或采明珠，或拾翠羽。从南湘之二妃，携汉滨之游女。叹匏瓜之无匹兮，咏牵牛之独处。扬轻袿之猗靡兮，翳修袖以延伫。体迅飞凫，飘忽若神，凌波微步，罗袜生尘。动无常则，若危若安。进止难期，若往若还。转眄流精，光润玉颜。含辞未吐，气若幽兰。华容婀娜，令我忘餐。 于是屏翳收风，川后静波。冯夷鸣鼓，女娲清歌。腾文鱼以警乘，鸣玉鸾以偕逝。六龙俨其齐首，载云车之容裔，鲸鲵踊而夹毂，水禽翔而为卫。 于是越北沚。过南冈，纡素领，回清阳，动朱唇以徐言，陈交接之大纲。恨人神之道殊兮，怨盛年之莫当。抗罗袂以掩涕兮，泪流襟之浪浪。悼良会之永绝兮。哀一逝而异乡。无微情以效爱兮，献江南之明。虽潜处于太阳，长寄心于君王。忽不悟其所舍，怅神宵而蔽光。 于是背下陵高，足往神留，遗情想像，顾望怀愁。冀灵体之复形，御轻舟而上溯。浮长川而忘返，思绵绵督。夜耿耿而不寐，沾繁霜而至曙。命仆夫而就驾，吾将归乎东路。揽騑辔以抗策，怅盘桓而不能去。 备注：赋，是我国古代的一种文体，它讲究文采，韵律，兼具诗歌和散文性质。是以“铺采摛文，体物写志”为手段，侧重于写景，借景抒情。以“颂美”和“讽喻”为目的的一种有韵文体。它多用铺陈叙事的手法，赋必须押韵，这是赋区别于其他文体的一个主要特征。 起于战国，盛于两汉。赋最早出现于诸子散文中，叫”短赋“；以屈原为代表的”骚体“是诗向赋的过渡，叫”骚赋“；汉代正式确立了赋的体例，称为“辞赋”；魏晋以后，赋日益向骈文方向发展，叫做“骈赋”；唐代又由骈体转为律体，叫“律赋”；宋代用散文的形式写赋，称“文赋”。著名的赋体文章有司马相如的《子虚赋》，杜牧的《阿房宫赋》，欧阳修的《秋声赋》，苏轼的《赤壁赋》等。作者曹植以浪漫主义的手法，通过梦幻的境界，描写人神之间的真挚爱情，但终因“人神殊道”无从结合而惆怅分离。","categories":[{"name":"阅读","slug":"阅读","permalink":"http://huangyiblog.com/categories/阅读/"}],"tags":[{"name":"文学","slug":"文学","permalink":"http://huangyiblog.com/tags/文学/"}]},{"title":"长恨歌","slug":"长恨歌","date":"2018-04-12T08:17:13.000Z","updated":"2018-10-14T08:55:44.147Z","comments":true,"path":"阅读/长恨歌/","link":"","permalink":"http://huangyiblog.com/阅读/长恨歌/","excerpt":"","text":"长恨歌 【唐】 白居易 汉皇重色思倾国，御宇多年求不得。 杨家有女初长成，养在深闺人未识。 天生丽质难自弃，一朝选在君王侧。 回眸一笑百媚生，六宫粉黛无颜色。 春寒赐浴华清池，温泉水滑洗凝脂。 侍儿扶起娇无力，始是新承恩泽时。 云鬓花颜金步摇，芙蓉帐暖度春宵。 春宵苦短日高起，从此君王不早朝。 承欢侍宴无闲暇，春从春游夜专夜。 后宫佳丽三千人，三千宠爱在一身。 金屋妆成娇侍夜，玉楼宴罢醉和春。 姊妹弟兄皆列土，可怜光彩生门户。 遂令天下父母心，不重生男重生女。 骊宫高处入青云，仙乐风飘处处闻。 缓歌谩舞凝丝竹，尽日君王看不足。 渔阳鼙鼓动地来，惊破霓裳羽衣曲。 九重城阙烟尘生，千乘万骑西南行。 翠华摇摇行复止，西出都门百余里。 六军不发无奈何，宛转蛾眉马前死。 花钿委地无人收，翠翘金雀玉搔头。 君王掩面救不得，回看血泪相和流。 黄埃散漫风萧索，云栈萦纡登剑阁。 峨嵋山下少人行，旌旗无光日色薄。 蜀江水碧蜀山青，圣主朝朝暮暮情。 行宫见月伤心色，夜雨闻铃肠断声。 天旋地转回龙驭，到此踌躇不能去。 马嵬坡下泥土中，不见玉颜空死处。 君臣相顾尽沾衣，东望都门信马归。 归来池苑皆依旧，太液芙蓉未央柳。 芙蓉如面柳如眉，对此如何不泪垂。 春风桃李花开日，秋雨梧桐叶落时。 西宫南内多秋草，落叶满阶红不扫。 梨园弟子白发新，椒房阿监青娥老。 夕殿萤飞思悄然，孤灯挑尽未成眠。 迟迟钟鼓初长夜，耿耿星河欲曙天。 鸳鸯瓦冷霜华重，翡翠衾寒谁与共。 悠悠生死别经年，魂魄不曾来入梦。 临邛道士鸿都客，能以精诚致魂魄。 为感君王辗转思，遂教方士殷勤觅。 排空驭气奔如电，升天入地求之遍。 上穷碧落下黄泉，两处茫茫皆不见。 忽闻海上有仙山，山在虚无缥渺间。 楼阁玲珑五云起，其中绰约多仙子。 中有一人字太真，雪肤花貌参差是。 金阙西厢叩玉扃，转教小玉报双成。 闻道汉家天子使，九华帐里梦魂惊。 揽衣推枕起徘徊，珠箔银屏迤逦开。 云鬓半偏新睡觉，花冠不整下堂来。 风吹仙袂飘飘举，犹似霓裳羽衣舞。 玉容寂寞泪阑干，梨花一枝春带雨。 含情凝睇谢君王，一别音容两渺茫。 昭阳殿里恩爱绝，蓬莱宫中日月长。 回头下望人寰处，不见长安见尘雾。 惟将旧物表深情，钿合金钗寄将去。 钗留一股合一扇，钗擘黄金合分钿。 但教心似金钿坚，天上人间会相见。 临别殷勤重寄词，词中有誓两心知。 七月七日长生殿，夜半无人私语时。 在天愿作比翼鸟，在地愿为连理枝。 天长地久有时尽，此恨绵绵无绝期。","categories":[{"name":"阅读","slug":"阅读","permalink":"http://huangyiblog.com/categories/阅读/"}],"tags":[{"name":"诗歌","slug":"诗歌","permalink":"http://huangyiblog.com/tags/诗歌/"}]},{"title":"好了歌","slug":"好了歌","date":"2018-04-11T13:09:09.000Z","updated":"2018-12-19T15:12:55.493Z","comments":true,"path":"阅读/好了歌/","link":"","permalink":"http://huangyiblog.com/阅读/好了歌/","excerpt":"","text":"红楼梦原文甄士隐知投人不著，心中未免悔恨，再兼上年惊唬，急忿怨痛已伤，暮年之人，贫病交攻，竟渐渐的露出那下世的光景来。可巧这日拄了拐杖挣到街前散散心时，忽见那边来了一个跛足道人，疯癫落拓，麻鞋鹑衣，口内念着几句言词道：世人都晓神仙好，惟有功名忘不了！古今将相在何方？荒冢一堆草没了。世人都晓神仙好，只有金银忘不了！终朝只恨聚无多，及到多时眼闭了。世人都晓神仙好，只有娇妻忘不了！君生日日说恩情，君死又随人去了。世人都晓神仙好，只有儿孙忘不了！痴心父母古来多，孝顺儿孙谁见了？ 士隐听了，便迎上来道：“你满口说些甚么？只听见些‘好了’‘好了’。”那道人笑道：“你若果听见‘好了’二字，还算你明白。可知世上万般，好便是了，了便是好。若不了，便不好；若要好，须是了。我这歌儿便名《好了歌》。”士隐本是有夙慧的，一闻此言，心中早已彻悟，因笑道：“且住！待我将你这《好了歌》注解出来何如？”道人笑道：“你就请解。”士隐乃说道：陋室空堂，当年笏满床。衰草枯杨，曾为歌舞场。蛛丝儿结满雕梁，绿纱今又糊在蓬窗上。说甚么脂正浓、粉正香，如何两鬓又成霜？昨日黄土陇头送白骨，今宵红灯帐底卧鸳鸯。金满箱，银满箱，展眼乞丐人皆谤。正叹他人命不长，那知自己归来丧！训有方，保不定日后作强梁。择膏粱，谁承望流落在烟花巷！因嫌纱帽小，致使锁枷杠，昨怜破袄寒，今嫌紫蟒长。乱烘烘你方唱罢我登场，反认他乡是故乡。甚荒唐，到头来都是为他人作嫁衣裳。","categories":[{"name":"阅读","slug":"阅读","permalink":"http://huangyiblog.com/categories/阅读/"}],"tags":[{"name":"诗歌","slug":"诗歌","permalink":"http://huangyiblog.com/tags/诗歌/"}]},{"title":"归并排序","slug":"归并排序","date":"2018-04-11T10:23:35.000Z","updated":"2018-10-09T14:43:20.689Z","comments":true,"path":"算法和数据结构/归并排序/","link":"","permalink":"http://huangyiblog.com/算法和数据结构/归并排序/","excerpt":"","text":"归并排序 最基本的2-路归并排序。 原理：将序列两两分组，将序列归并为[n/2]个组，组内单独排序；然后将这些组再两两归并， 生成[n/4]个组，组内在单独排序；以此内推，直到只剩下一个组为止。 时间复杂度为O(nlogn)例：将序列{66,12,33,57,64,27,18}进行2路归并排序 第一趟 { { 12,66 },{ 33,57 },{ 27,64 },{ 18 } } 第二题 { { 12,33,57,66 },{ 18,27,64 } } 第三趟{12,18,27,33,57,64,66} 递归实现 1234567891011121314151617181920212223242526const int maxn=100;void merge(int a[],int l1,int r1,int l2,int r2)&#123; int i=l1,j=l2; int temp[maxn],index=0;//temp临时存放合并后的数组，index为其下标 while(i&lt;=r1&amp;&amp;j&lt;=r2)&#123; if(a[i]&lt;=a[j])&#123; temp[index++]=a[i++]; &#125; else&#123; temp[index++]=a[j++]; &#125; &#125; while(i&lt;=r1) temp[index++]=a[i++]; while(j&lt;=r2) temp[index++]=a[j++]; for(i=0;i&lt;index;i++)&#123; a[l1+i]=temp[i]; &#125;&#125;void mergeSort(int a[],int left,int right)&#123; if(left&lt;right)&#123; int mid=(left+right)/2; mergeSort(a,left,mid); //左子区间归并排序 mergeSort(a,mid+1,right);//右子区间归并排序 merge(a,left,mid,mid+1,right); 将左右子区间合并 &#125;&#125; 非递归实现 12345678910void mergeSort(int a[])&#123; for(int step=2;step/2&lt;=n;step*=2)&#123; for(int i=1;i&lt;=n;i+=step)&#123; int mid=i+step/2-1; if(mid+1&lt;=n)&#123; //sort(a+i,a+min(i+step,n+1)); merge(a,i,mid,mid+1,min(i+step-1,n)) &#125; &#125; &#125; &#125;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://huangyiblog.com/categories/算法和数据结构/"}],"tags":[]},{"title":"《控方证人》观后感","slug":"《控方证人》观后感","date":"2018-04-03T06:41:00.000Z","updated":"2019-12-22T12:09:54.411Z","comments":true,"path":"影音/《控方证人》观后感/","link":"","permalink":"http://huangyiblog.com/影音/《控方证人》观后感/","excerpt":"","text":"这个周末有点小忙哈哈，没办法，得准备Ｊａｖａ课件呀，好歹也是个愚人节呢，得让自己放松下，于是花了点时间看了部老电影《控方证人》，一部上世纪６０年代的电影，一部黑白片。我一般不大会特意去找某部电影，一些早已被广为认可的经典我会时不时抽几部欣赏欣赏，很少有令我失望过，当然，这次也不例外。 很好的一部剧情片，惊悚我倒没怎么感觉到，但不得不说，一流的演员以及一流的剧本让我佩服不已，至少我是被骗到了，结局在我的意料之外，当然中间确实有些困惑的地方，我很理解为什么沃尔的妻子竟然当起了控方证人。影片开始，个性鲜明的律师威尔弗里德爵士便出现在荧幕上，很有意思的一个家伙，一看到雪茄就耐不住想吸上一口，看似嘴不饶人，其实内心善良热诚。他身边的护士尽管一天到晚啰里啰嗦招人烦，却也是真正为威尔弗里德爵士的健康着想。紧接着，剧情展开，控方与被告的辩论也即将展开。 我为什么说我被骗到了，起初我真的认为沃尔是无辜的，是被冤枉的，富婆的死只是被某个入室抢劫犯误杀了，紧接着，伟大的威尔弗里德爵士作为正义的化身，冒着身体旧病复发的风险为沃尔展开辩护，然后一步步过关斩将，去的胜利，沃尔无罪释放！看，结局多么美好，但细想一番，若真是如此，这剧情片恐怕也难成为经典了。开头的警巡，包括之后的女佣，这两人的证词在我看来都很正常，警巡，按照职业习惯进行了正常的回答。至于女佣，势利的姿态可以说是展现的很充分，哈哈，这世上没有无缘无故的恨，沃尔的出现让本该属于她的遗产瞬间成为一场空，他恨透了沃尔，巴不得看着他上绞刑架．．但后一位控方证人让我难以理解，那就是沃尔的妻子克里斯汀，她的出现让我困惑，我相信威尔弗里德爵士当时也是和我相似的心情。看似恩爱的夫妻有什么理由说反目就反目呢，难道之前的感情本就是虚假的？没看到结尾，我真的没猜到这对夫妻竟然都在演戏，在法庭上演了一出精彩的戏。只不过人人喊打的克里斯汀确是陷入爱情的有心人，而看似无辜的沃尔才是花心大萝卜，才是真凶。法律规定，嫌疑人的妻子是无法为其辩护的，证词无效，于是克里斯汀就想到了该当控告，直到最后决定判决的那几分情书信纸，也不过只是她的计划一部分。好可怕的一个女人，竟然铁定了心犯伪证罪也要救这样一个花心大萝卜，难以理解。两个人一唱一和的一出戏，骗过了整个法庭，我没有想到，沃尔竟然真的杀了富婆，更没想到克里斯汀知道是他杀了富婆还要牺牲自己就他，更没想到两人的感情，谁是真心，谁是假意让我一脸蒙蔽，人生如戏，全靠演技呀！哈哈哈～～","categories":[{"name":"影音","slug":"影音","permalink":"http://huangyiblog.com/categories/影音/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://huangyiblog.com/tags/电影/"}]},{"title":"我的2017书单","slug":"我的2017书单","date":"2018-04-01T03:00:34.000Z","updated":"2018-12-19T15:12:55.493Z","comments":true,"path":"阅读/我的2017书单/","link":"","permalink":"http://huangyiblog.com/阅读/我的2017书单/","excerpt":"","text":"你好,这是我的2017书单。1、《平凡的世界》2、《霜冷长河》3、《霍乱时期的爱情》4、《文化苦旅》5、《千年一叹》6、《许三观卖血记》7、《白夜行》8、《嫌疑人X的献身》9、《解忧杂货店》10、《资治通鉴》11、《活着》12、《三体》13、《百年孤独》14、《活着为了讲述》15、《人生》16、《偷影子的人》17、《黄金时代》18、《无声告白》19、《小王子》20、《夜莺与玫瑰》21、《飘》22、《海边的卡夫卡》23、《东方快车上的谋杀案》24、《挪威的森林》25、《雪国》26、《不能承受的生命之轻》27、《恶意》28、《陶庵梦忆》29、《红楼梦》30、《沉默的大多数》31、《少年维特的烦恼》32、《傲慢与偏见》33、《麦田里的守望者》34、《北岛诗集》35、《顾城诗集》36、《海子诗集》37、《余光中散文诗集》38、《鳄鱼街》39、《自由在高处》40、《愿你与这世界温暖相拥》41、《很高兴见到你》42、《无证之罪》43、《白马山庄杀人事件》44、《浮士德》45、《老人与海》46、《北鸢》47、《菜根谭》48、《单恋》49、《鬼谷子》50、《人类群星闪耀时》51、《人间词话》52、《古文观止》53、《假面饭店》54、《幻夜》55、《看见》56、《撒哈拉的故事》57、《月亮和六便士》58、《漫漫自由路》59、《1984》60、《1980年代的爱情》61、《本草纲目》62、《傅雷家书》63、《我们三》64、《围城》65、《钱钟书传》66、《草房子》67、《我的职业是小说家》68、《爱你就像爱生命》69、《这些人那些事》70、《明朝那些事》","categories":[{"name":"阅读","slug":"阅读","permalink":"http://huangyiblog.com/categories/阅读/"}],"tags":[{"name":"书单","slug":"书单","permalink":"http://huangyiblog.com/tags/书单/"}]},{"title":"C++字符串操作","slug":"C++字符串操作","date":"2018-03-31T08:55:28.000Z","updated":"2018-12-19T15:12:55.487Z","comments":true,"path":"语言/C++字符串操作/","link":"","permalink":"http://huangyiblog.com/语言/C++字符串操作/","excerpt":"","text":"1）字符串操作strcpy(p, p1) 复制字符串strncpy(p, p1, n) 复制指定长度字符串strcat(p, p1) 附加字符串strncat(p, p1, n) 附加指定长度字符串strlen(p) 取字符串长度strcmp(p, p1) 比较字符串strcasecmp忽略大小写比较字符串strncmp(p, p1, n) 比较指定长度字符串strchr(p, c) 在字符串中查找指定字符strrchr(p, c) 在字符串中反向查找strstr(p, p1) 查找字符串strpbrk(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找该集合的任一元素strspn(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找不属于该集合的任一元素的偏移strcspn(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找属于该集合的任一元素的偏移 具有指定长度的字符串处理函数在已处理的字符串之后填补零结尾符 2）字符串到数值类型的转换strtod(p, ppend) 从字符串 p 中转换 double 类型数值，并将后续的字符串指针存储到 ppend 指向的 char* 类型存储。strtol(p, ppend, base) 从字符串 p 中转换 long 类型整型数值，base 显式设置转换的整型进制，设置为 0 以根据特定格式判断所用进制，0x, 0X 前缀以解释为十六进制格式整型，0 前缀以解释为八进制格式整型atoi(p) 字符串转换到 int 整型atof(p) 字符串转换到 double 符点数atol(p) 字符串转换到 long 整型 12345678910111213141516void *memset(void *dest, int c, size_t count); 将dest前面count个字符置为字符c. 返回dest的值.void *memmove(void *dest, const void *src, size_t count); 从src复制count字节的字符到dest. 如果src和dest出现重叠, 函数会自动处理. 返回dest的值.void *memcpy(void *dest, const void *src, size_t count); 从src复制count字节的字符到dest. 与memmove功能一样, 只是不能处理src和dest出现重叠. 返回dest的值.void *memchr(const void *buf, int c, size_t count); 在buf前面count字节中查找首次出现字符c的位置. 找到了字符c或者已经搜寻了count个字节, 查找即停止. 操作成功则返回buf中首次出现c的位置指针, 否则返回NULL.void *_memccpy(void *dest, const void *src, int c, size_t count); 从src复制0个或多个字节的字符到dest. 当字符c被复制或者count个字符被复制时, 复制停止.如果字符c被复制, 函数返回这个字符后面紧挨一个字符位置的指针. 否则返回NULL. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950实现strcpy函数,将源串strSrc的内容复制到目标串strDest，返回值为指向目标串的指针char *strcpy(char *strDest,const char *strSrc)//源字符串+const，表明其为输入参数&#123; assert((strDest!=NULL&amp;&amp;(strSrc!=NULL))); //对源地址和目的地址加非0判断 char *address=strDest; while((*strDest++=*strSrc++)!='\\0'); return address;&#125;实现strcat函数：将源串添加到str1的末尾，同时覆盖旧串末尾的'\\0',在新串末尾+'\\0',返回指向str1的指针。char *strcat(char *str1,char *str2)&#123; char *p=str1; assert((str1!=NULL)&amp;&amp;(str2!=NULL)); while(*str1!='\\0') str1++; while(*str1++=*str2++); return p;&#125;strcmp函数：比较str1和str2两个字符串的大小，若str1&gt;str2，则返回正数；若str1&lt;str2，则返回负数；若str1==str2，则返回0。int strcmp(const char *str1,const char *str2)&#123; assert((str1!=NULL)&amp;&amp;(str2!=NULL)); while(*str1&amp;&amp;*str2&amp;&amp;(*str1==*str2)) &#123; str1++; str2++; &#125; return *str1-*str2;&#125;void memset(void *s,int c,size_t n) //将已开辟内存空间s的首n个字节的值设为c&#123; assert(s!=NULL); char *tmp=(char *)s; while(n--) &#123; *tmp++=(char)c; &#125; return s;&#125;void memcpy(void *dest,const void *src,size_t n)//从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中&#123; assert(dest!=NULL&amp;&amp;src!=NULL); char *tmpdest=(char *)dest; char *tmpsrc=(char *)src; while(n-- &gt;0) *tmpdest++=*tmpsrc++; return dest;&#125; 实现C的strstr功能：从字符串str1中查找是否有字符串str2， -如果有，从str1中的str2位置起，返回str1中str2起始位置的指针，如果没有，返回null。12345678910111213141516171819202122232425262728293031323334353637383940414243char *mystrstr(char *s1 , char *s2) &#123; if(*s1==0) &#123; if(*s2) return(char*)NULL; return (char*)s1; &#125; while(*s1) &#123; int i=0; while(1) &#123; if(s2[i]==0) return s1; if(s2[i]!=s1[i]) break; i++; &#125; s1++; &#125; return (char*)NULL; &#125; class Solution &#123; public: char *strStr(char *haystack, char *needle) &#123; // Start typing your C/C++ solution below // DO NOT write int main() function int i,j; for (i = j = 0; haystack[i] &amp;&amp; needle[j];) &#123; if (haystack[i] == needle[j]) &#123; ++i; ++j; &#125; else &#123; i = i - j + 1; j = 0; &#125; &#125; return needle[j]?0:(haystack + i - j); &#125; &#125;; 用C语言实现函数void memmove(void dest, const void *src, size_t n)。memmove函数的功能死拷贝src所指向内存内容前n个字节到dest所指的地址上。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;void * my_memmove( void * const dest, const char * const src, size_t n )&#123; // check parameters if( 0 == n ) &#123; return NULL; &#125; if( NULL == dest || NULL == src ) &#123; return NULL; &#125; char * psrc = (char *)src; char * pdest = (char *)dest; if( pdest &lt;= psrc || pdest &gt; psrc + n ) &#123; std::cout &lt;&lt; \"forward overlapping\" &lt;&lt; std::endl; // copy forward direction for( size_t i = 0; i &lt; n; i++ ) &#123; *pdest = *psrc; pdest++; psrc++; &#125; &#125; else &#123; std::cout &lt;&lt; \"backward overlapping\" &lt;&lt; std::endl; // copy backward direction pdest = pdest + n; psrc = psrc + n; for( size_t i = 0; i&lt; n; i++ ) &#123; *pdest = *psrc; pdest--; psrc--; &#125; &#125; return dest;&#125;int main( int argc, char ** argv )&#123; char *src = new char[100]; sprintf( src, \"%s\", \"hello world!\" ); char * dest = new char[100]; memset( dest, 0, 100*sizeof(char ) ); std::cout &lt;&lt; src &lt;&lt; std::endl; char * result = (char*)my_memmove( dest, src, strlen(src) ); std::cout &lt;&lt; result &lt;&lt; std::endl; delete src; delete dest; return 0;&#125; 设计一个反转字符串的函数 char reverse_str(char str),不使用系统函数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 递归实现字符串反转 char *reverse(char *str) &#123; if( !str ) &#123; return NULL; &#125; int len = strlen(str); if( len &gt; 1 ) &#123; char ctemp =str[0]; str[0] = str[len-1]; str[len-1] = '/0';// 最后一个字符在下次递归时不再处理 reverse(str+1); // 递归调用 str[len-1] = ctemp; &#125; return str; &#125; // 非递归实现字符串反转 char *reverse(char *str) &#123; if( !str ) &#123; return NULL; &#125; int len = strlen(str); char temp; for( int i = 0; i &lt; len / 2; i++ ) &#123; // 交换前后两个相应位置的字符 temp = *(str + i); *(str + i) = *(str + len - 1 - i); *(str + len - 1 - i) = temp; &#125; return str; &#125; int _tmain(int argc, _TCHAR* argv[]) &#123; char src[] = &#123;\"abcdef\"&#125;; char *pdest = reverse(src); getchar(); return 0; &#125;","categories":[{"name":"语言","slug":"语言","permalink":"http://huangyiblog.com/categories/语言/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://huangyiblog.com/tags/C/"}]},{"title":"我的2016电影","slug":"我的2016电影","date":"2018-03-31T05:12:25.000Z","updated":"2018-12-19T15:12:55.493Z","comments":true,"path":"影音/我的2016电影/","link":"","permalink":"http://huangyiblog.com/影音/我的2016电影/","excerpt":"","text":"你好,这是我的2016电影列表。1、《马力和马克思》2、《怦然心动》3、《天堂电影院》4、《海上钢琴师》5、《教父系列》6、《控方证人》7、《千与千寻》8、《从你的全世界路过》9、《战狼2》10、《金刚狼3》11、《大话西游系列》12、《鬼子来了》13、《让子弹飞》14、《天才枪手》15、《比利比恩的中场战事》16、《麦兜的故事》17、《美国丽人》18、《泰坦尼克号》19、《阿飞正传》20、《x森林系列》21、《辩护人》22、《记忆碎片》23、《哈尔的移动城堡》24、《烈日灼心》25、《一条狗的使命》26、《致命魔术》27、《星际穿越》28、《驯龙高手》29、《幸福终点站》30、《时空恋旅人》31、《致命ID》32、《你的名字》33、《幽灵公主》34、《盗梦空间》","categories":[{"name":"影音","slug":"影音","permalink":"http://huangyiblog.com/categories/影音/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://huangyiblog.com/tags/电影/"}]},{"title":"我的2016书单","slug":"我的2016书单","date":"2018-03-29T11:35:37.000Z","updated":"2018-11-05T03:01:45.380Z","comments":true,"path":"阅读/我的2016书单/","link":"","permalink":"http://huangyiblog.com/阅读/我的2016书单/","excerpt":"","text":"你好,这是我的2016书单。1、《一句顶一万句》2、《寻路中国》3、《人类简史》4、《一只特立独行的猪》5、《三国演义》6、《世说新语》7、《战国策》8、《春风沉醉的夜晚》9、《水浒传》10、《茶花女》11、《天黑以后》12、《悟空传》13、《苦妓回忆录》14、《不属于我们的世纪》15、《身份的焦虑》16、《追忆似水年华》17、《约翰克里斯多夫》18、《无名的裘德》19、《高老头》20、《浮生六记》21、《二手时间》22、《洗澡》23、《爱情和其他魔鬼》24、《芳华》25、《冰与火之歌》26、《远山淡影》27、《目送》28、《自深深处》29、《巨人的陨落》30、《余华短篇集》31、《基督山伯爵》32、《三个火枪手》33、《和喜欢的一切在一起》34、《弗兰克尔自传》35、《重新认识你自己》36、《二十四史》37、《长恨歌》38、《面包树上的女人》39、《追随你的心》40、《不能不去爱的两件事》41、《在这复杂世界里》42、《坏小孩》43、《季羡林私人史》44、《金瓶梅》45、《孤独六讲》46、《我们生活在巨大的差距里》47、《分身》48、《宿命》49、《快乐是在心里》50、《我的精神家园》51、《万历十五年》52、《撒切尔夫人传》53、《飞鸟集》54、《幻灭》55、《当我跑步时我谈些什么》56、《富爸爸、穷爸爸》57、《雅舍小品》58、《一个女子恋爱的时候》59、《从一到无穷大》60、《虚无的十字架》61、《资本论》62、《白说》63、《在细雨中呼喊》","categories":[{"name":"阅读","slug":"阅读","permalink":"http://huangyiblog.com/categories/阅读/"}],"tags":[{"name":"书单","slug":"书单","permalink":"http://huangyiblog.com/tags/书单/"}]},{"title":"腾讯精选50题 236. 二叉树的最近公共祖先","slug":"腾讯精选50题-236-二叉树的最近公共祖先","date":"2017-08-13T13:58:14.000Z","updated":"2019-09-02T05:01:51.539Z","comments":true,"path":"题解集/腾讯精选50题-236-二叉树的最近公共祖先/","link":"","permalink":"http://huangyiblog.com/题解集/腾讯精选50题-236-二叉树的最近公共祖先/","excerpt":"","text":"题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1:123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2:123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路这题要注意跟235题求二叉搜索树的公共祖先作区分，这题只是普通二叉树，结点之间无序考虑递归解法递归边界：如果 root == NULL 返回NULL从根节点递归的后续遍历整棵树，定义两个结点left和right来存放p和q在左右子树的位置。如果p，q在root的左右子树，那么root就是LCA，如果p结点在q节点的子树，那么q就是LCA 具体代码123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root == NULL) &#123; return NULL; &#125; if(root == p || root == q) &#123; return root; &#125; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if(left != NULL &amp;&amp; right != NULL) &#123; return root; &#125; else if(left != NULL) &#123; return left; &#125; else &#123; return right; &#125; &#125;&#125;;","categories":[{"name":"题解集","slug":"题解集","permalink":"http://huangyiblog.com/categories/题解集/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://huangyiblog.com/tags/LeetCode/"}]},{"title":"腾讯精选50题 235. 二叉搜索树的最近公共祖先","slug":"腾讯精选50题-235-二叉搜索树的最近公共祖先","date":"2017-08-13T13:43:37.000Z","updated":"2019-09-02T05:02:00.284Z","comments":true,"path":"题解集/腾讯精选50题-235-二叉搜索树的最近公共祖先/","link":"","permalink":"http://huangyiblog.com/题解集/腾讯精选50题-235-二叉搜索树的最近公共祖先/","excerpt":"","text":"题目描述给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1:123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2:123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路考虑递归解法：递归边界：如果 root == NULL 那么返回NULL递归函数：如果当前结点的值比p和q的值都要小，那么最近公共祖先必然在该结点的右子树里面如果当前结点的值比p和q的值都要大，那么最近公共祖先必然在该结点的左子树里面 如果上述都不满足，那么当前结点就是p和q的最近公共祖先 具体代码 递归写法 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root == NULL) &#123; return NULL; &#125; if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123; return lowestCommonAncestor(root-&gt;right, p, q); &#125; if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123; return lowestCommonAncestor(root-&gt;left, p, q); &#125; return root; &#125;&#125;; 迭代写法 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; while(root != NULL) &#123; if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123; root = root-&gt;right; &#125; else if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123; root = root-&gt;left; &#125; else &#123; break; &#125; &#125; return root; &#125;&#125;;","categories":[{"name":"题解集","slug":"题解集","permalink":"http://huangyiblog.com/categories/题解集/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://huangyiblog.com/tags/LeetCode/"}]},{"title":"腾讯精选50题 230. 二叉搜索树中第K小的元素","slug":"腾讯精选50题-230-二叉搜索树中第K小的元素","date":"2017-08-13T13:20:55.000Z","updated":"2019-09-02T05:02:11.729Z","comments":true,"path":"题解集/腾讯精选50题-230-二叉搜索树中第K小的元素/","link":"","permalink":"http://huangyiblog.com/题解集/腾讯精选50题-230-二叉搜索树中第K小的元素/","excerpt":"","text":"题目描述给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。 说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。 示例 1:1234567输入: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2输出: 1 示例 2:123456789输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1输出: 3 进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路这题还是比较好想的，关键点就是二叉搜索树的中序遍历后的序列为升序序列。所以我们只需要定义一个cnt变量用作计数，在中序遍历每次访问结点，cnt + 1当cnt == k ，返回当前结点值，就是当前二叉搜索树中第k小的值 具体代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int kthSmallest(TreeNode* root, int k) &#123; int cnt = 0; stack&lt;TreeNode* &gt; s; TreeNode* p = root; while(p || !s.empty()) &#123; while(p) &#123; s.push(p); p = p-&gt;left; &#125; p = s.top(); s.pop(); cnt++; if(cnt == k) &#123; return p-&gt;val; &#125; p = p-&gt;right; &#125; return 0; &#125;&#125;;","categories":[{"name":"题解集","slug":"题解集","permalink":"http://huangyiblog.com/categories/题解集/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://huangyiblog.com/tags/LeetCode/"}]},{"title":"腾讯精选50题 124. 二叉树中的最大路径和","slug":"腾讯精选50题-124-二叉树中的最大路径和","date":"2017-08-13T12:56:01.000Z","updated":"2019-09-02T05:02:25.987Z","comments":true,"path":"题解集/腾讯精选50题-124-二叉树中的最大路径和/","link":"","permalink":"http://huangyiblog.com/题解集/腾讯精选50题-124-二叉树中的最大路径和/","excerpt":"","text":"题目描述给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1:1234567输入: [1,2,3] 1 / \\ 2 3输出: 6 示例 2:123456789输入: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7输出: 42 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路大家有没有发现这题和之前那到求二叉树最大深度很相似，只不过这题需要加上节点值考虑递归写法：递归边界为：node == NULL 返回0中间定义left 和 right 分别存放当前结点左子树最大和与右子树最大和，注意和为负数的情况递归时用一个res变量记录最大值，如果当前节点的子树和更大，则更新这个最大值 具体代码12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int res = INT_MIN; int getSum(TreeNode* node) &#123; if(node == NULL) &#123; return 0; &#125; //考虑子树和为负的情况，所以需要和0相比取最大值 int left = max(getSum(node-&gt;left), 0); int right = max(getSum(node-&gt;right), 0); res = max(res, node-&gt;val + left + right); return max(left, right) + node-&gt;val; &#125; int maxPathSum(TreeNode* root) &#123; getSum(root); return res; &#125; &#125;;","categories":[{"name":"题解集","slug":"题解集","permalink":"http://huangyiblog.com/categories/题解集/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://huangyiblog.com/tags/LeetCode/"}]},{"title":"腾讯精选50题LeetCode104. 二叉树的最大深度","slug":"LeetCode104-二叉树的最大深度","date":"2017-08-13T05:40:30.000Z","updated":"2019-09-02T05:02:43.938Z","comments":true,"path":"题解集/LeetCode104-二叉树的最大深度/","link":"","permalink":"http://huangyiblog.com/题解集/LeetCode104-二叉树的最大深度/","excerpt":"","text":"题目描述给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：12345678给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7返回它的最大深度 3 。 解题思路我们借助递归来求：递归边界为：root为NULL，那么返回0在递归函数中分别定义结点左右子树的高度：left = maxDepth(root-&gt;left);right = maxDepth(root-&gt;right);最后返回：max(left, right) + 1;求出最大深度 具体代码1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(root==NULL) return 0; return max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+1; &#125;&#125;;","categories":[{"name":"题解集","slug":"题解集","permalink":"http://huangyiblog.com/categories/题解集/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://huangyiblog.com/tags/LeetCode/"}]},{"title":"LeetCode 136.只出现一次的数字","slug":"LeetCode-136-只出现一次的数字","date":"2017-08-12T07:46:22.000Z","updated":"2019-09-02T05:03:07.657Z","comments":true,"path":"题解集/LeetCode-136-只出现一次的数字/","link":"","permalink":"http://huangyiblog.com/题解集/LeetCode-136-只出现一次的数字/","excerpt":"","text":"腾讯精选50题136.只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1:12输入: [2,2,1]输出: 1 示例 2:12输入: [4,1,2,1,2]输出: 4 分析，只有一个元素出现一次，其余均出现两次，可以想到异或运算符，遍历整个数组，出现两次的异或以后为0，最后自然只剩下了出现一次的。12345678910class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int x = 0; for(int i=0;i&lt;nums.size();i++)&#123; x^=nums[i]; &#125; return x; &#125;&#125;;","categories":[{"name":"题解集","slug":"题解集","permalink":"http://huangyiblog.com/categories/题解集/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://huangyiblog.com/tags/LeetCode/"}]},{"title":"腾讯精选50题 231. 2的幂","slug":"231-2的幂","date":"2017-08-12T06:56:43.000Z","updated":"2019-09-02T05:02:52.880Z","comments":true,"path":"题解集/231-2的幂/","link":"","permalink":"http://huangyiblog.com/题解集/231-2的幂/","excerpt":"","text":"腾讯精选50题 231. 2的幂给定一个整数，写一个函数来判断它是否是 2 的幂次方。 示例 1:12输入: 1输出: true 示例 2:12输入: 16输出: true 示例 3:12输入: 218输出: false 分析：解法一：最常规的想法是对这个数一直除2，判断最后剩下的是不是1 解法二：巧用位运算：举两个例子，4的二进制为：100 3的二进制为：011 2的二进制为：10 1的二进制为：01 所以我们只需要判断下 n &amp; (n - 1)是否等于0即可下面的代码里有个地方要注意下：那就是 n &amp; (n - 1) 外面还要加个括号，因为==优先级比&amp;要高。 123456789101112class Solution &#123;public: bool isPowerOfTwo(int n) &#123; if(n &lt;= 0) &#123; return false; &#125; if(n == 1) &#123; return true; &#125; return (n &amp; (n-1)) == 0 ? true : false; &#125;&#125;; 解法二： 负数一定不是2的幂 2的整数次幂对应的二进制数只含有0个或者1个1 时间复杂度：O(n) 空间复杂度：O(1) 123456789101112131415161718class Solution &#123;public: bool isPowerOfTwo(int n) &#123; if(n&lt;0) return false; bool hasOne = false; while(n&gt;0)&#123; if(n&amp;1)&#123; if(hasOne)&#123; return false; &#125;else&#123; hasOne = true; &#125; &#125; n&gt;&gt;=1; &#125; return hasOne; &#125;&#125;;","categories":[{"name":"题解集","slug":"题解集","permalink":"http://huangyiblog.com/categories/题解集/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://huangyiblog.com/tags/LeetCode/"}]},{"title":"腾讯精选50题169. 求众数","slug":"腾讯精选50题169-求众数","date":"2017-08-11T15:00:23.000Z","updated":"2019-09-02T05:03:00.671Z","comments":true,"path":"题解集/腾讯精选50题169-求众数/","link":"","permalink":"http://huangyiblog.com/题解集/腾讯精选50题169-求众数/","excerpt":"","text":"腾讯精选50题169. 求众数给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1:12输入: [3,2,3]输出: 3 示例 2:12输入: [2,2,1,1,1,2,2]输出: 2 对数组进行排序，数组中间的元素即为众数1234567class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); return nums[nums.size()&gt;&gt;1]; &#125;&#125;;","categories":[{"name":"题解集","slug":"题解集","permalink":"http://huangyiblog.com/categories/题解集/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://huangyiblog.com/tags/LeetCode/"}]},{"title":"腾讯精选50题 78. 子集","slug":"腾讯精选50题-78-子集","date":"2017-08-11T14:36:35.000Z","updated":"2019-09-02T05:03:17.947Z","comments":true,"path":"题解集/腾讯精选50题-78-子集/","link":"","permalink":"http://huangyiblog.com/题解集/腾讯精选50题-78-子集/","excerpt":"","text":"给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 考虑回溯算法1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; temp; helper(res, temp, nums, 0); return res; &#125; void helper(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt; temp, vector&lt;int&gt;&amp; nums, int level) &#123; if(temp.size() &lt;= nums.size()) &#123; res.push_back(temp); &#125; for(int i = level; i &lt; nums.size(); i++) &#123; temp.push_back(nums[i]); helper(res, temp, nums, i + 1); temp.pop_back(); &#125; &#125;&#125;;","categories":[{"name":"题解集","slug":"题解集","permalink":"http://huangyiblog.com/categories/题解集/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://huangyiblog.com/tags/LeetCode/"}]},{"title":"腾讯精选50题 148. 排序链表","slug":"腾讯精选50题-148-排序链表","date":"2017-08-09T12:56:16.000Z","updated":"2019-09-02T05:03:25.014Z","comments":true,"path":"题解集/腾讯精选50题-148-排序链表/","link":"","permalink":"http://huangyiblog.com/题解集/腾讯精选50题-148-排序链表/","excerpt":"","text":"腾讯精选50题 148. 排序链表在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4示例 2: 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 如果不考虑常数空间复杂度的话，可以借鉴归并排序的思想，最后归并两个有序链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode* slow = head; ListNode* fast = head; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; fast = slow-&gt;next; slow-&gt;next = NULL; ListNode* p1 = sortList(head); ListNode* p2 = sortList(fast); return merge(p1, p2); &#125; ListNode* merge(ListNode* l1, ListNode* l2) &#123; ListNode dummy(0); ListNode* p = &amp;dummy; while(l1 &amp;&amp; l2) &#123; if(l1-&gt;val &lt; l2-&gt;val) &#123; p-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; p-&gt;next = l2; l2 = l2-&gt;next; &#125; p = p-&gt;next; &#125; if(l1) &#123; p-&gt;next = l1; &#125; else if(l2) &#123; p-&gt;next = l2; &#125; return dummy.next; &#125;&#125;;","categories":[{"name":"题解集","slug":"题解集","permalink":"http://huangyiblog.com/categories/题解集/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://huangyiblog.com/tags/LeetCode/"}]}]}