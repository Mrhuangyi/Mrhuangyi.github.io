<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你的小黄^_^</title>
  <icon>https://www.gravatar.com/avatar/3a25a3ab34305615e80247defadfd4f6</icon>
  <subtitle>做一名有情怀的程序员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huangyiblog.com/"/>
  <updated>2018-10-01T07:32:30.414Z</updated>
  <id>http://huangyiblog.com/</id>
  
  <author>
    <name>Mr.Huangyi</name>
    <email>18757163093@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于Ubuntu与win10双系统引导修复的问题</title>
    <link href="http://huangyiblog.com/%E9%9A%8F%E7%AC%94/%E5%85%B3%E4%BA%8EUbuntu%E4%B8%8Ewin10%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E4%BF%AE%E5%A4%8D%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://huangyiblog.com/随笔/关于Ubuntu与win10双系统引导修复的问题/</id>
    <published>2018-10-01T07:30:50.000Z</published>
    <updated>2018-10-01T07:32:30.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p>我的电脑之前是在Windows10系统上装了一个Fedora版本的linux，基本上使用都没什么问题，说实话，因为我大部分软件或开发工具啥的主要都装在Windows系统上，所以平时还是win10用的比较多。但最近听说国内有一款仿Ubuntu的深度deepin系统也挺不错的，而且界面还挺像mac，所以就急着将自己电脑上的Fedora换成了deepin，但估计就是在安装deepin的时候出了叉子。我到现在也没搞清楚是哪里出了问题，动了什么不该动的东西，导致win10的启动引导程序坏了，最后结果就是按下开机键只能进入deepin了。即是你在刚开机时按下ESC进入系统选择界面选择Windows也是照样进不了。</p><h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><p>发现进不了Windows只能进deepin我就开始有点慌了，要知道我很多软件和工具都是装在Windows上面，而linux还只是个壳子。我可不想重装系统，当然也不得不做好这最坏的打算。当时试了很多方法行不通，就又将deepin换成了Ubuntu，但结果还是一样，这倒是在意料之中。起初以为只是Ubuntu与win10不兼容，需要修复一下引导就行，但按理说不应该的，我室友的组装机用的就是这两个系统，从来没出什么问题。我上网查了查，有人说直接进入Ubuntu终端，运行sudo -updategrub，更新一下grub就行了，但我试了好几次，包括修改grub.cfg文件，但都行不通，每次update以后根本不显示found Windows这样的字眼。这是便意识到想必是win10的引导已经损坏了，再在linux上面瞎搞估计也无济于事。这样一来，我就去网上找资料，查如何修复win10引导。主要步骤如下：</p><ul><li>首先你得有个win64位的PE系统启动U盘，在开机的时候按下ESC键进入系统选择界面（我的电脑是ESC，这个不同版本电脑可能有所不同，也有可能你是F11，F12）,之后选择你的U盘启动系统进入。</li><li>进入系统后，打开你的DG（DiskGenuis）分区工具</li></ul><p><img src="http://pc5wd3ju6.bkt.clouddn.com/dg1.PNG" alt="alt"></p><p>使用这个工具之前需要注意一个问题，那就是你的硬盘是什么格式的，是GPT还是MBR？<br>-</p><p>很多人写的修复方法都是针对硬盘类型为mbr的，就是直接选中的系统盘，如下图：点击硬盘选项下的重建主引导记录。</p><p><img src="http://pc5wd3ju6.bkt.clouddn.com/dg2.png" alt="alt"></p><p>然而问题出现了，当我点击 硬盘选项后，重建主引导记录这一栏是灰色的，无法选中。原因就是我的硬盘类型是GPT的。</p><ul><li><p>接下来要做的就是修复GPT格式的引导，首先我们注意到ESP分区没有盘符，我们需要给他指定一个盘符：<br><img src="http://pc5wd3ju6.bkt.clouddn.com/dg3.PNG" alt="alt"></p></li><li><p>指派好了就关闭DG工具，回到桌面，</p></li></ul><p>打开cmd命令行，输入以下命令并运行</p><p>　　bcdboot c:\windows /s g: /f uefi /l zh-cn</p><p>　　其中：c:\windows  硬盘系统目录，根据实际情况修改</p><p>　　/s g:     指定esp分区所在磁盘，根据实际情况修改</p><p>　　/f uefi   指定启动方式为uefi</p><p>　　/l zh-cn  指定uefi启动界面语言为简体中文</p><p>　　注：64位7PE不带/s参数，故7PE不支持bios启动下修复</p><p><img src="http://pc5wd3ju6.bkt.clouddn.com/dg4.PNG" alt="alt"></p><ul><li>创建成功后重新启动电脑，选择Windows boot manager进入系统，到这里win10的引导也就修复完成。</li></ul><h1 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h1><p>win10引导修复完成后的结果是，每次开机都是默认直接进入Windows，如果想要进入Ubuntu，还是要刚开机时按下ESC手动选择进入，而不是和之前一样，出现一个双系统选择界面供你直接选择。我进入Ubuntu之后尝试修复此问题，主要进行了如下操作：<br>1 进入Ubuntu终端，输入如下命令利用bootrepair修复引导<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 进入root用户</span><br><span class="line">sudo -i </span><br><span class="line"># 添加软件源并更新</span><br><span class="line">add-apt-repository ppa:yannubuntu/boot-repair &amp;&amp;　apt-get update</span><br><span class="line">＃　安装boot-repair并启动软件</span><br><span class="line">apt-get install -y boot-repair &amp;&amp; boot-repair</span><br></pre></td></tr></table></figure></p><p>2 查看Windows10磁盘所在引导，然后继续进入Ubuntu终端，修改引导</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo -i</span><br><span class="line">vim /boot/grub/grub.cfg</span><br><span class="line">//再该文件末尾修改win10引导信息。</span><br><span class="line">//之后再更新引导</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>3 庆幸的是更新引导之后的确出现了found Windows的字眼，但是当我重启电脑，发现并没有改变什么，还是只能直接进入Windows，所以挺困惑的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题来源&quot;&gt;&lt;a href=&quot;#问题来源&quot; class=&quot;headerlink&quot; title=&quot;问题来源&quot;&gt;&lt;/a&gt;问题来源&lt;/h1&gt;&lt;p&gt;我的电脑之前是在Windows10系统上装了一个Fedora版本的linux，基本上使用都没什么问题，说实话，因为我大部分软
      
    
    </summary>
    
      <category term="随笔" scheme="http://huangyiblog.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaWeb开发环境设置</title>
    <link href="http://huangyiblog.com/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/JavaWeb%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"/>
    <id>http://huangyiblog.com/业务开发/JavaWeb开发环境设置/</id>
    <published>2018-10-01T05:39:58.000Z</published>
    <updated>2018-10-01T05:43:00.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一步：下载所需要的开发工具"><a href="#第一步：下载所需要的开发工具" class="headerlink" title="第一步：下载所需要的开发工具"></a>第一步：下载所需要的开发工具</h1><ul><li>我这里的javaweb项目选择eclipse的javaee，下载网站：<a href="https://www.eclipse.org/downloads/packages/" target="_blank" rel="noopener">https://www.eclipse.org/downloads/packages/</a></li><li>服务器下载Tomcat，下载网站：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a></li><li>java jdk下载：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li><li>jdk的环境配置这里我就不写了。</li><li>注意点：版本问题，每个软件版本都不是随便下的，首先不提倡急着下载最新版的，容易出bug。另外尤其要注意jdk版本和Tomcat版本的兼容问题，有一个版本过高或过低都是不行的。<br>关于版本匹配：可以参考下图（Tomcat官网有介绍）<br><img src="http://pc5wd3ju6.bkt.clouddn.com/tomcatversion.PNG" alt="alt"></li></ul><h1 id="第二步：eclipse配置"><a href="#第二步：eclipse配置" class="headerlink" title="第二步：eclipse配置"></a>第二步：eclipse配置</h1><p>1 如下图：<br>进入preferences<br><img src="http://pc5wd3ju6.bkt.clouddn.com/jw1.PNG" alt="alt"></p><p>2 进入java选项下的installed JREs配置jdk目录</p><p><img src="http://pc5wd3ju6.bkt.clouddn.com/jw2.PNG" alt="alt"></p><p><img src="http://pc5wd3ju6.bkt.clouddn.com/jw3.PNG" alt="alt"></p><p>3 进入server配置tomcat的运行环境</p><p><img src="http://pc5wd3ju6.bkt.clouddn.com/jw4.PNG" alt="alt"></p><h1 id="第三步，新建一个javaweb项目，验证"><a href="#第三步，新建一个javaweb项目，验证" class="headerlink" title="第三步，新建一个javaweb项目，验证"></a>第三步，新建一个javaweb项目，验证</h1><p>如下图，在web选项新建一个Dynamic Web Project,并新建一个jsp，在里面任意输入内容后并允许，若能够正常输出，则配置成功。<br><img src="http://pc5wd3ju6.bkt.clouddn.com/jw5.PNG" alt="alt"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一步：下载所需要的开发工具&quot;&gt;&lt;a href=&quot;#第一步：下载所需要的开发工具&quot; class=&quot;headerlink&quot; title=&quot;第一步：下载所需要的开发工具&quot;&gt;&lt;/a&gt;第一步：下载所需要的开发工具&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;我这里的javaweb项目选择e
      
    
    </summary>
    
      <category term="业务开发" scheme="http://huangyiblog.com/categories/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Java" scheme="http://huangyiblog.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git 与Ｇithub入门介绍</title>
    <link href="http://huangyiblog.com/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/Git-%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://huangyiblog.com/业务开发/Git-入门介绍/</id>
    <published>2018-09-27T14:22:17.000Z</published>
    <updated>2018-09-28T13:33:07.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git是什么？"><a href="#Git是什么？" class="headerlink" title="Git是什么？"></a>Git是什么？</h1><p>　　Git 是一款免费、开源的分布式版本控制系统，最早由 LinilusTorvalds 创建，用于管理 Linux 内核开发， 现已成为分布式版本控制的主流工具。版本控制系统（VCS）： 一种可以管理和追逐软件代码或其他类似类容的不同版本的工具。我们知道一旦启动一个项目，数据短暂且易失，对于相关的文本和代码，我们需要寻找合适的备份策略。而版本控制系统就是很好的备份策略，方便开发人员对变更进行追踪管理。。Git 由 Linus Torvalds 发明，起初是为了方便管理 Linux1内核的开发工作。如今，Git 已经在大量的项目中得到了 非常成功的应用。 　　</p><h1 id="Git常见功能"><a href="#Git常见功能" class="headerlink" title="Ｇｉｔ常见功能"></a>Ｇｉｔ常见功能</h1><ol><li>从服务器上克隆数据库（包括代码和版本信息）到单机上。 </li><li>在自己的机器上创建分支，修改代码。</li><li>在本地上自己创建的分支上提交代码。</li><li>在单机上合并分支。</li><li>新建⼀个分⽀，把服务器上最新版的代码fetch下来，然后跟⾃⼰的主分⽀合并。 </li><li>⽣成补丁（patch），把补丁发送给主开发者。   </li><li>看主开发者的反馈，如果主开发者发现两个⼀般开发者之间有冲突（他们之间可 以合作解决的冲突），就会要求他们先解决冲突，然后再由其中⼀个⼈提交。如果 主开发者可以⾃⼰解决，或者没有冲突，就通过。 </li><li>⼀般开发者之间解决冲突的⽅法，开发者之间可以使⽤ pull 命令解决冲突，解决 完冲突之后再向主开发者提交补丁</li></ol><h1 id="Git初步入门"><a href="#Git初步入门" class="headerlink" title="Git初步入门"></a>Git初步入门</h1><ul><li><p>如果你是第一次安装使用Git，你需要设置署名和邮箱：</p><pre><code>$ git config --global user.name &quot;⽤户名&quot; $ git config --global user.email &quot;电⼦邮箱&quot;</code></pre></li></ul><h2 id="关于git的常用命令，阮一峰老师有一篇博客讲的蛮好的。"><a href="#关于git的常用命令，阮一峰老师有一篇博客讲的蛮好的。" class="headerlink" title="关于git的常用命令，阮一峰老师有一篇博客讲的蛮好的。"></a>关于git的常用命令，阮一峰老师有一篇博客讲的蛮好的。</h2><p>  链接：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p><p>阮老师用了一张图介绍了最常用的6个命令。<br><img src="http://pc5wd3ju6.bkt.clouddn.com/git.png" alt="alt"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* Workspace：工作区</span><br><span class="line">* Index / Stage：暂存区</span><br><span class="line">* Repository：仓库区（或本地仓库）</span><br><span class="line">* Remote：远程仓库</span><br></pre></td></tr></table></figure></p><ul><li><p>将代码仓库clone到本地，其实就是将代码复制到你的机器⾥，并交由Git来管理：</p><pre><code>$ git clone git@github.com:someone/symfony-docs-chs.git</code></pre></li><li><p>初始化本地仓库，当前目录下会出现一个名为 .git 的目录</p><p>  $ git init</p></li><li><p>新建一个目录，将其初始化为Git代码库</p><p>  $ git init [project-name]</p></li><li><p>下载一个项目和它的整个代码历史</p><p>   $ git clone [url]</p></li><li><p>删除工作区文件，并将这次删除放入暂存区</p><p>  $ git rm [file1] [file2] …</p></li><li><p>向这个本地的代码仓库添加当前目录的所有改动。</p><pre><code>$ git add .</code></pre></li><li><p>提交文件到本地仓库</p><p>   $ git commit -m “Hello”   </p></li><li><p>提交暂存区的指定文件到仓库</p><p>   $ git commit [file1] [file2] … -m [message]</p></li><li><p>添加某个文件</p><p>   $ git add -p</p></li><li><p>查看现在的状态</p><p>  $ git status</p></li><li><p>推送所有分支到远程仓库</p><p>   $ git push [remote] –all</p><h1 id="Github是什么"><a href="#Github是什么" class="headerlink" title="Github是什么"></a>Github是什么</h1></li><li><p>维基百科的说明：</p></li></ul><p>GitHub 是⼀个共享虚拟主机服务，⽤于存放使⽤ Git 版本控制的软件代码 和内容项⽬。它由 GitHub 公司（曾称 Logical Awesome）的开发者 Chris Wanstrath、PJHyett和TomPreston-Werner使⽤RubyonRails编写⽽成。</p><ul><li><p>官方介绍：<br>GitHubisthebestplacetosharecodewithfriends,co-workers,classmates, andcompletestrangers. OvereightmillionpeopleuseGitHubtobuildamazingthingstogether.</p></li><li><p>对普通用户来说，它还可以是：<br>1 网站<br>2 静态博客<br>3 管理配置文件<br>4 资料收集库<br>5 简历<br>6 管理代码片段<br>7 托管的编程环境<br>8 写作<br>……</p></li><li>界面主要功能<br>1 Git仓库<br>2 Organization<br>可以统一管理账户和权 限，还能统一支付一些费用。<br>3 Issue<br>Issue功能，是将一个任务或问题分配给一个 Issue进行追踪和管理的功能。每一个功能更改或修正都对应一个Issue，讨论或修正都以这个 Issue为中心进行。只要查看Issue，就能知道和这个更改相关的一切信 息，并以此进行管理。<br>4 Wiki<br>通过Wiki功能，任何人都能随时对一篇文章进行更改并保存，因 此可以多人共同完成一篇文章。该功能常用在开发文档或手册的编写 中。<br>5 Pull Request<br>开发者向GitHub的仓库推送更改或功能添加后，可以通过Pull Request 功能向别人的仓库提出申请，请求对方合并。</li></ul><p>GitHub可以托管各种git库，并提供⼀个web界⾯，但与其它像SourceForge 或 GoogleCode 这样的服务不同，GitHub 的独特卖点在于从另外⼀个项⽬ 进⾏分⽀的简易性。为⼀个项⽬贡献代码⾮常简单：⾸先点击项⽬站点的 “fork” 的按钮，然后将代码检出并将修改加⼊到刚才分出的代码库中，最后通过内建的 “pullrequest” 机制向项⽬负责⼈申请代码合并。</p><h1 id="GitHub项目创建"><a href="#GitHub项目创建" class="headerlink" title="GitHub项目创建"></a>GitHub项目创建</h1><p>可以直接在web页面new repository。<br>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git init </span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;first commit&quot; </span><br><span class="line">$ git remote add origin 地址</span><br><span class="line">$ git push -u origin master //将代码由本地仓库上传到Github远程仓库</span><br></pre></td></tr></table></figure></p><h1 id="Pull-Request-的概要"><a href="#Pull-Request-的概要" class="headerlink" title="Pull Request 的概要"></a>Pull Request 的概要</h1><ul><li>Pull Request 是自己修改源代 码后，请求对方仓库采纳该修改时采取的一种行为。</li></ul><p><img src="http://pc5wd3ju6.bkt.clouddn.com/pushrequest.PNG" alt="alt"></p><p>PR流程：<br>1 fork对方的repository<br>2 clone你之前fork的repository到你的本地电脑</p><pre><code>git clone git@url</code></pre><p>3 与对方GitHub的repository建立连接</p><pre><code>git remote add upstream url</code></pre><p>4 建立工作分支</p><pre><code>git checkout -b xiaoming-branch</code></pre><p>5 添加代码</p><p>6 提交修改<br>用 git diff命令查看修改是否已经正确进行。<br>使用 git add PRTest ，git commit ,git push等系列命令提交</p><p>7 发起Pull Request</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git是什么？&quot;&gt;&lt;a href=&quot;#Git是什么？&quot; class=&quot;headerlink&quot; title=&quot;Git是什么？&quot;&gt;&lt;/a&gt;Git是什么？&lt;/h1&gt;&lt;p&gt;　　Git 是一款免费、开源的分布式版本控制系统，最早由 LinilusTorvalds 创建，用于
      
    
    </summary>
    
      <category term="业务开发" scheme="http://huangyiblog.com/categories/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Github" scheme="http://huangyiblog.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>2018上半年的阅读整理</title>
    <link href="http://huangyiblog.com/%E9%9A%8F%E7%AC%94/2018%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%9A%84%E9%98%85%E8%AF%BB%E6%95%B4%E7%90%86/"/>
    <id>http://huangyiblog.com/随笔/2018上半年的阅读整理/</id>
    <published>2018-09-20T02:52:28.000Z</published>
    <updated>2018-09-20T11:34:49.744Z</updated>
    
    <content type="html"><![CDATA[<p>　　转眼间，２０１８大半年就过去了，今天想把自己这半年来的一些阅读整理下，也想让自己有个概念，这么长时间的浑浑噩噩，自己都干了些啥，都读了些啥。看看哪些书自个感觉还不错，哪些书虽不错但因自己能力有限无法深读，哪些书只是为了消遣时间。<br>　　１《卑鄙的圣人：曹操》<br>　　这本书姑且可算作是本历史书吧，至少让我从另一个视角了解到了曹操，其实说起来，读三国的时候，其他人暂且不提，你若是问我曹操和刘备你喜欢哪个，毫无疑问我更看好曹操。三国乱世，枭雄方能立足，假仁假义的君子有何用。你说曹操奸诈也好，卑鄙也好，但你得承认他很牛，对用兵为政有自己的一套见解，作诗也是一把好手。曹操若非奸雄，别说后来的三国鼎立，怕是都活不到那时就已命丧黄泉了。<br>　　２《包法利夫人》<br>　　《包法利夫人》是法国作家福楼拜创作的长篇小说。<br>　　小说描写包法利夫人爱玛为摆脱不幸婚姻，追求不正当爱情而导致堕落毁灭的悲剧。表面上是一个淫妇不满婚后情感而渴望爱情因此通奸偷晴，但确实一个真正可怜的角色，不光是情感上的，同时也是当时所处社会的悲剧。<br>　　３《红楼梦评论》王国维<br>　　因为对红楼梦特别着迷，所以有些人写的一些关于红楼梦我的看法我也会去了解下，这本书或许也不算不上是本书吧，有点像是一篇论文，简要的论述了红楼梦在伦理，美术，艺术、哲学等方面的价值。<br>　　４《依偎》<br>　　依偎是丁捷写的一部爱情小说，有点悲剧色彩。这本小说剧情展开也挺特别，主要根据安芬和小天互相讲故事来展开，最后一步步发现两人之间竟然还有着不为人知的联系并且深深相爱。<br>　　５《陪安东尼度过漫长岁月》<br>　　这本书的写法也挺奇葩，至少很少看到，算是挺治愈的一本书。<br>　　６《罗密欧与朱丽叶》<br>　　莎士比亚的一部很经典的悲剧。<br>　　７《奥赛罗》<br>　　同样是莎士比亚的一部悲剧<br>　　８《道德经》<br>　　．．．篇幅不长，我看的是一段古文后面一段白话文解释的，有些倒还能理解，有些看着就有点玄乎了，或许是自己水平太差。<br>　　９《伊豆的舞女》<br>　　《伊豆的舞女》是川端康成早期的代表作和成名作，也是一篇杰出的中篇小说。<br>　　展现了少男少女初恋时的朦胧与美好，挺清新的。<br>　　１０《告白》<br>　　挺好的剧情小说，人物角色多面性，而不是单的纯谁善谁恶，刻画出人性的复杂多面。<br>　　１１《少年的你，如此美丽》<br>　　玖月晞写的一本青春言情小说吧，剧情上感觉有一些地方有点雷同《白夜行》，但这部小说还是很大胆的刻画了青少年女生的校园欺凌事件，反映了弱势群体如何自保以及法律相关的问题。<br>　　１２《妻妾成群》<br>　　《妻妾成群》是作家苏童创作的一部中篇小说。这部作品通过描写一个“受过新时代教育”的女学生颂莲，自愿嫁入到高墙深院秩序井然的封建家族陈府，最终又在“妻妾成群”明争暗斗中走向精神崩溃的悲惨命运，艺术化地再现了中国封建礼教吞噬人性的恐怖景象。<br>　　１３《老婆，跟我回家吧》<br>　　酒小七写的网络言情小说，还算有点幽默吧<br>　　１４《魔道祖师》<br>　　这部小说是因为先看了动漫，好奇剧情发展而去看的。我是挺喜欢的，故事线完整，人物性格分明。最开始夷陵老祖魏无羡复活，我以为受尽冤屈与不公的他会走浩浩荡荡的复仇路线，但却并没有，内心依旧洒脱，和蓝忘机一同维护心中的正义。<br>　　１５《窦娥冤》<br>　　窦娥冤的冤情今天动地，但我一直不清楚窦娥冤在何处，但现在总算明白了。<br>　　１６《莺莺传》<br>　　读了西厢记，就顺便把元稹的莺莺传也读了<br>　　１７《斗破苍穹》<br>　　玄幻小说<br>　　１８《基都山伯爵》<br>　　复仇曲。我爱爱我的人，我很恨我的人。<br>　　１９《人间失格》太宰治<br>　　２０《我的晃荡的青春》<br>　　东野圭吾的故事<br>　　２１《富爸爸，穷爸爸》<br>　　这本书倒是略为提到了理财的方面，钱的重要性在现今社会不言而喻。<br>　　富爸爸喜欢买入资产，穷爸爸喜欢买入负债。<br>　　２２《堂吉诃德》<br>　　骑士小说<br>　　２３《罗生门》<br>　　《罗生门》以风雨不透的布局将人推向生死抉择的极限，从而展示了“恶”的无可回避，第一次传递出作者对人的理解，对人的无奈与绝望。<br>　　２４《爱情和其他魔鬼》<br>　　加西亚马尔克斯眼中魔鬼般的爱情。<br>　　２５《红顶商人胡雪岩》<br>　　商圣的传奇人生<br>　　２６《韩寒的ｏｎｅ系列》<br>　　２７《半小时漫画中国史》<br>　　有意思的漫画历史作品<br>　　２８《死刑今夜执行》<br>　　思婷写的一部推理小说<br>　　２９《革命时期的爱情》<br>　　３０《杨绛传》<br>　　３１《蒋勋说红楼梦》<br>　　３２《理想国》<br>　　３３《婉约词》<br>　　一本词集，只有词，没有注释解释啥的，你可以把自己想象成古人，嘻嘻，陶冶一番。<br>　　３４《小王子的领悟》<br>　　３５《邻人之妻》<br>　　由两性视角，诸多人物实例，反映美国社会这些年的发展。<br>　　３６古典四大名剧《西厢记》《牡丹亭》《桃花扇》《长生殿》<br>　　３７《战国策》<br>　　３８《资治通鉴》原著<br>　　３９《红手指》<br>　　东野圭吾较早的一部推理小说，但是也反映了家庭关系之间出现的一些问题<br>　　４０《聊斋志异》<br>以上主要是上半年看的一些书，其他的还有一些是关于编程的专业技能书，以及修仙玄幻言情等等网络小说，说白了，很多时候也就是为了消磨消磨时间，阅读就是挺能满足我的方式之一，嘻嘻。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　转眼间，２０１８大半年就过去了，今天想把自己这半年来的一些阅读整理下，也想让自己有个概念，这么长时间的浑浑噩噩，自己都干了些啥，都读了些啥。看看哪些书自个感觉还不错，哪些书虽不错但因自己能力有限无法深读，哪些书只是为了消遣时间。&lt;br&gt;　　１《卑鄙的圣人：曹操》&lt;br&gt;
      
    
    </summary>
    
      <category term="随笔" scheme="http://huangyiblog.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="阅读" scheme="http://huangyiblog.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>154. 寻找旋转排序数组中的最小值 II</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-II/"/>
    <id>http://huangyiblog.com/题解集/154-寻找旋转排序数组中的最小值-II/</id>
    <published>2018-09-08T07:35:45.000Z</published>
    <updated>2018-09-08T07:43:49.645Z</updated>
    
    <content type="html"><![CDATA[<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,2,0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></p><p>分析：查找旋转了的排序数组，数组里允许存在重复元素，我们知道在一个数组里求最小元素，遍历整个数组肯定能求出，但一般时间复杂度都不是最优的，所以采用二分查找，当然对于这道题，如果数组里重复元素过多，二分的优势也并不明显。<br>分以下三种情况遍历：</p><ul><li>nums[mid] &gt; nums[left],查找右半区间</li><li>nums[mid] &lt; nums[left],查找左半区间</li><li>nums[mid] = nums[left] ，left++，跳过继续查找</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(size == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(size == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> min(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt; nums[right]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[left]) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[left]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(nums[left], nums[right]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。&lt;/p&gt;
&lt;p&gt;请找出其中最小的元素。&lt;/p&gt;
&lt;p&gt;注意数组中可能存在重复的元素。&lt;/p&gt;
&lt;p&gt;示例 1：
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>18. 四数之和</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://huangyiblog.com/题解集/18-四数之和/</id>
    <published>2018-09-08T06:19:04.000Z</published>
    <updated>2018-09-08T06:22:33.108Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>注意：</p><p>答案中不可以包含重复的四元组。</p><p>示例：</p><p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p><p>满足要求的四元组集合为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>分析：这道题和三数之和思路类似，无非是多了一个数，首先对给定数组进行排序，是最后答案数组有序，用两个do while循环去重。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size() - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> l = nums.size() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(k &lt; l) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k] + nums[l];</span><br><span class="line">                    <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">                        curr.push_back(nums[i]);</span><br><span class="line">                        curr.push_back(nums[j]);</span><br><span class="line">                        curr.push_back(nums[k]);</span><br><span class="line">                        curr.push_back(nums[l]);</span><br><span class="line">                        res.push_back(curr);</span><br><span class="line">                        <span class="keyword">do</span>&#123;++k;&#125;</span><br><span class="line">                        <span class="keyword">while</span>(k &lt; l &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]);</span><br><span class="line">                        <span class="keyword">do</span>&#123;--l;&#125;</span><br><span class="line">                        <span class="keyword">while</span>(k &lt; l &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                        ++k;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        --l;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;答案中不可以
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>16. 最接近的三数之和</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://huangyiblog.com/题解集/16-最接近的三数之和/</id>
    <published>2018-09-06T07:53:18.000Z</published>
    <updated>2018-09-06T07:55:46.441Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p><p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p><p>分析：还是双指针思想，类似之前的三数之和解法，设定3个指针，固定两个，根据和的大小移动另一个。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> distance = INT_MAX;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> k = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; k) &#123;</span><br><span class="line">                <span class="keyword">int</span> tempVal = nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">int</span> tempDis;</span><br><span class="line">                <span class="keyword">if</span>(tempVal &lt; target) &#123;</span><br><span class="line">                    tempDis = target - tempVal;</span><br><span class="line">                    <span class="keyword">if</span>(tempDis &lt; distance) &#123;</span><br><span class="line">                        distance = tempDis;</span><br><span class="line">                        res = nums[i] + nums[j] + nums[k];</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tempVal &gt; target) &#123;</span><br><span class="line">                    tempDis = tempVal - target;</span><br><span class="line">                    <span class="keyword">if</span>(tempDis &lt; distance) &#123;</span><br><span class="line">                        distance = tempDis;</span><br><span class="line">                        res = nums[i] + nums[j] + nums[k];</span><br><span class="line">                    &#125;</span><br><span class="line">                    --k;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res = nums[i] + nums[j] + nums[k];</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。&lt;/p&gt;
&lt;p&gt;例如，给定数组 nums = [-1，2，1，-4], 和 target
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>15. 三数之和</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://huangyiblog.com/题解集/15-三数之和/</id>
    <published>2018-09-06T05:45:08.000Z</published>
    <updated>2018-09-06T05:49:35.344Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>分析：双指针思想，定位其中两个指针，根据和的大小来移动第三个指针。由于要求每个答案数组中的元素是升序排列的，所以在开始要对原数组进行排序，另外题目要求不能包含重复的答案数组，所以要有相应的去重操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> k = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; k) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                    curr.push_back(nums[i]);</span><br><span class="line">                    curr.push_back(nums[j]);</span><br><span class="line">                    curr.push_back(nums[k]);</span><br><span class="line">                    res.push_back(curr);</span><br><span class="line">                    ++j;</span><br><span class="line">                    --k;</span><br><span class="line">                    <span class="keyword">while</span>(j &lt; k &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;</span><br><span class="line">                        ++j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(j &lt; k &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                        --k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    --k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; nums.size() - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。&lt;/p&gt;
&lt;p&gt;注意：答案中不可以包含重复的三元组。&lt;/p&gt;
&lt;p&gt;例如, 给定数组 nums = [-1, 0
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>1057 Stack（30 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1057-Stack%EF%BC%8830-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1057-Stack（30-分）/</id>
    <published>2018-09-04T06:29:57.000Z</published>
    <updated>2018-09-04T06:33:17.476Z</updated>
    
    <content type="html"><![CDATA[<p>1057 Stack（30 分）<br>Stack is one of the most fundamental data structures, which is based on the principle of Last In First Out (LIFO). The basic operations include Push (inserting an element onto the top position) and Pop (deleting the top element). Now you are supposed to implement a stack with an extra operation: PeekMedian – return the median value of all the elements in the stack. With N elements, the median value is defined to be the (N/2)-th smallest element if N is even, or ((N+1)/2)-th if N is odd.</p><p>Input Specification:<br>Each input file contains one test case. For each case, the first line contains a positive integer N (≤10<br>​5<br>​​ ). Then N lines follow, each contains a command in one of the following 3 formats:</p><p>Push key<br>Pop<br>PeekMedian<br>where key is a positive integer no more than 10<br>​5<br>​​ .</p><p>Output Specification:<br>For each Push command, insert key into the stack and output nothing. For each Pop or PeekMedian command, print in a line the corresponding returned value. If the command is invalid, print Invalid instead.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">17</span><br><span class="line">Pop</span><br><span class="line">PeekMedian</span><br><span class="line">Push 3</span><br><span class="line">PeekMedian</span><br><span class="line">Push 2</span><br><span class="line">PeekMedian</span><br><span class="line">Push 1</span><br><span class="line">PeekMedian</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 5</span><br><span class="line">Push 4</span><br><span class="line">PeekMedian</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Invalid</span><br><span class="line">Invalid</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">Invalid</span><br></pre></td></tr></table></figure></p><p>分析：这道题除了要求实现栈的弹入和弹出操作，还要求查询栈内元素第k大（k是中位数），为了缩减时间复杂度，可以考虑分快思想，或者直接用树状数组<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sqrn = <span class="number">316</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">int</span> block[sqrn];</span><br><span class="line"><span class="keyword">int</span> table[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">peekMedian</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sum + block[idx] &lt; k) &#123;</span><br><span class="line">        sum += block[idx++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = idx * sqrn;</span><br><span class="line">    <span class="keyword">while</span>(sum + table[num] &lt; k) &#123;</span><br><span class="line">        sum += table[num++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    st.push(x);</span><br><span class="line">    block[x / sqrn]++;</span><br><span class="line">    table[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = st.top();</span><br><span class="line">    st.pop();</span><br><span class="line">    block[x / sqrn]--;</span><br><span class="line">    table[x]--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, query;</span><br><span class="line">    <span class="built_in">memset</span>(block, <span class="number">0</span>, <span class="keyword">sizeof</span>(block));</span><br><span class="line">    <span class="built_in">memset</span>(table, <span class="number">0</span>, <span class="keyword">sizeof</span>(table));</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;query);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; query; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd, <span class="string">"Push"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            Push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd, <span class="string">"Pop"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.empty() == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Invalid\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.empty() == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Invalid\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> k = st.size();</span><br><span class="line">                <span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    k = (k + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    k = k / <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                peekMedian(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1057 Stack（30 分）&lt;br&gt;Stack is one of the most fundamental data structures, which is based on the principle of Last In First Out (LIFO). Th
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>1068 Find More Coins（30 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1068-Find-More-Coins%EF%BC%8830-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1068-Find-More-Coins（30-分）/</id>
    <published>2018-09-04T06:04:13.000Z</published>
    <updated>2018-09-04T06:14:42.229Z</updated>
    
    <content type="html"><![CDATA[<p>1068 Find More Coins（30 分）<br>Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she must pay the exact amount. Since she has as many as 10<br>​4<br>​​  coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find some coins to pay for it.</p><p>Input Specification:<br>Each input file contains one test case. For each case, the first line contains 2 positive numbers: N (≤10<br>​4<br>​​ , the total number of coins) and M (≤10<br>​2<br>​​ , the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers. All the numbers in a line are separated by a space.</p><p>Output Specification:<br>For each test case, print in one line the face values V<br>​1<br>​​ ≤V<br>​2<br>​​ ≤⋯≤V<br>​k<br>​​  such that V<br>​1<br>​​ +V<br>​2<br>​​ +⋯+V<br>​k<br>​​ =M. All the numbers must be separated by a space, and there must be no extra space at the end of the line. If such a solution is not unique, output the smallest sequence. If there is no solution, output “No Solution” instead.</p><p>Note: sequence {A[1], A[2], …} is said to be “smaller” than sequence {B[1], B[2], …} if there exists k≥1 such that A[i]=B[i] for all i&lt;k, and A[k] &lt; B[k].</p><p>Sample Input 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 9</span><br><span class="line">5 9 8 7 2 3 4 1</span><br></pre></td></tr></table></figure></p><p>Sample Output 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 5</span><br></pre></td></tr></table></figure></p><p>Sample Input 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 8</span><br><span class="line">7 2 4 3</span><br></pre></td></tr></table></figure></p><p>Sample Output 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No Solution</span><br></pre></td></tr></table></figure></p><p>题目大意：背包问题，有n枚硬币，给出每枚硬币的价值，现在要用这些硬币去支付价值为m的东西，问是否存在这样的方案使选择用来支付的硬币价值之和恰好为m，如果存在从小到大输出硬币的价值，如果有多种方案，则输出“字典序“”最小的</p><p>01背包问题：<br>状态转移方程：dp[i][v] = max{dp[i - 1][v], dp[i - 1][v - w[i] + c[i]}<br>开一个bool型二维数组choice[i][v]用来记录是选择了哪个策略，即是放第i件物品还是不放第i件物品。<br>无解条件为dp[m] != m<br>求解dp数组时，如果两种策略的大小相等，选择放第i件物品的策略。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> w[maxn], dp[maxv] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> choice[maxn][maxv], flag[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(w + <span class="number">1</span>, w + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = m; v &gt;= w[i]; v--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[v] &lt;= dp[v - w[i]] + w[i]) &#123;</span><br><span class="line">                dp[v] = dp[v - w[i]] + w[i];</span><br><span class="line">                choice[i][v] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                choice[i][v] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[m] != m) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No Solution"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> k = n, num = <span class="number">0</span>, v = m;</span><br><span class="line">        <span class="keyword">while</span>(k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(choice[k][v] == <span class="number">1</span>) &#123;</span><br><span class="line">                flag[k] = <span class="literal">true</span>;</span><br><span class="line">                v -= w[k];</span><br><span class="line">                num++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag[k] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i] == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, w[i]);</span><br><span class="line">                num--;</span><br><span class="line">                <span class="keyword">if</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1068 Find More Coins（30 分）&lt;br&gt;Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she 
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>1021 Deepest Root（25 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1021-Deepest-Root%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1021-Deepest-Root（25-分）/</id>
    <published>2018-08-31T02:28:18.000Z</published>
    <updated>2018-08-31T02:39:24.361Z</updated>
    
    <content type="html"><![CDATA[<p>1021 Deepest Root（25 分）<br>A graph which is connected and acyclic can be considered a tree. The hight of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called the deepest root.</p><p>Input Specification:<br>Each input file contains one test case. For each case, the first line contains a positive integer N (≤10<br>​4<br>​​ ) which is the number of nodes, and hence the nodes are numbered from 1 to N. Then N−1 lines follow, each describes an edge by given the two adjacent nodes’ numbers.</p><p>Output Specification:<br>For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print Error: K components where K is the number of connected components in the graph.</p><p>Sample Input 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure></p><p>Sample Output 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p><p>Sample Input 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure></p><p>Sample Output 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: 2 components</span><br></pre></td></tr></table></figure></p><p>题目大意：给出n个结点和n-1条边，问它们能否形成一棵n个结点的树，如果能，从中选出结点作为树根，使整棵树的高度最大。输出所有满足要求的可以作为树根的结点。<br>思路：<br>1 由于连通、边数为n-1的图一定是一棵树，因此需要判断给定数据是否能使图连通。使用并查集判断方法：<br>每读入一条边的两个端点，判断这两个端点是否属于相同的集合，如果不同，则将它们合并到一个集合中，当处理完所有边后根据最终产生的集合个数是否为1来判断给定的图是否连通。<br>2 确定图连通后，则确定了树，选择合适根结点使树高最大的做法为：<br>先任意选择一个结点，从该节点开始遍历整棵树，获取能达到的最深的结点，记为集合A；然后从集合A中任意一个结点出发遍历整棵树，获取能达到的最深顶点，记为结点集合B。集合A与B的并集就是所求结果。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">bool</span> isRoot[maxn];</span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = x;</span><br><span class="line">    <span class="keyword">while</span>(x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a != father[a]) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = a;</span><br><span class="line">        a = father[a];</span><br><span class="line">        father[z] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span>(faA != faB) &#123;</span><br><span class="line">        father[faA] = faB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">blockCnt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        isRoot[findFather(i)] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cnt += isRoot[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxH = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp, ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> height, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height &gt; maxH) &#123;</span><br><span class="line">        temp.clear();</span><br><span class="line">        temp.push_back(u);</span><br><span class="line">        maxH = height;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(height == maxH) &#123;</span><br><span class="line">        temp.push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(G[u][i] == pre) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(G[u][i], height + <span class="number">1</span>, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">        Union(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> block = blockCnt(n);</span><br><span class="line">    <span class="keyword">if</span>(block != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: %d components\n"</span>, block);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        ans = temp;</span><br><span class="line">        dfs(ans[<span class="number">0</span>], <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.size(); i++) &#123;</span><br><span class="line">            ans.push_back(temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ans.begin(), ans.end());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i] != ans[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1021 Deepest Root（25 分）&lt;br&gt;A graph which is connected and acyclic can be considered a tree. The hight of the tree depends on the selected
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>1007 Maximum Subsequence Sum (25)（25 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1007-Maximum-Subsequence-Sum-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1007-Maximum-Subsequence-Sum-25-（25-分）/</id>
    <published>2018-08-23T08:59:26.000Z</published>
    <updated>2018-08-23T09:06:46.623Z</updated>
    
    <content type="html"><![CDATA[<p>1007 Maximum Subsequence Sum (25)（25 分）<br>Given a sequence of K integers { N~1~, N~2~, …, N~K~ }. A continuous subsequence is defined to be { N~i~, N~i+1~, …, N~j~ } where 1 &lt;= i &lt;= j &lt;= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p><p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p><p>Input Specification:</p><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (&lt;= 10000). The second line contains K numbers, separated by a space.</p><p>Output Specification:</p><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">-10 1 2 3 4 -5 -23 3 7 -21</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 4</span><br></pre></td></tr></table></figure></p><p>求解最大连续子序列和，并且要求输出首尾元素，<br>边界dp[0] = a[0]<br>转移方程：if(dp[i - 1] + a[i]) &gt; a[i] : dp[i] = dp[i - 1] + a[i]<br>                 else  dp[i] = a[i]<br>用s[i]表示以a[i]作为结尾的最大连续子序列是从哪个元素开始的<br>两种情况<br>1 只有一个元素，这个最大连续子序列就是从a[i]开始，s[i] = a[i]<br>2 s[i] = s[i - 1]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], dp[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 %d %d\n"</span>, a[<span class="number">0</span>], a[n - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i - <span class="number">1</span>] + a[i] &gt; a[i]) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + a[i];</span><br><span class="line">            s[i] = s[i - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = a[i];</span><br><span class="line">            s[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt; dp[k]) &#123;</span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, dp[k], a[s[k]], a[k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1007 Maximum Subsequence Sum (25)（25 分）&lt;br&gt;Given a sequence of K integers { N~1~, N~2~, …, N~K~ }. A continuous subsequence is defined to
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>1013 Battle Over Cities (25)（25 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1013-Battle-Over-Cities-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1013-Battle-Over-Cities-25-（25-分）/</id>
    <published>2018-08-23T08:20:50.000Z</published>
    <updated>2018-08-23T08:42:38.997Z</updated>
    
    <content type="html"><![CDATA[<p>1013 Battle Over Cities (25)（25 分）<br>It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from/toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly.</p><p>For example, if we have 3 cities and 2 highways connecting city~1~-city~2~ and city~1~-city~3~. Then if city~1~ is occupied by the enemy, we must have 1 highway repaired, that is the highway city~2~-city~3~.</p><p>Input</p><p>Each input file contains one test case. Each case starts with a line containing 3 numbers N (&amp;lt1000), M and K, which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then M lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to N. Finally there is a line containing K numbers, which represent the cities we concern.</p><p>Output</p><p>For each of the K cities, output in a line the number of highways need to be repaired if that city is lost.</p><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 2 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure></p><p>Sample Output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>题目大意：<br>给定一个无向图并规定：当删除图中某个顶点时，将会同时把与之连接的边一起删除，接下来给出k个查询，每个查询给出一个欲删除的顶点编号，求删除该顶点后需要增加多少边，才能使图连通。</p><p>分析：给定一个无向图，如何计算需要增加的边，使得整个图连通。<br>显然需要增加的边数等于连通块个数减1<br>求解一个无向图的连通块个数一般有两种方法：</p><ol><li>图的遍历：在遍历图的过程中总是每次访问单个连通块，并将该连通块内的所有顶点都标记为已访问，然后去访问下个连通块，在访问过程中同时计数遍历的连通快数</li><li>并查集：判断无向图每条边的两个顶点是否在一个集合内，如果在同一个集合内，则不作处理；否则将这两个顶点加入同一个集合。最后统计集合个数<br>关于删除顶点，当访问回到该顶点时返回即可。<br>1 遍历图计算连通块<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1111</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> currentPoint;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v == currentPoint) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[G[v][i]] == <span class="literal">false</span>) &#123;</span><br><span class="line">            dfs(G[v][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> query = <span class="number">0</span>; query &lt; k; query++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;currentPoint);</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">int</span> block = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != currentPoint &amp;&amp; vis[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">                block++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, block - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>2 并查集求连通块</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1111</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = x;</span><br><span class="line">    <span class="keyword">while</span>(x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a != father[a]) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = a;</span><br><span class="line">        a = father[a];</span><br><span class="line">        father[z] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span>(faA != faB) &#123;</span><br><span class="line">        father[faA] = father[faB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> currentPoint;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> query = <span class="number">0</span>; query &lt; k; query++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;currentPoint);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = i, v = G[i][j];</span><br><span class="line">                <span class="keyword">if</span>(u == currentPoint || v == currentPoint) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Union(u, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> block = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == currentPoint) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> fai = findFather(i);</span><br><span class="line">            <span class="keyword">if</span>(vis[fai] == <span class="literal">false</span>) &#123;</span><br><span class="line">                block++;</span><br><span class="line">                vis[fai] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, block - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1013 Battle Over Cities (25)（25 分）&lt;br&gt;It is vitally important to have all the cities connected by highways in a war. If a city is occupie
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>1098 Insertion or Heap Sort（25 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1098-Insertion-or-Heap-Sort%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1098-Insertion-or-Heap-Sort（25-分）/</id>
    <published>2018-08-21T09:19:54.000Z</published>
    <updated>2018-08-21T09:23:39.857Z</updated>
    
    <content type="html"><![CDATA[<p>1098 Insertion or Heap Sort（25 分）<br>According to Wikipedia:</p><p>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.</p><p>Heap sort divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum.</p><p>Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?</p><p>Input Specification:<br>Each input file contains one test case. For each case, the first line gives a positive integer N (≤100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.</p><p>Output Specification:<br>For each test case, print in the first line either “Insertion Sort” or “Heap Sort” to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p><p>Sample Input 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">3 1 2 8 7 5 9 4 6 0</span><br><span class="line">1 2 3 7 8 5 9 4 6 0</span><br></pre></td></tr></table></figure></p><p>Sample Output 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Insertion Sort</span><br><span class="line">1 2 3 5 7 8 9 4 6 0</span><br></pre></td></tr></table></figure></p><p>Sample Input 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">3 1 2 8 7 5 9 4 6 0</span><br><span class="line">6 4 5 1 0 3 2 7 8 9</span><br></pre></td></tr></table></figure></p><p>Sample Output 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Heap Sort</span><br><span class="line">5 4 3 1 0 2 6 7 8 9</span><br></pre></td></tr></table></figure></p><p>题目大意：给出一个初始序列，对它使用插入排序或堆排序法进行排序，先给出一个序列，问它是由插入排序产生还是堆排序产生，并输出下一步将会产生的序列。<br>直接模拟插入排序和堆排序的每一步过程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">int</span> origin[maxn], temp[maxn], changed[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">showArray</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, a[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">2</span> &amp;&amp; isSame(temp, changed)) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(temp, temp + i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = i * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= high &amp;&amp; temp[j + <span class="number">1</span>] &gt; temp[j]) &#123;</span><br><span class="line">            j = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp[j] &gt; temp[i]) &#123;</span><br><span class="line">            swap(temp[j], temp[i]);</span><br><span class="line">            i = j;</span><br><span class="line">            j = i * <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        downAdjust(i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != n &amp;&amp; isSame(temp, changed)) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(temp[i], temp[<span class="number">1</span>]);</span><br><span class="line">        downAdjust(<span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>) &#123;</span><br><span class="line">            showArray(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;origin[i]);</span><br><span class="line">        temp[i] = origin[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;changed[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(insertSort()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Insertion Sort\n"</span>);</span><br><span class="line">        showArray(temp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Heap Sort\n"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            temp[i] = origin[i];</span><br><span class="line">        &#125;</span><br><span class="line">        headSort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1098 Insertion or Heap Sort（25 分）&lt;br&gt;According to Wikipedia:&lt;/p&gt;
&lt;p&gt;Insertion sort iterates, consuming one input element each repetition,
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>707. 设计链表</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
    <id>http://huangyiblog.com/题解集/707-设计链表/</id>
    <published>2018-08-21T09:02:09.000Z</published>
    <updated>2018-08-21T09:03:20.431Z</updated>
    
    <content type="html"><![CDATA[<p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。<br>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyLinkedList linkedList = new MyLinkedList();</span><br><span class="line">linkedList.addAtHead(1);</span><br><span class="line">linkedList.addAtTail(3);</span><br><span class="line">linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3</span><br><span class="line">linkedList.get(1);            //返回2</span><br><span class="line">linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3</span><br><span class="line">linkedList.get(1);            //返回3</span><br></pre></td></tr></table></figure></p><p>提示：</p><p>所有值都在 [1, 1000] 之内。<br>操作次数将在  [1, 1000] 之内。<br>请不要使用内置的 LinkedList 库。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        LinkedList = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* LinkedList;</span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        ListNode* head = LinkedList;</span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; i &lt; index) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head &amp;&amp; i == index) &#123;</span><br><span class="line">            <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* head = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">        head-&gt;next = LinkedList;</span><br><span class="line">        head-&gt;val = val;</span><br><span class="line">        LinkedList = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* head = LinkedList;</span><br><span class="line">        ListNode* temp = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">        temp-&gt;next = <span class="number">0</span>;</span><br><span class="line">        temp-&gt;val = val;</span><br><span class="line">        <span class="keyword">if</span>(!head) &#123;</span><br><span class="line">            LinkedList = temp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        ListNode* head = LinkedList;</span><br><span class="line">        <span class="keyword">if</span>(!head &amp;&amp; index == <span class="number">0</span>) &#123;</span><br><span class="line">            ListNode* temp = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">            temp-&gt;val = val;</span><br><span class="line">            temp-&gt;next = <span class="number">0</span>;</span><br><span class="line">            LinkedList = temp;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; i &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head &amp;&amp; head-&gt;next == <span class="number">0</span>) &#123;</span><br><span class="line">            ListNode* temp = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">            temp-&gt;val = val;</span><br><span class="line">            temp-&gt;next = <span class="number">0</span>;</span><br><span class="line">            head-&gt;next = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == index - <span class="number">1</span> &amp;&amp; head &amp;&amp; head-&gt;next) &#123;</span><br><span class="line">            ListNode* temp = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">            temp-&gt;val = val;</span><br><span class="line">            temp-&gt;next = head-&gt;next;</span><br><span class="line">            head-&gt;next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        ListNode* head = LinkedList;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; i &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next == <span class="number">0</span> &amp;&amp; index == <span class="number">0</span>) &#123;</span><br><span class="line">            LinkedList = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next) &#123;</span><br><span class="line">            ListNode* temp = head-&gt;next;</span><br><span class="line">            head-&gt;next = temp-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-ind
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>687. 最长同值路径</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/687-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/"/>
    <id>http://huangyiblog.com/题解集/687-最长同值路径/</id>
    <published>2018-08-21T08:09:56.000Z</published>
    <updated>2018-08-21T08:15:42.388Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p><p>注意：两个节点之间的路径长度由它们之间的边数表示。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">              5</span><br><span class="line">             / \</span><br><span class="line">            4   5</span><br><span class="line">           / \   \</span><br><span class="line">          1   1   5</span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">              1</span><br><span class="line">             / \</span><br><span class="line">            4   5</span><br><span class="line">           / \   \</span><br><span class="line">          4   4   5</span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p>注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。</p><p>分析：考察二叉树的递归<br>首先判断二叉树root是否为空，如果是直接返回0，之后对左右子结点分别调用当前函数，取其中较大值保存到临时变量，表示左右子树中最长的同值路径，然后跟当前树的最长同值路径进行比较，对左右子结点调用dfs函数，并传入当前结点值，将返回值与临时变量比较取较大值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sub = max(longestUnivaluePath(root-&gt;left), longestUnivaluePath(root-&gt;right));</span><br><span class="line">        <span class="keyword">return</span> max(sub, dfs(root-&gt;left, root-&gt;val) + dfs(root-&gt;right, root-&gt;val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node || node-&gt;val != parent) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(dfs(node-&gt;left, node-&gt;val), dfs(node-&gt;right, node-&gt;val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。&lt;/p&gt;
&lt;p&gt;注意：两个节点之间的路径长度由它们之间的边数表示。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>686. 重复叠加字符串匹配</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/686-%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>http://huangyiblog.com/题解集/686-重复叠加字符串匹配/</id>
    <published>2018-08-21T07:57:59.000Z</published>
    <updated>2018-08-21T08:00:58.209Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个字符串 A 和 B, 寻找重复叠加字符串A的最小次数，使得字符串B成为叠加后的字符串A的子串，如果不存在则返回 -1。</p><p>举个例子，A = “abcd”，B = “cdabcdab”。</p><p>答案为 3， 因为 A 重复叠加三遍后为 “abcdabcdabcd”，此时 B 是其子串；A 重复叠加两遍后为”abcdabcd”，B 并不是其子串。</p><p>注意:</p><p> A 与 B 字符串的长度在1和10000区间范围内。</p><p>在字符串b的长度范围内循环累加a并且判断是否存在子串，但要注意边界，所以循环结束后如果不存在，需要在累加一次并进行判断。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenb = B.length();</span><br><span class="line">        String res = A;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(res.length() &lt; lenb) &#123;</span><br><span class="line">            res += A;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.contains(B)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        res += A;</span><br><span class="line">        <span class="keyword">if</span>(res.contains(B)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cnt + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定两个字符串 A 和 B, 寻找重复叠加字符串A的最小次数，使得字符串B成为叠加后的字符串A的子串，如果不存在则返回 -1。&lt;/p&gt;
&lt;p&gt;举个例子，A = “abcd”，B = “cdabcdab”。&lt;/p&gt;
&lt;p&gt;答案为 3， 因为 A 重复叠加三遍后为 “abcda
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>690. 员工的重要性</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/690-%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"/>
    <id>http://huangyiblog.com/题解集/690-员工的重要性/</id>
    <published>2018-08-21T07:44:48.000Z</published>
    <updated>2018-08-21T07:47:34.582Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。</p><p>比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。</p><p>现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1</span><br><span class="line">输出: 11</span><br></pre></td></tr></table></figure></p><p>解释:<br>员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 = 11。<br>注意:</p><p>一个员工最多有一个直系领导，但是可以有多个直系下属<br>员工数量不超过2000。</p><p>思路：这题本质还是二叉树的遍历，所以用dfs或bfs都能做。<br>首先把 employees 存入 HashMap， id 为 key， Employee 为value。</p><p>　　然后建立一个 dfs function：</p><p>　　　　当员工的 subordinates 的 size  等于 0 的时候， 说明没有必要继续递归了，返回员工的重要值；</p><p>　　　　如果 size 大于0，那么遍历 subordinates，把每一个 员工id 递归，累加重要值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Employee info</span></span><br><span class="line"><span class="comment">class Employee &#123;</span></span><br><span class="line"><span class="comment">    // It's the unique id of each node;</span></span><br><span class="line"><span class="comment">    // unique id of this employee</span></span><br><span class="line"><span class="comment">    public int id;</span></span><br><span class="line"><span class="comment">    // the importance value of this employee</span></span><br><span class="line"><span class="comment">    public int importance;</span></span><br><span class="line"><span class="comment">    // the id of direct subordinates</span></span><br><span class="line"><span class="comment">    public List&lt;Integer&gt; subordinates;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(List&lt;Employee&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Employee&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Employee e : employees) &#123;</span><br><span class="line">            map.put(e.id, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(id, map);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id, HashMap&lt;Integer, Employee&gt; map)</span> </span>&#123;</span><br><span class="line">        Employee e = map.get(id);</span><br><span class="line">        <span class="keyword">if</span>(e.subordinates.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.importance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = e.importance;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sub : e.subordinates) &#123;</span><br><span class="line">            res += dfs(sub, map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。&lt;/p&gt;
&lt;p&gt;比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>665. 非递减数列</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/665-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/"/>
    <id>http://huangyiblog.com/题解集/665-非递减数列/</id>
    <published>2018-08-21T07:12:44.000Z</published>
    <updated>2018-08-21T07:17:16.558Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。</p><p>我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，满足 array[i] &lt;= array[i + 1]。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,2,3]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure></p><p>解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。<br>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,2,1]</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure></p><p>解释: 你不能在只改变一个元素的情况下将其变为非递减数列。<br>说明:  n 的范围为 [1, 10,000]。<br>分析：要求最多改变一个元素问能否使给定序列成为非递减序列。遍历给定数组，计数递增节点个数。<br>假设有一个数列a1a2a3a4a5,在a3之前一切正常，但是a4 &lt; a3，这时候有两种解决方案：一种是抬高a4，一种是降低a3，判断的依据就看a4和a2的关系，若a4 &lt; a2,则最好的解决方案就是抬高a4,抬高到a3的值刚好，反之亦然。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size(), needChange = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i + <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">                needChange++;</span><br><span class="line">                <span class="keyword">if</span>(needChange &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i + <span class="number">1</span>] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    nums[i + <span class="number">1</span>] = nums[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nums[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。&lt;/p&gt;
&lt;p&gt;我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &amp;lt;= i &amp;lt; n)，满足 array[i] &amp;lt;= array[i + 
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>1107 Social Clusters（30 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1107-Social-Clusters%EF%BC%8830-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1107-Social-Clusters（30-分）/</id>
    <published>2018-08-20T09:52:35.000Z</published>
    <updated>2018-08-20T09:59:09.190Z</updated>
    
    <content type="html"><![CDATA[<p>1107 Social Clusters（30 分）<br>When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. A social cluster is a set of people who have some of their hobbies in common. You are supposed to find all the clusters.</p><p>Input Specification:<br>Each input file contains one test case. For each test case, the first line contains a positive integer N (≤1000), the total number of people in a social network. Hence the people are numbered from 1 to N. Then N lines follow, each gives the hobby list of a person in the format:</p><p>K<br>​i<br>​​ : h<br>​i<br>​​ [1] h<br>​i<br>​​ [2] … h<br>​i<br>​​ [K<br>​i<br>​​ ]</p><p>where K<br>​i<br>​​  (&gt;0) is the number of hobbies, and h<br>​i<br>​​ [j] is the index of the j-th hobby, which is an integer in [1, 1000].</p><p>Output Specification:<br>For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p><p>Sample Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">3: 2 7 10</span><br><span class="line">1: 4</span><br><span class="line">2: 5 3</span><br><span class="line">1: 4</span><br><span class="line">1: 3</span><br><span class="line">1: 4</span><br><span class="line">4: 6 8 1 5</span><br><span class="line">1: 4</span><br></pre></td></tr></table></figure></p><p>Sample Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4 3 1</span><br></pre></td></tr></table></figure></p><p>题目大意：如果有两个人有任意一个活动相同，那么救称他们处于同一个社交网络，给定n个人，求n个人形成了多少社交网络。<br>用course[h]记录喜欢活动h的人的编号，那么findFather(course[h])就是这个人所在的社交网络的根结点，合并当前读入的编号i与findFather(course[h])<br>集合计数可以开一个isRoot数组表示x号人作为根结点的社交网络中有多少人<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="keyword">int</span> isRoot[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> course[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = x;</span><br><span class="line">    <span class="keyword">while</span>(x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a != father[a]) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = a;</span><br><span class="line">        a = father[a];</span><br><span class="line">        father[z] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span>(faA != faB) &#123;</span><br><span class="line">        father[faA] = faB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">        isRoot[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, h;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h);</span><br><span class="line">            <span class="keyword">if</span>(course[h] == <span class="number">0</span>) &#123;</span><br><span class="line">                course[h] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            Union(i, findFather(course[h]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        isRoot[findFather(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isRoot[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    sort(isRoot + <span class="number">1</span>, isRoot + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ans; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, isRoot[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; ans) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1107 Social Clusters（30 分）&lt;br&gt;When register on a social network, you are always asked to specify your hobbies in order to find some poten
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
</feed>
