<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你的小黄^_^</title>
  <icon>https://www.gravatar.com/avatar/3a25a3ab34305615e80247defadfd4f6</icon>
  <subtitle>做一名有情怀的程序员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huangyiblog.com/"/>
  <updated>2018-05-16T12:24:06.846Z</updated>
  <id>http://huangyiblog.com/</id>
  
  <author>
    <name>Mr.Huangyi</name>
    <email>18757163093@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>技术书单系列1</title>
    <link href="http://huangyiblog.com/%E9%9A%8F%E7%AC%94/%E6%8A%80%E6%9C%AF%E4%B9%A6%E5%8D%95%E7%B3%BB%E5%88%971/"/>
    <id>http://huangyiblog.com/随笔/技术书单系列1/</id>
    <published>2018-05-16T12:22:08.000Z</published>
    <updated>2018-05-16T12:24:06.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我眼中的阅读"><a href="#我眼中的阅读" class="headerlink" title="我眼中的阅读"></a>我眼中的阅读</h1><p>有这么一句话：看一个人，只需看他读什么书，与什么交往。</p><p>但不知为什么，估计是我的社交圈太小的原因吧，大学里面认识的同学，目前没有几个是真正热爱阅读的，不论是带有功利性质的技能书还是休闲性质的杂书。注意，我没有过分强调读书的功利作用，我从不认为不读书的人就怎么怎么没素养，不读书就不能有大的作为。很多时候这也不过是一种爱好，一种消磨时间的途径而已。所以爱读书的也不必故作清高，但不爱读书的，也请将你的读书无用论收一收，不读书的一个巨大遗憾就是让你们产生了这样的眼界。</p><p>对我来说，书的魅力是巨大的，起初和很多人一样，一看到书就头疼，会有种读不下去的感觉，尤其是面对一些字典般大小的恐龙书。因此很多时候，读书也得讲策略，不是任何一本书都得一字一句的啃下去，有选择有针对性的扩展广度，当发现一本内容精致的好书在一遍遍精读也不迟。这里又提到了选书的问题，其实人这一生，你再怎么努力，能读的书终究是有限的，因此选择成了至关重要的一环，门外汉建议还是根据口碑选择较为靠谱，数年积累的业内口碑一般都不是没有理由的，经典之所以能成为经典，必然是经过一代代人的筛选与淘汰留下的宝藏。</p><p>说起自己，倒也误区多多，一方面，关于买书，我明显对技术书籍有了歧视，至今我买的纸质书里面，大多以古今中外文学名著小说诗歌居多，然而技术书却是能用指头就点的过来的寥寥几本。其中，我可能嫌一些技术书价格过高，网上的pdf版本一搜一大把，何苦花这冤枉钱。但后面意识到，很多技术书却是值这个价，内容对一些原理和思维剖析深刻到位，总之纸质书的阅读感很多时候还是电子书无法取代的。我目前两种媒介都不拒绝，大多时候不方便的话，kindle带在身边就是了，方便的话，翻开纸质书就是撸。另外，在读书笔记方面我做的也是有很大欠缺的，一本书读完，或者一部电影看完，只要不是内容空洞话作品，多多少少也该有点自己的理解与总结吧。转眼已到大二下半年，紧迫感似乎越来越强，面对学业上的考核，大三的实习校招，貌似留给我的阅读时间越来越少，且行且珍惜把。</p><p>中学，在高考中考的指挥棒下，自主时间实在有限，以后工作想必时间上的安排也必然紧张。粗想一下，大学貌似是我人生中为数不多的可以有大把时间读书，大把时间旅游，大把时间培养自主习惯的时候了，生活已经不易，希望有更多的人愿意与我一同追逐心中的书和远方。</p><h1 id="刘大佬认为的面试微软10本必读书"><a href="#刘大佬认为的面试微软10本必读书" class="headerlink" title="刘大佬认为的面试微软10本必读书"></a>刘大佬认为的面试微软10本必读书</h1><ol><li>Code: The Hidden Language of Computer Hardware and Software （《编码的奥秘》）</li><li>Computer System: A Programmer’s Perspective （《深入理解计算机系统》） / Windows via C/C++ （《Windows核心编程》 / 《程序员的自我修养》</li><li>Code Complete 2（《代码大全》）/ The Pragmatic Programmer （《程序员修炼之道》，我也把这本书称为《代码小全》）</li><li>Programming Pearls （《编程珠玑》） / Algorithms / Algorithm Design / 《编程之美》</li><li>The C Programming Language</li><li>The C++ Programming Language / Programming: Principles and Practice Using C++ / Accelerated C++</li><li>The Structure and Interpretation of Computer Programs （《计算机程序的构造和解释》）</li><li>Clean Code / Implementation Patterns</li><li>Design Patterns （《设计模式》） / Agile Software Development, Principles, Patterns, and Practices</li><li>Refactoring （《重构》）</li></ol><h1 id="云风的书单（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）"><a href="#云风的书单（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）" class="headerlink" title="云风的书单（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）"></a>云风的书单（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）</h1><ol><li>C++编程思想</li><li>Effective C++</li><li>深度探索C++对象模型</li><li>C++语言的设计和演化</li><li>C专家编程</li><li>C陷阱与缺陷</li><li>C语言接口与实现</li><li>Lua程序设计</li><li>Linkers and Loaders</li><li>COM本质论</li><li>Windows核心编程</li><li>深入解析Windows操作系统</li><li>程序员修炼之道</li><li>代码大全</li><li>UNIX编程艺术</li><li>设计模式</li><li>代码优化：有效使用内存</li><li>深入理解计算机系统</li><li>深入理解LINUX内核</li><li>TCP/IP 详解</li></ol><h1 id="来自stackoverflow的一个帖子"><a href="#来自stackoverflow的一个帖子" class="headerlink" title="来自stackoverflow的一个帖子"></a>来自stackoverflow的一个帖子</h1><ul><li><a href="https://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read" target="_blank" rel="noopener">原网址</a></li></ul><ol><li>Code Complete (2nd edition) by Steve McConnell</li><li>The Pragmatic Programmer</li><li>Structure and Interpretation of Computer Programs</li><li>The C Programming Language by Kernighan and Ritchie</li><li>Introduction to Algorithms by Cormen, Leiserson, Rivest &amp; Stein</li><li>Design Patterns by the Gang of Four</li><li>Refactoring: Improving the Design of Existing Code</li><li>The Mythical Man Month</li><li>The Art of Computer Programming by Donald Knuth</li><li>Compilers: Principles, Techniques and Tools by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman</li><li>Gödel, Escher, Bach by Douglas Hofstadter</li><li>Clean Code: A Handbook of Agile Software Craftsmanship by Robert C. Martin</li><li>Effective C++</li><li>More Effective C++</li><li>CODE by Charles Petzold</li><li>Programming Pearls by Jon Bentley</li><li>Working Effectively with Legacy Code by Michael C. Feathers</li><li>Peopleware by Demarco and Lister</li><li>Coders at Work by Peter Seibel</li><li>Surely You’re Joking, Mr. Feynman!</li><li>Effective Java 2nd edition</li><li>Patterns of Enterprise Application Architecture by Martin Fowler</li><li>The Little Schemer</li><li>The Seasoned Schemer</li><li>Why’s (Poignant) Guide to Ruby</li><li>The Inmates Are Running The Asylum: Why High Tech Products Drive Us Crazy and How to Restore the Sanity</li><li>The Art of Unix Programming</li><li>Test-Driven Development: By Example by Kent Beck</li><li>Practices of an Agile Developer</li><li>Don’t Make Me Think</li><li>Agile Software Development, Principles, Patterns, and Practices by Robert C. Martin</li><li>Domain Driven Designs by Eric Evans</li><li>The Design of Everyday Things by Donald Norman</li><li>Modern C++ Design by Andrei Alexandrescu</li><li>Best Software Writing I by Joel Spolsky</li><li>The Practice of Programming by Kernighan and Pike</li><li>Pragmatic Thinking and Learning: Refactor Your Wetware by Andy Hunt</li><li>Software Estimation: Demystifying the Black Art by Steve McConnel</li><li>The Passionate Programmer (My Job Went To India) by Chad Fowler</li><li>Hackers: Heroes of the Computer Revolution</li><li>Algorithms + Data Structures = Programs</li><li>Writing Solid Code</li><li>JavaScript - The Good Parts</li><li>Getting Real by 37 Signals</li><li>Foundations of Programming by Karl Seguin</li><li>Computer Graphics: Principles and Practice in C (2nd Edition)</li><li>Thinking in Java by Bruce Eckel</li><li>The Elements of Computing Systems</li><li>Refactoring to Patterns by Joshua Kerievsky</li><li>Modern Operating Systems by Andrew S. Tanenbaum</li><li>The Annotated Turing</li><li>Things That Make Us Smart by Donald Norman</li><li>The Timeless Way of Building by Christopher Alexander</li><li>The Deadline: A Novel About Project Management by Tom DeMarco</li><li>The C++ Programming Language (3rd edition) by Stroustrup</li><li>Patterns of Enterprise Application Architecture</li><li>Computer Systems - A Programmer’s Perspective</li><li>Agile Principles, Patterns, and Practices in C# by Robert C. Martin</li><li>Growing Object-Oriented Software, Guided by Tests</li><li>Framework Design Guidelines by Brad Abrams</li><li>Object Thinking by Dr. David West</li><li>Advanced Programming in the UNIX Environment by W. Richard Stevens</li><li>Hackers and Painters: Big Ideas from the Computer Age</li><li>The Soul of a New Machine by Tracy Kidder</li><li>CLR via C# by Jeffrey Richter</li><li>The Timeless Way of Building by Christopher Alexander</li><li>Design Patterns in C# by Steve Metsker</li><li>Alice in Wonderland by Lewis Carol</li><li>Zen and the Art of Motorcycle Maintenance by Robert M. Pirsig</li><li>About Face - The Essentials of Interaction Design</li><li>Here Comes Everybody: The Power of Organizing Without Organizations by Clay Shirky</li><li>The Tao of Programming</li><li>Computational Beauty of Nature</li><li>Writing Solid Code by Steve Maguire</li><li>Philip and Alex’s Guide to Web Publishing</li><li>Object-Oriented Analysis and Design with Applications by Grady Booch</li><li>Effective Java by Joshua Bloch</li><li>Computability by N. J. Cutland</li><li>Masterminds of Programming</li><li>The Tao Te Ching</li><li>The Productive Programmer</li><li>The Art of Deception by Kevin Mitnick</li><li>The Career Programmer: Guerilla Tactics for an Imperfect World by Christopher Duncan</li><li>Paradigms of Artificial Intelligence Programming: Case studies in Common Lisp</li><li>Masters of Doom</li><li>Pragmatic Unit Testing in C# with NUnit by Andy Hunt and Dave Thomas with Matt Hargett</li><li>How To Solve It by George Polya</li><li>The Alchemist by Paulo Coelho</li><li>Smalltalk-80: The Language and its Implementation</li><li>Writing Secure Code (2nd Edition) by Michael Howard</li><li>Introduction to Functional Programming by Philip Wadler and Richard Bird</li><li>No Bugs! by David Thielen</li><li>Rework by Jason Freid and DHH</li><li>JUnit in Action</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;我眼中的阅读&quot;&gt;&lt;a href=&quot;#我眼中的阅读&quot; class=&quot;headerlink&quot; title=&quot;我眼中的阅读&quot;&gt;&lt;/a&gt;我眼中的阅读&lt;/h1&gt;&lt;p&gt;有这么一句话：看一个人，只需看他读什么书，与什么交往。&lt;/p&gt;
&lt;p&gt;但不知为什么，估计是我的社交圈太小的原
      
    
    </summary>
    
      <category term="随笔" scheme="http://huangyiblog.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="阅读" scheme="http://huangyiblog.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>完全背包</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    <id>http://huangyiblog.com/算法和数据结构/完全背包/</id>
    <published>2018-05-16T11:45:25.000Z</published>
    <updated>2018-05-16T11:47:06.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><p>有n种物品，每种物品的单件重量为w[i],价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，<br>使得背包内物品的总价值最大。其中每种物品都有无穷件。</p><p>完全背包与01背包的唯一区别：完全背包的物品数量每种有无穷件，而01背包的物品数量每种只有1件。</p><p>令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值</p><p>对每种物品有两种策略：</p><ol><li>不放第i件物品，那么dp[i][v] = dp[i-1][v]</li><li>放第i件物品。dp[i][v] = dp[i][v-w[i]]+c[i]<br>由此得出状态转移方程：<pre><code>**dp[i][v] = max(dp[i-1][v],dp[i][v-w[i]]+c[i]) (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V)**边界：dp[0][v] = 0(0&lt;=v&lt;=V)</code></pre>改写成一维形式：<pre><code>**dp[v] = max(dp[v],dp[v-w[i]]+c[i]) (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V)**边界：dp[v] = 0(0&lt;=v&lt;=V)</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=w[i];v&lt;=V;v++)&#123;</span><br><span class="line">    dp[v] = max(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="常见dp问题的模型总结"><a href="#常见dp问题的模型总结" class="headerlink" title="常见dp问题的模型总结"></a>常见dp问题的模型总结</h1><ol><li><p>最大连续子列和<br>令dp[i]表示以A[i]作为末尾的连续序列的最大和。</p></li><li><p>最长不下降子序列（LIS）<br>令dp[i]表示以A[i]结尾的最长不下降子序列长度</p></li><li><p>最长公共子序列（LCS）<br>令dp[i][j]表示字符串A的i号位和字符串B的j号位之前的LCS长度</p></li><li><p>最长回文子串<br>令dp[i][j]表示S[i]至S[j]所表示的子串是否是回文子串</p></li><li><p>数塔dp<br>令dp[i][j]表示从第i行第j个数字出发的到达最底层的所有路径上所能得到的最大和</p></li><li><p>DAG最长路<br>令dp[i]表示从i号顶点出发能获得的最长路径长度</p></li><li><p>01背包<br>令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值</p></li><li><p>完全背包<br>令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;完全背包问题&quot;&gt;&lt;a href=&quot;#完全背包问题&quot; class=&quot;headerlink&quot; title=&quot;完全背包问题&quot;&gt;&lt;/a&gt;完全背包问题&lt;/h1&gt;&lt;p&gt;有n种物品，每种物品的单件重量为w[i],价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，&lt;
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>01背包</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01%E8%83%8C%E5%8C%85/"/>
    <id>http://huangyiblog.com/算法和数据结构/01背包/</id>
    <published>2018-05-16T11:45:01.000Z</published>
    <updated>2018-05-16T11:46:20.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><p>有n件物品，每件物品的重量为w[i]，价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，使得背包<br>内物品的总价值最大。其中每件物品都只有1件。<br>样例：</p><p>5 8  //n,v</p><p>3 5 1 2 2 //w[i]</p><p>4 5 2 1 3 //c[i]</p><h2 id="暴力枚举的想法"><a href="#暴力枚举的想法" class="headerlink" title="暴力枚举的想法"></a>暴力枚举的想法</h2><p>枚举每一件物品放或者不放进背包，显然每件物品都有两种选择，因此n件物品就有2^n种情况，<br>显然不是理想的解决方案</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>时间复杂度为O(nV)</p><p>令dp[i][v]表示前i件物品（1&lt;=i&lt;=n,0&lt;=v&lt;=V）恰好装入容量为v的背包中所能获得的最大价值。</p><p>考虑对第i件物品的选择策略，有两种策略：</p><ol><li><p>不放第i件物品，那么问题转化为前i-1件物品恰好装入容量为v的背包中所能获得的最大价值，即dp[i-1][v]</p></li><li><p>放第i件物品，那么问题转化为前i-1件物品恰好装入容量为v-w[i]的背包中所能获得的最大价值，即dp[i-1][v-w[i]]+c[i]</p></li></ol><p>由此得出状态转移方程：<br>      <strong>dp[i][v] = max{dp[i-1][v],dp[i-1][v-w[i]]+c[i]} (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V)</strong></p><p>边界： dp[0][v] = 0(0&lt;=v&lt;=V)（即前0件物品放入任何容量为v的背包中都只能获得价值0）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=w[i];v&lt;=V;v++)&#123;</span><br><span class="line">        dp[i][v] = max(dp[i<span class="number">-1</span>][v],dp[i<span class="number">-1</span>][v-w[i]]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码时间复杂度与空间复杂度均为O(nV),其中时间复杂度无法优化，但空间复杂度可以<br>优化的关键在于开一个一维数组dp[v]，枚举方向改变为i从1到n，<strong>v从V到0（逆序）</strong></p><p>状态转移方程： <strong>dp[v] = max{dp[v],dp[v-w[i]]+c[i]} (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=V;v&gt;=w[i];v--)&#123;</span><br><span class="line">        dp[v] = max(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时空间复杂度为O(V)<br>说明：如果是二维数组存放，v的枚举顺序或逆序皆可；但如果用一维数组存放，v的枚举必须为逆序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> w[maxn],c[maxn],dp[maxv];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,V;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;V);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=V;v++)&#123;</span><br><span class="line">        dp[v] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=V;v&gt;=w[i];v--)&#123;</span><br><span class="line">            dp[v] = max(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=V;v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[v]&gt;max)&#123;</span><br><span class="line">            max = dp[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;01背包问题&quot;&gt;&lt;a href=&quot;#01背包问题&quot; class=&quot;headerlink&quot; title=&quot;01背包问题&quot;&gt;&lt;/a&gt;01背包问题&lt;/h1&gt;&lt;p&gt;有n件物品，每件物品的重量为w[i]，价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，使得背
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>git-it</title>
    <link href="http://huangyiblog.com/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/git-it/"/>
    <id>http://huangyiblog.com/业务开发/git-it/</id>
    <published>2018-05-16T01:15:10.000Z</published>
    <updated>2018-05-16T01:16:55.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-it-Desktop-App"><a href="#Git-it-Desktop-App" class="headerlink" title="Git-it (Desktop App)"></a>Git-it (Desktop App)</h1><p><a href="https://travis-ci.org/jlord/git-it-electron" target="_blank" rel="noopener"><img src="https://travis-ci.org/jlord/git-it-electron.svg?branch=master" alt="Build Status"></a> <a href="http://standardjs.com/" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/code%20style-standard-brightgreen.svg" alt="js-standard-style"></a></p><ul><li><p>分享一款学习如何使用Git和Github的客户端应用<br><a href="https://github.com/jlord/git-it-electron/releases" target="_blank" rel="noopener">相应的发行版本</a><br>其中提供了Linux，Mac和Windos相应的版本，语言也有多种选择。<br>app对应的源代码也发布在这个人的GitHub页面</p></li><li><p>这款应用的所有贡献者仓库主也都记录并放在了她的Gitpage主页上了<br><a href="http://jlord.github.io/patchwork" target="_blank" rel="noopener">All the Git-it Workshop completers! </a></p></li></ul><p><img src="https://cloud.githubusercontent.com/assets/1305617/14594613/23873f64-04ed-11e6-9d3b-72f424dd0842.png" alt="screen shot 2016-04-17 at 10 37 55 pm"><br>Git-it is a desktop (Mac, Windows and Linux) app that teaches you how to use Git and GitHub on the <a href="https://en.wikipedia.org/wiki/Command-line_interface" target="_blank" rel="noopener">command line</a>.</p><p>Previously it ran _in_ terminal (the command line application) with a guide online but now the guide _is_ the app and it runs on your desktop on its own :sparkles: <strong>This will be the only maintained version going forward</strong> :arrow_right:</p><hr><h2 id="Hello-future-Forkers-Branchers-and-Pull-Requesters"><a href="#Hello-future-Forkers-Branchers-and-Pull-Requesters" class="headerlink" title="Hello future Forkers, Branchers and Pull Requesters!"></a>Hello future Forkers, Branchers and Pull Requesters!</h2><p>This application contains challenges for learning Git and GitHub—by using <em>real</em> Git and GitHub, not emulators. You’ll be learning the awesome (and not so scary) command line and GitHub which means when you finish all of the challenges you’ll have <em>real</em> repositories on your GitHub account and green squares on your <a href="https://github.com/blog/1360-introducing-contributions" target="_blank" rel="noopener">contribution chart</a>.</p><p><img src="https://raw.githubusercontent.com/jlord/git-it/master/ghcc.png" alt="contributions"></p><h2 id="What-to-Install"><a href="#What-to-Install" class="headerlink" title="What to Install"></a>What to Install</h2><p>You will need this app, Git-it as well as a text editor. You’ll also of course need Git and the first challenge in Git-it helps you get that set up. But if you want to get a head start, go for it! You’ll continue to use Git and your text editor throughout your bright social coding future.</p><p>As a part of the challenges you’ll also create a (free) account on GitHub. If you’ve already got one, high-five!</p><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><p>We recommend installing <a href="http://desktop.github.com" target="_blank" rel="noopener">GitHub Desktop</a> (free) because it installs Git in the most consistent way across supported operating systems (Windows and Mac). We won’t use the app itself in the challenges (but it is really useful once you get going in Git!), just the Git that it install for you.</p><p>Note—If you’re using Windows, you should use the <strong>Git Shell</strong> app as your terminal—it is installed with GitHub Desktop. In Mac and Linux you can use the app <strong>Terminal</strong>, which is already on your computer.</p><h4 id="Text-Editor"><a href="#Text-Editor" class="headerlink" title="Text Editor"></a>Text Editor</h4><p>I’m quite partial (I’m on the team!) but <a href="http://atom.io" target="_blank" rel="noopener">Atom</a> is a great text editor (also free) and it is built on <a href="http://electron.atom.io" target="_blank" rel="noopener">Electron.js</a>, just like Git-it. Visit the website and download the version for your operating system. <a href="https://www.sublimetext.com" target="_blank" rel="noopener">Sublime</a>, <a href="https://code.visualstudio.com" target="_blank" rel="noopener">Microsoft VS Code</a> and <a href="http://brackets.io" target="_blank" rel="noopener">Adobe Brackets</a> are other options.</p><h4 id="Git-it"><a href="#Git-it" class="headerlink" title="Git-it"></a>Git-it</h4><p>You can view the <a href="http://github.com/jlord/git-it-electron/releases" target="_blank" rel="noopener">releases</a> section of this repository to find the download for your operating system. Click to download your version. Once it has downloaded to your default Downloads directory, unzip the folder and run the Git-it executable. The executables for Mac, Windows and Linux:</p><p><img src="https://cloud.githubusercontent.com/assets/1305617/14696588/2b10abf8-0731-11e6-945e-f3d57114bce9.png" alt="executables"></p><ul><li><strong>Mac</strong> Right (control) click the Git-it icon, select Open and then Open again. You can drag the icon into your Applications directory if you want, but it’s not required. If needed, more <a href="https://github.com/jlord/git-it-electron/issues/121#issue-149747488" target="_blank" rel="noopener">detailed installation instructions</a> can be found in this issue.</li><li><strong>Windows</strong> Double-click the executable.</li><li><strong>Linux</strong> Double-click the executable. If the app isn’t running, <a href="https://github.com/jlord/git-it-electron/issues/182" target="_blank" rel="noopener">see this issue</a>.</li></ul><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started!"></a>Get Started!</h2><p>Open Git-it and click the button to begin the first challenge. Have your terminal and text editor open, too. Follow along with the instructions in each challenge and use the terminal or editor as instructed.</p><p>When you’ve completed the steps in a challenge click ‘Verify’. Depending on the challenge you may need to also select the folder you did your work in for Git-it to verify.</p><p><strong>Questions?</strong> <a href="http://github.com/jlord/git-it-electron/issues/new" target="_blank" rel="noopener">Open an issue</a> on this repository.</p><p><strong>Want to contribute or build locally?</strong> See the <a href="CONTRIBUTING.md">contributing documentation</a></p><hr><h3 id="Tips-For-Getting-Started"><a href="#Tips-For-Getting-Started" class="headerlink" title="Tips For Getting Started"></a>Tips For Getting Started</h3><p><strong>Code snippets</strong> often times look like <code>$ some code-stuff --here</code>. The dollar sign identifies the line as one a user would enter into the command line, but you don’t actually include it when you type it into terminal. In this case, you’d actually just type <code>some code-stuff --here</code>.</p><p><strong>Variables</strong> are indicated by <code>&lt;VARIABLENAME&gt;</code> in code snippets. When you actually use the line of code, replace <code>&lt;VARIABLENAME&gt;</code>, with your variable. For instance to make a new folder in terminal the format is, <code>mkdir &lt;FOLDERNAME&gt;</code>, so if you wanted to make a folder named ‘octocat’, you’d type: <code>mkdir octocat</code>.</p><p><strong>Command line, terminal and bash</strong> all basically mean the same thing: the MS-DOS, Doogie Howser looking screen full of words and numbers. It’s awesomely powerful and allows you to control your computer with text commands.</p><p>You can do a lot of things from your terminal like delete, rename, copy or create files and folders; run scripts and send things back and forth between servers (like the ones storing things on GitHub.com) and your computer (also a server!).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git-it-Desktop-App&quot;&gt;&lt;a href=&quot;#Git-it-Desktop-App&quot; class=&quot;headerlink&quot; title=&quot;Git-it (Desktop App)&quot;&gt;&lt;/a&gt;Git-it (Desktop App)&lt;/h1&gt;&lt;p&gt;&lt;a
      
    
    </summary>
    
      <category term="业务开发" scheme="http://huangyiblog.com/categories/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Github" scheme="http://huangyiblog.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 5. 最长回文子串</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://huangyiblog.com/算法和数据结构/LeetCode-5-最长回文子串/</id>
    <published>2018-05-15T08:23:42.000Z</published>
    <updated>2018-05-15T10:23:11.006Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p><p>示例 1：</p><p>输入: “babad”<br>输出: “bab”<br>注意: “aba”也是一个有效答案。<br>示例 2：</p><p>输入: “cbbd”<br>输出: “bb”</p><h1 id="解决思路-1-——-暴力枚举法"><a href="#解决思路-1-——-暴力枚举法" class="headerlink" title="解决思路 1 —— 暴力枚举法"></a>解决思路 1 —— 暴力枚举法</h1><p>暴力枚举法是这几种方法中最直观的求解，<br>求解过程中分别以每个元素为中间元素（奇数为最中间的一个数，偶数为中间元素的其中一个），<br>同时从左右出发，计算出最长的回文子串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> endIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存最大回文子串的起始与终点位置</span></span><br><span class="line">    <span class="keyword">int</span> resStart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resEnd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> countLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">      <span class="comment">/* 回文子串为奇串处理 */</span></span><br><span class="line">      startIndex = i;</span><br><span class="line">      endIndex = i;</span><br><span class="line">      countLen = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(startIndex &gt;= <span class="number">0</span> &amp;&amp; endIndex &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[startIndex] == s[endIndex]) &#123;</span><br><span class="line">          <span class="keyword">if</span>(startIndex == endIndex) &#123;</span><br><span class="line">            countLen++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            countLen += <span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          startIndex--;</span><br><span class="line">          endIndex++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前回文子串大于上一次最大回文子串</span></span><br><span class="line">      <span class="keyword">if</span>(countLen &gt; maxLen) &#123;</span><br><span class="line">        maxLen = countLen;</span><br><span class="line">        resStart = startIndex + <span class="number">1</span>;</span><br><span class="line">        resEnd = endIndex - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 回文子串为奇串处理 */</span></span><br><span class="line">      startIndex = i<span class="number">-1</span>;</span><br><span class="line">      endIndex = i;</span><br><span class="line">      countLen = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(startIndex &gt;= <span class="number">0</span> &amp;&amp; endIndex &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[startIndex] == s[endIndex]) &#123;</span><br><span class="line">          <span class="keyword">if</span>(startIndex == endIndex) &#123;</span><br><span class="line">            countLen++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            countLen += <span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          startIndex--;</span><br><span class="line">          endIndex++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前回文子串大于上一次最大回文子串</span></span><br><span class="line">      <span class="keyword">if</span>(countLen &gt; maxLen) &#123;</span><br><span class="line">        maxLen = countLen;</span><br><span class="line">        resStart = startIndex + <span class="number">1</span>;</span><br><span class="line">        resEnd = endIndex - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.substr(resStart, resEnd - resStart + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：最外层循环复杂度为O(n),内层两个循环的复杂度都为O(n/2),因此时间复杂度为O(n2)。</li><li>空间复杂度：在此算法中，没有使用额外的辅助空间，因此空间复杂度为O(1)。</li></ul><h1 id="解决思路-2-——-记忆化搜索"><a href="#解决思路-2-——-记忆化搜索" class="headerlink" title="解决思路 2 —— 记忆化搜索"></a>解决思路 2 —— 记忆化搜索</h1><p>回文字符串的子串也是回文，我们可以将最长回文子串分解一系列子问题，使用动态规划求解。<br>设状态f(i,j)表示区间[i,j]是否为回文串，<br>f(i,j) = false表示子串[i,j]不是回文，f(i,j)=true表示子串[i,j]是回文串，则有以下的关系：</p><p><img src="/img/4.jpg" alt="Alt"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    n = s.size();</span><br><span class="line">    <span class="keyword">bool</span> **f = <span class="keyword">new</span> <span class="keyword">bool</span>*[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      f[i] = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        f[i][j] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">      f[i][i] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        f[j][i] = (s[j] == s[i] &amp;&amp; (i-j &lt; <span class="number">2</span> || f[j+<span class="number">1</span>][i<span class="number">-1</span>]));</span><br><span class="line">        <span class="keyword">if</span>(f[j][i] &amp;&amp; maxLen &lt; (i-j+<span class="number">1</span>)) &#123;</span><br><span class="line">          maxLen = i - j + <span class="number">1</span>;</span><br><span class="line">          start = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">delete</span>[] f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] f;</span><br><span class="line">    <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：使用了两层循环,因此时间复杂度为O(n2)。</li><li>空间复杂度：使用了f[n][n]作为辅助空间，因此空间复杂度为O(n2)。</li></ul><h1 id="解决思路-3-——-Mancher’s-Algorithm"><a href="#解决思路-3-——-Mancher’s-Algorithm" class="headerlink" title="解决思路 3 —— Mancher’s Algorithm"></a>解决思路 3 —— Mancher’s Algorithm</h1><p>Mancher算法能够很快的得到一个字符串中以任意一个字符为中心的回文子串，<br>其基本原理使用已知回文串的左半部分来推导有半部分。</p><p>我们使用rad[i]表示以第i个字符为中心的最长回文半径，<br>假设我们求出了rad[0,…,i-1]的值，现在我们需要通过已知的结果计算出rad[i]的值，<br>在此我们定义maxRight是i位置前所有回文串能延伸到的最右端位置，并且此时回文串的中心位置为k（取第一个达到最右端的位置），<br>则我们可以得到maxRight = k + rad<a href="中心位置加上半径">k</a>，可以有以下两种情况：</p><p><img src="/img/3.jpg" alt="Alt"></p><p>第一种情况：位置i不在前面的任何回文串中，即i &gt; maxRight,这时则初始化rad[i]=1，然后rad[i]向两边延伸，即</p><p>while(s[i+rad[i]] == s[i-rad[i]])<br>  rad[i]++;<br>第二种情况：i这个位置被前面位置k为中心的回文串包含，即i &lt;= maxRight，这种情况下rad[i]就不是从1开始。由回文串的性质，我们可以知道2k-i这个位置与i关于k对称，在这种情况下由可分为三种情形：<br>第一种情形：以2k-i为中心的回文串有一部分在以i为中心回文串之外，<br>这种情况下rad[i]=maxRight-i=k+rad[k]-i,即为图中空心箭头长度，<br>那有没有可能rad[i]会更长呢？不可能，如果rad[i]会更长，则会延伸到k为中心的子串外，<br>由于i和2k-i的对称性可得到k为中心的子串会大于图中紫色对应的半径，与已知矛盾。</p><p><img src="/img/2.jpg" alt="Alt"></p><p>第二种情形：以2k-i为中心的回文串在以i为中心回文串之内，此时rad[i]=rad[2k-i],<br>那么这个时候rad[i]会更长吗？不可能，如果rad[i]长度更长，则延伸部分与2k-i正好对称，<br>这个时候2k-i子串半径则大于图中蓝色箭头的长度，矛盾。</p><p><img src="/img/1.jpg" alt="Alt"></p><p>第三种情形：以2k-i为中心的回文串与i为中心回文串左端部重叠，则ran[i]=rad[2k-i],并且rad[i]可能继续增加，所以有:<br>rad[i]=rad[2k-i];<br>while(s[i+rad[i]] == s[i-rad[i]])<br>  rad[i]++;<br>上面的方法存在一个问题，就是只能计算出奇数长度的回文子串，偶数的就不行，<br>怎么解决呢？这里使用一个比较好的方法，在原来的串中每两个字符之间添加一个特殊字符，<br>如aabbaca变成^#a#a#b#b#a#c#a#$，这里^$作为字符串的定界符是为了防止算法越界。<br>这样处理后，无论原来的回文子串长度是偶数还是奇数，现在都变成奇数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 字符串预处理，如输入"abba",返回"^#a#b#b#a#$"</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">preProcess</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"^$"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">"^"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">      ret += <span class="string">"#"</span> + s.substr(i,<span class="number">1</span>);</span><br><span class="line">    ret+= <span class="string">"#$"</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> tmpStr = preProcess(s);</span><br><span class="line">    <span class="keyword">int</span> n = tmpStr.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *rad = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> center = <span class="number">0</span>, maxRight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> sym_pos = <span class="number">2</span> * center - i;</span><br><span class="line"></span><br><span class="line">      rad[i] = (maxRight &gt; i) ? min(maxRight - i, rad[sym_pos]) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 以i为中心检索两边的字符串</span></span><br><span class="line">      <span class="keyword">while</span>(tmpStr[i + rad[i]] == tmpStr[i - rad[i]])</span><br><span class="line">        rad[i]++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(i + rad[i] &gt; maxRight) &#123;</span><br><span class="line">        center = i;</span><br><span class="line">        maxRight = i + rad[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找最长的半径</span></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> center_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(rad[i] &gt; maxLen) &#123;</span><br><span class="line">        maxLen = rad[i];</span><br><span class="line">        center_index = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.substr((center_index - maxLen) / <span class="number">2</span>, maxLen<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：Mancher算法时间复杂度为O(n)。</li><li>空间复杂度：空间复杂度也为O(n)。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入: “babad”&lt;br&gt;输出: “bab”&lt;br&gt;注意: “aba”也是一个有效答案。&lt;br&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入: “cbbd”
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://huangyiblog.com/算法和数据结构/最长回文子串/</id>
    <published>2018-05-15T06:40:37.000Z</published>
    <updated>2018-05-15T06:41:28.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p>问题描述：<br>给出一个字符串S，求S的最长回文子串的长度。</p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>枚举子串的两个端点i和j，判断[i,j]区间内的子串是否回文。<br>其中枚举端点需要O(n^2),判断回文需要O(n)因此总的复杂度为O(n^3)</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>时间复杂度为O(n^2)<br>令dp[i][j]表示S[i]至S[j]所表示的子串是否是回文子串，是则为1，不是为0.<br>根据S[i]是否等于S[j]，将转移情况分为两类：</p><ol><li>若S[i]==S[j]，只要S[i+1]到S[j-1]是回文子串，那么S[i]到S[j]就是回文子串；<br>否则，就不是。</li><li>若S[i]!=S[j]那么S[i]到S[j]一定不是回文子串。<br>由此得出状态转移方程：</li></ol><p>dp[i][j]= dp[i+1][j-1],S[i]==S[j]<br>          0,S[i]!=S[j]<br>边界：dp[i][i] = 1,dp[i][i+1] = (S[i]==S[i+1)?1:0</p><p>但是不能按照i和j从小到大进行枚举子串两个端点然后更新dp[i][j]，因为无法保证<br>dp[i+1][j-1]已经被计算过，从而无法得到正确的dp[i][j]</p><p>由于边界表示的是长度为1和2的子串，且每次转移时都对子串的长度减1，因此考虑按子串的长度和子串的初始位置进行枚举<br>即第一遍将长度为3的子串的dp值全部求出，第二遍通过第一遍结果计算长度为4的子串的值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">char</span> S[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gets(S);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(S),ans = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==S[i+<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                ans = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">3</span>;t&lt;=len;t++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+t<span class="number">-1</span>&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+t<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==S[j]&amp;&amp;dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                ans = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="字符串哈希-二分解法"><a href="#字符串哈希-二分解法" class="headerlink" title="字符串哈希+二分解法"></a>字符串哈希+二分解法</h2><p>时间复杂度为O(nlogn)<br>对给定的字符串str，可以先求出其字符串hash数组h1，然后再将str反转，<br>求出反转字符串rstr的hash数组h2，接着按回文串的奇偶情况讨论</p><ul><li><p>回文串的长度是奇数：枚举回文中心点i，二分子串的半径k，找到最大的使子串[i-k,i+k]是回文串的k。</p></li><li><p>回文串的长度是偶数：枚举回文空隙点，令i表示空隙左边第一个元素的下标，二分子串的半径k，找到最大的使子串<br>[i-k+1,i+k]是回文串的k。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> ll p = <span class="number">10000019</span>;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">200010</span>;</span><br><span class="line">ll powp[maxn],h1[maxn],h2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    powp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">        powp[i] = (powp[i<span class="number">-1</span>]*p)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calh</span><span class="params">(ll h[],<span class="built_in">string</span> &amp;str)</span></span>&#123;</span><br><span class="line">    h[<span class="number">0</span>] = str[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        h[i] = (h[i<span class="number">-1</span>]*p+str[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calSingleSubh</span><span class="params">(ll h[],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span> h[j];</span><br><span class="line">    <span class="keyword">return</span> ((h[j]-h[i<span class="number">-1</span>]*powp[j-i+<span class="number">1</span>])%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> len,<span class="keyword">int</span> i,<span class="keyword">int</span> isEven)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> h1l = i-mid+isEven,h1r = i;</span><br><span class="line">        <span class="keyword">int</span> h2l = len<span class="number">-1</span>-(i+mid),h2r = len<span class="number">-1</span>-(i+isEven);</span><br><span class="line">        <span class="keyword">int</span> hashl = calSingleSubh(h1,h1l,h1r);</span><br><span class="line">        <span class="keyword">int</span> hashr = calSingleSubh(h2,h2l,h2r);</span><br><span class="line">        <span class="keyword">if</span>(hashl!=hashr) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    getline(<span class="built_in">cin</span>,str);</span><br><span class="line">    calh(h1,str);</span><br><span class="line">    reverse(str.begin(),str.end());</span><br><span class="line">    calh(h2,str);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> maxlen = min(i,(<span class="keyword">int</span>)str.length()<span class="number">-1</span>-i)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = binarySearch(<span class="number">0</span>,maxlen,str.length(),i,<span class="number">0</span>);</span><br><span class="line">        ans = max(ans,k*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> maxlen = min(i+<span class="number">1</span>,(<span class="keyword">int</span>)str.length()<span class="number">-1</span>-i)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = binarySearch(<span class="number">0</span>,maxlen,str.length(),i,<span class="number">1</span>);</span><br><span class="line">        ans = max(ans,k*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h1><p>时间复杂度为O(n)<br>算法分析：<br>由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。</p><p>举个例子：s=”abbahopxpo”，转换为s_new=”$#a#b#b#a#h#o#p#x#p#o#”（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文abba和一个奇回文opxpo，被转换为#a#b#b#a#和#o#p#x#p#o#，长度都转换成了奇数。</p><p>定义一个辅助数组int p[]，其中p[i]表示以 i 为中心的最长回文的半径<br>p[i] - 1正好是原字符串中最长回文串的长度。</p><p><img src="https://segmentfault.com/img/remote/1460000014416801?w=590&amp;h=190/view" alt="Alt txt"><br>设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。</p><p>假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; mx)  </span><br><span class="line">    p[i] = min(p[<span class="number">2</span> * id - i], mx - i);</span><br></pre></td></tr></table></figure></p><p>2 * id - i为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快查找。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findBMstr</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[str.size() + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=  str.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx &gt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i] = (p[<span class="number">2</span>*id - i] &lt; (mx - i) ? p[<span class="number">2</span>*id - i] : (mx - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(str[i - p[i]] == str[i + p[i]])</span><br><span class="line">            p[i]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i + p[i] &gt; mx)</span><br><span class="line">        &#123;</span><br><span class="line">            mx = i + p[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, ii;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            ii = i;</span><br><span class="line">            max = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = ii - max ;</span><br><span class="line">    <span class="keyword">int</span> end = ii + max;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] != <span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>  p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"12212321"</span>;</span><br><span class="line">    <span class="built_in">string</span> str0;</span><br><span class="line">    str0 += <span class="string">"$#"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str0 += str[i];</span><br><span class="line">        str0 += <span class="string">"#"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str0 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    findBMstr(str0);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最长回文子串&quot;&gt;&lt;a href=&quot;#最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;最长回文子串&quot;&gt;&lt;/a&gt;最长回文子串&lt;/h1&gt;&lt;p&gt;问题描述：&lt;br&gt;给出一个字符串S，求S的最长回文子串的长度。&lt;/p&gt;
&lt;h2 id=&quot;暴力解法&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>最长公共子序列</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://huangyiblog.com/算法和数据结构/最长公共子序列/</id>
    <published>2018-05-14T07:47:17.000Z</published>
    <updated>2018-05-14T07:48:06.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>最长公共子序列问题描述：<br>给定两个字符串（或数字序列）A和B,求一个字符串，使得这个字符串是A和B的最长公共部分（子序列可以不连续）</p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>设字符串A和B的长度分别是n和m，那么对两个字符串中的每个字符，分别有选与不选两个决策，而得到子序列后<br>比较两个子序列是否相同有需要O(max(m,n))，这样总的复杂度就会达到O(2^(m+n)*max(m,n))，无法承受较大数据</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>令dp[i][j]表示字符串A的i号位和字符串B的j号位之前的LCS长度（下标从1开始）两种决策如下：</p><ol><li><p>若A[i]==B[j]则字符串A与字符串B的LCS增加了1位，即dp[i][j]=dp[i-1][j-1]+!</p></li><li><p>若A[i]!=B[j]，则字符串A的i号位和字符串B的j号位之前的LCS无法延长，因此dp[i][j]将会继承dp[i-1][j]与dp[i][j-1]<br>z中的较大值，即dp[i][j]= max{dp[i-1][j],dp[i][j-1]}</p></li></ol><p>由此可以得到状态转移方程：<br>dp[i][j]= dp[i-1][j-1]+1,A[i]==B[j]<br>          max{dp[i-1][j],dp[i][j-1]},A[i]!=B[j]<br>边界：dp[i][0]=dp[0][j]=0(0&lt;=i&lt;=n,0&lt;=j&lt;=m)<br>时间复杂度为O(nm)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> A[N],B[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    gets(A+<span class="number">1</span>);<span class="comment">//从下标为1开始读入</span></span><br><span class="line">    gets(B+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> lenA = <span class="built_in">strlen</span>(A+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> lenB = <span class="built_in">strlen</span>(B+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lenA;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=lenB;j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lenA;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lenB;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]==B[j])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[lenA][lenB]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最长公共子序列&quot;&gt;&lt;a href=&quot;#最长公共子序列&quot; class=&quot;headerlink&quot; title=&quot;最长公共子序列&quot;&gt;&lt;/a&gt;最长公共子序列&lt;/h1&gt;&lt;p&gt;最长公共子序列问题描述：&lt;br&gt;给定两个字符串（或数字序列）A和B,求一个字符串，使得这个字符串是A
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>最长不下降子序列</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://huangyiblog.com/算法和数据结构/最长不下降子序列/</id>
    <published>2018-05-14T07:25:42.000Z</published>
    <updated>2018-05-14T07:26:22.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最长不下降子序列"><a href="#最长不下降子序列" class="headerlink" title="最长不下降子序列"></a>最长不下降子序列</h1><p>LIS问题：<br>在一个数字序列中，找到一个最长的子序列（可以不连续），使得这个子序列是不下降的</p><h2 id="原始方法"><a href="#原始方法" class="headerlink" title="原始方法"></a>原始方法</h2><p>枚举每种情况，即对于每个元素有取和不取两种选择，然后判断序列是否为不下降序列。<br>如果是不下降序列，则更新最大长度，直到枚举完所有情况并得到最大长度。<br>但这种做法时间复杂度将达到O(2^n)显然不可取</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>用dp[i]表示以A[i]结尾的最长不下降子序列长度，则A[i]有两种情况</p><ol><li>如果存在A[i]之前的元素A<a href="j&lt;i">j</a>，使得A[j]&lt;=A[i]且dp[j]+1&gt;dp[i]（即把A[i]跟以A[j]结尾的LIS后面时能比当前以A[i]结尾的LIS长度更长）<br>，那么就把A[i]跟在以A[j]结尾的LIS后面，形成一条更长的不下降子序列，（令dp[i]=dp[j]+1）</li><li>如果A[i]之前的元素都比A[i]大，那么A[i]就只好自己形成一条LIS,但是长度为1，即这个子序列里面只有一个A[i]</li></ol><p>最后以A[i]结尾的LIS长度就是上述两点中能形成的最大长度</p><p>由此写出状态转移方程：<br>dp[i] = max{1,dp[j]+1}(j=1,2,…i-1&amp;&amp;A[j]&lt;A[i])<br>边界dp[i] = 1(1&lt;=i&lt;=n)<br>整体复杂度为O(n^2)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> A[N],dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;=A[j]&amp;&amp;(dp[j]+<span class="number">1</span>&gt;dp[i]))&#123;</span><br><span class="line">                dp[i] = dp[j]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最长不下降子序列&quot;&gt;&lt;a href=&quot;#最长不下降子序列&quot; class=&quot;headerlink&quot; title=&quot;最长不下降子序列&quot;&gt;&lt;/a&gt;最长不下降子序列&lt;/h1&gt;&lt;p&gt;LIS问题：&lt;br&gt;在一个数字序列中，找到一个最长的子序列（可以不连续），使得这个子序列是不
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>最大连续子列和</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%88%97%E5%92%8C/"/>
    <id>http://huangyiblog.com/算法和数据结构/最大连续子列和/</id>
    <published>2018-05-13T03:57:35.000Z</published>
    <updated>2018-05-13T03:58:56.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最大连续子列和问题"><a href="#最大连续子列和问题" class="headerlink" title="最大连续子列和问题"></a>最大连续子列和问题</h1><p>给定一个数字序列A1，A2，……An,求i，j(1&lt;=i&lt;=j&lt;=n),使得Ai+….Aj最大，输出这个最大和。</p><h3 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h3><p>枚举左端点和右端点（即枚举i和j），需要O(n^2)的复杂度，求和有需要O(n)的复杂度，因此总复杂度为O(n^3)</p><h3 id="方法二：预处理记录前缀和"><a href="#方法二：预处理记录前缀和" class="headerlink" title="方法二：预处理记录前缀和"></a>方法二：预处理记录前缀和</h3><p>记S[i] = A[0]+A[1]….+A[i],这样A[i]+…+A[j] = S[j]-S[i-1];该计算的复杂度为O(1),但总的时间复杂度为O(n^2)</p><h3 id="方法三：动态规划"><a href="#方法三：动态规划" class="headerlink" title="方法三：动态规划"></a>方法三：动态规划</h3><p>动态规划问题的核心与难点其实就在于确定状态和状态转移方程，以及边界分析。<br>步骤一：确定状态<br>令状态dp[i]表示以A[i]作为末尾的连续序列的最大和，<br>因此所求最大和便是dp[0],dp[1],dp[2]…dp[n-1]中的最大值。<br>步骤二：确定状态转移方程，求dp数组<br>以A[i]结尾的连续序列只有两种情况</p><ol><li>这个最大和的连续序列只有一个元素，即以A[i]开始，以A[i]结尾</li><li>这个最大和的连续序列有多个元素，即以A[p]开始，A[i]结尾<br>第一种情况，最大和就是A[i]<br>第二种情况，最大和是dp[i-1]+A[i]<br>所以可以得到状态转移方程<br>dp[i] = max{A[i],dp[i-1]+A[i]}<br>边界为dp[0] = A[0]<br>时间复杂度为O(n)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i] = max(a[i],dp[i<span class="number">-1</span>]+a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;dp[k])&#123;</span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="状态的无后效性"><a href="#状态的无后效性" class="headerlink" title="状态的无后效性"></a>状态的无后效性</h1><p>状态的无后效性是指：当前状态记录了信息，一旦当前状态确定，就不会再改变，且未来的决策只能在已有的一个或若干个状态的<br>基础上进行，历史信息只能通过已有的状态去影响未来的决策。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最大连续子列和问题&quot;&gt;&lt;a href=&quot;#最大连续子列和问题&quot; class=&quot;headerlink&quot; title=&quot;最大连续子列和问题&quot;&gt;&lt;/a&gt;最大连续子列和问题&lt;/h1&gt;&lt;p&gt;给定一个数字序列A1，A2，……An,求i，j(1&amp;lt;=i&amp;lt;=j&amp;lt;=
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>dp简介</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dp%E7%AE%80%E4%BB%8B/"/>
    <id>http://huangyiblog.com/算法和数据结构/dp简介/</id>
    <published>2018-05-12T08:43:12.000Z</published>
    <updated>2018-05-12T08:43:45.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划的递归写法和递推写法"><a href="#动态规划的递归写法和递推写法" class="headerlink" title="动态规划的递归写法和递推写法"></a>动态规划的递归写法和递推写法</h1><p>动态规划是一种算法思想，没有固定写法，十分灵活，需要具体问题具体分析</p><p>动态规划是一种用来解决一类最优化问题的算法思想。<br>即将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得到原问题的最优解。<br>动态规划会将每个求解过的子问题的解记录下来，这样当下一次碰到同样的子问题时，就可以直接使用之前记录的结果。</p><h2 id="动态规划的递归写法"><a href="#动态规划的递归写法" class="headerlink" title="动态规划的递归写法"></a>动态规划的递归写法</h2><p>以求解斐波那契数列为例<br>f0=1,f1=1,f(n)=f(n-1)+f(n-2)(n&gt;=2)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f(n<span class="number">-1</span>)+f(n<span class="number">-2</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码就涉及到了很多重复计算，严重增大了时间复杂度<br>为了便重复计算，可以开一个dp数组，用来保存已经计算过的结果<br>其中dp[n]表示f(n)的结果<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dp[n]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[n];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dp[n] = f(n<span class="number">-1</span>)+f(n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种做法将复杂度由O(2^n)降到了O(n)，这也是名词记忆化搜索的由来。</p><h2 id="动态规划的递推写法"><a href="#动态规划的递推写法" class="headerlink" title="动态规划的递推写法"></a>动态规划的递推写法</h2><p>以数塔问题为例<br>从顶部出发在每一个节点可以选择向左或者向右走，一直走到底层，要求找出一条路径，<br>使得路径上的数字之和最大.<br>不妨令dp[i][j]表示从第i行第j个数字出发的到达底层的所有路径中能得到的最大和。<br>于是dp[1][1]就是dp[2][1]和dp[2][2]的较大值加上5<br>即： dp[1][1] = max(dp[2][1],dp[2][2]+f[1][1])</p><p>状态转移方程：<br>dp[i][j] = max(dp[i+1][j],dp[i+1][j+1]+f[i][j])<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn],dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;f[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        dp[n][j] = f[n][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            dp[i][j] = max(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>])+f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用递推写法采用自底向上，即从边界开始，不断向上解决问题，直到解决目标问题<br>使用递归写法采用自顶向下，即从目标问题开始，将她分解成子问题的组合，直到分解至边界为止</p><ul><li>一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决</li></ul><ol><li><p>分治与动态规划：分治和动态规划都是讲问题分解成子问题，然后合并子问题的解得到原问题的解。<br>但是分治法分解出的子问题时不重叠的，因此分治法解决的问题不拥有重叠子问题，而动态规划解决的问题拥有重叠子问题<br>另外，分治法解决的问题不一定是最优化问题，而动态规划解决的一定是最优化问题</p></li><li><p>贪心和动态规划：贪心和动态规划都要求原问题必须拥有最优子结构。<br>贪心并不等待子问题求解完毕后在选择使用哪一个，而是通过一种策略直接选择一个问题去求解，没被选择的子问题就<br>不在去求解，直接抛弃。<br>而动态规划不管是自底向上还是自顶向下，都是从边界开始向上得到目标问题的解。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划的递归写法和递推写法&quot;&gt;&lt;a href=&quot;#动态规划的递归写法和递推写法&quot; class=&quot;headerlink&quot; title=&quot;动态规划的递归写法和递推写法&quot;&gt;&lt;/a&gt;动态规划的递归写法和递推写法&lt;/h1&gt;&lt;p&gt;动态规划是一种算法思想，没有固定写法，十分灵
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://huangyiblog.com/算法和数据结构/拓扑排序/</id>
    <published>2018-05-11T13:09:24.000Z</published>
    <updated>2018-05-11T13:13:08.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有向无环图"><a href="#有向无环图" class="headerlink" title="有向无环图"></a>有向无环图</h1><p>如果一个有向图的任意顶点都无法通过一些有向边回到自身，那么称这个有向图为有向无环图。</p><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>拓扑排序是将有向无环图G的所有顶点排成一个线性序列，使得对图G中的任意两个顶点u，v，如果<br>存在边u-&gt;v,那么在序列中u一定在v前面。该序列被称为拓扑序列。<br>求解拓扑序列：</p><ol><li>定义一个队列q,并把所有入度为0的结点加入队列</li><li>取队首结点，输出。然后删去所有从它出发的边，并令这些边到达的顶点的入度减1，如果某个顶点的入度减为0，则将其加入队列。</li><li>反复进行2操作，直到队列为空。如果队列为空时入队的结点数目恰好为n，说明拓扑排序成功，图G为有向无环图；<br>否则，拓扑排序失败，图G中有环。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxv];</span><br><span class="line"><span class="keyword">int</span> n,m,inDegree[maxv];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,u);</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        G[u].clear();</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用拓扑排序可以判断一个給定的图是否为有向无环图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;有向无环图&quot;&gt;&lt;a href=&quot;#有向无环图&quot; class=&quot;headerlink&quot; title=&quot;有向无环图&quot;&gt;&lt;/a&gt;有向无环图&lt;/h1&gt;&lt;p&gt;如果一个有向图的任意顶点都无法通过一些有向边回到自身，那么称这个有向图为有向无环图。&lt;/p&gt;
&lt;h1 id=&quot;拓扑排
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>最小生成树</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://huangyiblog.com/算法和数据结构/最小生成树/</id>
    <published>2018-05-10T12:21:08.000Z</published>
    <updated>2018-05-10T12:21:48.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>最小生成树（MST）是在一个給定的无向图G(v,e)中求一棵树T，使得这棵树拥有图G中的所有顶点，且所有边都是来自<br>图G中的边，并且满足整棵树的边权之和最小。</p><p>三个重要性质</p><ol><li>最小生成树是树，因此其边数等于顶点数减1，且树内一定不会有环。</li><li>对給定的图G（v,e），其最小生成树可以不唯一，但其边权之和一定是唯一的。</li><li>由于最小生成树是在无向图中生成的，因此其根结点可以是这棵树上的任意一个结点，于是，<br>如果题目中涉及最小生成树本身的输出，为了让最小生成树唯一，一般都会直接给出根结点。</li></ol><p>求最小生成树一般有两种算法，即prim算法和kruskal算法。这两种算法均采用了贪心的思想。</p><h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><p>基本思想：对图G（v，e）设置集合s，存放已被访问的顶点，然后每次从集合v-s中选择与集合s的最短距离最小的一个顶点（记为u）<br>访问并加入集合s。之后，令顶点u为中介点，优化所有从u能到达的顶点v与集合s之间的最短距离。<br>这样的操作执行n次，直到集合s已包含所有顶点。其实思路与Dijstra算法类似。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//邻接矩阵写法</span></span><br><span class="line"><span class="keyword">int</span> n,g[maxv][maxv];</span><br><span class="line"><span class="keyword">int</span> d[maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;<span class="comment">//默认0为初始点，返回最小生成树边权之和</span></span><br><span class="line">    fill(d,d+maxv,inf);</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,minm = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">//找到未被访问的顶点中d[]最小的</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minm)&#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minm = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找不到小于inf的d[u],则剩下的顶点和集合s不连通</span></span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        ans+= d[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;<span class="comment">//v未被访问&amp;&amp;u能到达v&amp;&amp;以u为中介点可以使v离集合s更近</span></span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;g[u][v]!=inf&amp;&amp;g[u][v]&lt;d[v])&#123;</span><br><span class="line">                d[v] = g[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//邻接表写法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(d,d+maxv,inf);</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,minm = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minm)&#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minm = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        ans+ = d[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;Adj[u][j]&lt;div)&#123;</span><br><span class="line">                d[v] = g[u][[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h3><p>kruskal算法采用的是边贪心的策略<br>基本思想：在初始状态时隐去图中的所有边，这样图中每个顶点都自成一个连通块。之后执行如下步骤：</p><ol><li>对所有边按边权从小到大排序</li><li>按边权从小到大测试所有边，如果当前测试边所连接的两个顶点不在同一个连通块中，则把这条测试边加入到当前最小生成树中；否则，将边舍弃</li><li>执行步骤2，直到最小生成树中的边数等于总顶点数减1或是测试完所有边时结束。<br>当结束时如果最小生成树的边数小于总顶点数减1，说明该图不连通。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">int</span> cost;<span class="comment">//边权</span></span><br><span class="line">&#125;e[maxe];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost&lt;b.cost;</span><br><span class="line">&#125;</span><br><span class="line">伪代码</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    令最小生成树的边权之和为ans，最小生成树的当前边数为Num_Edge;</span><br><span class="line">    将所有边按边权从小到大排序;</span><br><span class="line">    <span class="keyword">for</span>(从小到大枚举所有边)&#123;</span><br><span class="line">        <span class="keyword">if</span>(当前测试边的两个端点在不同的连通块中)&#123;</span><br><span class="line">            将该测试边加入最小生成树中;</span><br><span class="line">            ans+=测试边的边权;</span><br><span class="line">            最小生成树的当前边数为Num_Edge+<span class="number">1</span>;</span><br><span class="line">            当边数Num_Edge等于顶点数减<span class="number">1</span>时结束循环;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">其中 并查集可以通过查询两个结点所在集合的根结点是否相同来判断他们是否在同一个集合</span><br><span class="line">而只要把测试边的两个端点所在集合合并，就能达到将边加入最小生成树的效果</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[n];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findfather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,Num_Edge = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e,e+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> fau = findfather(e[i].u);</span><br><span class="line">        <span class="keyword">int</span> fav = findfather(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(fau!=fav)&#123;</span><br><span class="line">            father[fau] = fav;</span><br><span class="line">            ans += e[i].cost;</span><br><span class="line">            Num_Edge++;</span><br><span class="line">            <span class="keyword">if</span>(Num_Edge==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Num_Edge!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kruskal算法的时间复杂度主要来源于对边进行排序<br>所以其时间复杂度为O(eloge)<br>综合来看：如果是稠密图（边多），则用prim算法；如果是稀疏图（边少），则用kruskal算法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最小生成树&quot;&gt;&lt;a href=&quot;#最小生成树&quot; class=&quot;headerlink&quot; title=&quot;最小生成树&quot;&gt;&lt;/a&gt;最小生成树&lt;/h1&gt;&lt;p&gt;最小生成树（MST）是在一个給定的无向图G(v,e)中求一棵树T，使得这棵树拥有图G中的所有顶点，且所有边都是来自&lt;
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>memset与fill</title>
    <link href="http://huangyiblog.com/%E8%AF%AD%E8%A8%80/memset%E4%B8%8Efill/"/>
    <id>http://huangyiblog.com/语言/memset与fill/</id>
    <published>2018-05-10T04:45:43.000Z</published>
    <updated>2018-05-10T04:53:18.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h1><p>memset是计算机中C/C++语言函数。将s所指向的某一块内存中的后n个 字节的内容全部设置为ch指定的ASCII值，</p><p>第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作， 其返回值为s。</p><p>头文件:memory.h或string.h</p><p>函    数：void *memset</p><p>原    型 (void *s,int ch,size_t n);</p><p>void <em>memset(void </em>s, int ch, size_t n);</p><p>函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。</p><p>memset：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法</p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>第一：memset函数按字节对内存块进行初始化，所以不能用它将int数组初始化为0和-1之外的其他值（除非该值高字节和低字节相同）。</p><p>第二：memset(void *s, int ch,size_tn);中key实际范围应该在0~~255，</p><p>因为该函数只能取ch的后八位赋值给你所输入的范围的每个字节，</p><p>比如int a[5]赋值memset（a,-1,sizeof(int )<em>5）与memset（a,511,sizeof(int )</em>5） 所赋值的结果是一样的都为-1；</p><p>因为-1的二进制码为（11111111 11111111 11111111 11111111）而511的二进制码为（00000000 00000000 00000001 11111111）后八位都为（11111111)，</p><p>所以数组中每个字节，如a[0]含四个字节都被赋值为（11111111），其结果为a[0]（11111111 11111111 11111111 11111111），</p><p>及a[0]=-1，因此无论ch多大只有后八位二进制有效，而八位二进制 [2]  的范围（0~255）YKQ改。</p><p>而对字符数组操作时则取后八位赋值给字符数组，其八位值作为ASCII [3]  码。</p><p>第三： 搞反了 ch 和 n 的位置.</p><p>一定要记住如果要把一个char a[20]清零，一定是 memset(a,0,20*sizeof(char));</p><p>而不是 memset(a,20*sizeof(char),0);</p><h1 id="fill-函数"><a href="#fill-函数" class="headerlink" title="fill()函数"></a>fill()函数</h1><p>用途：</p><ul><li><p>按照单元赋值，将一个区间的元素都赋同一个值</p></li><li><p>fill(arr, arr + n, 要填入的内容);</p></li></ul><p>头文件：<algorithm></algorithm></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];    fill(arr, arr + <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="与memset-函数的区别："><a href="#与memset-函数的区别：" class="headerlink" title="与memset()函数的区别："></a>与memset()函数的区别：</h2><p>两者都可以用来对数组填充，memset是对按照字节来填充的，所以一般用来填充char型数组，也经常用于填充int型的全0或全-1操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(arr));</span><br></pre></td></tr></table></figure><p>fill是按照单元来填充的，所以可以填充一个区间的任意值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">fill(arr,arr+<span class="number">10</span>,<span class="number">65</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;fill(arr.begin(),arr.end(),<span class="number">65</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;memset&quot;&gt;&lt;a href=&quot;#memset&quot; class=&quot;headerlink&quot; title=&quot;memset&quot;&gt;&lt;/a&gt;memset&lt;/h1&gt;&lt;p&gt;memset是计算机中C/C++语言函数。将s所指向的某一块内存中的后n个 字节的内容全部设置为ch指定的A
      
    
    </summary>
    
      <category term="语言" scheme="http://huangyiblog.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++" scheme="http://huangyiblog.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>最短路问题</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    <id>http://huangyiblog.com/算法和数据结构/最短路问题/</id>
    <published>2018-05-09T11:45:53.000Z</published>
    <updated>2018-05-09T11:47:36.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>最短路径是图论中的一个经典问题：给定图G(v,e)，求一条从起点到终点的路径，使得这条路径上经过的<br>所有边的边权之和最小。</p><p>即解决如下问题：<br>对任意给出的图G（v，e）和起点s，终点t，如何求从s到t的最短路径<br>解决最短路径的常用算法有Dijkstra算法、Bellman-Ford算法，SPFA算法和Floyd算法</p><h3 id="Dijstra算法"><a href="#Dijstra算法" class="headerlink" title="Dijstra算法"></a>Dijstra算法</h3><p>Dijstra算法用来解决单源最短路问题，即给定图G和起点s，通过算法得到s到达其他每个顶点的最短距离。<br>基本思想：对图G（v，e）设置集合s，存放已被访问的顶点，然后每次从集合v-s中选择与起点s的最短距离最小的一个顶点<br>（记为u），访问并加入集合s。之后，令顶点u为中介点，优化起点s与所有从u能到达的顶点v之间的最短距离。<br>这样的操作执行n次，直到集合s已包含所有顶点。<br>算法策略：<br>设置集合s存放已被访问的顶点，然后执行n次下面的两个步骤</p><ol><li>每次从集合v-s中选择与起点s的最短距离最小的一个顶点（记为u），访问并加入集合s</li><li>之后，令顶点u为中介点，优化起点s与所有从u能到达的顶点v之间的最短距离</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">伪代码</span><br><span class="line">Dijkstra(G,d[],s)&#123;</span><br><span class="line">  初始化;</span><br><span class="line">  <span class="keyword">for</span>(循环n次)&#123;</span><br><span class="line">      u = 使d[u]最小的还未被访问的顶点的标号;</span><br><span class="line">      记u已被访问;</span><br><span class="line">      <span class="keyword">for</span>(从u出发能到达的所有顶点v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v未被访问&amp;&amp;以u为中介点使s到顶点v的最短距离d[v]更优)&#123;</span><br><span class="line">         优化d[v];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//邻接矩阵版</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> maxv = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> n,G[maxv][maxv];</span><br><span class="line"><span class="keyword">int</span> d[maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d,d+maxv,inf);<span class="comment">//fill函数将整个d数组赋值为inf</span></span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>,minm = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minm)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                minm = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>;v&lt;n;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[v] == <span class="literal">false</span>&amp;&amp;G[u][v]!=inf&amp;&amp;d[u]+G[u][v]&lt;d[v])&#123;</span><br><span class="line">                d[v] = d[u]+G[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表版</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> v,dis;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d,d+maxv,inf);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,minm=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;d[j]&lt;minm)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                minm=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = Adj[u][j].v;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;d[u]+Adj[u][j].dis&lt;d[v])&#123;</span><br><span class="line">                d[v] = d[u] + Adj[u][j].dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h1><p>Dijstra算法可以很好地解决无负权图的最短路径问题，但如果出现了负权边，Dijstra算法会失效。<br>Bellman-Ford和Dijstra一样，也可以解决单源最短路径问题，同时能处理有负权边的情况。</p><p>由于Bellman-Ford算法需要遍历所有边，所以使用邻接表会比邻接矩阵方便<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis;<span class="comment">//v为邻接边的目标顶点，dis为邻接边的边权</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv]; <span class="comment">//图G的邻接表</span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//n为顶点数，maxv为最大顶点数</span></span><br><span class="line"><span class="keyword">int</span> d[maxv]; <span class="comment">//起点到达各边的最短路径长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d,d+maxv,inf);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">                <span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line">                <span class="keyword">if</span>(d[u]+dis&lt;d[v])&#123;</span><br><span class="line">                    d[v]=d[u]+dis;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下为判断负环的代码</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">            <span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line">            <span class="keyword">if</span>(d[u]+dis&lt;d[v])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于Bellman-Ford算法的时间复杂度达到了O(ve),这并不如意，所以需要进行优化，<br>Bellman-Ford的每轮操作都需要操作所有边，这其中会有大量无意义操作，严重影响了算法性能。<br>由于，只有当某个顶点u的d[u]值改变时，从它出发的邻接点v的d[v]值才有可能被改变。<br>所以可以如下优化：<br>建立一个队列，每次将队首顶点u取出，然后对从u出发的所有边u-&gt;v进行松弛操作，<br>即判断d[u]+length[u-&gt;v]&lt;d[v]是否成立，如果成立，则用d[u]+length[u-&gt;v]覆盖d[v];<br>如果v不在队列中，就把v加入队列。<br>这样操作直到队列为空（说明图中没有从源点可达的负环），或某个顶点的入队次数超过v-1（说明图中存在从源点可达的负环）</p><h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p>上述被优化后的算法即为SPFA算法，期望时间复杂度为O(ve)<br>但如果图中有从源点可达的负环，则SPFA的时间复杂度又会退化为O(ve)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Node&gt; ADj[maxv];</span><br><span class="line"><span class="keyword">int</span> n,d[maxv],num[maxv];</span><br><span class="line"><span class="keyword">bool</span> inq[maxv];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(inq,<span class="literal">false</span>,<span class="keyword">sizeof</span>(inq));</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">    fill(d,d+maxv,inf);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    inq[s]=<span class="literal">true</span>;</span><br><span class="line">    num[s]++;</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        inq[u]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">            <span class="keyword">int</span> dis=Adj[u][j].dis;</span><br><span class="line">            <span class="keyword">if</span>(d[u]+dis&lt;d[v])&#123;</span><br><span class="line">                d[v]=d[u]+dis;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v])&#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    inq[v]=<span class="literal">true</span>;</span><br><span class="line">                    num[v]++;</span><br><span class="line">                    <span class="keyword">if</span>(num[v]&gt;=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Flord算法"><a href="#Flord算法" class="headerlink" title="Flord算法"></a>Flord算法</h1><p>Flord算法用来解决全源最短路问题。<br>即对給定的图G（v,e），求任意两点u，v之间的最短路径长度，时间复杂度为O(n^3)所以顶点数要限制约在200以内。<br>用邻接矩阵来实现Flord算法比较合适。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf =<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv =<span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dis[maxv][maxv];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Flord</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][k]!=inf&amp;&amp;dis[k][j]!=inf&amp;&amp;dis[i][k]+dis[k][j]&lt;dis[i][j])&#123;</span><br><span class="line">                    dis[i][j]=dis[i][k]+dis[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    fill(dis[<span class="number">0</span>],dis[<span class="number">0</span>]+maxv*maxv,inf);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dis[i][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        dis[u][v]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    Flord();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,dis[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路径&quot;&gt;&lt;a href=&quot;#最短路径&quot; class=&quot;headerlink&quot; title=&quot;最短路径&quot;&gt;&lt;/a&gt;最短路径&lt;/h1&gt;&lt;p&gt;最短路径是图论中的一个经典问题：给定图G(v,e)，求一条从起点到终点的路径，使得这条路径上经过的&lt;br&gt;所有边的边权之和最
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>图的存储和遍历</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/"/>
    <id>http://huangyiblog.com/算法和数据结构/图的存储和遍历/</id>
    <published>2018-05-04T09:10:20.000Z</published>
    <updated>2018-05-04T09:12:06.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><p>图的存储一般有两种方式：邻接矩阵和邻接表</p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>设图G(V,E)的顶点标号为0,1，……n-1，则令二维数组G[n][n]的两维分别表示图的顶点标号。<br>即如果G[i][j]等于1，指顶点i和顶点j之间有边，如果G[i][j]等于0，指顶点i和顶点j之间没有边，<br>如果为有权图，则令G[i][j]存放边权。<br>但如果题目中顶点数过大，可能会造成内存超限。</p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>图的常用储存结构之一，由表头结点和表结点两部分组成，其中表头结点存储图的各顶点，<br>表结点用单向链表存储表头结点所对应顶点的相邻顶点（也就是表示了图的边）。<br>在有向图里表示表头结点指向其它结点（a-&gt;b）,无向图则表示与表头结点相邻的所有结点（a—b）<br><img src="https://img-blog.csdn.net/20170516155825235?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzMyNDAxMjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表头结点（表示图的顶点）  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vnode</span>&#123;</span>  </span><br><span class="line">       <span class="keyword">char</span> data;             <span class="comment">//顶点数据，这里用字符表示  </span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span> * <span class="title">firstarc</span>;</span>   <span class="comment">//指针指向第一条边   </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">//表结点（表示图的边）  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span>&#123;</span>  </span><br><span class="line">       <span class="keyword">int</span> wt;           <span class="comment">//权重  </span></span><br><span class="line">       <span class="keyword">int</span> adjvex;     <span class="comment">//顶点下标  </span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span> *<span class="title">nextarc</span>;</span>   <span class="comment">//指针指向下一条边  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">arcnode</span> * <span class="title">Arc</span>;</span>  </span><br><span class="line"><span class="comment">//图  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mgraph</span>&#123;</span>  </span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">vnode</span> <span class="title">vexs</span>[100];</span>  </span><br><span class="line">       <span class="keyword">int</span> vexsnum,arcnum;     <span class="comment">//顶点数，边数  </span></span><br><span class="line">&#125; *g;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mgraph</span>* <span class="title">Graph</span>;</span></span><br></pre></td></tr></table></figure><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h3 id="用DFS遍历图"><a href="#用DFS遍历图" class="headerlink" title="用DFS遍历图"></a>用DFS遍历图</h3><p>沿着一条路径直到无法继续前进，才退回到路径上离当前顶点最近的还存在未访问分支顶点的岔道口，并前往访问那些未访问的分支节点，直至遍历完成</p><ul><li>连通分量：在无向图中，如果两个顶点可以互相到达，则称这两个顶点连通，如果图G（V，E）的任意两个顶点都连通，则称图G为连通图，<br>否则，称图G为非连通图，且称其中的极大连通子图为连通分量。</li><li>强连通分量：在有向图中，如果两个顶点可以各自通过一条有向路径到达另一个顶点，则称这两个顶点强联通。如果一个图的任意两个顶点都强联通，<br>则称这个图为强连通图；否则这个图为非强连通图，且称其中的极大连通子图为强联通分量。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">伪代码</span><br><span class="line">DFS(u)&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(从u出发能到达的所有顶点v)</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)</span><br><span class="line">        DFS(v);</span><br><span class="line">&#125;</span><br><span class="line">DFSTrave(G)&#123;</span><br><span class="line">    <span class="keyword">for</span>(G的所有顶点u)</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)</span><br><span class="line">        DFS(u);</span><br><span class="line">&#125;</span><br><span class="line">邻接矩阵实现</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,G[maxv][maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=inf)&#123;</span><br><span class="line">            dfs(v,depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfstrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)&#123;</span><br><span class="line">            dfs(u,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">邻接表实现</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[maxv];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    vis[u] =<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">            dfs(v,depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfstrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)&#123;</span><br><span class="line">            dfs(u,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="用BFS遍历图"><a href="#用BFS遍历图" class="headerlink" title="用BFS遍历图"></a>用BFS遍历图</h3><p>类似树的遍历，遍历图需要使用一个队列，通过反复取出队首顶点，将该顶点可到达的未曾加入过队列的顶点全部入队，直到队列为空时遍历结束。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">伪代码</span><br><span class="line">BFS(u)&#123;</span><br><span class="line">    <span class="built_in">queue</span> q;</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q非空)&#123;</span><br><span class="line">        取出q的队首元素加以访问;</span><br><span class="line">        <span class="keyword">for</span>(从u出发能到达的所有顶点v)</span><br><span class="line">        <span class="keyword">if</span>(inq[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">            将v入队;</span><br><span class="line">            inq[v]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BFSTrave(G)&#123;</span><br><span class="line">    <span class="keyword">for</span>(G的所有顶点u)</span><br><span class="line">        <span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BFS(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">邻接矩阵实现</span><br><span class="line"><span class="keyword">int</span> n,G[maxv][maxv];</span><br><span class="line"><span class="keyword">bool</span> inq[maxv]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u.q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inq[v]==<span class="literal">false</span>&amp;&amp;G[u][v]!=inf)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                inq[v]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)&#123;</span><br><span class="line">            BFS(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">邻接表实现</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[maxv];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> inq[maxv]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">            <span class="keyword">if</span>(inq[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                inq[v]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)&#123;</span><br><span class="line">            BFS(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> edges[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">///邻接矩阵  </span></span><br><span class="line">    <span class="keyword">int</span> n;  </span><br><span class="line">    <span class="keyword">int</span> e;  </span><br><span class="line">&#125;graph;  </span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">100</span>];<span class="comment">///访问数组  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creategraph</span><span class="params">(graph &amp;G)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i,j;  </span><br><span class="line">    <span class="keyword">int</span> s,t;  </span><br><span class="line">    <span class="keyword">int</span> v;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.n;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.n;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            G.edges[i][j]=<span class="number">0</span>;<span class="comment">///邻接表初始化  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        vis[i]=<span class="literal">false</span>;<span class="comment">///访问数组初始化  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.e;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t&gt;&gt;v;<span class="comment">///读入顶点数边数和权值  </span></span><br><span class="line">        G.edges[s][t]=v;<span class="comment">///赋值  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(graph G,<span class="keyword">int</span> v)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,v);  </span><br><span class="line">    vis[v]=<span class="literal">true</span>;<span class="comment">///访问第v个定点，并将访问数组置为true  </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.n;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(G.edges[v][i]!=<span class="number">0</span>&amp;&amp;vis[i]==<span class="literal">false</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            dfs(G,i);<span class="comment">///如果i未被访问递归调用dfs  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(graph G,<span class="keyword">int</span> v)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Q;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,v);  </span><br><span class="line">    vis[v]=<span class="literal">true</span>;  </span><br><span class="line">    Q.push(v);  </span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> i,j;  </span><br><span class="line">        i=Q.front();<span class="comment">///取队头元素  </span></span><br><span class="line">        Q.pop();<span class="comment">///队头元素出队  </span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.n;j++)  </span><br><span class="line">        &#123;<span class="comment">///检查所有邻接点  </span></span><br><span class="line">            <span class="keyword">if</span>(G.edges[i][j]!=<span class="number">0</span>&amp;&amp;vis[j]==<span class="literal">false</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,j);  </span><br><span class="line">                vis[j]=<span class="literal">true</span>;  </span><br><span class="line">                Q.push(j);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n,e;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"输入图的顶点数和边数："</span>);  </span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;e;  </span><br><span class="line">        graph G;  </span><br><span class="line">        G.n=n;  </span><br><span class="line">        G.e=e;  </span><br><span class="line">        creategraph(G);  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"输出深度优先遍历序列："</span>);  </span><br><span class="line">        dfs(G,<span class="number">0</span>);  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"\n"</span>);  </span><br><span class="line">        creategraph(G);  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"输出广度优先遍历序列："</span>);  </span><br><span class="line">        bfs(G,<span class="number">0</span>);  </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"\n"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图的存储&quot;&gt;&lt;a href=&quot;#图的存储&quot; class=&quot;headerlink&quot; title=&quot;图的存储&quot;&gt;&lt;/a&gt;图的存储&lt;/h1&gt;&lt;p&gt;图的存储一般有两种方式：邻接矩阵和邻接表&lt;/p&gt;
&lt;h2 id=&quot;邻接矩阵&quot;&gt;&lt;a href=&quot;#邻接矩阵&quot; class=&quot;
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>堆的简介</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E7%9A%84%E7%AE%80%E4%BB%8B/"/>
    <id>http://huangyiblog.com/算法和数据结构/堆的简介/</id>
    <published>2018-05-03T11:53:51.000Z</published>
    <updated>2018-05-03T11:56:06.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆的定义与基本操作"><a href="#堆的定义与基本操作" class="headerlink" title="堆的定义与基本操作"></a>堆的定义与基本操作</h1><p>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子结点的值。<br>如果父亲结点的值大于或等于孩子结点的值，则称这样的堆为大顶堆，这时每个结点的值都是以它为根结点的子树的最大值；<br>如果父亲结点的值小于或等于孩子结点的值，则称这样的堆为小顶堆，这时每个结点的值都是以它为根结点的子树的最小值。<br>堆一般用于优先队列的实现，优先队列实现默认使用大顶堆。</p><h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><p>用数组来存储完全二叉树，则结点就按层序存储于数组中，其中第一个结点存于数组中的1号位，第i号结点的左孩子为2i，右孩子为2i+1<br>建堆采用结点向下调整的方法：<br>如果结点存在，总是将当前结点V与它的左右孩子进行比较，，假如孩子中存在权值比结点V大的，就将其中权值最大的那个孩子结点与结点V交换。<br>交换完毕后继续让结点V和孩子比较，直到结点V的孩子的权值都比结点V的权值小或是结点V不存在孩子结点<br>时间复杂度O(logn)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> heap[maxn],n=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//对heap数组在[low,high]范围进行向下调整</span></span><br><span class="line"><span class="comment">//low为欲调整结点的数组下标，high为堆的最后一个元素的数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=low,j=i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;=high&amp;&amp;heap[j+<span class="number">1</span>]&gt;heap[j])&#123;</span><br><span class="line">            i=j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(heap[j]&gt;heap[i])&#123;</span><br><span class="line">            swap(heap[j]&gt;heap[i]);</span><br><span class="line">            i=j;</span><br><span class="line">            j=i*<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        downAdjust(i,n);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">  heap[<span class="number">1</span>]=heap[n--];</span><br><span class="line">  downAdjust(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="往堆里添加一个元素"><a href="#往堆里添加一个元素" class="headerlink" title="往堆里添加一个元素"></a>往堆里添加一个元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=high,j=i/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;=low)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap[j]&lt;heap[i])&#123;</span><br><span class="line">            swap(heap[j],heap[i]);</span><br><span class="line">            i=j;</span><br><span class="line">            j=i/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    heap[++n]=x;</span><br><span class="line">    UpAdjust(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序是指使用堆结构对一个序列进行排序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    createHeap();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">        swap(heap[i],heap[<span class="number">1</span>]);</span><br><span class="line">        downAdjust(<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆的定义与基本操作&quot;&gt;&lt;a href=&quot;#堆的定义与基本操作&quot; class=&quot;headerlink&quot; title=&quot;堆的定义与基本操作&quot;&gt;&lt;/a&gt;堆的定义与基本操作&lt;/h1&gt;&lt;p&gt;堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子结点的值。&lt;br&gt;
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://huangyiblog.com/算法和数据结构/并查集/</id>
    <published>2018-05-02T11:49:07.000Z</published>
    <updated>2018-05-02T11:50:34.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并查集的定义"><a href="#并查集的定义" class="headerlink" title="并查集的定义"></a>并查集的定义</h1><p>并查集是一种维护集合的数据结构：合并（Union）、查找（Find）、集合（Set）<br>并查集支持以下两个操作：</p><ul><li>合并：合并两个集合</li><li>查找：判断两个元素是否在一个集合<br>通过数组即可实现<h2 id="并查集基本操作"><a href="#并查集基本操作" class="headerlink" title="并查集基本操作"></a>并查集基本操作</h2></li></ul><ol><li><p>初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  father[i]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找<br>由于规定同一个集合中只存在一个根结点，因此查找操作就是对給定的结点寻找其根结点的过程<br>实现方式：递推或递归<br>思路：反复寻找父亲结点，直到找到根结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递推低吗</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=father[x])&#123;</span><br><span class="line">        x=father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==father[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> findFather(father[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>3.合并<br>合并是指把两个集合合并成一个集合，题目中一般给出两个元素，要求把这两个元素所在集合合并。<br>一般是先判断两个元素是否属于同一集合，只有当两个元素属于不同集合时才合并，而合并的过程一般是<br>把其中一个集合的根结点的父亲指向另一个集合的根结点。<br>思路：</p><ul><li>对于給定的两个元素a，b，判断它们是否属于同一集合。可以调用查找函数对这两个元素分别查找根结点，然后判断其根节点是否相同</li><li>合并两个集合：在第一步中获得了两个元素的根结点faA和faB，因此只需要把其中一个的父亲结点指向另一个结点。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> faA=findFather(a);</span><br><span class="line">  <span class="keyword">int</span> fab=findFather(b);</span><br><span class="line">  <span class="keyword">if</span>(faA!=faB)&#123;</span><br><span class="line">    father[faA]=faB;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>并查集产生的每一个集合都是一棵树</p><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>当题目给出的元素数量很多并且形成一条链，则上述查找函数效率较低，需进行优化<br>把当前查询结点的路径上的所有结点的父亲都指向根结点，查找的时候就不需要一直回溯去找父亲了，查询复杂度降为O(1）<br>转换步骤：</p><ol><li>按原先的写法获得x的根结点r</li><li>重新从x开始走一遍寻找根结点的过程，把路径上经过的所有结点的父亲全部改为根结点r<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=x;</span><br><span class="line">  <span class="keyword">while</span>(x!=father[x])&#123;</span><br><span class="line">    x=father[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(a!=father[x])&#123;</span><br><span class="line">    <span class="keyword">int</span> z=a;</span><br><span class="line">    a=father[a];</span><br><span class="line">    father[z]=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(v==father[v]) <span class="keyword">return</span> v;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f=findFather(father[v]);</span><br><span class="line">    father[v]=f;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并查集的定义&quot;&gt;&lt;a href=&quot;#并查集的定义&quot; class=&quot;headerlink&quot; title=&quot;并查集的定义&quot;&gt;&lt;/a&gt;并查集的定义&lt;/h1&gt;&lt;p&gt;并查集是一种维护集合的数据结构：合并（Union）、查找（Find）、集合（Set）&lt;br&gt;并查集支持以下两
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://huangyiblog.com/算法和数据结构/平衡二叉树/</id>
    <published>2018-05-02T11:14:55.000Z</published>
    <updated>2018-05-02T11:16:10.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平衡二叉树的定义"><a href="#平衡二叉树的定义" class="headerlink" title="平衡二叉树的定义"></a>平衡二叉树的定义</h1><p>当使用序列{1,2,3,4,5}构建二叉查找树，会得到一棵长链条式的树，此时对这棵树中的结点进行查找，<br>时间复杂度会达到O(n)，为了优化数据查询，需要对树的结构进行调整，使树的高度在每次插入元素后仍能保持O(logn)<br>的级别，这样能让查询操作仍然为O(logn)的时间复杂度<br>AVL树仍然是一棵二叉查找树，只是在其基础上增加了平衡要求。<br>即对AVL树的任意结点来说，其左子树与右子树的高度之差的绝对值不超过1，其中左子树和右子树的高度之差称为该结点的平衡因子。<br>只要能随时保证每个结点的平衡因子的绝对值不超过1，AVL的高度就始终能保持O(logn)级别。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结点结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,height;</span><br><span class="line">    node *lchild,*rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//生成一个新结点，v为结点权值</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    node* Node = <span class="keyword">new</span> node;</span><br><span class="line">    Node-&gt;v=v;</span><br><span class="line">    Node-&gt;height=<span class="number">1</span>;</span><br><span class="line">    Node-&gt;lchild=Node-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取以root为根结点的子树的当前height</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算结点root的平衡因子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getHeight(root-&gt;lchild)-getHeight(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新结点root的height</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateHeight</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    root-&gt;height=max(getHeight(root-&gt;lchild),getHeight(root-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="平衡二叉树的基本操作"><a href="#平衡二叉树的基本操作" class="headerlink" title="平衡二叉树的基本操作"></a>平衡二叉树的基本操作</h2><ol><li><p>查找操作<br>类似于二叉查找树，由于AVL树的高度为O(logn)级别，所以查找操作的时间复杂度为O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"search failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==root-&gt;data)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;data)&#123;</span><br><span class="line">        search(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        search(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>旋转操作<br><img src="https://img-blog.csdn.net/20141201123218032?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29sbG9ubg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(node* &amp;root)</span></span>&#123;</span><br><span class="line">    node* temp=root-&gt;rchild;</span><br><span class="line">    root-&gt;rchild=temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild=root;</span><br><span class="line">    UpdateHeight(root);</span><br><span class="line">    UpdateHeight(temp);</span><br><span class="line">    root=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(node* &amp;root)</span></span>&#123;</span><br><span class="line">    node* temp=root-&gt;lchild;</span><br><span class="line">    root-&gt;lchild=temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild=root;</span><br><span class="line">    UpdateHeight(root);</span><br><span class="line">    UpdateHeight(temp);</span><br><span class="line">    root=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入操作<br>只要把最靠近插入结点的失衡结点调整到正常，路径上的所有结点就都会平衡<br>在二叉查找树的插入操作基础上从下往上判断结点是否失衡，因此需要在每个insert函数之后更新当前子树高度，<br>并在这之后根据树型是LL型、LR型、RR型、RL型之一来进行平衡操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=newNode(v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v&lt;root-&gt;v)&#123;</span><br><span class="line">        insert(root-&gt;lchild,v);</span><br><span class="line">        UpdateHeight(root);</span><br><span class="line">        <span class="keyword">if</span>(getBalanceFactor(root)==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild)==<span class="number">1</span>)&#123;</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild)==<span class="number">1</span>)&#123;</span><br><span class="line">                L(root-&gt;lchild);</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert(root-&gt;rchild,v);</span><br><span class="line">        UpdateHeight(root);</span><br><span class="line">        <span class="keyword">if</span>(getBalanceFactor(root)==<span class="number">-2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild)==<span class="number">1</span>)&#123;</span><br><span class="line">                R(root-&gt;rchild);</span><br><span class="line">                L(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AVL树的建立<br>建立在插入操作的基础上，依次插入n个结点即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    node* root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        insert(root,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;平衡二叉树的定义&quot;&gt;&lt;a href=&quot;#平衡二叉树的定义&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树的定义&quot;&gt;&lt;/a&gt;平衡二叉树的定义&lt;/h1&gt;&lt;p&gt;当使用序列{1,2,3,4,5}构建二叉查找树，会得到一棵长链条式的树，此时对这棵树中的结点
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉查找树</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>http://huangyiblog.com/算法和数据结构/二叉查找树/</id>
    <published>2018-05-01T13:38:15.000Z</published>
    <updated>2018-05-01T13:40:25.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><h2 id="二叉查找树的定义"><a href="#二叉查找树的定义" class="headerlink" title="二叉查找树的定义"></a>二叉查找树的定义</h2><p>二叉查找树是一种特殊的二叉树，又称二叉排序树、二叉搜索树。<br>二叉查找树的递归定义：</p><ol><li>二叉查找树要么为一棵空树。</li><li>二叉查找树要么为由根结点、左子树、右子树组成，其中左子树和右子树都是二叉查找树，<br>且左子树上所有结点的数据域均小于或等于根结点的数据域，右子树上所有结点的数据域均大于等于根节点的数据域。</li></ol><p>二叉查找树其实是一棵数据有序的树。即对树上的每个结点，都满足其左子树上所有结点的数据域均小于或等于根结点的数据域，<br>右子树上所有结点的数据域均大于根结点的数据域。</p><h1 id="二叉查找树的基本操作"><a href="#二叉查找树的基本操作" class="headerlink" title="二叉查找树的基本操作"></a>二叉查找树的基本操作</h1><ol><li>查找操作<br>由二叉查找树的性质得：可以只选择一棵子树进行遍历，因此查找将会是从树根到查找结点的一条路径，<br>故最坏时间复杂度为O(h),h为二叉查找树高度<br>基本思路：</li><li>如果当前根结点为空，则查找失败，返回</li><li>如果需要查找的值x等于当前根结点的数据域root-&gt;data，说明查找成功，访问</li><li>如果需要查找的值x小于当前根结点的数据域root-&gt;data,则向左子树root-&gt;lchild递归查找</li><li><p>如果需要查找的值x大于当前根结点的数据域root-&gt;data,则向右子树root-&gt;rchild递归查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"search failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==root-&gt;data)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;data)&#123;</span><br><span class="line">        search(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        search(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入操作<br>对一棵二叉查找树来说，查找某个数据域的结点一定是沿着确定的路径进行的。<br>当某个需要查找的值在二叉查找树中查找成功，说明结点已经存在；<br>反之，查找失败的地方一定是结点需要插入的位置。<br>插入操作的时间复杂对也是O(h)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            root=newNode(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==root-&gt;data)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;data)&#123;</span><br><span class="line">        insert(root-&gt;lchild,x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert(root-&gt;rchild,x);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉查找树的建立<br>建立一棵二叉查找树就是先后插入n个结点的过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    node* root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        insert(root,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉查找树的删除（确保删除后仍是一棵二叉查找树）<br>一般有两种做法，时间复杂度都为O(h)<br>删除操作的基本思路：</p></li><li>如果当前结点root为空，说明不存在权值为x的结点，返回</li><li>如果当前结点root的权值恰为给定的权值x，说明找到了想要删除的结点，进入删除处理<br>a. 如果当前结点root不存在左右孩子，说明是叶子结点，直接删除<br>b. 如果当前结点root存在左孩子，那么在左子树中寻找结点前驱pre，然后让pre的数据覆盖root，接着在右子树中删除节点next<br>c. 如果当前结点root存在右孩子，那么在右子树中寻找结点后继next，然后让next的数据覆盖root，接着在右子树中删除节点next</li><li>如果当前结点root的权值大于给定的权值x，则在左子树中递归删除权值为x的结点</li><li>如果当前结点root的权值大于給定的权值x，则在右子树中递归删除权值为x的结点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找以root为根结点的树中的最大权值结点</span></span><br><span class="line"><span class="function">node* <span class="title">findMax</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;rchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=root-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找以root为根结点的树中权值最小的结点</span></span><br><span class="line"><span class="function">node* <span class="title">findMin</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=root-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(node* &amp;root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data==x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;root-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            root=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        node* pre=findMax(root-&gt;lchild);</span><br><span class="line">        root-&gt;data=pre-&gt;data;</span><br><span class="line">        deleteNode(root-&gt;lchild,pre-&gt;data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        node* next=findMin(root-&gt;rchild);</span><br><span class="line">        root-&gt;data=next-&gt;data;</span><br><span class="line">        deleteNode(root-&gt;rchild,next-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data&gt;x)&#123;</span><br><span class="line">    deleteNode(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    deleteNode(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="二叉查找树的性质"><a href="#二叉查找树的性质" class="headerlink" title="二叉查找树的性质"></a>二叉查找树的性质</h2><p>对二叉查找树进行中序遍历，遍历的结果是有序的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二叉查找树&quot;&gt;&lt;a href=&quot;#二叉查找树&quot; class=&quot;headerlink&quot; title=&quot;二叉查找树&quot;&gt;&lt;/a&gt;二叉查找树&lt;/h1&gt;&lt;h2 id=&quot;二叉查找树的定义&quot;&gt;&lt;a href=&quot;#二叉查找树的定义&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>树的遍历</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://huangyiblog.com/算法和数据结构/树的遍历/</id>
    <published>2018-04-30T12:12:22.000Z</published>
    <updated>2018-04-30T12:14:03.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><h3 id="树的静态写法"><a href="#树的静态写法" class="headerlink" title="树的静态写法"></a>树的静态写法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">typename</span> data;<span class="comment">//数据域</span></span><br><span class="line">  <span class="keyword">int</span> child[maxn];<span class="comment">//指针域，存放所有子结点的下标</span></span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;</span><br><span class="line">    <span class="built_in">vector</span> child;</span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    Node[index].data=v;</span><br><span class="line">    Node[index].child.clear();</span><br><span class="line">    <span class="keyword">return</span> index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树的先根遍历"><a href="#树的先根遍历" class="headerlink" title="树的先根遍历"></a>树的先根遍历</h3><p>先访问根结点，在访问子树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,Node[root].data);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[root].child/size();i++)&#123;</span><br><span class="line">        preorder(Node[root].child[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="树的层序遍历"><a href="#树的层序遍历" class="headerlink" title="树的层序遍历"></a>树的层序遍历</h3><p>与二叉树的层序遍历类似，一般使用一个队列来存放结点在数组中的下标，每次取出队首元素来访问，并将<br>其所有子结点加入队列，直到队列为空。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> front=q.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,Node[front].data);</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[front].child.size();i++)&#123;</span><br><span class="line">            q.push(Node[front].child[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要对结点的层次进行记录</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> layer;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    Node[root].layer=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> front=q.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,Node[front].data);</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[front].child.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> child = Node[front].child[i];</span><br><span class="line">            q.push(Node[front].child[i]);</span><br><span class="line">            q.push(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;树的遍历&quot;&gt;&lt;a href=&quot;#树的遍历&quot; class=&quot;headerlink&quot; title=&quot;树的遍历&quot;&gt;&lt;/a&gt;树的遍历&lt;/h1&gt;&lt;h3 id=&quot;树的静态写法&quot;&gt;&lt;a href=&quot;#树的静态写法&quot; class=&quot;headerlink&quot; title=&quot;树的静态写
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
</feed>
