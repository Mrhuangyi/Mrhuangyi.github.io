<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你的小黄^_^</title>
  <icon>https://www.gravatar.com/avatar/3a25a3ab34305615e80247defadfd4f6</icon>
  <subtitle>做一名有情怀的程序员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huangyiblog.com/"/>
  <updated>2019-04-27T12:51:19.127Z</updated>
  <id>http://huangyiblog.com/</id>
  
  <author>
    <name>Mr.Huangyi</name>
    <email>18757163093@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis数据结构入门</title>
    <link href="http://huangyiblog.com/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/"/>
    <id>http://huangyiblog.com/业务开发/redis数据结构入门/</id>
    <published>2019-04-27T12:35:16.000Z</published>
    <updated>2019-04-27T12:51:19.127Z</updated>
    
    <content type="html"><![CDATA[<p><div align="center"> <img src="http://huangyiblog.com/redis.jpg" width="660"> </div><br></p><blockquote><p>参考资料：《redis设计与实现》</p></blockquote><h1 id="redis介绍"><a href="#redis介绍" class="headerlink" title="redis介绍"></a>redis介绍</h1><p><strong><em>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</em></strong></p><p>上面一段话是redis中文网的官方介绍。<br>有几个关键的点值得注意：</p><ul><li>redis属于内存存储，数据是存在内存里面的</li><li>redis本质是数据结构服务器，官方提供了各种数据结构供你使用，你可以将redis用作数据库或者缓存。</li><li>redis的存储方式为key-value的形式存储，所以redis是非关系型数据库</li></ul><a id="more"></a><h1 id="为什么我们要用redis"><a href="#为什么我们要用redis" class="headerlink" title="为什么我们要用redis"></a>为什么我们要用redis</h1><p>学一门技术之前往往会出现这么一个问题，它好在哪里，为什么值得学？值得用？<br>官方给出了以下几点优势：</p><ul><li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li><li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><p>我们看到上面第一点就是性能极高！！那么问题来了，redis是怎么做到这么快的读写速度的？这个问题我当时面试的时候也被问到过…说白了就是让你说清楚redis为什么很快？？</p><h1 id="redis为什么很快"><a href="#redis为什么很快" class="headerlink" title="redis为什么很快"></a>redis为什么很快</h1><p>关于redis为什么快的问题，有两点我们其实很容易想到：</p><ol><li>redis是基于内存的，内存的读写速度很快</li><li>redis是单线程的，在一定程度上减少了竞争锁和频繁的上下文切换</li></ol><p>我们知道一般数据库的读写都是需要经过磁盘的，而磁盘的读写速度相对于内存来说绝对是算慢的了，所以我们需要用缓存，我们希望不要每次进行读写都跑去数据库进行操作。mybatis为什么要设置一级缓存，二级缓存？主要还是为了不希望每次读取数据都要到数据库去读取，以提升性能。</p><p>但是除了上述两点，还有什么特点是提升了redis的性能的呢？</p><p>其实还有一点很重要：redis采用了非阻塞的网络IO多路复用技术来保证多连接的时候系统的高吞吐量。也就是指多个socket网络连接复用同一个线程。</p><p>另外还有两点：</p><ol start="4"><li>redis整体的hash数据结构提高了读取速度，以及压缩表和跳跃表等的使用。</li><li>redis采用了效率较高的事件分离器，内部采用非阻塞执行方式。</li></ol><h1 id="redis的数据类型"><a href="#redis的数据类型" class="headerlink" title="redis的数据类型"></a>redis的数据类型</h1><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">可以存储的值</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">STRING</td><td style="text-align:center">字符串、整数或者浮点数</td><td style="text-align:center">对整个字符串或者字符串的其中一部分执行操作<br> 对整数和浮点数执行自增或者自减操作</td></tr><tr><td style="text-align:center">LIST</td><td style="text-align:center">列表</td><td style="text-align:center">从两端压入或者弹出元素 <br> 对单个或者多个元素<br> 进行修剪，只保留一个范围内的元素</td></tr><tr><td style="text-align:center">SET</td><td style="text-align:center">无序集合</td><td style="text-align:center">添加、获取、移除单个元素<br> 检查一个元素是否存在于集合中<br> 计算交集、并集、差集<br> 从集合里面随机获取元素</td></tr><tr><td style="text-align:center">HASH</td><td style="text-align:center">包含键值对的无序散列表</td><td style="text-align:center">添加、获取、移除单个键值对<br> 获取所有键值对<br> 检查某个键是否存在</td></tr><tr><td style="text-align:center">ZSET</td><td style="text-align:center">有序集合</td><td style="text-align:center">添加、获取、删除元素<br> 根据分值范围或者成员来获取元素<br> 计算一个键的排名</td></tr></tbody></table><p>redis的存储形式为key-value，其中key为字符串，value可以是string、list、hash、set、zset。redis并没有直接使用这些数据结构来构建key-value数据库，而是基于这些数据结构构建了一个对象系统。每个相应的键对象、值对象都有自己的类型、编码、和指向底层数据结构的指针。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>string是redis最基本的类型，一个key对应一个value。<br>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p><p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name &quot;xiaohuang&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;xiaohuang&quot;</span><br><span class="line">127.0.0.1:6379&gt; del name</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></p><h3 id="SDS-简单动态字符串"><a href="#SDS-简单动态字符串" class="headerlink" title="SDS(简单动态字符串)"></a>SDS(简单动态字符串)</h3><p>redis自己构建了一种叫做简单动态字符串（SDS）的抽象类型，并将SDS用作redis的默认字符串表示。<br>每个sdshdr结构表示一个SDS值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"><span class="comment">//记录buf数组中已使用的字节数量</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="comment">//记录buf数组中未使用的字节数量</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="comment">//字节数组，用来保存字符串</span></span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><div align="center"> <img src="http://huangyiblog.com/sds.png" width="600"> </div><br></p><ul><li>C字符串和SDS的区别</li></ul><table><thead><tr><th>C字符串</th><th>SDS</th></tr></thead><tbody><tr><td>获取字符串长度的复杂度为O(N)</td><td>获取字符串长度的复杂度为O(1)</td></tr><tr><td>API不安全，可能会造成缓冲区溢出</td><td>API安全，不会造成缓冲区溢出</td></tr><tr><td>修改字符串长度n次必然要进行N次内存重分配</td><td>修改字符串N次最多需要N次内存重分配</td></tr><tr><td>只能保存文本数据</td><td>可以保存文本或二进制</td></tr><tr><td>可以使用所有&lt;string.h&gt;库函数</td><td>可以使用部分&lt;string.h&gt; 库函数</td></tr></tbody></table><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。</p><p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list-key redis</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush list-key mongodb</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush list-key java</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list-key 0 5</span><br><span class="line">1) &quot;mongodb&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">3) &quot;java&quot;</span><br></pre></td></tr></table></figure></p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li><p>redis列表键的底层实现之一为链表</p></li><li><p>每个链表结点listnode的结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"><span class="comment">//前置节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"><span class="comment">//后置节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="comment">//结点值</span></span><br><span class="line"><span class="keyword">void</span> *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure></li><li><p>list链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="comment">//表头节点</span></span><br><span class="line">listNode *head;</span><br><span class="line"><span class="comment">//表尾节点</span></span><br><span class="line">listNode *tail;</span><br><span class="line"><span class="comment">//链表节点数量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"><span class="comment">//节点值复制函数</span></span><br><span class="line"><span class="keyword">void</span> *(*dup) (<span class="keyword">void</span> *ptr);</span><br><span class="line"><span class="comment">//节点值释放函数</span></span><br><span class="line"><span class="keyword">void</span> *(*<span class="built_in">free</span>) (<span class="keyword">void</span> *ptr);</span><br><span class="line"><span class="comment">//节点值对比函数</span></span><br><span class="line"><span class="keyword">int</span> (*match) (<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></li></ul><p><div align="center"> <img src="http://huangyiblog.com/list.png" width="600"> </div><br></p><h3 id="redis链表特性"><a href="#redis链表特性" class="headerlink" title="redis链表特性"></a>redis链表特性</h3><ul><li>无环双向链表</li><li>获取表头指针和表尾指针的复杂度为O(1)</li><li>获取某个节点的前置节点和后置节点的复杂度为O(1)</li><li>获取链表中节点数量的复杂度为O(1)</li><li>链表使用 void*  指针来保存节点值，链表可以保存不同类型的值</li></ul><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>Redis hash 是一个键值对集合。</p><p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset hash-key field1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset hash-key field2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset hash-key field3 value3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset hash-key field1 value1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hgetall hash-key</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;value1&quot;</span><br><span class="line">3) &quot;field2&quot;</span><br><span class="line">4) &quot;value2&quot;</span><br><span class="line">5) &quot;field3&quot;</span><br><span class="line">6) &quot;value3&quot;</span><br><span class="line">127.0.0.1:6379&gt; hdel hash-key field1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget hash-key field2</span><br><span class="line">&quot;value2&quot;</span><br></pre></td></tr></table></figure></p><h3 id="hash表结构与哈希表节点结构"><a href="#hash表结构与哈希表节点结构" class="headerlink" title="hash表结构与哈希表节点结构"></a>hash表结构与哈希表节点结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line"><span class="comment">//哈希表数组</span></span><br><span class="line">dictEntry **table;</span><br><span class="line"><span class="comment">//哈希表大小</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line"><span class="comment">//哈希表大小掩码，用于计算索引值，总是等于size-1</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line"><span class="comment">//该哈希表已有节点数量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line"><span class="comment">//键</span></span><br><span class="line"><span class="keyword">void</span> *key;</span><br><span class="line"><span class="comment">//值</span></span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line"><span class="keyword">void</span> *val;</span><br><span class="line"><span class="keyword">uint64_t</span> u64;</span><br><span class="line"><span class="keyword">int64_t</span> s64;</span><br><span class="line">&#125;v;</span><br><span class="line"><span class="comment">//指向下个哈希表节点，形成链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure><p><div align="center"> <img src="http://huangyiblog.com/hash.png" width="600"> </div><br></p><h3 id="字典结构表示"><a href="#字典结构表示" class="headerlink" title="字典结构表示"></a>字典结构表示</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">dictType *type;</span><br><span class="line"><span class="keyword">void</span> *privdata;</span><br><span class="line">dictht ht[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> trehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line"><span class="comment">//计算哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="comment">//复制键</span></span><br><span class="line"><span class="keyword">void</span> *(*keyDup) (<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//复制值</span></span><br><span class="line"><span class="keyword">void</span> *(*valDup) (<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line"><span class="comment">//对比建</span></span><br><span class="line"><span class="keyword">int</span> (*keyCompare) (<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line"><span class="comment">//销毁键</span></span><br><span class="line"><span class="keyword">void</span> (*keyDestructor) (<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line"><span class="comment">//销毁值</span></span><br><span class="line"><span class="keyword">void</span> (*valDestructor) (<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125;dictType;</span><br></pre></td></tr></table></figure><p><div align="center"> <img src="http://huangyiblog.com/dict.png" width="600"> </div><br></p><p>当我们要插入新的键值对到字典里面的时候，首先要根据键值对的键计算得到哈希值，然后根据哈希值得到索引值，最后将相应包含键值对的哈希表节点放到哈希数组的制定索引位置。整个过程你会发现和Java里的HashMap很相似。<br><strong>hash = dict-&gt;type-&gt;hashFunction(key);</strong><br><strong>index = hash &amp; dict-&gt;ht[x].sizemask;</strong></p><p>当两个或两个以上的键被分配到哈希表数组的同一个索引出，我们认为此时发生了hash冲突。和HashMap相似，redis的哈希表也是使用链地址法来解决哈希冲突。被分配到同一个索引的多个结点可以利用next指针构成一个单链表，并且为了提升性能，总是将新节点添加到链表的表头位置(复杂度为O(1)),</p><p>但是rehash（重新散列）redis和Java并不同，redis采用的是渐进式rehash，而不是一次性完成。因为如果数据量过大，一次性rehash会导致较大的计算延时，可能会导致服务器在一段时间内停止服务。</p><p>具体的rehash步骤：</p><ul><li>为ht[0]分配空间，让字典同时持有ht[0]，ht[1]两个哈希表</li><li>在字典中维持一个索引计数器变量rehashidx，并将其设为0，表示rehash开始</li><li>在rehash期间，每次对字典执行添加、查找或更新操作时，程序除了执行指定的操作以外，还会将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash完成后，将rehashidx的值增加1</li><li>不断执行以上操作，当ht[0]的所有键值对都被rehash到ht[1]，程序将rehashidx的值设为-1，表示rehash完成。</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set-key redis</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set-key java</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set-key mysql</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set-key redis</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers set-key</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">3) &quot;mysql&quot;</span><br><span class="line">127.0.0.1:6379&gt; sismember set-key redis</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; srem set-key mysql</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers set-key</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br></pre></td></tr></table></figure></p><h3 id="整数集合-intset"><a href="#整数集合-intset" class="headerlink" title="整数集合(intset)"></a>整数集合(intset)</h3><p>整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且元素数量不多，redis会使用整数集合作为集合键的底层实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line"><span class="comment">//编码方式</span></span><br><span class="line"><span class="keyword">uint32_t</span> encoding;</span><br><span class="line"><span class="comment">//集合包含的元素数量</span></span><br><span class="line"><span class="keyword">uint32_t</span> length;</span><br><span class="line"><span class="comment">//保存元素的数组</span></span><br><span class="line"><span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure><p><div align="center"> <img src="http://huangyiblog.com/intset.png" width="600"> </div><br></p><p>关于整数集合如何升级，可以自行查阅黄建宏的《redis设计与实现》<br>redis的整数集合底层为有序，无重复的数组，有需要时，程序会改变数组类型。<br>整数集合只支持升级操作，不支持降级操作</p><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset-key 11 member1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset-key 9 member2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset-key 13 member3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset-key 13 member3</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;9&quot;</span><br><span class="line">3) &quot;member1&quot;</span><br><span class="line">4) &quot;11&quot;</span><br><span class="line">5) &quot;member3&quot;</span><br><span class="line">6) &quot;13&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;9&quot;</span><br><span class="line">3) &quot;member3&quot;</span><br><span class="line">4) &quot;13&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳跃表是一种有序数据结构，属于有序集合键的底层实现之一，它通过在每个节点中维持多个指向其他节点的指针，从而能够快速访问节点。<br>平均复杂度O(logN)，最坏O(N)复杂度,<br>如果一个有序集合包含的元素比较多，或者有序集合中元素的成员是比较长的字符串时，redis就会使用跳跃表来作为有序集合键的底层实现。<br>跳跃表除了在有序集合中用到，在redis的集群节点中也有用作内部数据结构。</p><p>跳跃表节点结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"><span class="comment">//后退指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"><span class="comment">//分值</span></span><br><span class="line"><span class="keyword">double</span> score;</span><br><span class="line"><span class="comment">//成员对象</span></span><br><span class="line">robj *obj;</span><br><span class="line"><span class="comment">//层</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"><span class="comment">//前进指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"><span class="comment">//跨度</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">&#125;level[];</span><br><span class="line">&#125;zskiplistNode;</span><br></pre></td></tr></table></figure></p><p>跳跃表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line"><span class="comment">//表头节点和表尾节点</span></span><br><span class="line">structz skiplistNode *header, *tail;</span><br><span class="line"><span class="comment">//表中节点数量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line"><span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line"><span class="keyword">int</span> level;</span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure><ul><li>每个跳跃表节点的层高都是1到32之间的随机数</li><li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须唯一</li><li>跳跃表中的节点按照分值大小进行排序，当分值相同，按照成员对象的大小进行排序</li></ul><p>与红黑树等平衡树相比，跳跃表的优势在于：</p><ul><li>插入速度快，不需要旋转等操作来维持平衡</li><li>支持无锁操作</li><li>实现相对简单</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://huangyiblog.com/redis.jpg&quot; width=&quot;660&quot;&gt; &lt;/div&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：《redis设计与实现》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;redis介绍&quot;&gt;&lt;a href=&quot;#redis介绍&quot; class=&quot;headerlink&quot; title=&quot;redis介绍&quot;&gt;&lt;/a&gt;redis介绍&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面一段话是redis中文网的官方介绍。&lt;br&gt;有几个关键的点值得注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;redis属于内存存储，数据是存在内存里面的&lt;/li&gt;
&lt;li&gt;redis本质是数据结构服务器，官方提供了各种数据结构供你使用，你可以将redis用作数据库或者缓存。&lt;/li&gt;
&lt;li&gt;redis的存储方式为key-value的形式存储，所以redis是非关系型数据库&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="业务开发" scheme="http://huangyiblog.com/categories/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Redis" scheme="http://huangyiblog.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>蘑菇街Java实习凉面</title>
    <link href="http://huangyiblog.com/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/%E8%98%91%E8%8F%87%E8%A1%97Java%E5%AE%9E%E4%B9%A0%E5%87%89%E9%9D%A2/"/>
    <id>http://huangyiblog.com/业务开发/蘑菇街Java实习凉面/</id>
    <published>2019-04-16T13:55:11.000Z</published>
    <updated>2019-04-16T14:04:17.616Z</updated>
    
    <content type="html"><![CDATA[<p>清明前就接到了蘑菇街hr的电话，约我去现场面试，当时时间有冲突，就约了清明后的一天上午去面试。当天一大早起来就去赶公交车前往城西。</p><p>总体来说面试体验很好，我没想到蘑菇街面试这么看重项目，太菜的我被怼的很惨呀！！面试官人很好，问题一点点展开，没思路也会给你提示，但我还是答不上来….</p><p>1 先做个自我介绍吧</p><p>2 项目介绍，你负责了哪一块？</p><p>3 你在项目中碰到最困难的点是什么？讲讲看</p><p>4 看到你有负责前后端之间的数据通信，是怎么实现的？<br>后面针对具体场景说我这一系列操作可能时延会较长，有没有想过怎么设计让交互速度更快？数据通信的安全问题考虑过吗？怎么解决安全隐患，比如客户端提交数据被人中途篡改？你平时有自己去学过安全相关的资料吗？</p><p>5 redis有哪些数据结构？set集合底层怎么实现的？Redis平时用的多吗？怎么用Redis实现点赞功能？Redis除了缓存，还有哪些地方用到？我们怎么确保Redis缓存和db中的数据一致性？</p><p>6 spring的aop用过吗？哪些地方用到了？现在假设我们需要对各种接口的权限管理采用aop编程，我们可以怎么设计？切点怎么确定？</p><p>7 mysql的索引底层为什么要用B+树而不用B树？除了时间效率方面，在存储方面有哪些优势？后面给了一个场景让我设计索引…我真的不太会..索引有哪几类当时都不清楚。。</p><p>8 后面又是一个场景问题，给了一个一直发邮件的场景？假设中途邮件发送中断了，可以怎么设计解决发送中断问题？你可以先思考几分钟，考虑两三个方案解释下。</p><p>9 mybatis了解吗？mybatis是怎么防止sql注入的？sql语句里的#和 \$ 到底有什么区别？你觉得什么时候应该用#，什么时候应该用 $</p><p>10 你有什么想问我的？</p><p>最后我就凉凉了…..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;清明前就接到了蘑菇街hr的电话，约我去现场面试，当时时间有冲突，就约了清明后的一天上午去面试。当天一大早起来就去赶公交车前往城西。&lt;/p&gt;
&lt;p&gt;总体来说面试体验很好，我没想到蘑菇街面试这么看重项目，太菜的我被怼的很惨呀！！面试官人很好，问题一点点展开，没思路也会给你提示，
      
    
    </summary>
    
      <category term="业务开发" scheme="http://huangyiblog.com/categories/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Java" scheme="http://huangyiblog.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>中通软Java实习面试</title>
    <link href="http://huangyiblog.com/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/%E4%B8%AD%E9%80%9A%E8%BD%AFJava%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/"/>
    <id>http://huangyiblog.com/业务开发/中通软Java实习面试/</id>
    <published>2019-04-10T07:04:39.000Z</published>
    <updated>2019-04-10T07:08:02.412Z</updated>
    
    <content type="html"><![CDATA[<p>本来我其实是不太想写面经的，但如何让面试的收益最大化呢，进行一个总结反省还是很有必要的。不管有没有通过，多积攒点经验，多认识到自己的不足，然后查漏补缺，把每一个没答上来的问题回去后一个个搞懂，这才没有白白浪费面试机会。</p><p>这也算是我人生中第一次面试了，答得不太好(懂的东西太少)，就把大致流程和问题介绍一下好了。</p><p>这家单位的人力一开始也没打个电话啥的，我投完简历后就收到了邮箱和短信，约了某天上午十点的面试。</p><p>当天早上起床，从宿舍出发坐地铁大概花了一个小时到达江干区的中国电信园区，本来是打算直接进去面试了，但被保安拦着，非要我拿出身份证登记，不凑巧身份证我没带。只能打电话给人力，让他下来接我。</p><p>进入会议室，陆陆续续进来了3个面试官，这和我预想中不太一样，我以为会一个一个面，通过了再进行下一轮。当时，他们3位坐在我对面，左右两边是技术面试官，中间一位不清楚，也许是行政管理的。首先是技术面试，考察技术基础。技术面试有点乱，是两个面试官交叉着问，有些会根据简历提问，尤其喜欢问你简历上提到的技术同时又是他们公司现在在用的技术，比如我简历上写了了解redis分布式缓存…刚好后面得知他们也用这个，所以光redis就问了很多。其实问题都挺常规的，但尴尬的是尽管我看了《redis设计与实现》，看了一些网上对redis的总结，但是由于自己用得少，或者说看的不深，很多东西只是有点印象，一旦让我说出来就蒙逼了，大脑一片空白。</p><ol><li>先做个自我介绍吧。</li><li>做了些什么项目？你主要做了些什么？</li><li>前端用了什么框架？</li><li>问到了spring AOP IOC的原理和应用场景，问到了spring注解，你在哪些地方用到了aop？怎么用的？<ul><li>IoC（Inversion of Control）是指容器控制程序对象之间的关系，而不是传统实现中，由程序代码直接操控。控制权由应用代码中转到了外部容器，控制权的转移是所谓反转。 对于Spring而言，就是由Spring来控制对象的生命周期和对象之间的关系；IoC还有另外一个名字——“依赖注入（Dependency Injection）”。从名字上理解，所谓依赖注入，即组件之间的依赖关系由容器在运行期决定，即由容器动态地将某种依赖关系注入到组件之中。</li><li>依赖注入的思想是通过反射机制实现的，在实例化一个类时，它通过反射调用类中set方法将事先保存在HashMap中的类属性注入到类中。 总而言之，在传统的对象创建方式中，通常由调用者来创建被调用者的实例，而在Spring中创建被调用者的工作由Spring来完成，然后注入调用者，即所谓的依赖注入or控制反转。 注入方式有两种：依赖注入和设置注入； IoC的优点：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。</li><li>AOP利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了 多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，就是将那些与业务无关，却为业务模块所共同调用的 逻辑或责任封装起来，比如日志记录，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</li><li>Spring实现AOP：JDK动态代理和CGLIB代理 JDK动态代理：其代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理；其核心的两个类是InvocationHandler和Proxy。 CGLIB代理：实现原理类似于JDK动态代理，只是它在运行期间生成的代理对象是针对目标类扩展的子类。CGLIB是高效的代码生成包，底层是依靠ASM（开源的java字节码编辑类库）操作字节码实现的，性能比JDK强；需要引入包asm.jar和cglib.jar。     使用AspectJ注入式切面和@AspectJ注解驱动的切面实际上底层也是通过动态代理实现的。</li><li>我当时讲aop只提了日志记录,,ioc的话至少反射机制要提到吧<br>可以参考博文 <a href="https://www.cnblogs.com/cyhzzu/p/6644981.html" target="_blank" rel="noopener">https://www.cnblogs.com/cyhzzu/p/6644981.html</a></li></ul></li><li>看到我简历上写了mybatis，所以问了mybatis用过吗？你是怎么配置的？你项目里的SQL语句的写法，问到了SQL语句里面#{}和${}的区别（我项目里其实只用到了#，当时真的不知道这是怎么回事）？后面有问了些SQL的查询语句，没让你写，就让你说下用了什么函数，关键字。后面还问了mybatis进行select映射的时候返回类型可以用resultType和resultMap（这个也不清楚），这两个有什么区别？</li></ol><ul><li>关于MyBatis 中的#和$的区别<br>参考博文 <a href="https://blog.csdn.net/yangfengjueqi/article/details/71719110" target="_blank" rel="noopener">https://blog.csdn.net/yangfengjueqi/article/details/71719110</a></li><li>关于输出映射-resultType与resultMap<br>参考博文 <a href="https://blog.csdn.net/acmman/article/details/46509375" target="_blank" rel="noopener">https://blog.csdn.net/acmman/article/details/46509375</a></li></ul><ol start="6"><li>创建线程有哪几种方式？后面我直接跟他说我Java多线程还不太熟悉，他就没问这一块了<br>使用线程其实主要有3种方式：</li></ol><ul><li>实现Runnable接口；</li><li>实现Callable接口；</li><li>继承Thread类；</li></ul><p>一、继承 Thread 类创建线程类<br>(1)定义 Thread 类的子类，并重写该类的 run 方法，该 run 方法的方法体就代表了线程要 完成的任务。因此把 run()方法称为执行体。</p><p>(2)创建 Thread 子类的实例，即创建了线程对象。 (3)调用线程对象的 start()方法来启动该线程。<br>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//重写 run 方法，run 方法的方法体就是现场执行体 public void run()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">System.out.println(getName()+<span class="string">" "</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; <span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" : "</span>+i);</span><br><span class="line">               <span class="keyword">if</span>(i==<span class="number">20</span>) &#123;</span><br><span class="line"><span class="keyword">new</span> FirstThreadTest().start();</span><br><span class="line">             <span class="keyword">new</span> FirstThreadTest().start(); &#125;</span><br><span class="line">         &#125; &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。GetName()方法返 回调用该方法的线程的名字。<br>        二、通过 Runnable 接口创建线程类<br>(1)定义 runnable 接口的实现类，并重写该接口的 run()方法，该 run()方法的方法体同样<br>         是该线程的线程执行体。<br>(2)创建 Runnable 实现类的实例，并依此实例作为 Thread 的 target 来创建 Thread 对象， 该 Thread 对象才是真正的线程对象。<br>              (3)调用线程对象的 start()方法来启动该线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line">               <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">             &#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i); <span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">RunnableThreadTest rtt = <span class="keyword">new</span> RunnableThreadTest(); <span class="keyword">new</span> Thread(rtt,<span class="string">"新线程 1"</span>).start();</span><br><span class="line">                 <span class="keyword">new</span> Thread(rtt,<span class="string">"新线程 2"</span>).start(); &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure></p><p>三、通过 Callable 和 Future 创建线程<br>        (1)创建 Callable 接口的实现类，并实现 call()方法，该 call()方法将作为线程执行体， 并且有返回值。<br>        (2)创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该    FutureTask 对象封装了该 Callable 对象的 call()方法的返回值。<br>        (3)使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。<br>        (4)调用 FutureTask 对象的 get()方法来获得子线程执行结束后的返回值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line">          <span class="keyword">import</span> java.util.concurrent.ExecutionException; <span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line">             <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">             CallableThreadTest ctt = <span class="keyword">new</span> CallableThreadTest(); FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(ctt); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">                        &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 的循环变量 i 的值</span></span><br><span class="line"><span class="string">        "</span>+i);</span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">20</span>) &#123;</span><br><span class="line">         <span class="keyword">new</span> Thread(ft,<span class="string">"有返回值的线程"</span>).start(); &#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程的返回值:"</span>+ft.get()); &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>**线程池的种类** 有:</code></pre><p>Java 通过 Executors 提供四种线程池，分别为:</p><ul><li>newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool 创建一个定时线程池，支持定时及周期性任务执行。 - newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ul><ol start="8"><li>Java集合了解哪些？说说看，我当时就先说了ArrayList，vector，LinkedList等，后面自然就问我实现原理是怎样的？这几个有什么区别？</li></ol><p>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便 增加和插入元素，它们都允许直接按序号索 引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法(线程安全)，通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据 需要进行前向或后向遍历，但是插入数 据时只需要记录本项的前后项即可，所以插入速度较快。</p><ol start="9"><li><p>HashMap底层怎么实现的？我当时提了数组和单链表，后面讲到jdk1.8之后当链表长度大于8会自动转换为红黑树结构，当小于6又会转为单链表。之后又问我为什么要将单链表转为红黑树？红黑树的查询时间复杂度是多少？它是怎么实现平衡的？之后又问了我还知道哪些树结构？我知道二叉树…..他紧接着又问我B树知不知道？B+树？</p></li><li><p>我说了mysql的底层索引就是根据B+树来实现的，然后问了MySQL引擎了解吗？一些基本的增删查改会的吧？</p></li><li><p>redis知道哪些内容？介绍下redis的数据结构。为什么要用redis？我肯定得说效率高，速度快啥的。然后就问我redis为什么速度快？除了这些，你还知道redis的哪些内容？之后问了我为什么项目里用到了mybatis，mybatis有二级缓存，为什么还要用redis？这两个都能作为缓存。mybatis里的一级缓存和二级缓存有些什么区别（这我之前都没了解过）？说说看redis持久化？redis锁有了解吗？  </p></li></ol><p>关于mybatis缓存机制可以看看美团技术博文： <a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/01/19/mybatis-cache.html</a>  </p><ol start="12"><li><p>有想过怎么提高你项目的并发性吗？怎么设计？</p><p>基本上技术面试就到这里了，还有些什么问题我也忘了，没记住。<br>后面是中间的面试官问了几个问题：</p></li><li>之前有面试过其他公司吗？对我们公司有了解吗？….我当时说了不太了解。。然后他问我不太了解为什么投了简历….</li><li>问了些学校相关的问题，课程现在多不多，什么时候可以实习？既然现在课不多为什么不考虑提前实习？能实习多长时间，实习的时候会不会还去找其他工作？总之很关心你的工作稳定性。</li><li>家是哪里的？</li><li>有什么想问我们的吗？我问了你们主要做的哪方面的业务，技术栈是怎么样的。</li><li>最后就是客套一下，有结果会及时通知。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本来我其实是不太想写面经的，但如何让面试的收益最大化呢，进行一个总结反省还是很有必要的。不管有没有通过，多积攒点经验，多认识到自己的不足，然后查漏补缺，把每一个没答上来的问题回去后一个个搞懂，这才没有白白浪费面试机会。&lt;/p&gt;
&lt;p&gt;这也算是我人生中第一次面试了，答得不太好
      
    
    </summary>
    
      <category term="业务开发" scheme="http://huangyiblog.com/categories/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Java" scheme="http://huangyiblog.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>我的高中暗恋对象脱单1年多了</title>
    <link href="http://huangyiblog.com/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E9%AB%98%E4%B8%AD%E6%9A%97%E6%81%8B%E5%AF%B9%E8%B1%A1%E8%84%B1%E5%8D%951%E5%B9%B4%E5%A4%9A%E4%BA%86/"/>
    <id>http://huangyiblog.com/随笔/我的高中暗恋对象脱单1年多了/</id>
    <published>2019-04-09T15:18:03.000Z</published>
    <updated>2019-04-10T07:11:17.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有些小伤感呢"><a href="#有些小伤感呢" class="headerlink" title="有些小伤感呢"></a>有些小伤感呢</h1><p><strong>《石头记》里曾说过，凡是真心相爱的，最后都散了，凡是凑合过日子的，最后都成了。</strong>  </p><p>爱情实在是个奢侈品，一般人可能消费不起。  </p><a id="more"></a><p>用了一年多的tim，一切都没觉得有什么不妥，只是最近又玩起了QQ。今天最刺激的就是，我浏览了高中暗恋对象的男朋友的空间动态，从2019年3月一直刷到了2015年高考前的日子…还是和高中一样屌丝,人生最大幻觉绝对是 她喜欢我！。之后删了好友，继续准备着自己的实习面试。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;有些小伤感呢&quot;&gt;&lt;a href=&quot;#有些小伤感呢&quot; class=&quot;headerlink&quot; title=&quot;有些小伤感呢&quot;&gt;&lt;/a&gt;有些小伤感呢&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;《石头记》里曾说过，凡是真心相爱的，最后都散了，凡是凑合过日子的，最后都成了。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;爱情实在是个奢侈品，一般人可能消费不起。  &lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://huangyiblog.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>一个成功的git分支模型</title>
    <link href="http://huangyiblog.com/%E8%AF%91%E6%96%87%E9%9B%86/%E4%B8%80%E4%B8%AA%E6%88%90%E5%8A%9F%E7%9A%84git%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/"/>
    <id>http://huangyiblog.com/译文集/一个成功的git分支模型/</id>
    <published>2019-03-16T11:20:45.000Z</published>
    <updated>2019-04-27T12:50:54.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个成功的Git分支模型"><a href="#一个成功的Git分支模型" class="headerlink" title="一个成功的Git分支模型"></a>一个成功的Git分支模型</h1><blockquote><p>原文链接：<a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">https://nvie.com/posts/a-successful-git-branching-model/</a><br>原文作者： Vincent Driessen</p></blockquote><p>在这片文章我介绍了一些我在一年前为一些项目（包括工作和私人）介绍的开发模型，并且事实证明非常成功。一直以来我都打算专门为其写一篇文章，然而我几乎完全找不到空闲的时间来做这件事，直到现在。我不会讨论任何有关项目的细节，只关注这个分支策略和发布管理。</p><p><div align="center"> <img src="https://nvie.com/img/git-model@2x.png" width="640"> </div><br><br><a id="more"></a></p><h1 id="为什么要用git？"><a href="#为什么要用git？" class="headerlink" title="为什么要用git？"></a>为什么要用git？</h1><p>有关Git与集中式源代码控制系统相比的优缺点的详细讨论，请参阅如下网站：<br><a href="https://git.wiki.kernel.org/index.php/GitSvnComparsion" target="_blank" rel="noopener">网站</a><br>上述论坛有很多思想碰撞的火焰。作为一个开发者，在今天所有其他的工具里面我更偏爱Git。Git确实改变了开发人员对合并与分支的看法。从经典的CVS / Subversion世界来看，合并/分支一直被认为有点可怕（“小心合并冲突，它们会咬你！”）以及有时候你在一段时间只做一次的事情。</p><p>但是使用Git，这些操作变得非常轻便和简单，并且它们被认为是您日常工作流程的核心部分之一。例如，在CVS / Subversion 书籍中，分支与合并首先在后面的章节中被讨论（对于高级用户），而在 每一本 Git 书中，它已经在第3章（基础知识）中被介绍过。  </p><p>由于其简单性和重复性，分支和合并不再是一件令人害怕的事情。版本控制工具应该比其他任何东西更有助于进行分支/合并的操作。</p><p>关于这个工具讲够了，让我们进入这个开发模型。我将在这里介绍的模型本质上不再是每个团队成员必须遵循的为了进入托管软件开发过程的一组程序。</p><h1 id="分散但集中"><a href="#分散但集中" class="headerlink" title="分散但集中"></a>分散但集中</h1><p>我们使用的存储库设置与该分支模型配合良好，具有中心“真实”存储库。请注意，这个仓库只被认为是一个中央仓库（因为Git是DVCS，在技术层面没有这种中央仓库这种东西）。我们将此repo称为origin，因为所有Git用户都熟悉此名称。</p><p><img src="https://nvie.com/img/centr-decentr@2x.png" alt="[alt]"></p><p>每个开发人员都会拉取并推送到origin。但除了集中式推拉关系之外，每个开发人员还可以从其他同行中获取更改以形成子团队。例如，在将正在进行的工作过早推进origin之前，在开发一项大的新功能时，这对于两个或更多开发人员一起工作可能是有用的 。在上图中，有爱丽丝和鲍勃，爱丽丝和大卫以及克莱尔和大卫这些子团队。</p><p>从技术上讲，这意味着Alice已经定义了一个Git远程，名为bob，指向Bob的存储库，反之亦然。</p><h1 id="主要分支"><a href="#主要分支" class="headerlink" title="主要分支"></a>主要分支</h1><p>在核心部分，开发模型受到现有模型的极大启发。中央仓库拥有两个主要分支，具有无限的生命周期：</p><ul><li>master</li><li>develop</li></ul><p><img src="https://nvie.com/img/main-branches@2x.png" alt="alt"></p><p>该master分支的origin应该对每一位Git用户都很熟悉。与master分支并行的另一个分支称为develop分支。</p><p>我们认为origin/master是反映这个HEAD源代码生产就绪状态的主要分支 。</p><p>我们认为origin/develop是主要的分支，其源代码 HEAD始终反映了最新交付的下一版本中开发被更改的状态。有些人称之为“整合分支”。这是在夜间自动被构建的地方。</p><p>当develop分支中的源代码到达稳定点并准备好被发布时，所有的更改都应该以某种方式被合并到master分支，然后使用版本号进行标记。上述将如何执行进一步详细讨论。  </p><p>因此，当每次将更改合并回master时，根据定义，这是一个新的生产版本。我们对此非常严格，因此从理论上讲，我们可以使用Git钩子脚本在每次提交时对master自动构建和发布我们的软件到我们的生产服务器 。</p><h1 id="支持分支"><a href="#支持分支" class="headerlink" title="支持分支"></a>支持分支</h1><p>接着上面的主要分支master和develop，我们的发展模式，采用了多种支持分支机构，以帮助团队成员进行并行开发，缓解功能跟踪，为生产版本做准备，并协助快速修复现场制作的问题。与主要分支不同，这些分支的寿命有限，因为它们最终会被删除。  </p><p>我们可能使用的不同类型的分支是：</p><ul><li>功能分支</li><li>发布分支机构</li><li>修补程序分支</li></ul><p>这些分支中的每一个都有特定的目的，并且必须遵守关于哪些分支可以是它们的起始分支以及哪些分支必须是它们的合并目标的严格规则。我们将在一分钟内讨论它们。  </p><p>从技术角度来看，这些分支绝不是“特殊的”。分支类型根据我们如何使用它们进行分类。他们当然是老的Git分支。</p><h2 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h2><ul><li>可能会分支于：<br>develop</li><li>必须合并回：<br>develop</li><li>分支命名约定：<br>anything except master, develop, release-*, or hotfix-*</li></ul><p>功能分支（或有时称为主题分支）用于为即将发布或将来的版本开发新功能。在开始开发功能时，此功能将会在其中合并的目标版本，但可能在此时未知。功能分支的本质是，只要功能处于开发阶段，它就会存在，但最终会被合并回develop（以便将新功能添加到即将发布的版本中）或丢弃（在实验令人失望的情况下）。  </p><p>功能分支通常仅存在于开发人员存储库中，而不存在于origin。</p><p><img src="https://nvie.com/img/fb@2x.png" alt="alt"></p><h2 id="创建一个功能分支"><a href="#创建一个功能分支" class="headerlink" title="创建一个功能分支"></a>创建一个功能分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b myfeature develop</span><br><span class="line"> 切换到新分支“myfeature”</span><br></pre></td></tr></table></figure><h2 id="在开发中加入完成的功能"><a href="#在开发中加入完成的功能" class="headerlink" title="在开发中加入完成的功能"></a>在开发中加入完成的功能</h2><p>完成的功能可能会合并到develop分支中，以确保将它们添加到即将发布的版本中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line"> 切换到分支&apos;develop&apos;</span><br><span class="line">$ git merge --no-ff myfeature</span><br><span class="line"> 更新ea1b82a..05e9557</span><br><span class="line">（更改摘要）</span><br><span class="line">$ git branch -d myfeature</span><br><span class="line"> 已删除分支myfeature（为05e9557）。</span><br><span class="line">$ git push origin开发</span><br></pre></td></tr></table></figure><p>该–no-ff标志会导致合并始终创建新的提交对象，即使可以使用快进执行合并。这样可以避免丢失有关历史上存在的功能分支的信息，并将所有一起添加的功能提交组合在一起。两者相比：</p><p><img src="https://nvie.com/img/merge-without-ff@2x.png" alt="alt"></p><p>在后一种情况下，不可能从Git历史中看到哪些提交对象一起实现了一个功能 - 您必须手动读取所有日志消息。恢复整个功能（即一组提交）在后一种情况下也是一件真正令人头痛的事，而如果使用该–no-ff标志则很容易完成 。</p><p>是的，它会创建一些（空的）提交对象，但增益远远大于成本。</p><h1 id="发布分支"><a href="#发布分支" class="headerlink" title="发布分支"></a>发布分支</h1><p>可能会分支于：<br>develop<br>必须合并回：<br>develop 和 master<br>分支命名约定：<br>release-*</p><p>发布分支支持准备新的生产版本。它们允许最后一刻点缀我和交叉t。此外，它们允许修复小错误并为发布准备元数据（版本号，构建日期等）。通过在发布分支上执行所有这些工作，develop 分支将被清除以接收下一个大版本的功能。</p><p>新发布分支的关键时刻develop是开发（几乎）反映新版本的期望状态。至少所有针对要构建的版本的功能必须在此时合并到其中 。针对未来版本的所有功能可能不会 - 他们必须等到发布分支后。</p><p>正是在发布分支的开始，即将发布的版本被分配了一个版本号 - 而不是之前的版本号。直到那一刻，这个develop 分支反映了“下一个版本”的变化，但不清楚“下一个版本”最终是否会变为0.3或1.0，直到发布分支开始。该决定是在发布分支的开始时做出的，并根据项目相关版本号冲突的规则执行。</p><h2 id="创建一个发布分支"><a href="#创建一个发布分支" class="headerlink" title="创建一个发布分支"></a>创建一个发布分支</h2><p>发布分支是从develop分支创建的。例如，假设版本1.1.5是当前的生产版本，我们即将推出一个大版本。状态develop为“下一个版本”做好了准备，我们已经决定这将成为版本1.2（而不是1.1.6或2.0）。因此，我们为发布分支提供反映新版本号的名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b release-1.2 develop</span><br><span class="line"> 切换到新分支“release-1.2”</span><br><span class="line">$ ./bump-version.sh 1.2</span><br><span class="line"> 文件修改成功，版本提升到1.2。</span><br><span class="line">$ git commit -a -m “Bumped version number to 1.2”</span><br><span class="line">[release-1.2 74d9424] Bumped version number改为1.2</span><br><span class="line">1个文件被改变，1个插入（+），1个删除（ - ）</span><br></pre></td></tr></table></figure><p>在创建新分支并切换到它后，我们会修改版本号。这个bump-version.sh是一个虚构的shell脚本，它可以更改工作副本中的某些文件以反映新版本。（这当然可以手动更改 - 关键是某些文件会发生变化。）然后，该冲突版本号会被提交。</p><p>这个新的分支可能存在一段时间，直到发布可能会被真正推出。在此期间，可以在此分支中应用错误修复（而不是在develop分支上）。严禁在此处添加大型新功能。它们必须合并到develop，因此要等待下一个大版本。</p><h2 id="完成一个发布分支"><a href="#完成一个发布分支" class="headerlink" title="完成一个发布分支"></a>完成一个发布分支</h2><p>当发布分支的状态准备好成为真正的发布版本时，需要执行一些操作。首先，发布分支被合并到 master（因为每次提交到master的都是按照定义的新版本，请记住）。接下来，master必须标记该提交，以便将来参考此历史版本。最后，需要将发布分支上所做的更改合并回到develop，以便将来的版本也包含这些错误修复。</p><p>Git的前两个步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">切换到分支&apos;master&apos;</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line"> 由递归合并而成。</span><br><span class="line">（更改摘要）</span><br><span class="line">$ git tag -a 1.2</span><br></pre></td></tr></table></figure></p><p>该版本现已完成，并标记以供将来参考。</p><blockquote><p>编辑：您可能还想使用-s或-u <key>标记以加密方式对您的标记进行签名。</key></p></blockquote><p>为了保持发布分支中所做的更改，我们需要将这些更改合并到develop。在Git中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line"> 切换到分支&apos;develop&apos;</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line"> 由递归合并而成。</span><br><span class="line">（变更摘要）</span><br></pre></td></tr></table></figure></p><p>这一步很可能导致合并冲突（甚至，因为我们已经更改了版本号）。如果是这样，请修复并提交。</p><p>现在我们已经完成了，并且可能会删除发布分支，因为我们不再需要它了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d release-1.2</span><br><span class="line"> 删除了分支版本1.2（ff452fe）。</span><br></pre></td></tr></table></figure><h2 id="修补程序分支"><a href="#修补程序分支" class="headerlink" title="修补程序分支"></a>修补程序分支</h2><p>可能会分支于：<br>master<br>必须合并回：<br>develop 和 master<br>分支命名约定：<br>hotfix-*</p><p>修补程序分支非常类似于发布分支，因为它们也是为了准备新的生产版本，尽管是计划外的。它们源于必须立即实际生产版本的不良状态采取反应。当必须立即解决生产版本中的关键错误时，可以从标记生产版本的主分支上的相应标记分支修补程序分支。</p><p>实质是团队成员（在develop分支机构）的工作可以继续，而另一个人正在准备快速生产修复。</p><p><img src="https://nvie.com/img/hotfix-branches@2x.png" alt="alt"></p><h2 id="创建修补程序分支"><a href="#创建修补程序分支" class="headerlink" title="创建修补程序分支"></a>创建修补程序分支</h2><p>从master分支创建修补程序分支。例如，假设版本1.2是当前生产版本正在运行的版本并且由于严重错误而出现了bug。但是变化在develop分支仍然不稳定。然后我们可以分支出修补程序分支并开始修复问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix-1.2.1 master</span><br><span class="line"> 切换到新分支“hotfix-1.2.1”</span><br><span class="line">$ ./bump-version.sh 1.2.1</span><br><span class="line"> 文件修改成功，版本提升到1.2.1。</span><br><span class="line">$ git commit -a -m “Bumped version number to 1.2.1”</span><br><span class="line">[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1</span><br><span class="line">1个文件改变了，1个插入（+），1个删除（ - ）</span><br></pre></td></tr></table></figure></p><p>分支后不要忘记碰撞版本号！<br>然后，修复错误并在一个或多个单独的提交中提交修复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m “修复了严重生产问题”</span><br><span class="line">[hotfix-1.2.1 abbe5d6]修复了严重生产问题</span><br><span class="line">5个文件发生了变化，32个插入（+），17个删除（ - ）</span><br></pre></td></tr></table></figure><h2 id="完成一个修补程序分支"><a href="#完成一个修补程序分支" class="headerlink" title="完成一个修补程序分支"></a>完成一个修补程序分支</h2><p>完成后，需要将错误修复合并回到master，但也需要合并回到develop，以保证错误修复程序也包含在下一个版本中。这与发布分支的完成方式完全相似。<br>首先，更新master并标记版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line"> 切换到分支&apos;master&apos;</span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br><span class="line"> 由递归合并。</span><br><span class="line">（更改摘要）</span><br><span class="line">$ git tag -a 1.2.1</span><br></pre></td></tr></table></figure><blockquote><p>编辑：您可能还想使用-s或-u <key>标记以加密方式对您的标记进行签名。</key></p></blockquote><p>接下来，在develop分支中也包括错误修复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line"> 切换到分支&apos;develop&apos;</span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br><span class="line"> 由递归合并。</span><br><span class="line">（变更摘要）</span><br></pre></td></tr></table></figure><p>此处规则的一个例外是，  当发布分支当前存在时，需要将修补程序更改合并到该发布分支中，而不是develop分支。在发布分支完成时，将错误修复反向合并到发布分支中最终会导致错误修复也被合并到develop分支。（如果develop分支立即工作并涉及次错误修复并且不能等待发布分支完成，您可以安全地将错误修复合并到develop分支。）</p><p>最后，删除临时分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix-1.2.1</span><br><span class="line"> 删除了分支修补程序-12.2.1（是abbe5d6）。</span><br></pre></td></tr></table></figure><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>虽然这个分支模型没有什么真正令人震惊的地方，但这篇文章开头的“大图”可以被证明在我们的项目中非常有用。它形成了一个易于理解的优雅模型，并能够让团队成员形成对分支和发布过程的共同理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一个成功的Git分支模型&quot;&gt;&lt;a href=&quot;#一个成功的Git分支模型&quot; class=&quot;headerlink&quot; title=&quot;一个成功的Git分支模型&quot;&gt;&lt;/a&gt;一个成功的Git分支模型&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://nvie.com/posts/a-successful-git-branching-model/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://nvie.com/posts/a-successful-git-branching-model/&lt;/a&gt;&lt;br&gt;原文作者： Vincent Driessen&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这片文章我介绍了一些我在一年前为一些项目（包括工作和私人）介绍的开发模型，并且事实证明非常成功。一直以来我都打算专门为其写一篇文章，然而我几乎完全找不到空闲的时间来做这件事，直到现在。我不会讨论任何有关项目的细节，只关注这个分支策略和发布管理。&lt;/p&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;https://nvie.com/img/git-model@2x.png&quot; width=&quot;640&quot;&gt; &lt;/div&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="译文集" scheme="http://huangyiblog.com/categories/%E8%AF%91%E6%96%87%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>风口过了，猪还是猪</title>
    <link href="http://huangyiblog.com/%E9%9A%8F%E7%AC%94/%E9%A3%8E%E5%8F%A3%E8%BF%87%E4%BA%86%EF%BC%8C%E7%8C%AA%E8%BF%98%E6%98%AF%E7%8C%AA/"/>
    <id>http://huangyiblog.com/随笔/风口过了，猪还是猪/</id>
    <published>2019-03-02T04:08:27.000Z</published>
    <updated>2019-03-02T04:45:44.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="风口过了，猪还是不会飞"><a href="#风口过了，猪还是不会飞" class="headerlink" title="风口过了，猪还是不会飞"></a>风口过了，猪还是不会飞</h1><p>互联网界内有句话挺有名，站在风口上，猪都能飞起来。<br>这话不难理解，往前回顾这些年it行业的迅猛发展，一批又一批的独角兽成长起来，动不动估值上亿，上市的造富神话一个又一个，大家都期待着下一个阿里巴巴的诞生。但从2018年的p2p爆雷，以及年底和19年初的各个公司爆出了裁员。<br>事实上大面积的裁员是真的，当然还在招人也是真的。这里一方面有国内大经济环境恶劣的原因，另一方行业本身的泡沫不小。</p><p>国内经济下行也不是我随便说说的，你们有关注过其他行业其实应该也有听到点消息，虽然通常都是互联网裁员会炒的比较火，但传统制造业日子也并不好过，全球制造业各个巨头也都在裁员，虽说还谈不上类似08年，97年的金融危机，但这个时候出现问题，风险还是蛮大的。至少我觉得资本一旦寒冬，且不说已经冬天，或许凛冬将至。这种时候能偷着乐的估计也就老师、公务员这种体制内的吧？给资本家打工你都需要意识到公司不是你的家。大环境不是我们这些普通人能够改变的，你能做的只有做好自己。我觉得如何应对危机，最重要的一条，那就是终身学习，你得让自己保持足够的竞争力。其余的点也有很多，比如别给自己加杠杆，背高负债，高消费等等。由俭入奢容易，由奢入俭难。裁员其实没那么可怕，能力在线，另外找一家就是了。但有些人压力就会不小。此前我就见过不少帖子，杭州，深圳都有，无非就是杠杆买了房，每个月背着一两万的房贷然后被炒鱿鱼，这就有点心累了。</p><p>这两年中国经济的持续增持有两条大腿一直在撑着，一条腿是房地产，一条腿是互联网。但恕我直言，我个人觉得经济泡沫最大的就是这两条腿。当像我这种在校生，或者你身边很多的人，开口闭口谈天都是房价，买房之类的，我觉得就很危险，这有点像全民买房的前兆，热钱全流入房地产，实体业必然受影响。杭州自从G20开完，再加上备受期待的亚运会加持，房价整体趋势就是猛涨，另一方面，棚改政策，城中村改造也是传出了不少造富神话，拆迁户各种送房送钱，补贴的钱又再次流入房地产，至于政府，卖地卖得好就行了。</p><p>互联网的问题一方面太虚了，另一方面各种红利用得也快差不多了，遭遇瓶颈是必然的。人口红利，微信，也好，淘宝也好，移动互联网这一块很大程度上得益于人口红利，但如今微信的用户其实已经很难再上涨。互金就不说了，去年倒闭的企业不少，至于游戏，国内主流游戏厂商股价全是下跌，游戏其实受政策影响很大，你版号拿不到，光有技术没什么卵用，另外游戏的赌博性质很高，虽说很赚钱，但往往是亏的企业多。大多数游戏的存活周期都不长，顶多几年算不错了，一款游戏从研发到最后发布，一系列的都是在砸钱，最后如果没什么用户，没什么玩家支持，那这些钱往往是打水漂的多。总之前几年互联网迅猛扩张，但并没出现什么新的比较好的增长点。倒是各种新概念很火，AI、VR、区块链等等，也许下一次产业革命就跟这些点有关，但是光有概念，没办法应用落地，赚不了钱，投资人是不会买账的！放放PPT，画画大饼就能融资的日子已经过去了。</p><p>总之大环境不好，个人是很难独善其身的，学生该学习的还是好好学习，该找工作的还是要好好找工作，该上班的还是好好上班。网上无非两种观点：悲观的认为这次的冬天会很冷，时间会很长，乐观的，对中国经济充满信息的，认为转暖也快了。特朗普会选择伤敌一千自损八百的贸易战政策不是没有原因的，直接的原因就是想扼制中国高端制造业的转型升级，也就是要扼制中国的发展，但我相信美国应该也看到了中国自身经济也存在着不少问题才敢直接打贸易战。既然是市场经济，与资本分不开的经济。那么经济规律你是躲不了的，经济危机你是避免不了的，可以说美国下一次金融危机必然还是会发生，或早或晚罢了，拖得越晚，反弹的越厉害。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;风口过了，猪还是不会飞&quot;&gt;&lt;a href=&quot;#风口过了，猪还是不会飞&quot; class=&quot;headerlink&quot; title=&quot;风口过了，猪还是不会飞&quot;&gt;&lt;/a&gt;风口过了，猪还是不会飞&lt;/h1&gt;&lt;p&gt;互联网界内有句话挺有名，站在风口上，猪都能飞起来。&lt;br&gt;这话不难理
      
    
    </summary>
    
      <category term="随笔" scheme="http://huangyiblog.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么我说考验人性多半会令你失望</title>
    <link href="http://huangyiblog.com/%E9%9A%8F%E7%AC%94/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%AF%B4%E8%80%83%E9%AA%8C%E4%BA%BA%E6%80%A7%E5%A4%9A%E5%8D%8A%E4%BC%9A%E4%BB%A4%E4%BD%A0%E5%A4%B1%E6%9C%9B/"/>
    <id>http://huangyiblog.com/随笔/为什么我说考验人性多半会令你失望/</id>
    <published>2018-12-25T07:42:51.000Z</published>
    <updated>2018-12-30T13:58:23.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="永远不要去尝试考验人性-人性真的经不起考验"><a href="#永远不要去尝试考验人性-人性真的经不起考验" class="headerlink" title="永远不要去尝试考验人性,人性真的经不起考验!"></a>永远不要去尝试考验人性,人性真的经不起考验!</h1><blockquote><p>下述内容多为个人见解，难免会犯学术上的错误，欢迎指正。</p></blockquote><a id="more"></a><p>我可能有一天会不与代码打交道，但我这一生不可能不与人打交道，这是避免不了的。这也大大激发了了我对人性理解的兴趣，各类学科里面与人性关联度最高的，又属心理学最甚。为了防止有些人说我以偏概全，说还有某某圣人并非如此，某某大贤已经四大皆空，无欲无求，考验他们的人性纯粹多此一举。我只说大多数情况下的心理状态是如何如何。因为绝大多数人都只是普通人，大部分人既不是圣人，也不是恶人，只是一个普通人，你可以想想看你生活到现在遇到的人，是不是大多和你一样，有自己的欲望和所求，有自己的弱点和困惑。既然是普通人，那么面对各种压力或者说诱惑，不说他真实表现如何，你觉得他的内心想法是如何的呢？</p><p>先来看看人性是什么，字面意思我觉得就是指人的本性，也就是请抛开各种约束，诸如道德，法律等等，人的心理表现已经相对应会做出的行为表现。百度百科的解释分了狭义和广义两种：</p><blockquote><p>狭义上是指人的本质心理属性，也就是人之所以为人的那一部分属性，是人与其它动物相区别的属性；广义上是指人普遍所具有的心理属性，其中包括人与其它动物所共有的那部分心理属性。无论是人的本质心理属性，还是人与动物所共有的属性，由于它们都是人所共有的心理属性，那么这种属性也就不可能是后天的结果，只能是人类天性，属于无条件反射。</p></blockquote><p>我们可以看到不论是狭义还是广义，都是人所共有的心理属性，也就是说指的是先天的，无条件的反射。所以我在之前就提到了，既然是讲人性，就不要将各种外在约束引进来，包括教育，各种行为规范，道德准则等等。因为在这些条件下做出的表现大多并不属于真正的人性表现。是经过了包装的。上述提到的定义其实也就指向了人性的本质，这里其实也引出了关于人性一直以来存在的贯穿于东西方世界的争论，人性本善还是本恶？中国古代关于这个问题一直争论不休，基本四中观点都涵盖了：包括孟子的性善论，认为人生来即有恻隐、善恶、辞让、是非四种“善端”，扩而充之，便可形成仁、义、礼、智的善性。荀子的性恶论，认为“人之性恶，其善伪也。”（《荀子·性恶》）善性是后天人为的。性无善无恶论，这包括：告子的“性无善无不善”论，认为“生之谓性”，“食色，性也”；性有善有恶论，这包括先秦世硕等的有善有恶论，汉杨雄的性善恶混论，董仲舒等的性三品论等：杨雄认为“人之性也，善恶混，修其善则为善人，修其恶则为恶人”；明清之际王夫之的性“日生日成”论，认为人性绝非在“初生之顷”就定型，一成不易，而是随着环境和教养的不同，“性屡移而异”，“未成可成，已成可革”，认为人性是可以培养和不断完善的；北宋的司马光的人性的先天不等论，司马光认为人生来在人性善恶上就先天不平等，无论圣人还是愚人善恶都是兼而有之，只是有些在善性上会占优势，有些人在恶性上会占优势。</p><p>人性最大的一个特点就是复杂性，因此首先我不认同纯粹的人性本恶或者性本善，我的观点就是有善有恶论，只不过是在恶性上占优势还是在善性上占优势因人而异。为什么我说复杂是人性的特点，这其实是很好理解，你看过很多真正出色艺术作品，小说也好，电影也好，电视剧也一样，真正塑造人物形象出色的，往往都是十分立体的人物形象。不像很多常规意义上的，哦，那谁谁谁是个好人，思想端庄正直，那谁谁谁是个坏人，无恶不作。一个人也许他不贪财，但他不一定不好色；一个人也许不好色，但他不一定不慕名；一个人也许不慕名，但他不一定不求权……同样的，一个贪财好色之人也可能重情重义，一个恶贯满盈之人也可能诚实有信，一诺千金。抗日战争时期，有一大波被人唾骂的汉奸，你能想象在这之前，这当中也有人做出过堪称为民族英雄的壮举。生活中人间人嫌弃的一个猥琐男，用钱各种抠门，色眯眯的眼睛不停在那些漂亮女生身上来回移动的家伙，怕是没几个人愿意和他交往，但是当一个同学得了绝症，竟然只有这个人拿出了自己几乎全部的几千块钱积蓄帮助他。</p><p>和复杂性关联比较大的一个特点就是变化性，也就是说人性不是一成不变的，而是可以一直变化着的。这一点说起来或许要困难不少。不是都说了人性是先天性的吗，是人所共有的生理，心理属性吗？难道是你通过教育，通过感化就能改变得了的吗？我认为是可变的，只是程度不同。我在之前提过，我支持的观点是人性有善有恶论，无非每个人善恶的比重不同，在成长过程中，可能一件不经意的小事，但对当事人却造成了极大的震撼，就是这份份震撼，不知不觉间就撼动了在他内心深处的善恶比重。看过武侠小说的人应该遇到过不少这种情况，一个一开始冷酷无情，杀人如麻的杀手为何在后期竟然渐渐放下了恶念，开始走自己的自我救赎之路？一个原先气质轩昂，众人称赞的武林正派人士，为何后期会走上背信弃义，追名逐利的道路？这些人都出现了变化，而这种变化往往都是有引子的。那个杀人如麻的冷血家伙可能有了温柔体贴的妻子，可爱聪慧的孩子，有了一个令人羡慕的美满家庭，他不想自己的亲人的命运因为自己而走上绝路，自然要做出内心的博弈。</p><p>人性另一个逃不开的特点就是自利性。当我提到自利，利己这样的字眼，很多人可能无意中就想到了阴暗面去，这又容易出问题，自利实在是太正常太普遍了，自利绝对不是错，不希望很多人想歪了。很多学者批判现在的学生一个个都是精致的利己主义者，这种批判是否合乎情理呢，或许他们是想说现在的人少了太多奉献精神，牺牲精神，集体精神。但这种批判从某个角度是不合人性的。人性本就是利己的，这是无可辩驳的，而且利己其实不是什么错，这才是真实人性的展现，这反倒有助于社会发展，进步，只要能够正视这样的本性，你想想看专制统治时期，统治者会让这种利己的思想得到发展吗？统治者只会想尽办法巩固自己的统治地位，让底层民众为皇族服务，以为皇族做出贡献为荣。利己心只得压抑着，过度放大显然就漏了马脚，因为这么做往往会触碰到统治阶级的蛋糕，这可是要杀头的哦。</p><p>除了自利性，还有就是普遍性，这我在最开头就说过了，定义里面也讲明了，人性人性，不就是人所共有的本性吗。既然如此，不论你是国家领袖，还是平民百姓；不论你是大学者，大教授，还是普通学生，职场白领，都有着许多共性的人性展露。你看看贪污腐败的问题，上到国务院高层，下到乡镇级村委，纵观历史各朝，哪朝哪代是没有贪污腐败现象的？这里其实展现了很好的人性问题。封建时期腐败问题严重，当然很大一部分是制度问题，纯粹让人性背锅就过分了。古代官场上的腐败，腐败之广，腐败之难治等等，都体现了人性的普遍性，自利性，贪婪性，很多大臣已经做到了一人之下，万人之上，为什么还是要贪污，要知道人性的贪婪可不是那么容易满足的哦。官场上的权臣之术，勾心斗角，权利角逐，无一不是人性的外在表现，帝王有着自己的野心，大臣打着自己的算盘，你想着捞够名和利就功成身退，我想着要你鞠躬尽瘁死而后已。</p><p>人性还有一个很好的表现常常展现的淋漓尽致，那就是性欲望，性欲很显然的，是来自内在本源驱动的。但是人类文化的发展，需要对性欲加工，性欲毫无限制的表现很多人认为是趋于兽性的，我们需要爱情来掩盖性欲，我们需要夫妻制来限制性欲，这都是人类文化前进的需求。但人的性与本身至今还是如初，不论你是否已婚，是否有了恋人，当一个充满魅惑的女子在你面前，往往还是能够勾起你本能的性欲，但是道德准则，爱情准则，法律准则告诫你，好好收起你内心的性欲吧，你是有妻子的，有家室的人了。当然也还是会有人出问题，出轨的现象有不少，这里当然也不能全让人性背锅，也许感情变了，也许不爱了，但也许真的只是一时的性欲冲昏了头脑。</p><p>人性的复杂让我不可能用几段文字将其介绍完尽，回过头，来看看很多人喜欢考验人性结果最后自讨苦吃的结局。这种事还是少做比较好，来看看考验人性的本质，既然你想要考验人性，那么其实你多半想要考验的其实是人性的阴暗面，也就是常常被人们藏起来的那一面。我说人性是有善有恶的，但你既然指的是考验，我想你总不会是想看看对方到底还能有多善良，多忠诚，多完美无缺，你想考验一下对方会不会背叛你，对方会不会不为名利所动，对方会不会不为美色所动。你想知道他能不能抗住自己的人性阴暗面，而不是想看看对方人性的阳光面有多美好，多善良。另外既然你说了是考验，那么本质上带有欺骗性，你想要看看对方在尽可能没有约束的环境下会做出何样的的选择。绝大多数人是普通人，普通人的定力又是相当有限，有了钱，想要更多，这才是人性，而不是知足常乐，有了恋人，想要长得更漂亮，身材更火辣，更温柔的对象，这才是人性；已经步入小康，想要往更高阶级爬，这才是人性；胜利了而骄傲，失败了而气馁，这才是人性。当你选择了考验，发现对方不过如此你又能如何，再说既然是欺骗，对方做出了遵从本性的选择实在是情理之中，你只能失望而归。生活已经如此艰难，你又何苦再让对方再人性的挣扎面前多几分纠结，最后甚至闹得不欢而散，好好珍惜对方为了你已经克服了人性的阴暗面吧，何苦还要在用欺骗的手法逼出人性的另一面呢，人性如何，由人性的普遍性可知大家很多时候都是心知肚明的。当你想要考验对方的时候，麻烦你先认真想想自己的本性如何，当真在七情六欲面前能够自控自如，收放自如？</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;永远不要去尝试考验人性-人性真的经不起考验&quot;&gt;&lt;a href=&quot;#永远不要去尝试考验人性-人性真的经不起考验&quot; class=&quot;headerlink&quot; title=&quot;永远不要去尝试考验人性,人性真的经不起考验!&quot;&gt;&lt;/a&gt;永远不要去尝试考验人性,人性真的经不起考验!&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;下述内容多为个人见解，难免会犯学术上的错误，欢迎指正。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://huangyiblog.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>215数组中的第K个最大元素</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/215%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://huangyiblog.com/题解集/215数组中的第K个最大元素/</id>
    <published>2018-11-28T12:48:29.000Z</published>
    <updated>2018-11-28T12:49:33.413Z</updated>
    
    <content type="html"><![CDATA[<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><p>分析：我觉得这道题很典型很重要，要吃透还是很花时间的，我要理解估计还得花不少时间，这道题虽然本身不是什么复杂算法或高级数据结构，但是很考验基本功。或许很多人面试的时候被问到过10万个数里面取第k大的数算法怎么设计，这种属于海量数据问题，思路又要变化下，你回答的时候肯定不可能直接给出一个算法就结束了，主要是如何针对不同场景和限制如何给出最优解，这就很考验基本功了。这里面最核心的就是考虑时间和内存的限制了。<br>先不管海量数据的情景，回到这题，我们一般考虑哪些思路。</p><h3 id="1-最直接的想法，先对整个数组进行排序，然后取第k大的数。"><a href="#1-最直接的想法，先对整个数组进行排序，然后取第k大的数。" class="headerlink" title="1 最直接的想法，先对整个数组进行排序，然后取第k大的数。"></a>1 最直接的想法，先对整个数组进行排序，然后取第k大的数。</h3><p>至于如何排序，那内容就多了。比如快排，堆排，偷懒的人可能直接调用STL里的sort函数就过了，但面试不能这么干，另外估计选择快排比较多的，比竟快排平均花费时间最少。<br>时间复杂度O(nlogn)</p><h3 id="2-利用快速选择的想法。"><a href="#2-利用快速选择的想法。" class="headerlink" title="2 利用快速选择的想法。"></a>2 利用快速选择的想法。</h3><p>也就是快排的分治思想。取一个指针pivot</p><ul><li>如果pivot == k，则正好找到了第k小的元素</li><li>如果pivot &gt; k，则第k小的元素存在于pivot左边</li><li>如果pivot &lt; k，则第k小的元素存在于pivot右边<h3 id="3-利用最小堆"><a href="#3-利用最小堆" class="headerlink" title="3 利用最小堆"></a>3 利用最小堆</h3>维护一个容量为k的最小堆，在建完堆后将取堆内第k个数即可。<br>关于快速选择的算法可以参考下算法导论。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(nums.rbegin(), nums.rend());</span><br><span class="line">        <span class="keyword">return</span> nums[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (nums.size() == <span class="number">0</span> || k &lt; <span class="number">1</span> || k &gt; nums.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> partition(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, nums.size() - k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = start, right = end;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[(start + end) / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; nums[left] &lt; pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; nums[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                swap(nums, left, right);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> partition(nums, start, right, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= left) &#123;</span><br><span class="line">            <span class="keyword">return</span> partition(nums, left, end, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[k];</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        shuffle(nums);</span><br><span class="line">        k = nums.length - k;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> pivot = partition(nums, low, high);</span><br><span class="line">            <span class="keyword">if</span>(pivot &lt; k) &#123;</span><br><span class="line">                low = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pivot &gt; k) &#123;</span><br><span class="line">                high = pivot - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参考算法第四版</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> j = high + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; high &amp;&amp; less(a[++i], a[low]));</span><br><span class="line">            <span class="keyword">while</span>(j &gt; low &amp;&amp; less(a[low], a[--j]));</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a, low, j);</span><br><span class="line">                    <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v &lt; w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在partition前将数组顺序打乱，保证不出现最坏情况。</span></span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = random.nextInt(i + <span class="number">1</span>);</span><br><span class="line">            exch(a, i, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val : nums) &#123;</span><br><span class="line">            pq.offer(val);</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展问题：</p><ul><li>输入是两个整数数组，他们任意两个数的和又可以组成一个数组，求这个和中前k个数怎么做？</li><li>有两个序列A和B,A=(a1,a2,…,ak),B=(b1,b2,…,bk)，A和B都按升序排列。对于1&lt;=i,j&lt;=k，求k个最小的（ai+bj）。</li><li>给定一个数列a1,a2,a3,…,an和m个三元组表示的查询，对于每个查询(i，j，k)，输出ai，ai+1，…，aj的升序排列中第k个数。</li></ul><h2 id="如果情境改为10亿个数的topK问题，怎么想。"><a href="#如果情境改为10亿个数的topK问题，怎么想。" class="headerlink" title="如果情境改为10亿个数的topK问题，怎么想。"></a>如果情境改为10亿个数的topK问题，怎么想。</h2><h3 id="最好想的，还是先全部排序，然后查找。"><a href="#最好想的，还是先全部排序，然后查找。" class="headerlink" title="最好想的，还是先全部排序，然后查找。"></a>最好想的，还是先全部排序，然后查找。</h3><p>最快的排序算法的时间复杂度一般为O（nlogn），如快速排序。<br>但是如果计算机内存不够大，这种方法很容易受内存限制。</p><p>主要解决方案：</p><ul><li><p>分治+Trie树</p></li><li><p>hash+小顶堆</p></li></ul><h3 id="局部淘汰法"><a href="#局部淘汰法" class="headerlink" title="局部淘汰法"></a>局部淘汰法</h3><p>用一个容器保存前1万个树，然后将剩余的所有数字一一和容器内最小的数字比较，如果后续元素比容器内的最小元素大就删掉容器内的最小元素，并将该元素插入容器，最后遍历玩这1亿个数，得到最终结果。</p><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>将1亿个数据分成100份，每份100万个数据，找出每份数据中最大的1万个，最后在剩下的100 X 10000个数据。也就是100万个数据里面找前1万</p><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>通过hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，</p><h3 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h3><p>先读入前10000个数来创建大小为10000的小顶堆，建堆的时间复杂度为O(mlogm),然后遍历后续数字，并与堆顶数字(最小)进行比较，如果比堆顶的数字大，替换堆顶元素调整堆为小顶堆。这个过程直到1亿个数全部遍历完。然后按照中序遍历的方式输出当前堆中的所有1万个数字。该算法的时间复杂度为O(nmlogm),空间复杂度是常数。</p><h3 id="几种应用情境"><a href="#几种应用情境" class="headerlink" title="几种应用情境"></a>几种应用情境</h3><ul><li>单机+单核+足够大内存</li><li>单机+多核+足够大内存</li><li>单机+单核+受限内存</li><li>多机+受限内存</li></ul><p>扩展问题：</p><ul><li>有10000000个记录，这些查询串的重复度比较高，如果除去重复后，不超过3000000个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。请统计最热门的10个查询串，要求使用的内存不能超过1GB。</li><li>有一个1GB大小的文件，里面的每一行是一个词，词的大小不超过16个字节，内存限制大小是1MB。返回频数最高的100个词。</li><li>提取某日访问网站次数最多的那个IP。</li><li>10亿个整数找出重复次数最多的100个整数。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>如何为Nginx服务器配置ssl证书</title>
    <link href="http://huangyiblog.com/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/%E5%A6%82%E4%BD%95%E4%B8%BANginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEssl%E8%AF%81%E4%B9%A6/"/>
    <id>http://huangyiblog.com/业务开发/如何为Nginx服务器配置ssl证书/</id>
    <published>2018-11-21T13:14:42.000Z</published>
    <updated>2018-11-21T14:47:31.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何为Nginx服务器配置ssl证书"><a href="#如何为Nginx服务器配置ssl证书" class="headerlink" title="如何为Nginx服务器配置ssl证书"></a>如何为Nginx服务器配置ssl证书</h1><p>&emsp;&emsp;我前不久才把自己的hexo博客部署到阿里云服务器上，买的学生机LAMP6.0.1,操作系统是centos，部署成功后就去申请备案，备案前期的资料审核还是快的，最后一步管局审核写着不超过20天，结果真的过了20天才发信息来审核通过…<br>&emsp;&emsp;之前的审核过程中，你的域名是不能进行访问，只能通过IP地址访问网站。审核通过后你可以通过http进行访问,但是不能通过进行https:进行访问。所以我们先来看看这两者的区别。</p><h2 id="http与https的基本定义"><a href="#http与https的基本定义" class="headerlink" title="http与https的基本定义"></a>http与https的基本定义</h2><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h2 id="http与https的区别"><a href="#http与https的区别" class="headerlink" title="http与https的区别"></a>http与https的区别</h2><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，这就是https的诞生。<br>阿里云官网的回答</p><blockquote><p>HTTP是过去很长一段时间我们经常用到的一种传输协议。HTTP协议传输的数据都是未加密的，这就意味着用户填写的密码、账号、交易记录等机密信息都是明文，随时可能被泄露、窃取、篡改，从而被黑客加以利用，因此使用HTTP协议传输隐私信息非常不安全。</p></blockquote><blockquote><p>HTTPS是一种基于SSL协议的网站加密传输协议，网站安装SSL证书后，使用HTTPS加密协议访问，可激活客户端浏览器到网站服务器之间的SSL加密通道(SSL协议)，实现高强度双向加密传输，防止传输数据被泄露或篡改。简单讲，HTTPS=HTTP+SSL，即HTTPS是HTTP的安全版。</p></blockquote><p>HTTPS加密、加密、及验证过程，如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2017/3/26/a480d891b7240325055da1e6b2f75ac3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="alt"></p><p>按照网上博客的资料，两者主要有以下具体区别：<br>1、HTTPS更安全：HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议的信息明文传输安全；</p><p>2、HTTPS需要申请证书：HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费，费用大概与.com域名差不多，每年需要大约几十元的费用。而常见的HTTP协议则没有这一项；</p><p>3、端口不同：HTTP使用的是大家最常见的80端口，而HTTPS连接使用的是443端口；</p><p>4、状态不同：HTTP的连接很简单，是无状态的。而HTTPS协议是SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全；</p><h2 id="为Nginx服务器配置ssl证书具体步骤"><a href="#为Nginx服务器配置ssl证书具体步骤" class="headerlink" title="为Nginx服务器配置ssl证书具体步骤"></a>为Nginx服务器配置ssl证书具体步骤</h2><p>一：购买并申请免费证书</p><p>前往阿里云域名控制台–&gt;进入域名管理–&gt;申请免费开启ssl证书<br>这个过程比较快，一般申请成功后不需要多久证书就会发到你的证书控制台。<br>在证书控制台下载Nginx版本证书，下载到本地的是一个压缩文件，解压后里面包含.pem文件是证书文件，.key文件是证书的私钥文件（申请证书时如果没有选择系统创建CSR，则没有该文件）。</p><p>二、进入服务器配置Nginx.conf<br>按照官方文档，我们首先进入服务器的Nginx目录下，新建一个目录cert<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir cert</span><br></pre></td></tr></table></figure></p><p>目录建完以后就需要把你之前下载的证书解压后的文件都拷贝到该目录下面。从本地拷贝文件到远程服务器可以用scp命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /Users/study/xxxxx root@xxx:/etc/nginx/cert</span><br></pre></td></tr></table></figure></p><p>我当时没注意，结果直接把整个文件夹给拷进去了，这样一来等会编辑文件路径的时候就不能忘了修改。<br>拷贝结束后就可以编辑Nginx.conf文件进行配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    ssl on;</span><br><span class="line">    root html;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    ssl_certificate   cert/a.pem;</span><br><span class="line">    ssl_certificate_key  cert/a.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root html;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我主要提几个初次接触的小白容易碰到的问题：</p><ul><li>include /etc/nginx/default.d/*.conf;这一行不需要取消注释</li><li>server_name 可以改为你自己的域名</li><li><p>location/{}里面的root注意要填写你当时配置的项目位置。</p><p>配置好以后保存并退出。<br>之后重新加载并启动nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line">systemctl restart nginx.service</span><br></pre></td></tr></table></figure></li></ul><p>这里很多人一开始可能会出现启动失败的错误，这时不要慌，我的建议是最好学会查看日志文件，看看命令行提示报了什么错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure></p><p>我碰到过的有一种是属于80端口被某个进程占用，当时我是直接强制杀死该进程解决的。其他启动失败的原因多数是你nginx.conf文件配置出错了，比如如法错误，多了什么或少了什么。<br>我当时启动成功后采用https方式访问域名，结果一直都是显示Nginx welcome的首页面，这里其实就是我之前提到过的location/{}里面写错了。当时还有点慌，因为我不记得我把自己的hexo放在哪里了，但还好，把Nginx.conf往上翻就能找到我以前配置过的hexo的root信息，直接复制下来即可。</p><p>到这里，证书配置基本就完成了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何为Nginx服务器配置ssl证书&quot;&gt;&lt;a href=&quot;#如何为Nginx服务器配置ssl证书&quot; class=&quot;headerlink&quot; title=&quot;如何为Nginx服务器配置ssl证书&quot;&gt;&lt;/a&gt;如何为Nginx服务器配置ssl证书&lt;/h1&gt;&lt;p&gt;&amp;emsp;
      
    
    </summary>
    
      <category term="业务开发" scheme="http://huangyiblog.com/categories/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>普通人如何稳固对自我价值的认同感</title>
    <link href="http://huangyiblog.com/%E9%9A%8F%E7%AC%94/%E6%99%AE%E9%80%9A%E4%BA%BA%E5%A6%82%E4%BD%95%E7%A8%B3%E5%9B%BA%E5%AF%B9%E8%87%AA%E6%88%91%E4%BB%B7%E5%80%BC%E7%9A%84%E8%AE%A4%E5%90%8C%E6%84%9F/"/>
    <id>http://huangyiblog.com/随笔/普通人如何稳固对自我价值的认同感/</id>
    <published>2018-11-07T06:01:18.000Z</published>
    <updated>2018-11-07T07:35:06.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="普通人自我认同感很低怎么办？"><a href="#普通人自我认同感很低怎么办？" class="headerlink" title="普通人自我认同感很低怎么办？"></a>普通人自我认同感很低怎么办？</h1><p>&emsp;&emsp;最近又到了清华本科特将评选的日子，看了他们的简历，众多网友耐不住了。纷纷调侃“神仙打架”又开始了。<br>&emsp;&emsp;不过毕竟神仙们打架对我们这些普通人影响其实并不是很大，毕竟距离太远了（指实力上的距离）。大多数人自我认同感低，其实还是因为身边的人，再加上各种网文贩卖焦虑，比如之前的某某单车创始人企业被收购，90后已经实现财务自由。于是有了你已被同龄人抛弃了之类的…在目前经济为王的社会里，各种浮躁的心态层出不穷，不论是在校的学生，还是在企业里的白领，似乎无时无刻不在焦虑着。为什么焦虑，因为怀疑，因为对自我价值的怀疑，导致对自己所做的努力，所做的事情同样产生怀疑。<br>&emsp;&emsp;首先焦虑是正常的，对自己有所怀疑也是正常的。但注意我标题注明的是你几乎已经怀疑过了度。也就是说你甚至已经有些不认同自我价值了。到了这一步，问题其实已然不小。我想写这篇随笔，自然不是因为空想就想到了这么个话题。而是我自己就属于迷茫，不自信的一类人中的一个典型。不知道解决方案，但是写这篇随笔可以让我反思，让我平视，然后再次让自己正常的融入到学习生活中去。能达到这一点就足够。<br>&emsp;&emsp;不同年龄段的人烦恼各不相同，但心态缺失类似的。我正处于学生时代的后期了，倘若不读研，那么在学校的日子几乎按着指头数也能数过来了。学校里终究还只是个象牙塔，与社会的庞杂相比还是相对单纯的多了，至少涉及物质层面的问题会少很多。说撑了无非就是些各种奖学金，助学金之类的。当然，不排除很多人爱慕虚荣，喜欢攀比。许多人的焦虑可能更多来自于学习。学渣与学霸之间的爱恨情仇似乎是学生时代过不去的一道坎也。当你看到身边的某某学霸又拿了个竞赛大奖，某某保研到了国内C9高效，某某某还在纠结于几个知名大厂的offer该选哪个时，你可能会有些触动，你可能还不知道自己想干嘛，毕业了工作能找到吗？上述几个例子自然是少数人，但是当你看到自己的同学如此优秀，你应该怀抱什么样的心态？嫉妒？自卑？蔑视？这里其实已经体现了自我认同感偏低的外因，那就是身边的人光芒四射，你找不到自己了。<br>&emsp;&emsp;有一点还是要明确。我是相信存在智商碾压这回事的。努力确实是个好东西，但是收获未必如你所期望的，毕竟这个过程还得乘上个系数，不然就不存在我在最开头提到的“神仙打架的事情”了。那么好，如今你可能和我一样有些焦虑，有些自我怀疑，害怕自己和身边的神仙差距越来越大，怎么处理。在此之前，你或许也还算努力吧，上课认真听讲，课后也会去翻翻书，你也为了目标有所付出。但是这离你想要的生活并未接近多少。再想想，要不随大流，一起开几把黑，打打王者，看看小说，让自己过得轻松点不行么？嘻嘻，当然没问题，而且要注意，打王者，看小说等等操作与我的问题并不矛盾，很简单，玩游戏就会影响自我认同感吗？没啥关系吧？刚刚前几天LG还拿了世界总决赛冠军呢，多少高校宿舍，朋友圈里的男同胞在自豪的呐喊。那么问题在哪呢？如果这么想，反正我这么菜，还不如上课开开黑，让自己过得舒坦点何乐而不为。这里有个前提，你默认了自己是个菜鸟(自黑的除外)，你从心底里认为了自己不是个优秀的人，即使努力了也是菜鸟一枚，这就有了问题。你并不怎么认同自己，导致你不愿为了些什么东西制定个小计划，小目标什么的，持之以恒的去做点什么。这就糟糕了。<br>&emsp;&emsp;当你开始转变，开始有所努力，慢慢认同自己的时候，你可能一不当心就陷入了另一个误区。那就是自我欺骗。你开始渐渐相信自己其实也很优秀，自己的存在不说对很多人，但对身边的人也还有点价值。于是你开始努力学习，认真生活，你希望让自己变得更加优秀，你希望放大自己的价值。你可能每天都有在刷算法题，你可能每天都在看技术书学习。然而过了段时间，你发现你刷了很多题，但问你一个算法原理你却还是云里雾里，你看了很多课外书，但问你个知识点你却是两眼发呆。你以为每天都在努力，那么自然每天都在收获，结果却是在原地踏步。这就会让你产生盲目的自我认同感。我们拿阅读技术书举例。你读过这本书，并不代表你读懂了，你读懂一个技术点，并不代表你会用了，你已经能够实践了，能够用了，并不代表你已经会变通了，因为你不了解它的底层是什么原理，只知道代码这么写会产生这样的效果。<br>&emsp;&emsp;当你发现了误区，你又开始慢慢转变，你希望让假懂慢慢变成真懂，你希望自己不是假优秀，而是确实肚子里有点货，，慢慢慢慢，可能情况就会有所好转，只要能一步步走上正轨，那么对自我价值的认同感自然也就慢慢上来了。到后面，或许会这么想，“神仙”们的确很厉害，但我在陆地上当个”将军”也不错，“马云、王健林”们的确有钱，而我虽然实现不了财务自由，但也勉强够用了。有勇气平视大家，才能交到好朋友哦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;普通人自我认同感很低怎么办？&quot;&gt;&lt;a href=&quot;#普通人自我认同感很低怎么办？&quot; class=&quot;headerlink&quot; title=&quot;普通人自我认同感很低怎么办？&quot;&gt;&lt;/a&gt;普通人自我认同感很低怎么办？&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近又到了清华本科特
      
    
    </summary>
    
      <category term="随笔" scheme="http://huangyiblog.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>回顾自己部署hexo博客的血泪史</title>
    <link href="http://huangyiblog.com/%E9%9A%8F%E7%AC%94/%E5%9B%9E%E9%A1%BE%E8%87%AA%E5%B7%B1%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%A1%80%E6%B3%AA%E5%8F%B2/"/>
    <id>http://huangyiblog.com/随笔/回顾自己部署hexo博客的血泪史/</id>
    <published>2018-10-29T14:52:02.000Z</published>
    <updated>2018-12-25T07:48:02.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回顾下自己使用hexo博客踩过的坑"><a href="#回顾下自己使用hexo博客踩过的坑" class="headerlink" title="回顾下自己使用hexo博客踩过的坑"></a>回顾下自己使用hexo博客踩过的坑</h1><blockquote><p>从一开始接触hexo博客到现在也过去好几个月了，在很多大佬看来搭建部署个个人博客是个很小儿科的事情，但对我这样一个菜鸟来说陆陆续续的几乎是采坑无数，现在回想起来都是泪啊，尤其是碰到一些bug，百度谷歌都找不到你想要的解答时，真的绝望的感觉。我这次虽然是坐个总结，但时间过去很久了，一些具体的bug，以及处理代码我就不写出来了，所以如果你想在这里看到一些实操干货的话，可能要失望了，毕竟我写的不是教程。</p></blockquote><p>我使用hexo博客主要经历了如下几个阶段：</p><ul><li>下载hexo，选择主题，编辑配置文件，部署到GitHub</li><li>想优化主题，自定义了一些css样式，加入了一些插件</li><li>后面换了电脑，想要在多终端协同管理hexo</li><li>纠结于GitHub pages 访问速度不给力，考虑CDN，最后还是想部署到阿里云服务器。　<a id="more"></a></li></ul><p>　　一开始和很多人一样活跃于博客园，ＣＳＤＮ等第三方博客平台，那是还是大学刚开学的时候吧，还不怎么写博客，到了后面偶尔也学一些大佬写点题解啥的，但也并不积极。到了大二，学的东西、课程越来越多，内容越积越多，但显而易见的是，我们不可能记住所有内容，如何有效的总结知识点，最好将书上的变成自己的，如何深入理解，如何提升自己的写作水平，总的来说，写博客还是一个不错的提升自己的方式。可这时，可能是想追求个性，想有一个自己的个人博客，当时主要就想到了ＷｏｒｄＰｒｅｓｓ和ｈｅｘｏ，但是用ＷｏｒｄＰｒｅｓｓ还是要买域名和云服务器，虽说阿里云和腾讯云等服务商对学生的优惠力度都很大，但我最初并不是很想花钱，于是选择了ｈｅｘｏ。选择ｈｅｘｏ其实也有很多好处，帮我入门了ｇｉｔ和ＧｉｔＨｕｂ。决定以后，边去网上找各种教程，下载ｎｏｄｅ、ｈｅｘｏ、ｎｅｘｔ主题等等，之后配置文件，然后ｈｅｘｏ　ｎｅｗ　ｐｏｓｔ，ｈｅｘｏ　ｓ，测试效果，这个过程中，出过一些小问题，但最后都能够成功部署，只是有一个小ｂｕｇ。部署成果后，导航栏的几个主要图标无法正常显示，我一直不明白到底是哪里出了问题，因为每一步都是按照网上的教程操作的，谷歌了好久也没解决。当时没辙，我就去问了我们的ｗｅｂ老师，然而老师说他也没搞过这个，所以并不了解，但是还是给出了建议，因为大部分ｂｕｇ，９９％前人肯定都遇到过，可以先去谷歌百度搜，实在不行可以去知乎等社区提问。我后面就去知乎发表提问，并要求了几位内行人回答，期初也没得到我想要的解答，但几天过去，总算是等来了我想要的。问题其实很简单，还是配置文件上没有填正确，之所以没有填正确。有两个主要原因：１版本问题，２自己不注意看官方注释。首先网上给出的教程并没有问题，但我完全照搬就出了问题，因为他们针对的版本与我再用的版本并不一样，而恰好我的版本在导航栏配置哪里格式有所区别，导致最后图标无法正常显示。总之，倒腾了半天，最后总算还顺利，我发布了自己的第一篇博客并且成功部署到了ＧｉｔＨｕｂ，网页上也能正常浏览。<br>　　我当时选择的是ｎｅｘｔ主题，我很喜欢这样简约大方的风格，大量留白，不花里胡哨，同时也能够满足我的需求，我只想写写东西，这样的就已经足够。但是还不够，我想往里面加点东西，改点东西。这个过程，也很心累，因为我前端没好好学，而页面设计这方面涉及的主要都是前端的点。我修改了一些样式，字体，颜色什么的，接了网易云嵌入式链接，开头评论功能，增加友链，用七牛做图床等等，总之就是各种折腾。有时看了自己改的很不满意又得想办法改回去。这个过程有一点很重要，就是了解ｈｅｘｏ主题的整体框架配置，知道哪个文件夹，哪个文件主要是负责哪一块的！<br>　　后面我买了台二手ＭＢＰ，想在这台电脑上也能管理发布ｈｅｘｏ博客，于是又想办法，在网上各种搜教程，如何在两台电脑上管理ｈｅｘｏ。最后的解决方案是利用ＧｉｔＨｕｂ分支，新建一个分支，然后将原电脑上所需的本地文件拷到新电脑，在新电脑上把内容ｐｕｓｈ到相应分支。这个过程也很不容易，主要是我不怎么理解ＧｉｔＨｕｂ的分支操作，哎，但还算好吧，没有花太多时间。<br>　　又过了一段时间，随之我发布的博客内容越来越多，而ＧｉｔＨｕｂ　ｐａｇｅｓ的访问速度又不稳定，有时还很令人纠结，这我就受不了了，我想着怎么才能加速访问，比较ＧｉｔＨｕｂ是国外的服务器，虽然免费给你一定空间使用，但访问速度我真的不满意。网上有说把博客再部署到ＣＯＤｉｎｇ上面的，也有说用ＣＤＮ的，我考虑过ＣＤＮ，当时选的是加速乐，但是生效要很久，我也没测试效果如何。最后想着趁现在自己还是学生，干脆去阿里云买个云服务器得了。服务器买了以后，问题又来了，如何将本地博客迁移到云服务器上了，这个过程有时让我掉了一堆头发。一开始就出了问题，按照网上的教程，我装好ｎｏｄｅ，ｇｉｔ，ｈｅｘｏ，Ｎｇｉｎｘ等等所需的软件，但是当我启动Ｎｇｉｎｘ的时候一直出错，无法启动，最初人物是自己在编辑．ｃｏｎｆ文件的时候可能哪里多了分号点号啥的，一直没搞清楚问题是啥，到后面干脆重置了虚拟机，将各种软件重新装了一遍。这是再次启动Ｎｇｉｎｘ，还是启动不了，真是崩溃的心都有了，没辙，只好按照命令行的提示，查看日志提示是哪里有ｂｕｇ，你别说，我这种菜鸟一开始看提示都还不大看得懂，只好又将提示代码复制到谷歌搜解答，但是这还不能马上搜到，因为有些时候一段提示信息可能会对应一堆可能的ｂｕｇ，但我这次还算运气可以吧。最后的结论是我的服务器上８０端口ｈｔｔｐｄ被占用，也就是说Ａｐａｃｈｅ和Ｎｇｉｎｘ不能同时启用吧，之后便停用８０端口，然后重新加载Ｎｇｉｎｘ，在游览器输入服务器ＩＰ，总算是见到了ｗｅｌｃｏｍｅ的页面了，松了一口气呀。之后要做的就是新建ｇｉｔ库，配置ｇｉｔｈｏｏｋｓ，配置Ｎｇｉｎｘ的ｓｅｒｖｅｒ的ｌｏｃａｔｉｏｎ等等，然后修改本地ｈｅｘｏ的．ｃｏｎｆｉｇ文件，然后将博客部署到服务器上。到这里你在输入ＩＰ到游览器便能够看到你的博客了。<br>　　上面就是我倒腾ｈｅｘｏ的主要历程，但是还有个问题要讲下，那就是域名，域名我很早就买了，也是在阿里云上买的，当时就是解析到了ＧｉｔＨｕｂ的ＸＸＸ．ｇｉｔｈｕｂ．ｉｏ，这样输入域名也能访问我的博客，另外由于访问的是国外服务器，所以我的域名也没有备案，换句话说，其实我也备不了案，因为我没有买服务器，也就没有备案服务号。后来我买了服务器就想着干脆也去备案下吧．．结果一开始我就觉得好烦，得我自己去打印核验单邮寄到贵州，还得用阿里云的幕布拍照，总觉得麻烦。现在还在备案中．．．　　</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;回顾下自己使用hexo博客踩过的坑&quot;&gt;&lt;a href=&quot;#回顾下自己使用hexo博客踩过的坑&quot; class=&quot;headerlink&quot; title=&quot;回顾下自己使用hexo博客踩过的坑&quot;&gt;&lt;/a&gt;回顾下自己使用hexo博客踩过的坑&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;从一开始接触hexo博客到现在也过去好几个月了，在很多大佬看来搭建部署个个人博客是个很小儿科的事情，但对我这样一个菜鸟来说陆陆续续的几乎是采坑无数，现在回想起来都是泪啊，尤其是碰到一些bug，百度谷歌都找不到你想要的解答时，真的绝望的感觉。我这次虽然是坐个总结，但时间过去很久了，一些具体的bug，以及处理代码我就不写出来了，所以如果你想在这里看到一些实操干货的话，可能要失望了，毕竟我写的不是教程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我使用hexo博客主要经历了如下几个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载hexo，选择主题，编辑配置文件，部署到GitHub&lt;/li&gt;
&lt;li&gt;想优化主题，自定义了一些css样式，加入了一些插件&lt;/li&gt;
&lt;li&gt;后面换了电脑，想要在多终端协同管理hexo&lt;/li&gt;
&lt;li&gt;纠结于GitHub pages 访问速度不给力，考虑CDN，最后还是想部署到阿里云服务器。
    
    </summary>
    
      <category term="随笔" scheme="http://huangyiblog.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Github" scheme="http://huangyiblog.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>11. 盛最多水的容器</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://huangyiblog.com/题解集/11-盛最多水的容器/</id>
    <published>2018-10-25T07:27:41.000Z</published>
    <updated>2018-10-25T07:28:53.413Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="alt"></p><p>示例:</p><p>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49</p><p>分析：考虑两种思路<br>解法一：暴力法<br>用两重for循环，考虑没对可能的线段组合并每次取较大值。<br>时间复杂度为O(n^2),要超时<br>解法二：双指针<br>定义两个指针，一个指向开头，一个指向结尾，每次更新最大面积的时候，将指向较短线段的指针向着指向较长线段指针的方向移动一步，因为如果是将指向较长线段的指针往内侧移的话，矩形区域的面积还是要受制于较短的线段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  maxArea11.cpp</span></span><br><span class="line"><span class="comment">//  LeetCode</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by a on 2018/10/25.</span></span><br><span class="line"><span class="comment">//  Copyright © 2018 Leetcode. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//时间复杂度O(n^2),空间复杂度O(1)</span></span><br><span class="line">    <span class="keyword">int</span> maxarea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; height.size(); j++) &#123;</span><br><span class="line">            maxarea = max(maxarea, min(height[i], height[j]) * (j - i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxarea;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line">    <span class="keyword">int</span> maxarea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = height.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        maxarea = max(maxarea, min(height[left], height[right] )* (right - left));;</span><br><span class="line">        <span class="keyword">if</span>(height[left] &lt; height[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxarea;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; height;</span><br><span class="line">    <span class="keyword">int</span> n, x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        height.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxarea1 = maxArea(height);</span><br><span class="line">    <span class="keyword">int</span> maxarea2 = maxArea2(height);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; maxarea1 &lt;&lt; <span class="string">" "</span> &lt;&lt; maxarea2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;说明：你不能
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Java容器概述</title>
    <link href="http://huangyiblog.com/%E8%AF%AD%E8%A8%80/Java%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0/"/>
    <id>http://huangyiblog.com/语言/Java容器概述/</id>
    <published>2018-10-22T08:39:48.000Z</published>
    <updated>2018-12-19T15:13:02.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java容器-Container"><a href="#Java容器-Container" class="headerlink" title="Java容器(Container)"></a>Java容器(Container)</h1><h2 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h2><p>容器可以管理对象的生命周期、对象与对象之间的依赖关系。<br>直白点说容器就是一段Java程序，能够帮助你管理对象间的关系，而不需要你自行编写程序处理。<br>维基百科定义：</p><blockquote><p>在计算机科学中，容器是指实例为其他类的对象的集合的类、数据结构、[1][2]或者抽象数据类型。换言之，它们以一种遵循特定访问规则的系统的方法来存储对象。容器的大小取决于其包含的对象（或元素）的数目。<br>潜在的不同容器类型的实现可能在空间和时间复杂度上有所差别，这使得在给定应用场景中选择合适的某种实现具有灵活性。</p></blockquote><a id="more"></a><h2 id="Java内部的容器类"><a href="#Java内部的容器类" class="headerlink" title="Java内部的容器类"></a>Java内部的容器类</h2><p>Java内部的容器类主要分为两类：Collection(集合)与Map(图)</p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p><img src="http://huangyiblog.com/java-collections.png" alt="alt"></p><p><strong>Set</strong></p><ul><li><strong><em>HashSet</em></strong></li></ul><ol><li>基于哈希表实现，底层使用HashMap来保存所有元素。</li><li>不能保证迭代顺序</li><li>允许使用null元素</li></ol><ul><li><strong><em>LinkedHashSet</em></strong></li></ul><ol><li>LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承于HashSet。</li><li>内部使用双向链表维护插入顺序。</li></ol><ul><li><strong><em>TreeSet</em></strong></li></ul><ol><li>基于（TreeMap）红黑树实现</li><li>TreeSet非同步，线程不安全</li><li>TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。</li></ol><p><strong>List</strong></p><ul><li><strong><em>ArrayList</em></strong></li></ul><ol><li>实现 List 接口、底层使用数组保存所有元素。</li><li>相当于动态数组，支持动态扩容。</li><li>不同步</li></ol><ul><li><strong><em>vector</em></strong></li></ul><ol><li>Vector 可以实现可增长的对象数组。</li><li>Vector 实现 List 接口，继承 AbstractList 类，同时还实现RandmoAccess 接口，Cloneable 接口</li><li>Vector 是线程安全的</li></ol><ul><li><strong><em>LinkedList</em></strong><br>LinkedList 是基于链表实现的（通过名字也能区分开来），<br>所以它的插入和删除操作比 ArrayList 更加高效。但也是由于其为基于链表的，所以随机访问的效率要比 ArrayList 差。</li></ul><p><strong>Queue</strong></p><ul><li><p><strong><em>LinkedList</em></strong><br>可以用于实现双向队列</p></li><li><p><strong><em>PriorityQueue</em></strong><br>通过二叉小顶堆实现，可以用一棵完全二叉树表示。<br>可以用于实现优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。</p><h3 id="Map-用于映射（键值对）问题处理"><a href="#Map-用于映射（键值对）问题处理" class="headerlink" title="Map(用于映射（键值对）问题处理)"></a>Map(用于映射（键值对）问题处理)</h3></li></ul><p><img src="http://huangyiblog.com/java-collections1.png" alt="alt"></p><p><strong>HashMap</strong></p><ol><li>HashMap根据键的HashCode来实现，访问速度较快，遍历顺序并不确定。</li><li>HashMap最多只允许一条记录的键为null，允许多条记录的值为null。</li><li>HashMap线程不安全，也就是说任意时刻可以有多个线程同时写HashMap，所以可能会导致数据的不一致。</li><li>如何确保线程安全？可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</li></ol><p><strong>HashTable</strong></p><ol><li>HashTable是遗留类，多数功能与HashMap类似，继承自Dictionary类。</li><li>HashTable是线程安全的。也就是说任意时刻只有一个线程能够写HashTable。</li><li>HashTable的并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。</li></ol><p><strong>LinkedHashMap</strong><br>基于哈希表和链表实现，借助双向链表确保迭代顺序是插入的顺序。</p><p><strong>TreeMap</strong></p><ol><li>基于红黑树实现</li><li>默认按照键值得升序进行排序。</li><li>在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，<br>否则会在运行时抛出java.lang.ClassCastException类型的异常。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java容器-Container&quot;&gt;&lt;a href=&quot;#Java容器-Container&quot; class=&quot;headerlink&quot; title=&quot;Java容器(Container)&quot;&gt;&lt;/a&gt;Java容器(Container)&lt;/h1&gt;&lt;h2 id=&quot;什么是容器？&quot;&gt;&lt;a href=&quot;#什么是容器？&quot; class=&quot;headerlink&quot; title=&quot;什么是容器？&quot;&gt;&lt;/a&gt;什么是容器？&lt;/h2&gt;&lt;p&gt;容器可以管理对象的生命周期、对象与对象之间的依赖关系。&lt;br&gt;直白点说容器就是一段Java程序，能够帮助你管理对象间的关系，而不需要你自行编写程序处理。&lt;br&gt;维基百科定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机科学中，容器是指实例为其他类的对象的集合的类、数据结构、[1][2]或者抽象数据类型。换言之，它们以一种遵循特定访问规则的系统的方法来存储对象。容器的大小取决于其包含的对象（或元素）的数目。&lt;br&gt;潜在的不同容器类型的实现可能在空间和时间复杂度上有所差别，这使得在给定应用场景中选择合适的某种实现具有灵活性。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="语言" scheme="http://huangyiblog.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="http://huangyiblog.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>24. 两两交换链表中的节点</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://huangyiblog.com/题解集/24-两两交换链表中的节点/</id>
    <published>2018-10-19T13:12:06.000Z</published>
    <updated>2018-12-19T14:03:41.873Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>分析：<br>解法一：<br>题目要求两两链表中的结点，比较好想得应该还是直接遍历整个链表list，每次swap(list-&gt;val,list-&gt;next-&gt;val),但是题目明确要求了不能只是单纯的改变结点的数据域，所以上述方法尽管输出一样，但并不符合要求。<br>解法二：<br>首先定义一个dummy哑结点指向head作为首结点来辅助操作。<br>之后定义一个current指向给定链表，定义一个前去指针pre指向dummy，定义一个临时链表temp储存每次要进行操作的两个结点。例如给定链表{1,2,3,4},先让temp指向3，然后分割{1,2}和{3,4},<br>让2的后继指针指向1，之后让dummy指向2，让1指向3，最后让pre指向1，current指向3继续遍历。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  swapNodes.cpp</span></span><br><span class="line"><span class="comment">//  LeetCode</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by a on 2018/10/19.</span></span><br><span class="line"><span class="comment">//  Copyright © 2018 Leetcode. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">creat</span><span class="params">( <span class="keyword">int</span> Array[])</span> </span>&#123;</span><br><span class="line">    ListNode *p, *pre, *head;</span><br><span class="line">    head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    pre = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        p-&gt;val = Array[i];</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;next = p;</span><br><span class="line">        pre = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">( ListNode* head )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;next) &#123;</span><br><span class="line">        swap(p-&gt;val, p-&gt;next-&gt;val);</span><br><span class="line">        p = p-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs2</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    ListNode* pre = dummy;</span><br><span class="line">    ListNode* temp;</span><br><span class="line">    <span class="keyword">while</span>(current &amp;&amp; current-&gt;next) &#123;</span><br><span class="line">        temp = current-&gt;next-&gt;next;</span><br><span class="line">        current-&gt;next-&gt;next = current;</span><br><span class="line">        pre-&gt;next = current-&gt;next;</span><br><span class="line">        current-&gt;next = temp;</span><br><span class="line">        pre = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Array[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    ListNode* head1 = creat(Array);</span><br><span class="line">    ListNode* head2 = creat(Array);</span><br><span class="line">    ListNode* L = swapPairs(head1);</span><br><span class="line">    <span class="comment">//L = L-&gt;next;</span></span><br><span class="line">    ListNode* res = swapPairs2(head2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(L != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, L-&gt;val);</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(res != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, res-&gt;val);</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>支持推理小说家紫金陈</title>
    <link href="http://huangyiblog.com/%E9%98%85%E8%AF%BB/%E6%94%AF%E6%8C%81%E6%8E%A8%E7%90%86%E5%B0%8F%E8%AF%B4%E5%AE%B6%E7%B4%AB%E9%87%91%E9%99%88/"/>
    <id>http://huangyiblog.com/阅读/支持推理小说家紫金陈/</id>
    <published>2018-10-19T06:29:55.000Z</published>
    <updated>2019-04-27T12:58:05.437Z</updated>
    
    <content type="html"><![CDATA[<p><div align="center"><img src="http://huangyiblog.com/zijinchen1.jpg" width="600" height="500"></div><br></p><h1 id="紫金陈主要作品"><a href="#紫金陈主要作品" class="headerlink" title="紫金陈主要作品"></a>紫金陈主要作品</h1><ul><li>《推理之王1：无证之罪》（2014年实体书出版）</li><li>《推理之王2：坏小孩》（2014年实体书出版）</li><li>《推理之王3：长夜难明》（2017年出版）</li><li>《浙大夜惊魂》（2010年出版改名《禁忌之地》）</li><li>《谋杀官员1》（2012年）</li><li>《谋杀官员2：化工女王的逆袭》（2012年）</li><li>《谋杀官员3：物理教师的时空诡计》（2013年1月更新完）</li><li>《谋杀官员4：代上帝之手(完结)》（2013年）<blockquote><p>因为我自己主要就阅读了他的上述作品，所以其他书没有全都一一例举。</p></blockquote></li></ul><a id="more"></a><p>　　一提到推理小说，估计很多人又想到了我们的邻居－－岛国日本，推理小说早期兴起于欧美，后来在日本也有了极大的发展。平时我们读的很多推理或者侦探小说相比大多都是欧美或者日本的作品比较多吧。著名的作者比如美国的埃德加·爱伦·坡，英国的阿加莎·克里斯蒂，日本的江川户乱步、东野圭吾等都是推理小说界的大神，不仅高产还高质量，我已开始读的也是日本的推理小说比较多。大一看了几本东野大神的作品后无意中接触到了国内紫金陈写的《无证之罪》，顿时来了兴趣，陆陆续续的也看了他的一些代表作，就我个人而言还是蛮喜欢他的推理作品，虽然不像有些大神那么高产，也不是每一本都布局十分巧妙，但吸引人的点还是很多的。<br>　　我已开始接触《无证之罪》后就顺便看完了他的推理之王系列的另外两本，《坏小孩》与《长夜难明》，之后又看了他较早的几部作品，从《浙大惊魂夜》（后来再版改名为《禁忌之地》）到《谋杀官员系列》，可以看出作者在每部作品的布局构思上都花了很大心思。紫金陈本名陈徐，毕业于浙江大学，主要走的是社会派本格推理路线，比如《谋杀官员系列》就是他的本格推理代表作。他的作品里的主要人物背景很多也是浙大毕业的校友，至于社会背景大多在以浙江各个市为模板进行创作。《无证之罪》很多人会拿来与东野圭吾的《嫌疑人Ｘ的献身》进行对比，认为在情节完善和人物塑造等方面还有很多不足之处，作者融入中国社会的背景，但同样是一位高智商大神为了帮助失误犯了罪的可怜人摆脱警察的故事。《坏小孩》的故事我大都忘了，比较早看的一本，其实说起来推理之王系列我最推崇的是《长夜难明》，他的说我也就这本买过实体说。不过说起来《长夜难明》或许并算不上推理吧，情节也不悬疑，只能说属于社会派推理比较好，但反映的社会问题还是很沉重的，虽然是小说，但现实生活中有没有类似的案情或者更为残酷的事实恐怕很难说，或许黑暗一直存在只是没有笼罩在你身上罢了。很多人应该看过韩国的一部电影《熔炉》，内容很沉重，在韩国法律界社会界都引起了极大的反响。《长夜难明》反应了类似的社会法律问题，书中直至结局也没能揪出幕后大老虎，尽管已经有人为此献出了生命的代价，但是在权利的悬殊面前你很难立马冲破黑暗。甚至很有可能一味的付出却给自己带来了毁灭的报复。总感觉现实中这么正义凛然的人很少，大家内心都有自己的想法，为什么要为了不相干的人去得罪人，做吃力不讨好的事？但如果人人都这么想，那些弱势群体就一直被压榨下去吗？<br>　　《谋杀官员系列》也不是每本都很精彩，有很多欠缺的地方还是明显的，尽管作为推理小说，或许不是非得文笔一流，但文笔不足的间接影响就是导致了人物造型，性格塑造方面不够鲜活，包括一些悬疑的点也很牵强。另外第二部和第四部都写到了屌丝对女神的爱，我就想说作者就不能放过广大屌丝吗，另外我想着尽管矮穷丑，但好歹是浙大高材生至于这么自卑吗，还是真的爱得真切，无法自拔。第四部结尾的有点牵强，竟然又扯出来了同性恋，但好在不是个完美的结尾，最后提到女神骆慧慧的孩子既不是李卫平也不是王红名的时候，估计很多人也蒙了，人性的复杂也只在这种时刻才能感受到。第二部又是一个单相思的家伙为了自己喜欢的人不惜付出一切为她犯罪，书名《化工女王的逆袭》估计误导了很多人，一直以为所谓的“同伙”就是化工女甘佳宁，结果这只是个幌子，但是“同伙”这个点设计的还是比较好的。另外这部反映的官场腐败等政治问题也挺厉害的，官场的腐败从上到下，从一手遮天的大老虎到仗势欺人的看家狗都让人不寒而栗，权利没有约束是很恐怖的。<br>　　我一般看这种推理小说并不怎么较真，不会太计较情节上的漏洞，除非是太明显的，毕竟自己只是个门外汉，娱乐为主哈哈。上述几本书看完倒也没花掉我多少时间，想想自己书架上的几本技术方面的恐龙📚，我内心就拔凉拔凉了，若是真想一本本从头看到尾，我又能吸收到少呢．．．　　</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://huangyiblog.com/zijinchen1.jpg&quot; width=&quot;600&quot; height=&quot;500&quot;&gt;&lt;/div&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;紫金陈主要作品&quot;&gt;&lt;a href=&quot;#紫金陈主要作品&quot; class=&quot;headerlink&quot; title=&quot;紫金陈主要作品&quot;&gt;&lt;/a&gt;紫金陈主要作品&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;《推理之王1：无证之罪》（2014年实体书出版）&lt;/li&gt;
&lt;li&gt;《推理之王2：坏小孩》（2014年实体书出版）&lt;/li&gt;
&lt;li&gt;《推理之王3：长夜难明》（2017年出版）&lt;/li&gt;
&lt;li&gt;《浙大夜惊魂》（2010年出版改名《禁忌之地》）&lt;/li&gt;
&lt;li&gt;《谋杀官员1》（2012年）&lt;/li&gt;
&lt;li&gt;《谋杀官员2：化工女王的逆袭》（2012年）&lt;/li&gt;
&lt;li&gt;《谋杀官员3：物理教师的时空诡计》（2013年1月更新完）&lt;/li&gt;
&lt;li&gt;《谋杀官员4：代上帝之手(完结)》（2013年）&lt;blockquote&gt;
&lt;p&gt;因为我自己主要就阅读了他的上述作品，所以其他书没有全都一一例举。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://huangyiblog.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="小说" scheme="http://huangyiblog.com/tags/%E5%B0%8F%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>137. 只出现一次的数字 II</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-II/"/>
    <id>http://huangyiblog.com/题解集/137-只出现一次的数字-II/</id>
    <published>2018-10-17T13:16:44.000Z</published>
    <updated>2018-12-19T15:13:02.596Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,3,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,1,0,1,99]</span><br><span class="line">输出: 99</span><br></pre></td></tr></table></figure></p><p>解法一：<br>创建一个长度为sizeof(int)的数组count[sizeof(int)]，用count[i]来表示在i位出现的1的次数，如果count[i]是3的倍数，跳过，否则，取出该位。<br>时间复杂度O(n),空间复杂度O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> w = <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> count[w];</span><br><span class="line">        fill_n(&amp;count[<span class="number">0</span>], w, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">                count[j] += (nums[i] &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">                count[j] %= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w; i++) &#123;</span><br><span class="line">            res += count[i] &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解法二：<br>用二进制模拟三进制运算。<br>用one记录到当前处理的元素为止，二进制1出现“1次”（mod 3 之后的 1）的有哪些二进制位；用two记录到当前计算的变量为止，二进制1出现“2次”（mod 3 之后的 2）的有哪些二进制位。当one和two中的某一位同时为1时表示该二进制位上1出现了3次，此时需要清零。<br>时间复杂度O(n),空间复杂度O(1)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> one  = <span class="number">0</span>, two = <span class="number">0</span>, three = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            two |= (one &amp; i);</span><br><span class="line">            one ^= i;</span><br><span class="line">            three = ~(one &amp; two);</span><br><span class="line">            one &amp;= three;</span><br><span class="line">            two &amp;= three;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>解法三：<br>我们把数组中数字的每一位累加起来对3取余，剩下的结果就是那个单独数组该位上的数字.<br>用二进制表示的过程为00-&gt;01-&gt;10-&gt;00,用a 和 b来表示一开始的状态的十位和个位：<br>b = b ^ r &amp; ~a;<br>a = a ^ r &amp; ~b;<br>刚开始的时候，a和b都是0，当遇到数字1的时候，b更新为1，a更新为0，就是01的状态；再次遇到1的时候，b更新为0，a更新为1，就是10的状态；再次遇到1的时候，b更新为0，a更新为0，就是00的状态，相当于重置了；所以最后的结果保存在b中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            b = (b ^ nums[i]) &amp; ~a;</span><br><span class="line">            a = (a ^ nums[i]) &amp; ~b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://soulmachine.gitbooks.io/algorithm-essentials/java/bitwise-operations/single-number-ii.html" target="_blank" rel="noopener">https://soulmachine.gitbooks.io/algorithm-essentials/java/bitwise-operations/single-number-ii.html</a></p><p><a href="https://leetcode.com/problems/single-number-ii/discuss/43294/challenge-me-thx" target="_blank" rel="noopener">https://leetcode.com/problems/single-number-ii/discuss/43294/challenge-me-thx</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>谈谈一部争议较大的日漫《缘之空》</title>
    <link href="http://huangyiblog.com/%E5%BD%B1%E9%9F%B3/%E8%B0%88%E8%B0%88%E4%B8%80%E9%83%A8%E4%BA%89%E8%AE%AE%E8%BE%83%E5%A4%A7%E7%9A%84%E6%97%A5%E6%BC%AB%E3%80%8A%E7%BC%98%E4%B9%8B%E7%A9%BA%E3%80%8B/"/>
    <id>http://huangyiblog.com/影音/谈谈一部争议较大的日漫《缘之空》/</id>
    <published>2018-10-16T08:33:45.000Z</published>
    <updated>2018-12-19T15:13:23.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我先给出自己的主要观点："><a href="#我先给出自己的主要观点：" class="headerlink" title="我先给出自己的主要观点："></a>我先给出自己的主要观点：</h2><ul><li>我不认为悠是渣男，恰恰相反，整部番里我觉得悠才是内心最纠结的可怜人。</li><li>我不支持兄妹乱伦的爱情，但我相信可能会有这样真实的感情。</li><li>我支持平行世界的剧情设计。</li><li>对我而言这部番吸引我的是BGM。</li><li>我不赞同有人纯粹拿这部番当里番来看，我不觉得这是部里番。</li><li>我不相信柏拉图式的爱情，完全没有性的爱情我觉得不存在。</li></ul><a id="more"></a><p>　　日本动漫产业一直以来都是其他国家难以匹敌的一块，我平时看的动漫虽然不能说很少吧，但多是完全谈不上，你可能无法想象一些宅男腐女追番有多么疯狂，其实在其他方面我也是这种状况，看书，看电影，似乎各种都有所投入，但都只是了解很少一部分。动漫能吸引人主要有几个点：剧情、画风、配音、ＢＧＭ。有时我是真佩服那些声优和作曲家，明明剧情狗血的要命，也能让我感动起来．．．我这次想写关于缘之空的故事，其实是因为三轮学创作的ｂｇｍ太好听了（×……————……×）　嘻嘻……<br>　　缘之空算是一部比较早期的作品了，是根据游戏改变过来的。当初游戏本就是分线路展开剧情的。所以后面改编成动画采用平行世界也没什么好奇怪的。游戏里主要有５条线，分别是宆悠线（也就是争议最大的兄妹线）、奈绪线、一叶线、悠瑛线、班长线。不过动漫里好像把班长那条线去掉了，只讲述了４条线。首先我们先来科普下平行世界的问题，我是在看之前就已经了解了剧情的构造，所以很多地方并不会觉得很奇怪或是难以理解。百度百科的定义如下：多元宇宙是一个理论上的无限个或有限个可能的宇宙的集合，包括了一切存在和可能存在的事物：所有的空间、时间、物质、能量以及描述它们的物理定律和物理常数。多元宇宙所包含的各个宇宙被称为平行宇宙（parallel universes）。好吧说实话我没怎么看明白，平行世界是否存在我也不知道，我这种物理渣渣还是就不要太纠结于这个了，一部动漫而已，太较真吃不消。按照字面意思来理解，缘之空其实就是讲述了男主悠在不同宇宙和一群相同的人之间发生的不同的故事。有和穹之间的故事，和奈绪之间的故事，和一叶之间的故事，还有瑛。<br>　　也许是改编成动漫时衔接的处理有些瑕疵，很多人认为悠是个渣男，脚踩都不止两只船了，可其实按照剧情设计，悠并没有脚踩两只船，他有同时在和两个女生交往吗？他有花心般的欺骗吗？和其他几个女生的交集更像是普通中学少男少女的青涩的爱情，只是到后来悠才意识的自己真正喜欢的是谁。穹妹给人的感觉有种红楼梦里林黛玉的影子，柔弱，多病，少话，内心却又感情丰富，有脾气有个性。这双胞胎兄妹的父母死于交通事故，两人相依为命，一起来到了祖父曾经生活过的奥木尔町生活，也是在这里发生了一系列的故事。<br>　　穹悠线饱受争议，就是因为双胞胎兄妹之间产生了情愫并甚至接受这样的情感。现实生活中包括我自己，想必很多人也是一样，很难想象或者说理解亲兄妹之间怎么能萌生出爱情的火花呢，从小一起长大。不知道你们有没有了解过韦斯特马效应，韦斯特马效应由芬兰人类学家爱德华·韦斯特马克在他的著作《The History of Human Marriage》（人类婚姻史）中提出，指出两个早年共同长大的儿童在成年后通常不会对彼此产生性吸引力：有血缘关系者也会存在亲缘监测机制（亲缘监测机制异常除外，三代以内越近越明显。）来保护；无血缘关系者由于生活在一起或可不会成年后产生性吸引；出生后六年的成长环境是一个关键时间点，其间生活在一起二者性吸引几率全会大大降低。但穹和悠却并不满足韦斯特马效应的前提，之前穹生病，兄妹二人长时间并未生活在一起，但突然间双亲离世，两人再次相遇，也许真有可能产生喜欢的情愫也说不定。但是兄妹恋终究是不被人认可的，所以可以感受悠的挣扎，悠和穹不一样，穹什么都不在乎，在乎的只有悠而已，悠作为哥哥，需要负起的应当是父亲般的责任，但却喜欢上了自己的妹妹，说出来谁能接受，不光会被人以异样的眼光看待，也没有做好一个哥哥的本分。动漫最后的处理是两人从湖中死里逃生最后一起移居他乡。我不知道这样的结局如何，如何确实互相爱慕，即使是兄妹，那么该不该在一起呢？我不知道，我不支持乱伦恋，但真实的感情并不能由外力改变，这是我相信的。<br>　　最后关于尺度问题，的确，这部动漫里有一些暴露的镜头，但我个人觉得并不过分，如果是爱情的话，这本也就是爱情的一部分，何必去特意躲闪。我大一暑假花了很长时间看完《金瓶梅》，好吧，我没那么纯洁，做不到看金瓶梅看出圣经来，但还是不否认这是一部伟大的文化作品，很多人认为金瓶梅的格调不如红楼梦，红楼梦当之无愧是我国古典文学的巅峰，但如果仅仅只是因为一个重点讲情、一个重点讲欲来评判高低那就太不公平了。缘之空很多人还是无法接受的，被禁我觉得也正常，有时也不能一天到晚黑广电，从国家层面来说，还是需要宣扬社会主义核心价值观比较好~~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;我先给出自己的主要观点：&quot;&gt;&lt;a href=&quot;#我先给出自己的主要观点：&quot; class=&quot;headerlink&quot; title=&quot;我先给出自己的主要观点：&quot;&gt;&lt;/a&gt;我先给出自己的主要观点：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我不认为悠是渣男，恰恰相反，整部番里我觉得悠才是内心最纠结的可怜人。&lt;/li&gt;
&lt;li&gt;我不支持兄妹乱伦的爱情，但我相信可能会有这样真实的感情。&lt;/li&gt;
&lt;li&gt;我支持平行世界的剧情设计。&lt;/li&gt;
&lt;li&gt;对我而言这部番吸引我的是BGM。&lt;/li&gt;
&lt;li&gt;我不赞同有人纯粹拿这部番当里番来看，我不觉得这是部里番。&lt;/li&gt;
&lt;li&gt;我不相信柏拉图式的爱情，完全没有性的爱情我觉得不存在。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="影音" scheme="http://huangyiblog.com/categories/%E5%BD%B1%E9%9F%B3/"/>
    
    
      <category term="动漫" scheme="http://huangyiblog.com/tags/%E5%8A%A8%E6%BC%AB/"/>
    
  </entry>
  
  <entry>
    <title>19. 删除链表的倒数第N个节点</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://huangyiblog.com/题解集/19-删除链表的倒数第N个节点/</id>
    <published>2018-10-14T14:06:13.000Z</published>
    <updated>2018-12-19T14:03:48.023Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure></p><p>说明：</p><p>给定的 n 保证是有效的。</p><p>进阶：</p><p><strong>你能尝试使用一趟扫描实现吗？</strong></p><p>分析：删除倒数第n个链表结点，两种想法。<br>解法一：正向扫描，删除倒数第n个结点，就是删除第(len - n + 1)个结点（len 为链表长度）,可以先扫描整个链表，求出链表长度，然后再次扫描链表，找到len - n 的位置，最后删除该位置的后一个结点。</p><p>解法二：双指针，定义两个指针都指向链表首结点，第一个指针先走n + 1步，之后两个指针同步前进，当第一个指针到达表尾时，第二个指针指向的就是要删除的倒数第n个结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveNthFromEnd</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        addVal(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ListNode res = removeNth(head, 3);</span></span><br><span class="line">        ListNode res = removeNth2(head, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">while</span>(res != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.print(res.val + <span class="string">" "</span>);</span><br><span class="line">        res = res.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addVal</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">ListNode node = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">ListNode current = head;</span><br><span class="line"><span class="keyword">while</span>(current.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">current = current.next;</span><br><span class="line">&#125;</span><br><span class="line">current.next = node;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNth</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(n)，空间复杂度O(1）</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode first = dummy;</span><br><span class="line">    ListNode second = dummy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(first != <span class="keyword">null</span>) &#123;</span><br><span class="line">    first = first.next;</span><br><span class="line">    second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    second.next = second.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNth2</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode first = head;</span><br><span class="line">    <span class="keyword">while</span>(first != <span class="keyword">null</span>) &#123;</span><br><span class="line">    len++;</span><br><span class="line">    first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    len = len - n;</span><br><span class="line">    first = dummy;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    len--;</span><br><span class="line">    first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    first.next = first.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>如何在Windows和Mac平台上协同管理hexo博客</title>
    <link href="http://huangyiblog.com/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/%E5%A6%82%E4%BD%95%E5%9C%A8Windows%E5%92%8CMac%E5%B9%B3%E5%8F%B0%E4%B8%8A%E5%8D%8F%E5%90%8C%E7%AE%A1%E7%90%86hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>http://huangyiblog.com/业务开发/如何在Windows和Mac平台上协同管理hexo博客/</id>
    <published>2018-10-10T09:12:56.000Z</published>
    <updated>2018-12-19T15:13:02.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何在多台电脑协同管理hexo博客"><a href="#如何在多台电脑协同管理hexo博客" class="headerlink" title="如何在多台电脑协同管理hexo博客"></a>如何在多台电脑协同管理hexo博客</h1><p>我很早就想搞个个人博客，其实写博客主要有3种选择：</p><ul><li>1 在第三方平台注册账号，直接在平台上写作并发布，例如博客圆，CSDN，新浪，网易等,这种方式最简单方便。</li><li>2 自己搭建博客。这种看个人需求，能力强的，可以完全前后端都自己代码实现，但大多数人一般也是直接采用模版的，简单省事。不过自己搭建的话需要去云服务商购买域名和云服务器，服务器的话学生优惠还是比较大的，阿里云，腾讯云上面都能买。</li><li>3 利用GitHub pages和hexo搭建静态博客，本地编写md文件，然后部署到github转化为html，相当于是托管于github。这种方法至少不用花钱买服务器，当然，你要是想绑定域名的话也可以照样去云服务商买一个，然后绑定到你的XXX.github.io上面。</li></ul><a id="more"></a><p>现在假设你已经在之前的Windows平台上搭好了hexo博客，并且能够正常部署运行。但因为需要，你要在另一台Mac系统的电脑上也能够管理你的hexo博客，可以利用Git分支来实现。</p><h1 id="在另一设备上管理博客"><a href="#在另一设备上管理博客" class="headerlink" title="在另一设备上管理博客"></a>在另一设备上管理博客</h1><ol><li>配置好环境</li></ol><ul><li>安装Node.js</li><li>安装Git</li><li>安装hexo<br>node.js可以直接去官网下载相应的匹配版本，Git的话，如果你的电脑安装是Mac并且安装了xcode，那么便不用再重新安装，xcode里便已经装有Git。</li></ul><ol start="2"><li>配置GitHub的SSH key<br>在新电脑上使用GitHub都需要先进行SSH key的配置，来获得GitHub的权限，以便本地和服务器之间数据的连接。</li></ol><ul><li>先测试你的电脑上是否已有ssh密钥,打开终端输入：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure></li></ul><p>如果没有，则进入下一步，生成ssh key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>将你的ssh key复制到GitHub上，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：将ssh key复制进去。</li><li>最后测试你的ssh是否配置成功<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ol><p>具体如何配置hexo博客可以参考：<a href="https://www.titanjun.top/2018/03/08/%E5%9F%BA%E4%BA%8EGitHub%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">使用hexo快速搭建个人博客</a></p><h1 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h1><ol><li><p>进入你的username.github.io仓库主要，新建一个分支，名字可以自定义，下面以hexo为例：<br><img src="http://huangyiblog.com/hexo1.jpg" alt="alt"></p></li><li><p>切换到hexo分支，并将该分支设置为默认分支后并保存。<br><img src="http://huangyiblog.com/hexo2.jpg" alt="alt"></p></li></ol><h1 id="上传配置文件到GitHub"><a href="#上传配置文件到GitHub" class="headerlink" title="上传配置文件到GitHub"></a>上传配置文件到GitHub</h1><ol><li>克隆hexo分支<br>将之前新建的分支克隆到本地<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b hexo git@github.com/username/username.github.io</span><br></pre></td></tr></table></figure></li></ol><p>查看当前所在分支是否为新建的hexo分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p><ol start="2"><li>上传部署文件</li></ol><ul><li><p>将你原先电脑里的配置文件拷贝到你的username.github.io文件目录下，这里的拷贝有几个文件或文件夹是必须要拷贝的：<br><strong>拷贝文件时要注意如果你的themes主题文件下下面有.git文件夹，要先将.git文件夹删除，否则主题文件会上传失败，一个GitHub仓库只能有一个.git</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line"> package.json</span><br><span class="line"> scaffolds/</span><br><span class="line"> source/</span><br><span class="line"> themes/</span><br></pre></td></tr></table></figure></li><li><p>拷贝完以后执行npm install 安装必要的组件</p></li><li><p>执行如下命令更新分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;add new files&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li><li><p>测试是否成功<br>可以执行hexo new “post”,hexo s预览是否有效，之后便用hexo d -g上传部署。</p></li></ul><ul><li>使用Mac系统操作hexo命令是要求在最前面加上sudo，否则会报错，提示你权限不足。<blockquote><p>master分支和hexo分支各自保存着一个版本，master分支用于保存博客静态资源，提供博客页面供人访问；hexo分支用于备份博客部署文件，供自己维护更新，两者在一个GitHub仓库内也不会有任何冲突</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何在多台电脑协同管理hexo博客&quot;&gt;&lt;a href=&quot;#如何在多台电脑协同管理hexo博客&quot; class=&quot;headerlink&quot; title=&quot;如何在多台电脑协同管理hexo博客&quot;&gt;&lt;/a&gt;如何在多台电脑协同管理hexo博客&lt;/h1&gt;&lt;p&gt;我很早就想搞个个人博客，其实写博客主要有3种选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 在第三方平台注册账号，直接在平台上写作并发布，例如博客圆，CSDN，新浪，网易等,这种方式最简单方便。&lt;/li&gt;
&lt;li&gt;2 自己搭建博客。这种看个人需求，能力强的，可以完全前后端都自己代码实现，但大多数人一般也是直接采用模版的，简单省事。不过自己搭建的话需要去云服务商购买域名和云服务器，服务器的话学生优惠还是比较大的，阿里云，腾讯云上面都能买。&lt;/li&gt;
&lt;li&gt;3 利用GitHub pages和hexo搭建静态博客，本地编写md文件，然后部署到github转化为html，相当于是托管于github。这种方法至少不用花钱买服务器，当然，你要是想绑定域名的话也可以照样去云服务商买一个，然后绑定到你的XXX.github.io上面。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="业务开发" scheme="http://huangyiblog.com/categories/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Github" scheme="http://huangyiblog.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>来普陀山拜观音了</title>
    <link href="http://huangyiblog.com/%E9%9A%8F%E7%AC%94/%E6%9D%A5%E6%99%AE%E9%99%80%E5%B1%B1%E6%8B%9C%E8%A7%82%E9%9F%B3%E4%BA%86/"/>
    <id>http://huangyiblog.com/随笔/来普陀山拜观音了/</id>
    <published>2018-10-04T10:48:41.000Z</published>
    <updated>2018-12-19T15:12:55.493Z</updated>
    
    <content type="html"><![CDATA[<p>　　鉴于中国国情，一直以来我都是十分抵触国庆出游的，原因你懂得。但这次可能有点坐不住了，我姐说要带母亲去泰国旅游，家里没了人，我咋办呀～不行，我也得出去玩，我想了想，恩，爬山挺不错的，我喜欢。然后就去找高中同学商量着一起国庆去爬山。爬什么山呢，浙江附近有名的山还是有不少的，黄山，三清山，庐山，雁荡山．．．这些我都考虑过，后来同学提了句普陀山怎么样，我立马便决定，好，就去普陀山，顺便看看大海，拜拜观音。从后面看来，我的决定还是比较正确的。<br>　　那时还没到中秋，我们俩就提前把去舟山的车票，民宿订好了，民宿订的是个混合旅馆，住两晚。国庆景区人山人海，这是一直被人诟病的事实，但我这次总体体验还行，天公作美呀，这两天天气出奇的好，温度适宜，海风凉爽。起初我还有点担心台风的问题，但最后收到预警通知时我们都已经准备返程了。你说运气好不好。当然唯一有点遗憾的就是没去东极岛，我只知道这是韩寒拍后会无期的取景地，中国的第一缕阳光照射的地方，不过东极岛本就不在我的计划范围内，真说遗憾到也谈不上，毕竟是个小岛，而且也远，票都不一定抢的到。<br>　　２号一大早起床，我就屁颠屁颠坐地铁来到杭州东站等大巴，坐着大巴离开杭州后的高速路上都很顺水，没发生什么堵车的问题，一直到了宁波镇海那边，速度有所减缓，真正发生堵车的地方就是在金塘大桥。这座桥是通往舟山的关键道路，也是图中碰到的第一座并且也是最长的一座跨海大桥。当然，比杭州湾跨海大桥要小点。<br><img src="http://huangyiblog.com/zs2.jpg" alt="alt"><br>看到大海以后最大的感慨就是为何如此混黄不清，与我心目中蔚蓝色大海相去甚远。但稍微想想，浙江的海应该都是灰黄灰黄的吧，不知道是因为地处钱塘江入海口还是其他原因。但浩瀚的气势还是有的，和我看惯了的千岛湖、西湖完全就是两种风格。<br>进入舟山以后车子就开的较慢了，一路时停时走的来到了舟山普陀区，我当时也不记得自己买了到哪里的车票，结果就一路坐着过了观音大桥来到了朱家尖慈航广场，我一看，这哪行，我们定的民宿是在普陀区大岭下呀，然后有坐上车回程，司机带我们到彩虹广场放我们下来，我就顺便吃了饭再去民宿。<br>　　到了民宿后，我们结识了这次出行的第一位室友，聊了几句，发现他和我们一样也是大三学生，是个高高瘦瘦还有些帅气的萧山小伙子。我看到脖子上手臂上通红通红的，估计是被晒成这样的，当时他刚好玩累了回来，一脸虚脱样。他和我们不一样，我们是第一次来舟山，去普陀山拜观音的，他可不是第一次来了，他有两个大学同学是舟山人，这次放假就顺便陪他们来舟山玩两天再回家。到了傍晚，我们都没怎么饿，我就和同学商量着晚上去哪玩，这时萧山小哥说：“听说沈家门那边的鲁家峙大桥夜景挺不错的，我们一起去逛逛吧”，我们也没其他主意，于是在手机地图上查了查鲁家峙大桥的位置，写着距离２.４公里，我们一看，那也没多少路吗，直接走过去就得了。从大岭下出发，我们三人没走多久就遇到了个山洞，没想到这山洞出乎意料的长，我们三一前一后的排成一列，足足走了将近２０分钟才走到另一头，边上时不时几辆电瓶车飞驰而过，让我们老老实实贴着边缘走着，还真是不容易。没多久我们就来到了鲁家峙大桥桥底，上桥还得走个楼梯，从桥上往下望还是挺高的，桥下就是大海，这要掉下去可不是开玩笑的，我也不敢走太边上。我们在桥上赏了赏夜景，吹了吹海风，就返程了，返程我们可吃不消再走回去了，是坐公交回去的。回到民宿后，又和这位萧山小哥聊了聊，他在临安的浙江农林大学学法学，还准备要考研，司法考什么的，他倒是和我们聊起了昨晚和它住一起的室友，他说那位老哥昨晚大半夜的还在打电话，一个劲的拿头撞墙。我们听了一惊，只是咋回事呀，有啥想不开的？原来是被女朋友放了鸽子，放了鸽子还不算，他女朋友还要和他分手，而他早早地订好住宿，昨晚却在那电话里拼了命的求复合，一直闹腾到了大半夜，哎。我们那天也真是累了，第二天还得早起买票去，于是早早就上床休息了。<br><img src="http://pc5wd3ju6.bkt.clouddn.com/zs1.jpg" alt="alt"></p><p>　　第二天６点多，我和同学起床吃了碗馄饨后就坐着公交来到慈航广场买船票了，那时还好，虽然已经有不少人在排队了，但还不算夸张，总之我们还是很庆幸自己出发的比较早。从朱家尖到普陀山的普通客船是３０元一人，普陀山进山门票是１８０，我们买了学生票９０元。进山后，我们往左开始游山，依次游览了百花园，观音<img src="http://huangyiblog.com/zs3.jpg" alt="alt">古洞，磐陀石等，那时人还不多，所以游览起来还是蛮舒服的。普陀山应该也是个佛教圣地，山上寺庙众多，经常看到一些墙上写着喃无哦米投佛，我们一路翻山，来到百步沙，这是个沙滩，我们随即脱了鞋子去沙滩玩了，这时我又想到了天气好的好处，大暑假的你让我在这沙滩上晒太阳我怕是不大吃得消。我们俩走沙滩上都留了好久，捐起裤脚走在海边，看着海浪一波波涌来，但不敢走太里面，万一一不当心海浪盖过膝盖，那我的裤子是得湿透了。这之后已经快中午了，人山人海的架势也有点显现了，我们之后绕到了不肯去观音院和紫竹林，我一开始还以为这紫竹林是一大片竹林呢，结果到了以后半根竹子都没见着…逛了大半天，真事还没干，来普陀山怎么也得拜下南海观音吧，但是当我们到了南海观音雕像时已经是人山人海了，还有不少拿着香在哪虔诚的拜观音，我们就走在人群里，都不知道他们是在拜观音还是在拜我了。<br><img src="http://huangyiblog.com/zs4.jpg" alt="alt"></p><p><img src="http://huangyiblog.com/zs5.jpg" alt="alt"><br>我们的最后一站是南天门，二石壁立如门，所以不要以为南天门真的是扇门，只是三块大石头，两边各一块，顶上一块，状似一扇门，也就是所谓的南天门。南天门逛完后我们便返程了，还真是挺累的，走了大半天的路。<br>　　到了晚上，我们又结识了一位新室友，昨晚那位萧山小哥回家去了，今天搬进来了另一位小伙子。这小伙子更有意思，我们一直聊天聊到后半夜都意犹未尽。他也是个大三学生，还和我一样学的是计算机，你说巧不巧，同行遇同行，两眼泪汪汪，我们竟然开始聊起来了学习．．对的，你没听错，我们一开始聊得是学习．．我问他有什么打算，准备走什么方向，他是在江西读书，想考研，以后走算法方向，不过不是ＡＩ算法，而是数据处理那方面的。但我们聊学习没聊多久就转移了话题，你也知道两个学渣聊不出多大花头。我对这位小哥倒是很感兴趣，慢慢慢慢兴致也就上来了，首先，他是新疆人，这就足以勾起我很大好奇心了，平时我可是很少接触到新疆人呢。而且他有些想法我也比较认同。我告诉我们他这次从江西那边过来，先在宁波玩了两天然后又来舟山玩，他已经去了全国很多地方，他对我们说他出去旅游很多时候并不是为了看景点啥的，而是接触各种各样的人，到四处游玩可以让他接触很多没见过的东西，碰到很多不一样的人，这些人都有自己的一些习俗，想法，和他们聊天是件很有意思的事。我们之后聊了很多很多，有关于他中学是谈对象的故事，有关于他一个土豪室友的故事，还有很多关于新疆的故事，我们俩真是第一次听说新疆竟然是这样的。据他说新疆治安那时真的厉害，目标就是震慑一些犯罪分子，恐怖分子。记得之前发生了一件什么事，整个新疆整整半年停网停通讯，当然他没具体说什么事，毕竟属于机密事件，我也不敢乱写，不然得惹上不小麻烦。而且他们那边你可不能偷偷翻墙，一翻墙你就得接受“教育”了．．．总是我们各种瞎扯，时不时发点感慨，哇，土豪的世界我理解不了，哇，新疆竟然发生过这种事，我们听来就更听故事似的。<br>　　最后大家都累了，便熄灯安稳入睡了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　鉴于中国国情，一直以来我都是十分抵触国庆出游的，原因你懂得。但这次可能有点坐不住了，我姐说要带母亲去泰国旅游，家里没了人，我咋办呀～不行，我也得出去玩，我想了想，恩，爬山挺不错的，我喜欢。然后就去找高中同学商量着一起国庆去爬山。爬什么山呢，浙江附近有名的山还是有不少的，
      
    
    </summary>
    
      <category term="随笔" scheme="http://huangyiblog.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="旅游记" scheme="http://huangyiblog.com/tags/%E6%97%85%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
</feed>
