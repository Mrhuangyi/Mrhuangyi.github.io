<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你的小黄^_^</title>
  <icon>https://www.gravatar.com/avatar/3a25a3ab34305615e80247defadfd4f6</icon>
  <subtitle>做一名有情怀的程序员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huangyiblog.com/"/>
  <updated>2018-05-31T07:12:37.969Z</updated>
  <id>http://huangyiblog.com/</id>
  
  <author>
    <name>Mr.Huangyi</name>
    <email>18757163093@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>190. 颠倒二进制位</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"/>
    <id>http://huangyiblog.com/题解集/190-颠倒二进制位/</id>
    <published>2018-05-31T07:12:06.000Z</published>
    <updated>2018-05-31T07:12:37.969Z</updated>
    
    <content type="html"><![CDATA[<p>颠倒给定的 32 位无符号整数的二进制位。</p><p>示例:</p><p>输入: 43261596<br>输出: 964176192<br>解释: 43261596 的二进制表示形式为 00000010100101000001111010011100 ，<br>     返回 964176192，其二进制表示形式为 00111001011110000010100101000000 。<br>进阶:<br>如果多次调用这个函数，你将如何优化你的算法？</p><p>方法一：<br>遍历整数的所有位。 如果第i个位置的一个位置在I / P编号中。<br>然后将该位设置为（NO_OF_BITS - 1） - i in o / p。 NO_OF_BITS是给定数字中存在的位数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>  NO_OF_BITS = <span class="keyword">sizeof</span>(n) * <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> reverse_num = <span class="number">0</span>, i, temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NO_OF_BITS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = (n &amp; (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">        <span class="keyword">if</span>(temp)</span><br><span class="line">            reverse_num |= (<span class="number">1</span> &lt;&lt; ((NO_OF_BITS - <span class="number">1</span>) - i));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> reverse_num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>时间复杂度：O(logn)<br>空间复杂度：O(1)<br>方法二：<br>保持reversenum每一位与给定num相等直到num变成0，之后反向移动剩余的位<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="keyword">sizeof</span>(n) * <span class="number">8</span> - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> reverse_num = n;</span><br><span class="line">     </span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">       reverse_num &lt;&lt;= <span class="number">1</span>;       </span><br><span class="line">       reverse_num |= n &amp; <span class="number">1</span>;</span><br><span class="line">       n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">       count--;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse_num &lt;&lt;= count;</span><br><span class="line">    <span class="keyword">return</span> reverse_num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;颠倒给定的 32 位无符号整数的二进制位。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: 43261596&lt;br&gt;输出: 964176192&lt;br&gt;解释: 43261596 的二进制表示形式为 00000010100101000001111010011100 ，&lt;br&gt;   
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>160. 相交链表</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>http://huangyiblog.com/题解集/160-相交链表/</id>
    <published>2018-05-31T06:45:33.000Z</published>
    <updated>2018-05-31T06:46:09.078Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个程序，找到两个单链表相交的起始节点。</p><p>例如，下面的两个链表：</p><p>A:          a1 → a2<br>                   ↘<br>                     c1 → c2 → c3<br>                   ↗<br>B:     b1 → b2 → b3<br>在节点 c1 开始相交。</p><p>注意：</p><ul><li>如果两个链表没有交点，返回 null.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li></ul><p>用环的思想来做，我们让两条链表分别从各自的开头开始往后遍历，当其中一条遍历到末尾时，我们跳到另一个条链表的开头继续遍历。两个指针最终会相等，<br>而且只有两种情况，一种情况是在交点处相遇，另一种情况是在各自的末尾的空节点处相等。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!headA||!headB) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *a = headA;</span><br><span class="line">        ListNode *b = headB;</span><br><span class="line">        <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">            a = a ? a-&gt;next : headB;</span><br><span class="line">            b = b ? b-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;/p&gt;
&lt;p&gt;例如，下面的两个链表：&lt;/p&gt;
&lt;p&gt;A:          a1 → a2&lt;br&gt;                   ↘&lt;br&gt;                     c1 → c2 → c3&lt;br&gt;    
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>1010 一元多项式求导 (25)（25 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1010-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1010-一元多项式求导-25-（25-分）/</id>
    <published>2018-05-30T09:06:42.000Z</published>
    <updated>2018-05-30T09:07:32.597Z</updated>
    
    <content type="html"><![CDATA[<p>1010 一元多项式求导 (25)（25 分）<br>设计函数求一元多项式的导数。（注：x^n^（n为整数）的一阶导数为n*x^n-1^。）</p><p>输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p><p>输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是0，但是表示为“0 0”。</p><p>输入样例：</p><p>3 4 -5 2 6 1 -2 0<br>输出样例：</p><p>12 3 -10 1 6 0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a,b;</span><br><span class="line">   <span class="keyword">bool</span> isfirst=<span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b))</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">if</span>(!isfirst)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">        isfirst=<span class="literal">false</span>;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,a*b,b<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(isfirst)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0 0"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1010 一元多项式求导 (25)（25 分）&lt;br&gt;设计函数求一元多项式的导数。（注：x^n^（n为整数）的一阶导数为n*x^n-1^。）&lt;/p&gt;
&lt;p&gt;输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>1009 说反话 (20)（20 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1009-%E8%AF%B4%E5%8F%8D%E8%AF%9D-20-%EF%BC%8820-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1009-说反话-20-（20-分）/</id>
    <published>2018-05-30T09:05:37.000Z</published>
    <updated>2018-05-30T09:05:58.109Z</updated>
    
    <content type="html"><![CDATA[<p>1009 说反话 (20)（20 分）<br>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p><p>输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。</p><p>输出格式：每个测试用例的输出占一行，输出倒序后的句子。</p><p>输入样例：</p><p>Hello World Here I Come<br>输出样例：</p><p>Come I Here World Hello</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">111</span>];</span><br><span class="line">    <span class="keyword">int</span> i,len,x,j,b[<span class="number">100</span>];</span><br><span class="line">    gets(a);</span><br><span class="line">    <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">    len=<span class="built_in">strlen</span>(a);</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">' '</span>)&#123;</span><br><span class="line">            b[j]=i;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    x=j<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(i=b[<span class="number">0</span>]+<span class="number">1</span>;i&lt;=len<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=b[j]+<span class="number">1</span>;;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[i]);</span><br><span class="line">            <span class="keyword">if</span>(a[i+<span class="number">1</span>]==<span class="string">' '</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;b[x];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1009 说反话 (20)（20 分）&lt;br&gt;给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。&lt;/p&gt;
&lt;p&gt;输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>1008 数组元素循环右移问题 (20)（20 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1008-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98-20-%EF%BC%8820-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1008-数组元素循环右移问题-20-（20-分）/</id>
    <published>2018-05-30T09:03:56.000Z</published>
    <updated>2018-05-30T09:04:19.817Z</updated>
    
    <content type="html"><![CDATA[<p>1008 数组元素循环右移问题 (20)（20 分）<br>一个数组A中存有N（N&amp;gt0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&gt;=0）个位置，即将A中的数据由（A~0~ A~1~……A~N-1~）变换为（A~N-M~ …… A~N-1~ A~0~ A~1~……A~N-M-1~）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p><p>输入格式：每个输入包含一个测试用例，第1行输入N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2行输入N个整数，之间用空格分隔。</p><p>输出格式：在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p><p>输入样例：</p><p>6 2<br>1 2 3 4 5 6<br>输出样例：</p><p>5 6 1 2 3 4</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    m=n-m%n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&lt;n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[j];</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count!=n)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[k];</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count!=n)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1008 数组元素循环右移问题 (20)（20 分）&lt;br&gt;一个数组A中存有N（N&amp;amp;gt0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&amp;gt;=0）个位置，即将A中的数据由（A~0~ A~1~……A~N-1~）变换为（A~N-M~ …… A~N
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>1007 素数对猜想 (20)（20 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1007-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3-20-%EF%BC%8820-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1007-素数对猜想-20-（20-分）/</id>
    <published>2018-05-30T09:02:00.000Z</published>
    <updated>2018-05-30T09:02:22.569Z</updated>
    
    <content type="html"><![CDATA[<p>1007 素数对猜想 (20)（20 分）<br>让我们定义 d~n~ 为：d~n~ = p~n+1~ - p~n~，其中 p~i~ 是第i个素数。显然有 d~1~=1 且对于n&amp;gt1有 d~n~ 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。</p><p>现给定任意正整数N (&lt; 10^5^)，请计算不超过N的满足猜想的素数对的个数。</p><p>输入格式：每个测试输入包含1个测试用例，给出正整数N。</p><p>输出格式：每个测试用例的输出占一行，不超过N的满足猜想的素数对的个数。</p><p>输入样例：</p><p>20<br>输出样例：</p><p>4<br>先打素数表，然后遍历计数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i,t,j,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=<span class="built_in">sqrt</span>(i);j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;<span class="built_in">sqrt</span>(i))</span><br><span class="line">        &#123;</span><br><span class="line">            a[k++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i+<span class="number">1</span>]-a[i]==<span class="number">2</span>)&#123;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1007 素数对猜想 (20)（20 分）&lt;br&gt;让我们定义 d~n~ 为：d~n~ = p~n+1~ - p~n~，其中 p~i~ 是第i个素数。显然有 d~1~=1 且对于n&amp;amp;gt1有 d~n~ 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。&lt;/
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>1006 换个格式输出整数 (15)（15 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1006-%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0-15-%EF%BC%8815-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1006-换个格式输出整数-15-（15-分）/</id>
    <published>2018-05-30T08:57:24.000Z</published>
    <updated>2018-05-30T08:59:14.812Z</updated>
    
    <content type="html"><![CDATA[<p>1006 换个格式输出整数 (15)（15 分）<br>让我们用字母B来表示“百”、字母S表示“十”，用“12…n”来表示个位数字n（&amp;lt10），换个格式来输出任一个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。</p><p>输入格式：每个测试输入包含1个测试用例，给出正整数n（&amp;lt1000）。</p><p>输出格式：每个测试用例的输出占一行，用规定的格式输出n。</p><p>输入样例1：</p><p>234<br>输出样例1：</p><p>BBSSS1234<br>输入样例2：</p><p>23<br>输出样例2：</p><p>SS123<br>我的想法就是分情况讨论，按照n是1位数2位数还是大于2位数来分情况进行输出<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,t,m,a,i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n&gt;=<span class="number">100</span>)&#123;</span><br><span class="line">        t=n/<span class="number">100</span>;</span><br><span class="line">       n=n%<span class="number">100</span>;</span><br><span class="line">       m=n/<span class="number">10</span>;</span><br><span class="line">       a=n%<span class="number">10</span>;</span><br><span class="line">       <span class="keyword">while</span>(t--)&#123;<span class="built_in">printf</span>(<span class="string">"B"</span>);&#125;</span><br><span class="line">       <span class="keyword">while</span>(m--)&#123;<span class="built_in">printf</span>(<span class="string">"S"</span>);&#125;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=a;i++)&#123;<span class="built_in">printf</span>(<span class="string">"%d"</span>,i);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n&lt;<span class="number">100</span>&amp;&amp;n&gt;=<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    t=n/<span class="number">10</span>;</span><br><span class="line">    a=n%<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;<span class="built_in">printf</span>(<span class="string">"S"</span>);&#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=a;i++)&#123;<span class="built_in">printf</span>(<span class="string">"%d"</span>,i);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">printf</span>(<span class="string">"%d"</span>,i);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1006 换个格式输出整数 (15)（15 分）&lt;br&gt;让我们用字母B来表示“百”、字母S表示“十”，用“12…n”来表示个位数字n（&amp;amp;lt10），换个格式来输出任一个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>141. 环形链表</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>http://huangyiblog.com/题解集/141-环形链表/</id>
    <published>2018-05-30T03:34:57.000Z</published>
    <updated>2018-05-30T03:35:34.006Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，判断链表中是否有环。</p><p>进阶：<br>你能否不使用额外空间解决此题？</p><p>可以用一个哈希表<br>···cpp</p><p>unordered_map&lt; int,bool&gt; visited<br>···<br>来标记每个元素是否被访问过，若某个元素被重复访问，则存在环。</p><p>最好的方法是用快慢指针，快指针每次走两步，慢指针每次走一步，只要快慢指针相遇，则肯定有环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;进阶：&lt;br&gt;你能否不使用额外空间解决此题？&lt;/p&gt;
&lt;p&gt;可以用一个哈希表&lt;br&gt;···cpp&lt;/p&gt;
&lt;p&gt;unordered_map&amp;lt; int,bool&amp;gt; visited&lt;br&gt;···&lt;br&gt;来标记每个元素
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>112. 路径总和</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <id>http://huangyiblog.com/题解集/112-路径总和/</id>
    <published>2018-05-30T03:21:34.000Z</published>
    <updated>2018-05-30T03:22:07.791Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p><pre><code>      5     / \    4   8   /   / \  11  13  4 /  \      \7    2      1</code></pre><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p><p>直接深搜<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(sum,<span class="number">0</span>,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> target,<span class="keyword">int</span> sum,TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> leftp = dfs(target,sum,root-&gt;left);</span><br><span class="line">        <span class="keyword">bool</span> rightp = dfs(target,sum,root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> leftp||rightp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。&lt;/p&gt;
&lt;p&gt;说明: 叶子节点是指没有子节点的节点。&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;给定如下二叉树，以及目标和 sum = 22，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>L2-005 集合相似度（25 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-005-%E9%9B%86%E5%90%88%E7%9B%B8%E4%BC%BC%E5%BA%A6%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/L2-005-集合相似度（25-分）/</id>
    <published>2018-05-30T03:08:32.000Z</published>
    <updated>2018-05-30T03:09:01.205Z</updated>
    
    <content type="html"><![CDATA[<p>L2-005 集合相似度（25 分）<br>给定两个整数集合，它们的相似度定义为：N~c~/N~t~*100%。其中N~c~是两个集合都有的不相等整数的个数，N~t~是两个集合一共有的不相等整数的个数。你的任务就是计算任意一对给定集合的相似度。</p><p>输入格式：</p><p>输入第一行给出一个正整数N（&lt;=50），是集合的个数。随后N行，每行对应一个集合。每个集合首先给出一个正整数M（&lt;=10^4^），是集合中元素的个数；然后跟M个[0, 10^9^]区间内的整数。</p><p>之后一行给出一个正整数K（&lt;=2000），随后K行，每行对应一对需要计算相似度的集合的编号（集合从1到N编号）。数字间以空格分隔。</p><p>输出格式：</p><p>对每一对需要计算的集合，在一行中输出它们的相似度，为保留小数点后2位的百分比数字。</p><p>输入样例：</p><p>3<br>3 99 87 101<br>4 87 101 5 87<br>7 99 101 18 5 135 18 99<br>2<br>1 2<br>1 3<br>输出样例：</p><p>50.00%<br>33.33%</p><p>直接用stl里的set存放集合，然后计算相同元素个数和总的不同元素个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s[<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> m,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            s[i].insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k,a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">int</span> cnta=s[a].size(),cntb=s[b].size(),cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=s[a].begin();it!=s[a].end();++it)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[b].find(*it)!=s[b].end())&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%.2lf%\n"</span>,cnt*<span class="number">1.0</span>/(cnta+cntb-cnt)*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;L2-005 集合相似度（25 分）&lt;br&gt;给定两个整数集合，它们的相似度定义为：N~c~/N~t~*100%。其中N~c~是两个集合都有的不相等整数的个数，N~t~是两个集合一共有的不相等整数的个数。你的任务就是计算任意一对给定集合的相似度。&lt;/p&gt;
&lt;p&gt;输入格式：&lt;/
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>L2-004 这是二叉搜索树吗？（25 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-004-%E8%BF%99%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%90%97%EF%BC%9F%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/L2-004-这是二叉搜索树吗？（25-分）/</id>
    <published>2018-05-30T02:37:10.000Z</published>
    <updated>2018-05-30T02:37:53.234Z</updated>
    
    <content type="html"><![CDATA[<p>L2-004 这是二叉搜索树吗？（25 分）<br>一棵二叉搜索树可被递归地定义为具有下列性质的二叉树：对于任一结点，</p><p>其左子树中所有结点的键值小于该结点的键值；<br>其右子树中所有结点的键值大于等于该结点的键值；<br>其左右子树都是二叉搜索树。<br>所谓二叉搜索树的“镜像”，即将所有结点的左右子树对换位置后所得到的树。</p><p>给定一个整数键值序列，现请你编写程序，判断这是否是对一棵二叉搜索树或其镜像进行前序遍历的结果。</p><p>输入格式：</p><p>输入的第一行给出正整数N（&lt;=1000）。随后一行给出N个整数键值，其间以空格分隔。</p><p>输出格式：</p><p>如果输入序列是对一棵二叉搜索树或其镜像进行前序遍历的结果，则首先在一行中输出“YES”，然后在下一行输出该树后序遍历的结果。数字间有1个空格，一行的首尾不得有多余空格。若答案是否，则输出“NO”。</p><p>输入样例1：</p><p>7<br>8 6 5 7 10 8 11<br>输出样例1：</p><p>YES<br>5 7 6 8 11 10 8<br>输入样例2：</p><p>7<br>8 10 11 8 6 7 5<br>输出样例2：</p><p>YES<br>11 8 10 7 5 6 8<br>输入样例3：</p><p>7<br>8 6 8 5 10 9 11<br>输出样例3：</p><p>NO</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node *left,*right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=<span class="keyword">new</span> node;</span><br><span class="line">        root-&gt;data=data;</span><br><span class="line">        root-&gt;left=root-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(data&lt;root-&gt;data) insert(root-&gt;left,data);</span><br><span class="line">    <span class="keyword">else</span> insert(root-&gt;right,data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(node* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;vi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    vi.push_back(root-&gt;data);</span><br><span class="line">    preOrder(root-&gt;left,vi);</span><br><span class="line">    preOrder(root-&gt;right,vi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderMirror</span><span class="params">(node* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;vi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    vi.push_back(root-&gt;data);</span><br><span class="line">    preOrderMirror(root-&gt;right,vi);</span><br><span class="line">    preOrderMirror(root-&gt;left,vi);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(node* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(root-&gt;left,vi);</span><br><span class="line">    postOrder(root-&gt;right,vi);</span><br><span class="line">    vi.push_back(root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderMirror</span><span class="params">(node* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;vi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrderMirror(root-&gt;right,vi);</span><br><span class="line">    postOrderMirror(root-&gt;left,vi);</span><br><span class="line">    vi.push_back(root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; origin,pre,preN,postN,post;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,data;</span><br><span class="line">    node* root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;data);</span><br><span class="line">        origin.push_back(data);</span><br><span class="line">        insert(root,data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root,pre);</span><br><span class="line">    preOrderMirror(root,preN);</span><br><span class="line">    postOrder(root,post);</span><br><span class="line">    postOrderMirror(root,postN);</span><br><span class="line">    <span class="keyword">if</span>(origin==pre)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;post.size();i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,post[i]);</span><br><span class="line">            <span class="keyword">if</span>(i&lt;post.size()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(origin==preN)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;postN.size();i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,postN[i]);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;postN.size()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;L2-004 这是二叉搜索树吗？（25 分）&lt;br&gt;一棵二叉搜索树可被递归地定义为具有下列性质的二叉树：对于任一结点，&lt;/p&gt;
&lt;p&gt;其左子树中所有结点的键值小于该结点的键值；&lt;br&gt;其右子树中所有结点的键值大于等于该结点的键值；&lt;br&gt;其左右子树都是二叉搜索树。&lt;br&gt;所
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>卖米</title>
    <link href="http://huangyiblog.com/%E6%91%98%E5%BD%95/%E5%8D%96%E7%B1%B3/"/>
    <id>http://huangyiblog.com/摘录/卖米/</id>
    <published>2018-05-30T00:16:57.000Z</published>
    <updated>2018-05-30T02:08:12.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01"><a href="#01" class="headerlink" title="01"></a>01</h1><p><strong>《卖米》作者飞花，原名张培祥，1979年，出生于湖南醴陵一个山区农民家庭。自小于贫寒中刻苦学习，1997年考入北京大学法学院，2001年攻读法学硕士。2003年非典期间，年仅24岁的张培祥就已身患白血病离开了人世。</strong></p><p>天刚蒙蒙亮，母亲就把我叫起来了：“琼宝，明天是这里的场，咱们担点米到场上卖了，好弄点钱给你爹买药。”</p><p>我恍恍惚惚展开双眼，看看窗外，日头还没出来呢。我真实太困，又在床上赖了一会儿。</p><p>近邻传来父亲的咳嗽声，母亲在厨房忙在世，饭菜的喷鼻气夹杂着淡淡的油烟味飘过去，渐渐遣散了我的睡意。我坐起来，穿好衣服，开端铺床。</p><p>“姐，我也跟你们一同去赶场好不好？你买冰棍给我吃！”</p><p>弟弟顶着一头睡得乱蓬蓬的头发跑到我房里来。</p><p>“毅宝，你不要去，你留在家里放水。”近邻传来父亲的声响，同化着几声咳嗽。</p><p>弟弟有些不甘愿地冲近邻说：“爹，天气这么热，你自个昨天才中了暑，今天又叫我去，就不怕我也中暑！”</p><p>“人怕热，庄稼不怕？都不去放水，地都干了，禾都死了，一家人喝东南风去？”父亲一动气，咳嗽得更加凶猛了。</p><p>弟弟冲我吐吐舌头，扮了个鬼脸，就到父亲房里去了。</p><p>只听见父亲开端叮嘱他怎样放水，去哪个塘里引水，先放哪丘田，哪几个中央要特别注意他人来截水，等等。</p><h1 id="02"><a href="#02" class="headerlink" title="02"></a>02</h1><p>吃过饭，弟弟就找着父亲常用的那把锄头出去了。我和母亲开始往谷箩里装米，装完后先称了一下，一担八十多斤，一担六十多斤。</p><p>我说：“妈，我挑重的那担吧。”</p><p>“你学生妹子，肩膀嫩，还是我来。”</p><p>母亲说着，一哈腰，把那担重的挑起来了。</p><p>我挑起那担轻的，跟着母亲出了门。</p><p>“路上当心点！我们家的米好，别廉价卖了！”父亲披着衣服站在门口吩咐道。</p><p>“晓得了。你快回床上躺着吧。”母亲困难地把头从扁担旁边扭过去，吩咐道，“饭菜在锅里，半夜你叫毅宝热一下吃！”</p><p>赶场的中央离我家大约有四里路，我和母亲挑着米，在窄窄的田间巷子上走走停停，足足走了一个钟头才到。场上的人曾经不少了，咱们赶忙找了一块旷地，把担子放上去，把扁担放在地上，两个人坐在扁担上，拿凉帽扇着。</p><p>一大早就这么热，中午就更不得了，我忍不住替弟弟担忧起来。</p><p>他去放水，是要在里头晒上一成天的。</p><p>我往周围看了看，发现场上有很多人卖米，莫非他们都等着用钱？</p><p>场上的人大都眼生，都是附近十里八里的同乡，人家也是耕田的，谁会来买米呢？</p><p>我问母亲，母亲说：“有专门的米商人会来收米的。他们开了车到乡间来赶场，收了米，拉到城里去卖，能挣好些哩。”</p><p>我说：“凭什么都给他们挣？咱们也拉到城里去卖好了！”其实自个也晓得不过是气话。</p><p>果真，母亲说：“我们这么一点米，又没车，真弄到城里去卖，挣的钱还不敷路费呢！早先你爹身体好的时刻，自个挑着一百来斤米进城去卖，隔几天去一趟，倒比较划算一点。”</p><p>我不由心里一紧，疼爱起父亲来。从家里到城里足足有三十多里山路呢，他挑着那么重的担子走着去，该何等辛劳！就为了多挣那几个钱，把人累成这样，多不值啊！但又有什么方法呢？家里除了种地，也没其余收入，不卖米，拿什么钱供我和弟弟上学？</p><p>我想着这些，心里一阵阵忧伤起来。看看旁边的母亲，头发有些花白了，黑黝黝的脸上爬上了好多皱纹，脑门上密密麻麻都是汗珠，眼睛有些红肿。</p><p>“妈，你喝点水。”</p><p>我把水壶递过来，拿凉帽替她扇着。</p><p><img src="http://www.veryok.net/img.php?u=https://mmbiz.qpic.cn/mmbiz_jpg/QFaTfWAr2VvdPbzVKoyIBsBFkyWLaEW0pyKcRjInyVfzGXTia5FZCAM3yaPeof8ZQVQEic7ibOS9zZky3VWcPfzVQ/0?wx_fmt=jpeg" alt="Alt text"></p><h1 id="03"><a href="#03" class="headerlink" title="03"></a>03</h1><p>米商人们终于开着车来了。他们四处看着卖米的人，走过来细心看米的成色，还把手插进米里，抓上一把米细看。</p><p>“一块零五。”</p><p>米商人开价了。</p><p>卖米的似乎嫌太低，想还价讨价。</p><p>“不讨价，一口价，爱卖不卖！”</p><p>米商人立场很强硬，究竟，满场都是卖米的人，只有他们是买家，不趁机压价，更待何时？</p><p>母亲留意着那里的情形说：“一块零五？也太廉价了。上场还卖到一块一呢。”</p><p>正说着，有个米商人朝咱们这边走过来了。</p><p>他把手插进大米里，抓了一把出来，迎着阳光细看着。</p><p>“这米好咧！又白又匀净，又筛得洁净，一点沙子也没有！”母亲堆着笑，语气里有几分骄傲。</p><p>确实，我家的米比场上其他人卖的米都好。</p><p>那人点了摇头，说：“米是好米，不过这几天城里涨价，再好的米也卖不出好价前来。一块零五，卖不卖？”</p><p>母亲摇摇头：“这也太廉价了吧？上场还卖一块一呢。再说，你是识货的，一分钱一分货，我这米一定好过别家的！”</p><p>那人又看了看米，犹疑了一下，说：“原本都是一口价，不许还的，看你们家米好，我加点，一块零八，怎样样？”</p><p>母亲照样摇头：“不可，咱们家这米，少说也要卖到一块一。你再加点？”</p><p>那人冷笑一声，说：“明天一定卖不出一块一的行情，我出一块零八你不卖，等会散场的时刻你一块零五都卖不出去！”</p><p>“卖不出去，我们再担回家！”那人的立场激恼了母亲。</p><p>“那你就等着担回家吧。”那人冷笑着，丢下这句话走了。</p><h1 id="04"><a href="#04" class="headerlink" title="04"></a>04</h1><p>我在旁边听着，心里算着：一块零八到一块一，每斤才差两分钱。</p><p>这里一共150斤米，总共也就三块钱的事情，路这么远，何须再挑回去呢？</p><p>我的肩膀还在痛呢。</p><p>我悄悄对母亲说：“妈，一块零八就一块零八吧，横竖也就三块钱的事。再说，还等着钱给爹买药呢。”</p><p>“那哪行？”母亲似乎有些生气了，“三块钱不是钱？再说了，也不单是几块钱的事，经商也得讲点良知，我们辛辛苦苦种出来的米，质量也好，哪能这么贱卖了？”</p><p>我不敢再说。</p><p>我晓得耕田有何等累。</p><p>光说炎天放水，不就把爹给病倒了？</p><p>弟弟也才十一二岁的毛孩子，还不得找着锄头去放水！</p><p>究竟，这是一家人的生计啊！</p><p>又有几个米商人过去了，他们也都只出一块零五。有一两个出到一块零八，也不愿再加。</p><p>母亲依然不愿卖。</p><p>看看人逐渐少了，我有些焦急了。</p><p>母亲必然也很心急吧，我想。</p><p>“妈，你去那里树下凉爽一下吧！”我说。</p><p>母亲一边擦汗，一边摇头：“不可。我走开了，来人买米怎样办？你又不会讨价！”</p><p>我有些羞愧。</p><p>“百无一用是书生”，固然在学校里功课好，但这些事情上就比母亲差远了。</p><p>又有好些人来买米，由于我家的米实在是好，人人都过去看，但谁也不愿出到一块一。</p><p>看看日头到头顶上了，我感觉肚子饿了，便拿出带来的饭菜和母亲一同吃起来。</p><p>母亲吃了两口就不吃了，我晓得她是担忧米卖不出去，心里焦急。</p><p>母亲叹了口气：“还不晓得卖得掉卖不掉呢。”</p><p>我趁机说：“不然就廉价点卖好了。”</p><p>母亲说：“我心里有数。”</p><h1 id="05"><a href="#05" class="headerlink" title="05"></a>05</h1><p>下午人更少了，日头又毒，谁情愿在场上晒着呢。</p><p>看看母亲，衣服都粘在背上了，乌黑的脸上也显露出晒红的印迹来。</p><p>“妈，我替你看着，你去溪里泡泡去。”</p><p>母亲照样摇头：“不行，我有风湿，不能在凉水里泡。你怕热，去那里树底下躲躲好了。”</p><p>“不必，我不怕晒。”</p><p>“那你去买根冰棍吃好了。”</p><p>母亲说着，从兜里掏出两毛钱零钱来。</p><p>我最喜好吃冰棍了，特别是那种叫“葡萄冰”的最好吃，也不贵，两毛钱一根。</p><p>但我今天忽然不想吃了：“妈，我不吃，喝水就行。”</p><p>最热的时候也过来了，转眼快散场了。</p><p>卖杂货的小贩开始降价甩卖，卖菜，卖西瓜的也都呼喊着：“散场了，廉价卖了！”</p><p>我四处看看，场上已经没有几个卖米的了，大部分人已经卖完回去了。</p><p>母亲也焦急起来，一焦急，汗就出得越多了。</p><p>终于有个米贩子过来了：“这米卖不卖？一块零五，不论价！”</p><p>母亲说：“你看我这米，多好！上场还卖一块一呢……”</p><p>不等母亲说完，那人就不耐性地说：“行情不同了！想卖一块一，你就等着往回担吧！”</p><p>奇怪的是，母亲没有生气，反而堆着笑说：“那，一块零八，你要不要？”</p><p>那人从鼻子里哼了一声，说：“你这个价钱，不是开场的时候也难卖出来，如今都散场了，谁买？做梦吧！”</p><p>母亲的脸一会儿白了，动着嘴唇，但什么也没说。</p><p>一旁的我不由得插嘴了：“不买就不买，谁稀罕？不买你就别站在这里挡道！”</p><p>“哟，大妹子，你别这么大火气。”</p><p>那人冷笑着说，“留着点力气等会把米担回去吧！”</p><p>等那人走了，我不由得抱怨母亲：“开场的时候人家出一块零八你不卖，这会好了，人家还不愿意买了！”</p><p>母亲似乎有些羞愧，但并不愿认错：“本来嘛，一分钱一分货，米是好米，哪能贱卖了？出门的时候你爹不还叮嘱叫卖个好价钱？”</p><p>“你还说爹呢！他病在家里，指着这米换钱买药治病！人要紧还是钱要紧？”</p><p>母亲似乎没有话说了，等了一会儿，低声说：“一会儿人家出一块零五也卖了吧。”</p><p>可是再没有人来买米了，米贩子把买来的米装上车，开走了。</p><h1 id="06"><a href="#06" class="headerlink" title="06"></a>06</h1><p>散场了，我和母亲晒了一天，一颗米也没卖出来。</p><p>“妈，走吧，回去吧，别愣在那儿了。”</p><p>我收拾好毛巾、水壶、饭盒，催促道。</p><p>母亲踌躇着，终于起了身。</p><p>“妈，我来挑重的。”</p><p>“你先生妹子，肩膀嫩……”</p><p>不等母亲说完，我已经把那担重的挑起来了。</p><p>母亲也没有再说什么，挑起那担轻的跟在我后面，踏上了回家的路。</p><p>肩上的担子好沉，我只感觉压着一座山似的。</p><p>忽然脚下一滑，我差点摔倒。</p><p>我赶忙把剩下的力气都用到腿上，好不容易站稳了，但肩上的担子还是倾斜了一下，洒了好多米出来。</p><p>“啊，怎么搞的？”母亲也放下担子走过来，嘴里说，“我叫你不要挑这么重的，你偏不听，这不是洒了。多惋惜！真是败家精！”</p><p>败家精是母亲的口头禅，我和弟弟干了什么坏事她老是这么数落我们。</p><p>但今天我感觉格外委屈，也不晓得为什么。</p><p>“你在这等会儿，我回家去拿个簸箕来把地上的米扫进去。浪费了多可惜！拿回去能够喂鸡呢！”母亲也不问我扭伤没有，只顾心疼洒了的米。</p><p>我晓得母亲的脾性，她素来是“刀子嘴，豆腐心”的，虽然也心疼我，嘴里却非要骂我几句。</p><p>想到这些，我也不委屈了。</p><p>“妈，你回去还要往返走个六七里路呢，时候也不早了。”我说。</p><p>“那地上的米怎样办？”</p><p>我心血来潮，把头上的凉帽摘下来：“装在这里边好了。”</p><p>母亲笑了：“还是你脑子活，学生妹子，机灵。”</p><p>说着，我们便蹲下身子，用手把洒落在地上的米捧起来，放在凉帽里，然后把凉帽顶朝下放在谷箩里，便挑着米持续往家赶。</p><p>回抵家里，弟弟曾经回来了，母亲便忙着做晚饭，我跟父亲申报卖米的经过。</p><p>父亲听了，也没埋怨母亲，只说：“那些米贩子也太黑了，城里都卖一块五呢，把价压这么低！这么挣庄稼人的血汗钱，太没良心了！”</p><p>我说：“爹，也没给你买药，怎样办？”</p><p>父亲说：“我原本就说不用买药的嘛，过两天就好了，花那个冤枉钱做什么！”</p><p>早晨，父亲咳嗽得更凶猛了。</p><p>母亲对我说：“琼宝，今天是转步的场，我们辛劳一点，把米挑到那里场上去卖了，好给你爹买药。”</p><p>“转步？那多远，十几里路呢！”我想到那漫长的山路，不由有些发怵。</p><p>“明天你们少担点米去。每人担50斤就够了。”父亲说。</p><p>“那明天可不要再卖不掉担回来哦！”我说，“十几里山路走个往返，还挑着担子，可不是说着玩的！”</p><p>“不会了不会了。”母亲说，“今天一块零八也好，一块零五也好，总之都卖了！”</p><p>母亲的话里有很多辛酸和无奈的意思，我听得出来，但不晓得怎样抚慰她。</p><p>我自个心里也很忧伤，有点想哭。</p><p>我想，别让母亲看见了，要哭就躲到被子里哭去吧。</p><p>可我真是太累啦，头刚刚挨到枕头就睡着了，睡得又香又甜。</p><p>　</p><p>注：《卖米》曾取得北京大学首届校园原创文学大赛一等奖。然而，在颁奖现场，获奖者并没有出现，而是由她的同窗们在寄予哀思，那氛围已经不是在颁奖，而是在开追悼会了。一时间，缄默掩盖了北大的整个阳光大厅。至此，我才晓得获奖者在一年前就已身患白血病离开了人世。</p><p>我为什么要分享这篇文章：读了后，感动是必然的。我老家在浙江省淳安县，我们县因为上个世纪中后期国家要规划建设新安江水电站来保障长三角地区的用电需求，栏坝蓄水，导致了我们县大面积被淹，当时当地的人民不得不举家移民，移民数达到了30余万，而如今的大坝之西，便是你们耳中时常听到的“千岛湖”。当时我外婆家因为离湖区较远，所以没有移民远处或外省，只是往后在高处退了点，千岛湖形成后，水刚好覆盖到了我外婆家边上，而我自己家则里湖区还有好几里路。人多人因为关注旅游渐渐听说了千岛湖的名字，但却不值淳安县是在哪。记得以前读《明朝那些事》的时候才了解到，大清官海瑞曾在淳安县当过县令。我说了这么多，是因为想要引出淳安为什么经济十分落后，至今，淳安仍旧是一个农业大县。建坝蓄水，可以说让淳安的经济倒退了十年，其中最致命的便是田地被淹，交通不便。当然，如今的淳安也很注重修路造桥，已经改善了许多。记得当初我若是想去一趟县城，我需要先赶小巴车，在弯弯曲曲的满是砂石的泥道上颠簸个半天赶到码头，然后在码头坐船到千岛湖镇，一天只有两班船，因为坐船可没开车那么快，到达目的地就得花去3到4个小时，基本上就半天过去了。不过现在想起来，我到挺怀恋当年坐车赶船的日子，其实我一点都不嫌弃坐船太慢，恰恰相反，我觉得挺惬意的，有时会在船上和哥哥姐姐一起打扑克牌，有时会跑到船舱外，凉风迎面吹来，看着客船在湖里稳速前进，别提有多舒服了，有时望着湖面，时不时还能看到鱼儿扑通一下跃出水面，激动地我对母亲叫着“妈，有鱼跳出来了！”，现如今，造好了千岛湖大桥，一条条道路接连开通，我已经很多年没做过船了，当时热闹繁华的客运码头，也被地产商承包了去，盖了一幢幢度假酒店。小时候，我爸在外地打工，母亲则待在家里，不仅种着土地，还要在外面厂里做会临时工，还要照顾我和我姐姐读书上学。在我刚上小学时，根本不知道什么是苦，干啥都兴致高昂，虽然要力气没力气，但只要母亲收拾着锄头镰刀要往地里田里去时，我一定也会背着一把迷你小锄头，屁颠屁颠跟在她后面也假装干活去了。街坊邻居见了，一个个都夸的我飞上了天，“毅毅，真是勤快呀，又帮你妈干活去了！”。事实上，多数时候我都是一到田里就把锄头丢在一旁，自个跑去玩了，有时会跑去田边的小溪里抓螃蟹，尤其是大热天的时候，泡在溪水里别提有多舒服了。而母亲本来也就没指望我能帮他干多少活。尽管如此，有时母亲实在忙过来，还是会叫我老老实实待在地里帮忙的，在30多度的太阳底下，你甚至找不到一点遮阴的地方，任由那汗水花花直流，你也得扛着干，这其实也就是很多农民的日子，所以我很清楚干农活是种怎样的苦。</p><p> 说来惭愧，到后面我就越来越懒，起初我还嘲讽我老姐，难得去地里干一次活，看我多勤快。但长大以后，我发现自己也和老姐半斤八两了，母亲喊了半天让我一起去地里帮忙，我总是死赖着不肯，最后我就说我还要学习呢！母亲一听，觉得不能让这种是占据了我的学习时间，就独自一人背着篮筐往庄稼地里走了去。读了《卖米》这篇文章，说实话我更多的是一种忏悔，我发现自己变得不是一点两点，我变得太多了，其实与文中作者描写的家庭相比，我家想必还算不错的了。我自责的也不是因为自己太物质，而是很多时候只想到了“钱”这个字眼，忽略了太多其他的东西。我和我姐一样都是在乡下读的小学初中，然后在县城读的高中，之后我来到杭州上大学，而我姐则是在宁波读的大学，一步步往外走，一步步求学，会发现有些人生来含着金钥匙，有些人活着已是拼尽了全力，但我们实在不能责怪自己的父母没能力，我也知道爸妈供我和我姐上学，甚至一直到大学毕业，他们就已经尽力了，教育资源的差距，社会阶层的差距，甚至是自己与同学的差距都不应怪在辛勤了半辈子的农民父母身上，在中国，可能仅仅一个户口的区别也会给你们带来巨大的差距。无论你是既得利益者还是非既得利益者，你都不得不承认这些事实。《卖米》这篇文章其实用词用句都很朴素，没有堆砌什么华丽的辞藻，但是却十分打动人，文章最后一句，累了整整一天的“我”，倒下就睡着，而且睡得又香又甜，生活不易，但我“安然以对”。文章以卖米这件许多人不以为然的小事展开，展现了底层家庭的生活实景，也许很多人根本无法感同身受，因为过惯了大鱼大肉的热子。但我也相信，大多数人的一生，本质都充满着艰难坎坷。努力并以正面姿态生活着吧，正如海子所说：<br> 你来人间一趟，总要看看太阳。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;01&quot;&gt;&lt;a href=&quot;#01&quot; class=&quot;headerlink&quot; title=&quot;01&quot;&gt;&lt;/a&gt;01&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;《卖米》作者飞花，原名张培祥，1979年，出生于湖南醴陵一个山区农民家庭。自小于贫寒中刻苦学习，1997年考入北京大学法学院
      
    
    </summary>
    
      <category term="摘录" scheme="http://huangyiblog.com/categories/%E6%91%98%E5%BD%95/"/>
    
    
      <category term="阅读" scheme="http://huangyiblog.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>红黑树简介</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AE%80%E4%BB%8B/"/>
    <id>http://huangyiblog.com/算法和数据结构/红黑树简介/</id>
    <published>2018-05-29T08:27:17.000Z</published>
    <updated>2018-05-29T08:34:48.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="红黑树简介"><a href="#红黑树简介" class="headerlink" title="红黑树简介"></a>红黑树简介</h1><p>红黑树（Red Black Tree）是一种自平衡的二叉查找树，它是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树。后来，在1978年被Leo J.Guibas和Robert Sedgewick修改为如今的“红黑树”。红黑树应用非常广泛，比如C++ STL库中的map和Java中的TreeMap、HashMap都是基于红黑树红黑树结构实现的。近年来，红黑树也常在面试中被问到。因此，掌握红黑树数据结构是非常必要的。</p><p><img src="/img/红黑树1.jpg" alt="alt text"></p><h1 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h1><p>普通的二叉查找树在极端的情况下可退化成链表，此时的查找效率会比较低下。为了避免这种情况，就出现了一些自平衡的查找树，比如AVL、红黑树等。这些自平衡的查找树通过定义一些性质，将任意结点的左右子树高度差控制在固定范围内，以达到平衡状态。红黑树需要满足如下五条性质：</p><ul><li><p>节点是红色或者黑色<br>在树里面的结点不是红色就是黑色，没有其他颜色，这也就是红黑树的由来</p></li><li><p>根节点是黑色<br>根节点总是黑色的，不能为红。</p></li><li><p>每个叶节点（NULL或空节点）是黑色<br>NULL节点是个空节点，并且是黑色的。</p></li><li><p>每个红色节点的两个子节点都是黑色的<br>连续的两个节点的意思就是父节点与子节点不能是连续的红色</p></li><li><p>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）<br>从根节点到每一个NULL节点的路径中，都包含了相同数量的黑色节点。</p></li></ul><p>这五条性质约束了红黑树，可以通过数学来证明，满足这五条性质的二叉树，就可以保证任意节点到其每个叶子节点路径最长不会超过最短路径的2倍。证明如下：</p><p>当某条路径最短时，这条路径比如都是黑色节点构成。当某条路径长度最长时，这条路径必然是由红色和黑色节点相间构成（性质4限定了不能出现两个连续的红色节点）。而性质5又限定了从任一节点到其每个叶子节点的所有路径必须包含相同数量的黑色节点。此时，在路径最长的情况下，路径上红色节点数量 = 黑色节点数量。该路径长度为黑色节点数量的2倍，也就是最短路径长度的2倍。</p><p><img src="/img/红黑树2.jpg" alt="alt text"></p><h1 id="红黑树的操作"><a href="#红黑树的操作" class="headerlink" title="红黑树的操作"></a>红黑树的操作</h1><p>红黑树的基本操作与其他树的操作一样，有查找、插入和删除等操作。由于查找与其他树的操作一样，比较简单，而插入、删除操作比较复杂，这里主要就是接受插入、删除操作。</p><h2 id="1-旋转操作"><a href="#1-旋转操作" class="headerlink" title="1.旋转操作"></a>1.旋转操作</h2><p>由于插入、删除的过程中都要涉及到旋转，这里首先介绍一下旋转这个基本操作。旋转操作分为左旋转和右旋转</p><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>左旋的过程是将节点x的右子树绕节点x逆时针旋转，使得节点x的右子树成为x的父亲，同时修改修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/img/红黑树3.jpg" alt="alt text"></p><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>右旋的过程是将节点x的左子树绕x顺时针旋转，使得节点x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/img/红黑树4.jpg" alt="alt text"></p><h2 id="2-插入操作"><a href="#2-插入操作" class="headerlink" title="2.插入操作"></a>2.插入操作</h2><p>红黑树的插入过程和二叉查找树的插入过程基本类似，不同的地方在于，红黑树插入新节点后，需要进行调整，以满足红黑树的性质。在讨论红黑树的插入操作之前必须要明白，任何一个即将插入的新节点的初始颜色都为红色。原因很简单，引入插入黑色的节点会增加某条路径上黑节点的数目，从而导致整棵树黑高度的不平衡。但如果插入的节点是红色的，此时所有路径上的黑色节点数量不变，仅可能会出现两个连续的红色节点的情况。这种情况下，通过变色和旋转进行调整即可，比插入黑色的简单多了。</p><p>红黑树的插入可能遇到如下几种情况：</p><ul><li>情况1：当插入的节点是根节点时，直接涂黑即可；</li><li>情况2：当要插入的节点的父节点是黑色的时候，这个时候插入一个红色的节点并没有对这五个性质产生破坏。所以直接插入不用在进行调整操作。</li></ul><p><img src="/img/红黑树5.jpg" alt="alt text"></p><ul><li>情况3：如果要插入的节点的父节点是红色且叔叔节点也是红色。由于父节点和插入的节点都是红色，所以性质4被打破，此时需要进行调整。在这种情况下，先将父节点和叔叔节点的颜色染成黑色，再让祖父结点染成红色。此时经过祖父结点的路径上的黑色节点数量不变，性质5仍然满足。但需要注意的是祖父节点被染成红色后，可能会和它的父节点形成连续的红色节点，此时需要递归向上调整。</li></ul><p><img src="/img/红黑树6.jpg" alt="alt text"></p><ul><li>情况4：当要插入的父节点为红色，叔叔节点为黑色。此时需要对父节点进行左旋，然后按照情况5进行处理（注：这里要插入的节点有可能是调整后的其它节点，这里我们理解父节点为插入节点而转到情况5）。</li></ul><p><img src="/img/红黑树7.jpg" alt="alt text"></p><ul><li>情况5：当要插入的父节点为红色，叔叔节点为黑色。插入节点是父节点的左孩子，且父节点是祖父节点的左孩子。此时对祖父节点进行右旋，并将祖父节点和父节点进行互换颜色。这时候满足了红黑树的全部性质。</li></ul><p><img src="/img/红黑树13.jpg" alt="alt text"></p><h2 id="3-删除操作"><a href="#3-删除操作" class="headerlink" title="3.删除操作"></a>3.删除操作</h2><p>相对于插入操作，红黑树的删除操作更为复杂。同样，这里我们也分为几种情况进行分析：</p><ul><li>情况1：当被删除元素为红时，对五条性质都没有什么影响，直接删除即可。</li><li>情况2：当被删除元素为黑且为根节点时，直接删除。</li><li>情况3：当被删除元素为黑，且有一个右子节点为红时，将右子节点涂黑放到被删除元素的位置，如图：</li></ul><p><img src="/img/红黑树8.jpg" alt="alt text"></p><ul><li>情况4：当被删除元素为黑，且兄弟节点为黑，兄弟节点两个孩子也为黑，父节点为红，此时，交换兄弟节点与父节点的颜色；NULL元素是指每个叶节点都是两个空的元素，颜色为黑的NULL元素，需要他的时候就可以把它看成两个黑元素，不需要的时候就可以忽视它。</li></ul><p><img src="/img/红黑树9.jpg" alt="alt text"></p><ul><li>情况5：当被删除的元素为黑、并且为父节点的左支，且兄弟颜色为黑，兄弟的右支为红色，这个时候需要交换兄弟与父亲的颜色，并把富且涂黑、兄弟的右支涂黑，并以父节点为中心左转。</li></ul><p><img src="/img/红黑树10.jpg" alt="alt text"></p><ul><li>情况6：当被删除元素为黑、并且为父节点的左支，且兄弟颜色为黑，兄弟的左支为红色，这个时候需要先把兄弟与兄弟的左子节点颜色互换，进行右转，然后就变成了情况5一样，在按照情况5进行旋转。</li></ul><p><img src="/img/红黑树11.jpg" alt="alt text"></p><ul><li><p>情况7：当被删除元素为黑且为父元素的右支时，跟情况5、情况6互为镜像。</p></li><li><p>情况8：当被删除的元素为黑，且父父元素的左支，兄弟节点为红色的时候，需要交换兄弟节点与父节点的颜色，以父节点进行左旋，就变成了情况4，再按照情况四进行操作即可。</p></li></ul><p><img src="/img/红黑树12.jpg" alt="alt text"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;红黑树简介&quot;&gt;&lt;a href=&quot;#红黑树简介&quot; class=&quot;headerlink&quot; title=&quot;红黑树简介&quot;&gt;&lt;/a&gt;红黑树简介&lt;/h1&gt;&lt;p&gt;红黑树（Red Black Tree）是一种自平衡的二叉查找树，它是在1972年由Rudolf Bayer发明的，当
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>107. 二叉树的层次遍历 II</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-II/"/>
    <id>http://huangyiblog.com/题解集/107-二叉树的层次遍历-II/</id>
    <published>2018-05-29T07:56:29.000Z</published>
    <updated>2018-05-29T07:57:28.301Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p><p>   3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回其自底向上的层次遍历为：</p><p>[<br>  [15,7],<br>  [9,20],<br>  [3]<br>]<br>题目要求：给定一颗二叉树，    返回一个二维数组，这个二维数组要满足这个条件， 二维数组的第一个一维数组要是这可二叉树的最下面一层，之后以此类推<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">int</span> depth = getHeight(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret(depth);</span><br><span class="line">        <span class="keyword">if</span>(depth==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(ret,ret.size()<span class="number">-1</span>,root);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ret,<span class="keyword">int</span> level,TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        ret[level].push_back(root-&gt;val);</span><br><span class="line">        dfs(ret,level<span class="number">-1</span>,root-&gt;left);</span><br><span class="line">        dfs(ret,level<span class="number">-1</span>,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lside = getHeight(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rside = getHeight(root-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> height = (lside&gt;rside?lside:rside)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）&lt;/p&gt;
&lt;p&gt;例如：&lt;br&gt;给定二叉树 [3,9,20,null,null,15,7],&lt;/p&gt;
&lt;p&gt;   3&lt;br&gt;   / \&lt;br&gt;  9  20&lt;br&gt; 
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>1005 继续(3n+1)猜想 (25)（25 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1005-%E7%BB%A7%E7%BB%AD-3n-1-%E7%8C%9C%E6%83%B3-25-%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1005-继续-3n-1-猜想-25-（25-分）/</id>
    <published>2018-05-29T07:41:04.000Z</published>
    <updated>2018-05-29T07:41:29.407Z</updated>
    
    <content type="html"><![CDATA[<p>1005 继续(3n+1)猜想 (25)（25 分）<br>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。</p><p>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，如果n不能被数列中的其他数字所覆盖。</p><p>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p><p>输入格式：每个测试输入包含1个测试用例，第1行给出一个正整数K(&amp;lt100)，第2行给出K个互不相同的待验证的正整数n(1&amp;ltn&lt;=100)的值，数字间用空格隔开。</p><p>输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。</p><p>输入样例：</p><p>6<br>3 5 6 7 8 11<br>输出样例：</p><p>7 6</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,x,k,a[<span class="number">111</span>],b[<span class="number">11011</span>],c[<span class="number">10011</span>],d[<span class="number">111</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        d[x]=a[i];</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;<span class="keyword">if</span>(b[a[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(a[i]&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">           b[a[i]/<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">           a[i]=a[i]/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">            b[(a[i]*<span class="number">3</span>+<span class="number">1</span>)/<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">            a[i]=(a[i]*<span class="number">3</span>+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(b[d[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">        c[j]=d[i];</span><br><span class="line">       j++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   sort(c,c+j,cmp);</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;j<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">"%d "</span>,c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,c[j<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1005 继续(3n+1)猜想 (25)（25 分）&lt;br&gt;卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。&lt;/p&gt;
&lt;p&gt;当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>1004 成绩排名 (20)（20 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1004-%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D-20-%EF%BC%8820-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1004-成绩排名-20-（20-分）/</id>
    <published>2018-05-29T07:39:14.000Z</published>
    <updated>2018-05-29T07:39:41.637Z</updated>
    
    <content type="html"><![CDATA[<p>1004 成绩排名 (20)（20 分）<br>读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p><p>输入格式：每个测试输入包含1个测试用例，格式为\</p><p>  第1行：正整数n<br>  第2行：第1个学生的姓名 学号 成绩<br>  第3行：第2个学生的姓名 学号 成绩<br>  … … …<br>  第n+1行：第n个学生的姓名 学号 成绩<br>其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。</p><p>输出格式：对每个测试用例输出2行，第1行是成绩最高学生的姓名和学号，第2行是成绩最低学生的姓名和学号，字符串间有1空格。</p><p>输入样例：</p><p>3<br>Joe Math990112 89<br>Mike CS991301 100<br>Mary EE990830 95<br>输出样例：</p><p>Mike CS991301<br>Joe Math990112</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> number;</span><br><span class="line">    <span class="keyword">int</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(student a,student b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.grade&lt;b.grade;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    student a[<span class="number">1110</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i].name&gt;&gt;a[i].number&gt;&gt;a[i].grade;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+n,cmp);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[n<span class="number">-1</span>].name&lt;&lt;<span class="string">" "</span>&lt;&lt;a[n<span class="number">-1</span>].number&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[<span class="number">0</span>].name&lt;&lt;<span class="string">" "</span>&lt;&lt;a[<span class="number">0</span>].number&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1004 成绩排名 (20)（20 分）&lt;br&gt;读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。&lt;/p&gt;
&lt;p&gt;输入格式：每个测试输入包含1个测试用例，格式为\&lt;/p&gt;
&lt;p&gt;  第1行：正整数n&lt;br&gt;  第2行：第1个学生的姓名 学号 成绩&lt;
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>1003 我要通过！(20)（20 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1003-%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87%EF%BC%81-20-%EF%BC%8820-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1003-我要通过！-20-（20-分）/</id>
    <published>2018-05-29T07:37:34.000Z</published>
    <updated>2018-05-29T07:38:07.079Z</updated>
    
    <content type="html"><![CDATA[<p>1003 我要通过！(20)（20 分）<br>“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。</p><p>得到“答案正确”的条件是：</p><ol><li>字符串中必须仅有P, A, T这三种字符，不可以包含其它字符；\</li></ol><p>任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；\<br>如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。<br>现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。</p><p>输入格式： 每个测试输入包含1个测试用例。第1行给出一个自然数n (&amp;lt10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。</p><p>输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。</p><p>输入样例：</p><p>8<br>PAT<br>PAAT<br>AAPATAA<br>AAPAATAAAA<br>xPATx<br>PT<br>Whatever<br>APAAATAA<br>输出样例：</p><p>YES<br>YES<br>YES<br>YES<br>NO<br>NO<br>NO<br>NO</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i,j;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">111</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>,z=<span class="number">0</span>,flag1=<span class="number">0</span>,flag2=<span class="number">0</span>,flag3=<span class="number">0</span>,len;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">        len=<span class="built_in">strlen</span>(a);</span><br><span class="line">        <span class="keyword">int</span> count1=<span class="number">0</span>,count2=<span class="number">0</span>,count3=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">'P'</span>&amp;&amp;a[len<span class="number">-1</span>]==<span class="string">'T'</span>)&#123;</span><br><span class="line">                flag1=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=len<span class="number">-2</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]==<span class="string">'A'</span>)</span><br><span class="line">                flag1=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag1=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag1==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">'A'</span>)</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="string">'P'</span>)</span><br><span class="line">                flag2=i;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="string">'T'</span>)</span><br><span class="line">                flag3=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;flag2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="string">'A'</span>)&#123;</span><br><span class="line">                x=<span class="number">1</span>;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                x=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=flag2+<span class="number">1</span>;i&lt;flag3;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="string">'A'</span>)&#123;</span><br><span class="line">                y=<span class="number">1</span>;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                y=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=flag3+<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="string">'A'</span>)&#123;</span><br><span class="line">                z=<span class="number">1</span>;</span><br><span class="line">                count3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                z=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>&amp;&amp;y==<span class="number">1</span>&amp;&amp;z==<span class="number">1</span>&amp;&amp;count1*count2==count3)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1003 我要通过！(20)（20 分）&lt;br&gt;“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。&lt;/p&gt;
&lt;p&gt;得到“答案正确”的条件是：&lt;/p&gt;
&lt;ol
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>1002 写出这个数 (20)（20 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1002-%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0-20-%EF%BC%8820-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1002-写出这个数-20-（20-分）/</id>
    <published>2018-05-29T07:35:47.000Z</published>
    <updated>2018-05-29T07:36:15.661Z</updated>
    
    <content type="html"><![CDATA[<p>1002 写出这个数 (20)（20 分）<br>读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p><p>输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10^100^。</p><p>输出格式：在一行内输出n的各位数字之和的每一位，拼音数字间有1 空格，但一行中最后一个拼音数字后没有空格。</p><p>输入样例：</p><p>1234567890987654321123456789<br>输出样例：</p><p>yi san wu</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> a[<span class="number">10000</span>];</span><br><span class="line">   <span class="keyword">int</span> s[<span class="number">1000</span>];</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">   <span class="keyword">int</span> len,i,sum,j,t;</span><br><span class="line">   len=<span class="built_in">strlen</span>(a);</span><br><span class="line">   j=sum=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    sum+=a[i]-<span class="string">'0'</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(sum!=<span class="number">0</span>)&#123;</span><br><span class="line">        j++;</span><br><span class="line">    t=sum%<span class="number">10</span>;</span><br><span class="line">    sum=sum/<span class="number">10</span>;</span><br><span class="line">    s[j]=t;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(i=j;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i]==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"yi "</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"er "</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">3</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"san "</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">4</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"si "</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"wu "</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">6</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"liu "</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">7</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"qi "</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">8</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ba "</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">9</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"jiu "</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ling "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(s[i]==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"yi"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"er"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">3</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"san"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">4</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"si"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"wu"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">6</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"liu"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">7</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"qi"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">8</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ba"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">9</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"jiu"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ling"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1002 写出这个数 (20)（20 分）&lt;br&gt;读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。&lt;/p&gt;
&lt;p&gt;输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10^100^。&lt;/p&gt;
&lt;p&gt;输出格式：在一行内输出n的各位数字
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>1001 害死人不偿命的(3n+1)猜想 (15)（15 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84-3n-1-%E7%8C%9C%E6%83%B3-15-%EF%BC%8815-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/1001-害死人不偿命的-3n-1-猜想-15-（15-分）/</id>
    <published>2018-05-29T07:34:11.000Z</published>
    <updated>2018-05-29T07:34:38.502Z</updated>
    
    <content type="html"><![CDATA[<p>1001 害死人不偿命的(3n+1)猜想 (15)（15 分）<br>卡拉兹(Callatz)猜想：</p><p>对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……</p><p>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？</p><p>输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。</p><p>输出格式：输出从n计算到1需要的步数。</p><p>输入样例：</p><p>3<br>输出样例：</p><p>5</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            n=n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            n=(<span class="number">3</span>*n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1001 害死人不偿命的(3n+1)猜想 (15)（15 分）&lt;br&gt;卡拉兹(Callatz)猜想：&lt;/p&gt;
&lt;p&gt;对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>L2-008 最长对称子串（25 分）</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/L2-008-%E6%9C%80%E9%95%BF%E5%AF%B9%E7%A7%B0%E5%AD%90%E4%B8%B2%EF%BC%8825-%E5%88%86%EF%BC%89/"/>
    <id>http://huangyiblog.com/题解集/L2-008-最长对称子串（25-分）/</id>
    <published>2018-05-29T07:30:54.000Z</published>
    <updated>2018-05-29T07:31:27.596Z</updated>
    
    <content type="html"><![CDATA[<p>L2-008 最长对称子串（25 分）<br>对给定的字符串，本题要求你输出最长对称子串的长度。例如，给定”Is PAT&amp;TAP symmetric?”，最长对称子串为”s PAT&amp;TAP s”，于是你应该输出11。</p><p>输入格式：</p><p>输入在一行中给出长度不超过1000的非空字符串。</p><p>输出格式：</p><p>在一行中输出最长对称子串的长度。</p><p>输入样例：</p><p>Is PAT&amp;TAP symmetric?<br>输出样例：</p><p>11</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">char</span> S[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gets(S);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(S),ans = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==S[i+<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                ans = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">3</span>;t&lt;=len;t++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+t<span class="number">-1</span>&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+t<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==S[j]&amp;&amp;dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                ans = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;L2-008 最长对称子串（25 分）&lt;br&gt;对给定的字符串，本题要求你输出最长对称子串的长度。例如，给定”Is PAT&amp;amp;TAP symmetric?”，最长对称子串为”s PAT&amp;amp;TAP s”，于是你应该输出11。&lt;/p&gt;
&lt;p&gt;输入格式：&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="http://huangyiblog.com/tags/PAT/"/>
    
  </entry>
  
</feed>
