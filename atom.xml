<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你的小黄^_^</title>
  <icon>https://www.gravatar.com/avatar/3a25a3ab34305615e80247defadfd4f6</icon>
  <subtitle>做一名有情怀的程序员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huangyiblog.com/"/>
  <updated>2018-05-18T04:26:09.235Z</updated>
  <id>http://huangyiblog.com/</id>
  
  <author>
    <name>Mr.Huangyi</name>
    <email>18757163093@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 9. 回文数</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://huangyiblog.com/题解集/LeetCode-9-回文数/</id>
    <published>2018-05-18T04:25:35.000Z</published>
    <updated>2018-05-18T04:26:09.235Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>示例 1:</p><p>输入: 121<br>输出: true<br>示例 2:</p><p>输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3:</p><p>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。<br>进阶:</p><p>你能不将整数转为字符串来解决这个问题吗？<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> d=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x/d&gt;=<span class="number">10</span>) d*=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> q = x/d;</span><br><span class="line">            <span class="keyword">int</span> r = x%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(q!=r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            x=x%d/<span class="number">10</span>;</span><br><span class="line">            d/=<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: 121&lt;br&gt;输出: true&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: -121&lt;br&gt;输出: false&lt;br&gt;解释: 从左向右读, 
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 88. 合并两个有序数组</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://huangyiblog.com/题解集/LeetCode-88-合并两个有序数组/</id>
    <published>2018-05-18T04:22:41.000Z</published>
    <updated>2018-05-18T04:23:28.555Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p><p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p><p>输出: [1,2,2,3,5,6]</p><p>由于题目已经假定nums1有足够的空间，所以就很好解决了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m,j=<span class="number">0</span>;i&lt;m+n,j&lt;n;i++,j++)&#123;</span><br><span class="line">            nums1[i] = nums2[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = m+n;</span><br><span class="line">        sort(nums1.begin(),nums1.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。&lt;/p&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;初始化 nums1 和 nums2 的元素数量分别为 m 和 n。&lt;br&gt;你可以假设 nums1 有足够的空间（
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 83. 删除排序链表中的重复元素</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://huangyiblog.com/题解集/LeetCode-83-删除排序链表中的重复元素/</id>
    <published>2018-05-18T04:18:37.000Z</published>
    <updated>2018-05-18T04:19:17.542Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p><p>/**</p><ul><li>Definition for singly-linked list.</li><li>struct ListNode {</li><li>int val;</li><li>ListNode *next;</li><li>ListNode(int x) : val(x), next(NULL) {}</li><li>};<br>*/</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;<span class="comment">//真正写的时候，链表为空一定不能漏了</span></span><br><span class="line">        <span class="keyword">int</span> val = head-&gt;val;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;p-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val!=val)&#123;</span><br><span class="line">                val = p-&gt;next-&gt;val;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode* n = p-&gt;next-&gt;next;</span><br><span class="line">                p-&gt;next = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: 1-&amp;gt;1-&amp;gt;2&lt;br&gt;输出: 1-&amp;gt;2&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3&lt;br&gt;输出:
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 70. 爬楼梯</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://huangyiblog.com/题解集/LeetCode-70-爬楼梯/</id>
    <published>2018-05-18T04:14:05.000Z</published>
    <updated>2018-05-18T04:14:39.849Z</updated>
    
    <content type="html"><![CDATA[<p>假设你正在爬楼梯。需要 n 步你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p><ol><li>1 步 + 1 步</li><li>2 步<br>示例 2：</li></ol><p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li>1 步 + 1 步 + 1 步</li><li>1 步 + 2 步</li><li>2 步 + 1 步</li></ol><p>找找规律，会发现这其实是个斐波那契<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) </span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>* step = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        step[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        step[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            step[i] = step[i<span class="number">-1</span>]+step[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设你正在爬楼梯。需要 n 步你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;p&gt;注意：给定 n 是一个正整数。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入： 2&lt;br&gt;输出： 2&lt;br&gt;解释： 有两种方法
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 7. 反转整数</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-7-%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>http://huangyiblog.com/题解集/LeetCode-7-反转整数/</id>
    <published>2018-05-18T04:10:35.000Z</published>
    <updated>2018-05-18T04:32:09.951Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个 32 位有符号整数，将整数中的数字进行反转。</p><p>示例 1:</p><p>输入: 123<br>输出: 321<br> 示例 2:</p><p>输入: -123<br>输出: -321<br>示例 3:</p><p>输入: 120<br>输出: 21<br>注意:</p><p>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。</p><p>这道题主要还是考察细节问题；</p><ol><li>考虑负数的情况</li><li>考虑溢出，包括正溢出和负溢出，即如果是正数，则大于2147483647溢出；如果是负数，则小于-2147483648溢出<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t = x;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            t=-t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;t;t/=<span class="number">10</span>)&#123;</span><br><span class="line">            r=r*<span class="number">10</span>+t%<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> sign;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sign = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sign =<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;<span class="number">2147483647</span>||(sign&amp;&amp;r&gt;<span class="number">2147483648</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(sign)&#123;</span><br><span class="line">                <span class="keyword">return</span> -r;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个 32 位有符号整数，将整数中的数字进行反转。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: 123&lt;br&gt;输出: 321&lt;br&gt; 示例 2:&lt;/p&gt;
&lt;p&gt;输入: -123&lt;br&gt;输出: -321&lt;br&gt;示例 3:&lt;/p&gt;
&lt;p&gt;输入: 120&lt;br&gt;输出: 2
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 69. x 的平方根</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-69-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <id>http://huangyiblog.com/题解集/LeetCode-69-x-的平方根/</id>
    <published>2018-05-18T04:07:02.000Z</published>
    <updated>2018-05-18T04:07:42.743Z</updated>
    
    <content type="html"><![CDATA[<p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:</p><p>输入: 4<br>输出: 2<br>示例 2:</p><p>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p><p>这道题明显就是考察二分，面试时你总不可能给面试官直接调用下sqrt函数吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>,right = x/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> last_mid;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">2</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x/mid&gt;mid)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">                last_mid = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x/mid&lt;mid)&#123;</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last_mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现 int sqrt(int x) 函数。&lt;/p&gt;
&lt;p&gt;计算并返回 x 的平方根，其中 x 是非负整数。&lt;/p&gt;
&lt;p&gt;由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: 4&lt;br&gt;输出: 2&lt;br&gt;示例 2:&lt;
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 58. 最后一个单词的长度</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
    <id>http://huangyiblog.com/题解集/LeetCode-58-最后一个单词的长度/</id>
    <published>2018-05-18T04:02:15.000Z</published>
    <updated>2018-05-18T04:03:14.458Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。</p><p>如果不存在最后一个单词，请返回 0 。</p><p>说明：一个单词是指由字母组成，但不包含任何空格的字符串。</p><p>示例:</p><p>输入: “Hello World”<br>输出: 5</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>,tag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">' '</span>)&#123;</span><br><span class="line">                len++;</span><br><span class="line">              </span><br><span class="line">            &#125;</span><br><span class="line">               <span class="keyword">if</span>((s[i]==<span class="string">' '</span>||i==<span class="number">0</span>)&amp;&amp;len!=<span class="number">0</span>)&#123;          </span><br><span class="line">                <span class="keyword">return</span> len;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。&lt;/p&gt;
&lt;p&gt;如果不存在最后一个单词，请返回 0 。&lt;/p&gt;
&lt;p&gt;说明：一个单词是指由字母组成，但不包含任何空格的字符串。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: “Hello World”
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 53. 最大子序和</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://huangyiblog.com/题解集/LeetCode-53-最大子序和/</id>
    <published>2018-05-17T09:29:01.000Z</published>
    <updated>2018-05-17T09:30:03.144Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶:</p><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><p>这是一道很经典的算法问题了，很多算法书在讲到dp问题的时候都是作为一个范例了</p><ul><li>思路1：暴力枚举，但是太low了，复杂度达到了O(n^3)量级，所以基本可以忽略</li><li>思路2：先预处理，因为连续子序列和等于两个前缀和之差，时间复杂度为O(n^2)</li><li>思路3：动态规划解法</li><li>思路4：分治法</li></ul><p>我主要就了解了这几种，还有一些其他的优化解法没怎么学过。<br>INT_MIN在标准头文件limits.h中定义。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN (-INT_MAX - 1)</span></span><br></pre></td></tr></table></figure></p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>转移方程：<strong>dp[i+1] = max(dp[i]+a[i+1])</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = INT_MIN,f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            f = max(f + nums[i],nums[i]);</span><br><span class="line">            result = max(result,f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="预处理解法"><a href="#预处理解法" class="headerlink" title="预处理解法"></a>预处理解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deal(nums.begin(),nums.end());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deal</span><span class="params">(T begin,T end)</span></span>&#123;</span><br><span class="line">          <span class="keyword">int</span> result,cur_min;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">int</span> n = distance(begin,end);</span><br><span class="line">          <span class="keyword">int</span> *sum = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">          sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">          result = INT_MIN;</span><br><span class="line">          cur_min = sum[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">              sum[i] = sum[i<span class="number">-1</span>]+*(begin + i - <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">              result = max(result,sum[i]-cur_min);</span><br><span class="line">              cur_min = min(cur_min,sum[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">delete</span>[] sum;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分治解法"><a href="#分治解法" class="headerlink" title="分治解法"></a>分治解法</h2><p>假设数组A[left,    right]存在最大区间，mid    =    (left    +    right)    /    2，那么无非就是三中情 况：</p><ol><li>最大值在A[left,    mid    -    1]里面<ol start="2"><li>最大值在A[mid    +    1,    right]里面</li><li>最大值跨过了mid，也就是我们需要计算[left,    mid    -    1]区间的最大值，以及[mid +    1,    right]的最大值，然后加上mid，三者之和就是总的最大值</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> divide(A,<span class="number">0</span>,n<span class="number">-1</span>,INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> maxm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> lmax = divide(A,left,mid<span class="number">-1</span>,maxm);</span><br><span class="line">        <span class="keyword">int</span> rmax = divide(A,mid+<span class="number">1</span>,right,maxm);</span><br><span class="line">        maxm = max(maxm,lmax);</span><br><span class="line">        maxm = max(maxm,rmax);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mlmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid<span class="number">-1</span>;i&gt;=left;i--)&#123;</span><br><span class="line">            sum+=A[i];</span><br><span class="line">            mlmax = max(mlmax,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mrmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid+<span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            mrmax = max(mrmax,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        maxm = max(maxm,A[mid]+mlmax+mrmax);</span><br><span class="line">        <span class="keyword">return</span> maxm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: [-2,1,-3,4,-1,2,1,-5,4],&lt;br&gt;输出: 6&lt;br&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 35. 搜索插入位置</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>http://huangyiblog.com/题解集/LeetCode-35-搜索插入位置/</id>
    <published>2018-05-17T08:14:52.000Z</published>
    <updated>2018-05-17T08:17:54.744Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><p>输入: [1,3,5,6], 5<br>输出: 2<br>示例 2:</p><p>输入: [1,3,5,6], 2<br>输出: 1<br>示例 3:</p><p>输入: [1,3,5,6], 7<br>输出: 4<br>示例 4:</p><p>输入: [1,3,5,6], 0<br>输出: 0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(nums[x<span class="number">-1</span>]&lt;target)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;=target)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;你可以假设数组中无重复元素。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: [1,3,5,6], 5&lt;br&gt;输出: 2&lt;br&gt;示例 2:
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 27. 移除元素</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>http://huangyiblog.com/题解集/LeetCode-27-移除元素/</id>
    <published>2018-05-17T08:11:15.000Z</published>
    <updated>2018-05-17T08:12:32.992Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><p><strong>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</strong></p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:</p><p>给定 nums = [3,2,2,3], val = 3,</p><p>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p><p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p><p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,</p><p>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p>注意这五个元素可为任意顺序。</p><p>你不需要考虑数组中超出新长度后面的元素。<br>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><p>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>int len = removeElement(nums, val);</p><p>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=val)&#123;</span><br><span class="line">                nums[index++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance(nums.begin(),remove(nums.begin(),nums.end(),val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;元素的顺
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 26. 删除排序数组中的重复项</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://huangyiblog.com/题解集/LeetCode-26-删除排序数组中的重复项/</id>
    <published>2018-05-17T08:05:52.000Z</published>
    <updated>2018-05-17T08:17:48.722Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p><strong>不要使用额外的数组空间</strong>，你必须在原地修改输入数组并在使用<strong> O(1) 额外</strong>空间的条件下完成。</p><p>示例 1:</p><p>给定数组 nums = [1,1,2], </p><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p><p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p><p>你不需要考虑数组中超出新长度后面的元素。<br>解法一：标记下标，然后遍历数组元素依次进行比较，出现不等元素就赋值给标记的下一个位置<br>解法二：利用STL里的unique函数（由于给的是有序数组，所以可以直接用）</p><ul><li>unique()是C++标准库函数里面的函数，其功能是去除相邻的重复元素（只保留一个），所以使用前需要对数组进行排序</li><li>distance主要是用来求两个迭代器之间的元素个数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                nums[++pos] = nums[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance(nums.begin(),unique(nums.begin(),nums.end()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要使用额外的数组空间&lt;/strong&gt;，你必须在原地修改输入数组并在使用&lt;strong&gt; O(1) 额外&lt;/strong&gt;空间的条件下完成。&lt;
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 21. 合并两个有序链表</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://huangyiblog.com/题解集/LeetCode-21-合并两个有序链表/</id>
    <published>2018-05-17T07:57:02.000Z</published>
    <updated>2018-05-17T07:58:32.002Z</updated>
    
    <content type="html"><![CDATA[<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p>逐个比较大小，到后面较长的链表的多余元素直接补上<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* p = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> val1 = l1-&gt;val;</span><br><span class="line">            <span class="keyword">int</span> val2 = l2-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(val1&lt;val2)&#123;</span><br><span class="line">                p-&gt;next = l1;</span><br><span class="line">                p = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">                p = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 &lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;br&gt;输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 204. 计数质数</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/"/>
    <id>http://huangyiblog.com/题解集/LeetCode-204-计数质数/</id>
    <published>2018-05-17T07:52:19.000Z</published>
    <updated>2018-05-17T07:53:07.699Z</updated>
    
    <content type="html"><![CDATA[<p>统计所有小于非负数整数 n 的质数的数量。</p><p>示例:</p><p>输入: 10<br>输出: 4<br>解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p><p>先预处理，不是素数的就标记出来<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; isPrime(n,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i;j&lt;n;j+=i)&#123;</span><br><span class="line">                    isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;统计所有小于非负数整数 n 的质数的数量。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: 10&lt;br&gt;输出: 4&lt;br&gt;解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。&lt;/p&gt;
&lt;p&gt;先预处理，不是素数的就标记出来&lt;br&gt;&lt;figure class
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 167. 两数之和 II - 输入有序数组</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://huangyiblog.com/题解集/LeetCode-167-两数之和-II-输入有序数组/</id>
    <published>2018-05-17T07:49:13.000Z</published>
    <updated>2018-05-17T07:49:55.463Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><p>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>示例:</p><p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.size();i++)&#123;</span><br><span class="line">            m[numbers[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.size();i++)&#123;</span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> gap = target-numbers[i];</span><br><span class="line">            <span class="keyword">if</span>(m.find(gap)!=m.end()&amp;&amp;m[gap]&gt;i)&#123;</span><br><span class="line">                result.push_back(i+<span class="number">1</span>);</span><br><span class="line">                result.push_back(m[gap]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。&lt;/p&gt;
&lt;p&gt;函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。&lt;/p&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;返回的下标值（index1 和 index2
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 136.只出现一次的数字</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://huangyiblog.com/题解集/LeetCode-136-只出现一次的数字/</id>
    <published>2018-05-17T07:46:22.000Z</published>
    <updated>2018-05-17T07:47:02.421Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有<strong>线性时间复杂度</strong>。 你可以<strong>不使用额外空间</strong>来实现吗？</p><p>示例 1:</p><p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p><p>输入: [4,1,2,1,2]<br>输出: 4</p><p>分析，只有一个元素出现一次，其余均出现两次，可以想到异或运算符，<br>遍历整个数组，出现两次的异或以后为0，最后自然只剩下了出现一次的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            x^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;你的算法应该具有&lt;strong&gt;线性时间复杂度&lt;/strong&gt;。 你可以&lt;strong&gt;不使用额外空间&lt;/strong&gt;来实现吗？&lt;
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1.两数之和</title>
    <link href="http://huangyiblog.com/%E9%A2%98%E8%A7%A3%E9%9B%86/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://huangyiblog.com/题解集/LeetCode-1-两数之和/</id>
    <published>2018-05-17T07:38:09.000Z</published>
    <updated>2018-05-17T07:39:46.410Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p><p>法一：直接双重循环 暴力解，但会超时，O(n^2)</p><p>法二：哈希，用一个哈希表，存储每个数的对应下标，复杂度O(n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            m[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> gap = target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(m.find(gap)!=m.end()&amp;&amp;m[gap]&gt;i)&#123;</span><br><span class="line">                result.push_back(i);</span><br><span class="line">                result.push_back(m[gap]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。&lt;/p&gt;
&lt;p&gt;你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;给定 nums = [2, 7, 11, 15], target = 9&lt;/p&gt;
&lt;p&gt;因为 nu
      
    
    </summary>
    
      <category term="题解集" scheme="http://huangyiblog.com/categories/%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    
    
      <category term="LeetCode" scheme="http://huangyiblog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>技术书单系列2</title>
    <link href="http://huangyiblog.com/%E9%9A%8F%E7%AC%94/%E6%8A%80%E6%9C%AF%E4%B9%A6%E5%8D%95%E7%B3%BB%E5%88%972/"/>
    <id>http://huangyiblog.com/随笔/技术书单系列2/</id>
    <published>2018-05-17T06:42:32.000Z</published>
    <updated>2018-05-17T06:44:02.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言相关"><a href="#C语言相关" class="headerlink" title="C语言相关"></a>C语言相关</h1><ul><li><p>《C和指针》</p></li><li><p>《C缺陷与陷阱》</p></li><li><p>《C专家编程》</p></li><li><p>《C语言深度剖析》</p></li></ul><h1 id="C-相关"><a href="#C-相关" class="headerlink" title="C++相关"></a>C++相关</h1><ul><li><p>《C++ Primer 5th》</p></li><li><p>《Effective C++》</p></li><li><p>《深度探索C++对象模型》</p></li><li><p>《STL源码剖析》</p></li></ul><h1 id="计算机底层相关"><a href="#计算机底层相关" class="headerlink" title="计算机底层相关"></a>计算机底层相关</h1><ul><li><p>《编码》</p></li><li><p>《编译原理》</p></li><li><p>《汇编语言》</p></li><li><p>《C++反汇编与逆向分析》</p></li></ul><h1 id="算法、数据结构相关"><a href="#算法、数据结构相关" class="headerlink" title="算法、数据结构相关"></a>算法、数据结构相关</h1><ul><li><p>《算法导论》</p></li><li><p>《编程珠玑》</p></li><li><p>《编程之美》</p></li><li><p>《算法艺术与信息学竞赛》</p></li></ul><h1 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h1><ul><li><p>《深入理解操作系统》</p></li><li><p>《Linux内核完全注释》</p></li><li><p>《自己动手写操作系统》</p></li><li><p>《Windows内核原理与实现》</p></li></ul><h1 id="软件开发相关"><a href="#软件开发相关" class="headerlink" title="软件开发相关"></a>软件开发相关</h1><ul><li><p>《Head First 设计模式》</p></li><li><p>《设计模式-可复用面向对象软件的基础》</p></li><li><p>《重构与模式》</p></li><li><p>《代码大全》</p></li><li><p>《设计模式》</p></li></ul><h1 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h1><ul><li><p>《数据库系统概念》</p></li><li><p>《数据库系统实现》</p></li><li><p>《MySQL技术内幕：sql编程》</p></li><li><p>《MySQL技术内幕：innodb存储引擎》</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C语言相关&quot;&gt;&lt;a href=&quot;#C语言相关&quot; class=&quot;headerlink&quot; title=&quot;C语言相关&quot;&gt;&lt;/a&gt;C语言相关&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;《C和指针》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;《C缺陷与陷阱》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
      <category term="随笔" scheme="http://huangyiblog.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="阅读" scheme="http://huangyiblog.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>面向Google的学习手册</title>
    <link href="http://huangyiblog.com/%E8%AF%91%E6%96%87%E9%9B%86/%E9%9D%A2%E5%90%91Google%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://huangyiblog.com/译文集/面向Google的学习手册/</id>
    <published>2018-05-17T03:04:44.000Z</published>
    <updated>2018-05-18T10:51:56.744Z</updated>
    
    <content type="html"><![CDATA[<p>在GitHub上无意中发现一位为了入职Google而准备的学习手册，粗略一看，深感佩服，获益颇多，故转发一波，希望与大家共勉。</p><h1 id="译-Google-Interview-University-一套完整的学习手册帮助自己准备-Google-的面试"><a href="#译-Google-Interview-University-一套完整的学习手册帮助自己准备-Google-的面试" class="headerlink" title="[译] Google Interview University 一套完整的学习手册帮助自己准备 Google 的面试"></a>[译] Google Interview University 一套完整的学习手册帮助自己准备 Google 的面试</h1><blockquote><ul><li>原文地址：<a href="https://github.com/jwasham/google-interview-university" target="_blank" rel="noopener">Google Interview University</a></li><li>原文作者：<a href="https://github.com/jwasham" target="_blank" rel="noopener">John Washam</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>译者：<a href="https://github.com/aleen42" target="_blank" rel="noopener">aleen42</a>，<a href="https://github.com/Newt0n" target="_blank" rel="noopener">Newton</a>，<a href="https://github.com/bobmayuze" target="_blank" rel="noopener">bobmayuze</a>，<a href="https://github.com/laobie" target="_blank" rel="noopener">Jaeger</a>，<a href="https://github.com/sqrthree" target="_blank" rel="noopener">sqrthree</a></li></ul></blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/c9c9db0a39b56738a62332f0791d58b1522fdf82/68747470733a2f2f7261776769742e636f6d2f616c65656e34322f6261646765732f6d61737465722f7372632f786974752e737667" alt="xitu"></a></p><h2 id="这是？"><a href="#这是？" class="headerlink" title="这是？"></a>这是？</h2><p>这是我为了从 web 开发者（自学、非计算机科学学位）蜕变至 Google 软件工程师所制定的计划，其内容历时数月。</p><p><img src="https://dng5l3qzreal6.cloudfront.net/2016/Aug/coding_board_small-1470866369118.jpg" alt="白板上编程 ———— 来自 HBO 频道的剧集，“硅谷”"></p><p>这一长列表是从 <strong>Google 的指导笔记</strong> 中萃取出来并进行扩展。因此，有些事情你必须去了解一下。我在列表的底部添加了一些额外项，用于解决面试中可能会出现的问题。这些额外项大部分是来自于 Steve Yegge 的“<a href="http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html" target="_blank" rel="noopener">得到在 Google 工作的机会</a>”。而在 Google 指导笔记的逐字间，它们有时也会被反映出来。</p><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#这是">这是？</a></li><li><a href="#为何要用到它">为何要用到它？</a></li><li><a href="#如何使用它">如何使用它</a></li><li><a href="#拥有一名-googler-的心态">拥有一名 Googler 的心态</a></li><li><a href="#我得到了工作吗">我得到了工作吗？</a></li><li><a href="#跟着我的脚步">跟着我的脚步</a></li><li><a href="#不要妄自菲薄">不要妄自菲薄</a></li><li><a href="#关于-google">关于 Google</a></li><li><a href="#相关视频资源">相关视频资源</a></li><li><a href="#面试过程--通用的面试准备">面试过程 &amp; 通用的面试准备</a></li><li><a href="#为你的面试选择一种语言">为你的面试选择一种语言</a></li><li><a href="#在你开始之前">在你开始之前</a></li><li><a href="#你所看不到的">你所看不到的</a></li><li><a href="#日常计划">日常计划</a></li><li><a href="#必备知识">必备知识</a></li><li><a href="#算法复杂度--big-o--渐进分析法">算法复杂度 / Big-O / 渐进分析法</a></li><li><a href="#数据结构">数据结构</a><ul><li><a href="#数组arrays">数组（Arrays）</a></li><li><a href="#链表linked-lists">链表（Linked Lists）</a></li><li><a href="#堆栈stack">堆栈（Stack）</a></li><li><a href="#队列queue">队列（Queue）</a></li><li><a href="#哈希表hash-table">哈希表（Hash table）</a></li></ul></li><li><a href="#更多的知识">更多的知识</a><ul><li><a href="#二分查找binary-search">二分查找（Binary search）</a></li><li><a href="#按位运算bitwise-operations">按位运算（Bitwise operations）</a></li></ul></li><li><a href="#树trees">树（Trees）</a><ul><li><a href="#树--笔记--背景">树 —— 笔记 &amp; 背景</a></li><li><a href="#二叉查找树binary-search-treesbsts">二叉查找树（Binary search trees）：BSTs</a></li><li><a href="#堆heap--优先级队列priority-queue--二叉堆binary-heap">堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）</a></li><li><a href="#字典树tries">字典树（Tries）</a></li><li><a href="#平衡查找树balanced-search-trees">平衡查找树（Balanced search trees）</a></li><li><a href="#n-叉树k-叉树m-叉树">N 叉树（K 叉树、M 叉树）</a></li></ul></li><li><a href="#排序sorting">排序</a></li><li><a href="#图graphs">图（Graphs）</a></li><li><a href="#更多知识">更多知识</a><ul><li><a href="#递归recursion">递归</a></li><li><a href="#动态规划dynamic-programming">动态规划</a></li><li><a href="#组合combinatorics-n-中选-k-个--概率probability">组合 &amp; 概率</a></li><li><a href="#np-np-完全和近似算法">NP, NP-完全和近似算法</a></li><li><a href="#缓存cache">缓存</a></li><li><a href="#进程processe和线程thread">进程和线程</a></li><li><a href="#系统设计可伸缩性数据处理">系统设计、可伸缩性、数据处理</a></li><li><a href="#论文">论文</a></li><li><a href="#测试">测试</a></li><li><a href="#调度">调度</a></li><li><a href="#实现系统例程">实现系统例程</a></li><li><a href="#字符串搜索和操作">字符串搜索和操作</a></li></ul></li><li><a href="#终面">终面</a></li><li><a href="#书籍">书籍</a></li><li><a href="#编码练习和挑战">编码练习和挑战</a></li><li><a href="#当你临近面试时">当你临近面试时</a></li><li><a href="#你的简历">你的简历</a></li><li><a href="#当面试来临的时候">当面试来临的时候</a></li><li><a href="#问面试官的问题">问面试官的问题</a></li><li><a href="#当你获得了梦想的职位">当你获得了梦想的职位</a></li></ul><p>—————- 下面的内容是可选的 —————-</p><ul><li><a href="#附加的学习">附加的学习</a><ul><li><a href="#unicode">Unicode</a></li><li><a href="#字节顺序">字节顺序</a></li><li><a href="#emacs-and-vim">Emacs and vi(m)</a></li><li><a href="#unix-命令行工具">Unix 命令行工具</a></li><li><a href="#信息资源-视频">信息资源 (视频)</a></li><li><a href="#奇偶校验位--汉明码-视频">奇偶校验位 &amp; 汉明码 (视频)</a></li><li><a href="#系统熵值系统复杂度">系统熵值（系统复杂度）</a></li><li><a href="#密码学">密码学</a></li><li><a href="#压缩">压缩</a></li><li><a href="#网络-视频">网络 (视频)</a></li><li><a href="#计算机安全">计算机安全</a></li><li><a href="#释放缓存">释放缓存</a></li><li><a href="#并行并发编程">并行/并发编程</a></li><li><a href="#设计模式">设计模式</a></li><li><a href="#信息传输-序列化和队列化的系统">信息传输, 序列化, 和队列化的系统</a></li><li><a href="#快速傅里叶变换">快速傅里叶变换</a></li><li><a href="#布隆过滤器">布隆过滤器</a></li><li><a href="#van-emde-boas-树">van Emde Boas 树</a></li><li><a href="#更深入的数据结构">更深入的数据结构</a></li><li><a href="#跳表">跳表</a></li><li><a href="#网络流">网络流</a></li><li><a href="#不相交集--联合查找">不相交集 &amp; 联合查找</a></li><li><a href="#math-for-fast-processing">快速处理数学</a></li><li><a href="#树堆-treap">树堆 (Treap)</a></li><li><a href="#线性规划linear-programming视频">线性规划</a></li><li><a href="#几何凸包geometry-convex-hull视频">几何：凸包（Geometry, Convex hull）</a></li><li><a href="#离散数学">离散数学</a></li><li><a href="#机器学习machine-learning">机器学习</a></li><li><a href="#go-语言">Go 语言</a></li></ul></li><li><a href="#一些主题的额外内容">一些主题的额外内容</a></li><li><a href="#视频系列">视频系列</a></li><li><a href="#计算机科学课程">计算机科学课程</a></li></ul><hr><h2 id="为何要用到它？"><a href="#为何要用到它？" class="headerlink" title="为何要用到它？"></a>为何要用到它？</h2><p>我一直都是遵循该计划去准备 Google 的面试。自 1997 年以来，我一直从事于 web 程序的构建、服务器的构建及创业型公司的创办。对于只有着一个经济学学位，而不是计算机科学学位（CS degree）的我来说，在职业生涯中所取得的都非常成功。然而，我想在 Google 工作，并进入大型系统中，真正地去理解计算机系统、算法效率、数据结构性能、低级别编程语言及其工作原理。可一项都不了解的我，怎么会被 Google 所应聘呢？</p><p>当我创建该项目时，我从一个堆栈到一个堆都不了解。那时的我，完全不了解 Big-O 、树，或如何去遍历一个图。如果非要我去编写一个排序算法的话，我只能说我所写的肯定是很糟糕。一直以来，我所用的任何数据结构都是内建于编程语言当中。至于它们在背后是如何运作，对此我一概不清楚。此外，以前的我并不需要对内存进行管理，最多就只是在一个正在执行的进程抛出了“内存不足”的错误后，采取一些权变措施。而在我的编程生活中，也甚少使用到多维数组，可关联数组却成千上万。而且，从一开始到现在，我都还未曾自己实现过数据结构。</p><p>就是这样的我，在经过该学习计划后，已然对被 Google 所雇佣充满信心。这是一个漫长的计划，以至于花费了我数月的时间。若您早已熟悉大部分的知识，那么也许能节省大量的时间。</p><h2 id="如何使用它"><a href="#如何使用它" class="headerlink" title="如何使用它"></a>如何使用它</h2><p>下面所有的东西都只是一个概述。因此，你需要由上而下逐一地去处理它。</p><p>在学习过程中，我是使用 GitHub 特殊的语法特性 markdown flavor 去检查计划的进展，包括使用任务列表。</p><ul><li style="list-style: none"><input type="checkbox" checked> 创建一个新的分支，以使得你可以像这样去检查计划的进展。直接往方括号中填写一个字符 x 即可：[x]</li></ul><p><a href="https://guides.github.com/features/mastering-markdown/#GitHub-flavored-markdown" target="_blank" rel="noopener">更多关于 Github-flavored markdown 的详情</a></p><h2 id="拥有一名-Googler-的心态"><a href="#拥有一名-Googler-的心态" class="headerlink" title="拥有一名 Googler 的心态"></a>拥有一名 Googler 的心态</h2><p>把一个（或两个）印有“<a href="https://github.com/jwasham/google-interview-university/blob/master/extras/future-googler.pdf" target="_blank" rel="noopener">future Googler</a>”的图案打印出来，并用你誓要成功的眼神盯着它。</p><p><a href="https://github.com/jwasham/google-interview-university/blob/master/extras/future-googler.pdf" target="_blank" rel="noopener"><img src="https://dng5l3qzreal6.cloudfront.net/2016/Oct/Screen_Shot_2016_10_04_at_10_13_24_AM-1475601104364.png" alt="future Googler sign"></a></p><h2 id="我得到了工作吗？"><a href="#我得到了工作吗？" class="headerlink" title="我得到了工作吗？"></a>我得到了工作吗？</h2><p>我还没去应聘。</p><p>因为我离完成学习（完成该疯狂的计划列表）还需要数天的时间，并打算在下周开始用一整天的时间，以编程的方式去解决问题。当然，这将会持续数周的时间。然后，我才通过使用在二月份所得到的一个介绍资格，去正式应聘 Google（没错，是二月份时就得到的）。</p><pre><code>感谢 JP 的这次介绍。</code></pre><h2 id="跟着我的脚步"><a href="#跟着我的脚步" class="headerlink" title="跟着我的脚步"></a>跟着我的脚步</h2><p>目前我仍在该计划的执行过程中，如果你想跟随我脚步去学习的话，可以登进我在 <a href="https://googleyasheck.com/" target="_blank" rel="noopener">GoogleyAsHeck.com</a> 上所写的博客。</p><p>下面是我的联系方式：</p><ul><li>Twitter: <a href="https://twitter.com/googleyasheck" target="_blank" rel="noopener">@googleyasheck</a></li><li>Twitter: <a href="https://twitter.com/StartupNextDoor" target="_blank" rel="noopener">@StartupNextDoor</a></li><li>Google+: <a href="https://plus.google.com/+Googleyasheck" target="_blank" rel="noopener">+Googleyasheck</a></li><li>LinkedIn: <a href="https://www.linkedin.com/in/johnawasham" target="_blank" rel="noopener">johnawasham</a></li></ul><p><img src="https://dng5l3qzreal6.cloudfront.net/2016/Aug/book_stack_photo_resized_18_1469302751157-1472661280368.png" alt="John Washam - Google Interview University"></p><h2 id="不要妄自菲薄"><a href="#不要妄自菲薄" class="headerlink" title="不要妄自菲薄"></a>不要妄自菲薄</h2><ul><li>Google 的工程师都是才智过人的。但是，就算是工作在 Google 的他们，仍然会因为觉得自己不够聪明而感到一种不安。</li><li><a href="https://www.youtube.com/watch?v=0SARbwvhupQ" target="_blank" rel="noopener">天才程序员的神话</a></li></ul><h2 id="关于-Google"><a href="#关于-Google" class="headerlink" title="关于 Google"></a>关于 Google</h2><ul><li style="list-style: none"><input type="checkbox"> 面向学生 —— <a href="https://www.google.com/about/careers/students/guide-to-technical-development.html" target="_blank" rel="noopener">Google 的职业生涯：技术开发指导</a></li><li style="list-style: none"><input type="checkbox"> Google 检索的原理：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=mTBShTwCnD4" target="_blank" rel="noopener">Google 检索的发展史（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.google.com/insidesearch/howsearchworks/thestory/" target="_blank" rel="noopener">Google 检索的原理 —— 故事篇</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.google.com/insidesearch/howsearchworks/" target="_blank" rel="noopener">Google 检索的原理</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=BNHR6IQJGZs" target="_blank" rel="noopener">Google 检索的原理 —— Matt Cutts（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=J5RZOU6vK4Q" target="_blank" rel="noopener">Google 是如何改善其检索算法（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 系列文章：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://backchannel.com/how-google-search-dealt-with-mobile-33bc09852dc9" target="_blank" rel="noopener">Google 检索是如何处理移动设备</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://backchannel.com/googles-secret-study-to-find-out-our-needs-eba8700263bf" target="_blank" rel="noopener">Google 为了寻找大众需求的秘密研究</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://backchannel.com/google-search-will-be-your-next-brain-5207c26e4523" target="_blank" rel="noopener">Google 检索将成为你的下一个大脑</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://backchannel.com/the-deep-mind-of-demis-hassabis-156112890d8a" target="_blank" rel="noopener">Demis Hassabis 的心灵直白</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.amazon.com/How-Google-Works-Eric-Schmidt/dp/1455582344" target="_blank" rel="noopener">书籍：Google 公司是如何运作的</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=q4y0KOeXViI" target="_blank" rel="noopener">由 Google 通告所制作 —— 2016年10月（视频）</a></li></ul><h2 id="相关视频资源"><a href="#相关视频资源" class="headerlink" title="相关视频资源"></a>相关视频资源</h2><p>部分视频只能通过在 Coursera、Edx 或 Lynda.com class 上注册登录才能观看。这些视频被称为网络公开课程（MOOC）。即便是免费观看，部分课程可能会由于不在时间段内而无法获取。因此，你需要多等待几个月。</p><pre><code>很感谢您能帮我把网络公开课程的视频链接转换成公开的视频源，以代替那些在线课程的视频。此外，一些大学的讲座视频也是我所青睐的。</code></pre><h2 id="面试过程-amp-通用的面试准备"><a href="#面试过程-amp-通用的面试准备" class="headerlink" title="面试过程 &amp; 通用的面试准备"></a>面试过程 &amp; 通用的面试准备</h2><ul><li><p>[ ] 视频：</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=oWbUtlUhwa8&amp;feature=youtu.be" target="_blank" rel="noopener">如何在 Google 工作 —— 考生指导课程（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=qc1owf2-220&amp;feature=youtu.be" target="_blank" rel="noopener">Google 招聘者所分享的技术面试小窍门（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=8npJLXkcmu8" target="_blank" rel="noopener">如何在 Google 工作：技术型简历的准备（视频）</a></li></ul></li><li><p>[ ] 文章：</p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.google.com/about/careers/lifeatgoogle/hiringprocess/" target="_blank" rel="noopener">三步成为 Googler</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html" target="_blank" rel="noopener">得到在 Google 的工作机会</a><ul><li>所有他所提及的事情都列在了下面</li></ul></li><li style="list-style: none"><input type="checkbox"> <em>（早已过期）</em> <a href="http://dondodge.typepad.com/the_next_big_thing/2010/09/how-to-get-a-job-at-google-interview-questions-hiring-process.html" target="_blank" rel="noopener">如何得到 Google 的一份工作，面试题，应聘过程</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://sites.google.com/site/steveyegge2/five-essential-phone-screen-questions" target="_blank" rel="noopener">电话面试的问题</a></li></ul></li><li><p>[ ] 附加的（虽然 Google 不建议，但我还是添加在此）：</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://medium.com/always-be-coding/abc-always-be-coding-d5f8051afce2#.4heg8zvm4" target="_blank" rel="noopener">ABC：永远都要去编程（Always Be Coding）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://medium.com/always-be-coding/four-steps-to-google-without-a-degree-8f381aa6bd5e#.asalo1vfx" target="_blank" rel="noopener">四步成为 Google 里一名没有学位的员工</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://medium.com/@dpup/whiteboarding-4df873dbba2e#.hf6jn45g1" target="_blank" rel="noopener">共享白板（Whiteboarding）</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.kpcb.com/blog/lessons-learned-how-google-thinks-about-hiring-management-and-culture" target="_blank" rel="noopener">Google 是如何看待应聘、管理和公司文化</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.coderust.com/blog/2014/04/10/effective-whiteboarding-during-programming-interviews/" target="_blank" rel="noopener">程序开发面试中有效的白板（Whiteboarding）</a></li><li style="list-style: none"><input type="checkbox"> 震撼开发类面试 第一集：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=rEJzOhC5ZtQ" target="_blank" rel="noopener">Gayle L McDowell —— 震撼开发类面试（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=aClxtDcdpsQ" target="_blank" rel="noopener">震撼开发类面试 —— 作者 Gayle Laakmann McDowell（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 如何在世界四强企业中获得一份工作：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=YJZCUhxNCv8" target="_blank" rel="noopener">“如何在世界四强企业中获得一份工作 —— Amazon、Facebook、Google 和 Microsoft”（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://alexbowe.com/failing-at-google-interviews/" target="_blank" rel="noopener">面试 Google 失败</a></li></ul></li></ul><h2 id="为你的面试选择一种语言"><a href="#为你的面试选择一种语言" class="headerlink" title="为你的面试选择一种语言"></a>为你的面试选择一种语言</h2><p>在这，我就以下话题写一篇短文 —— <a href="https://googleyasheck.com/important-pick-one-language-for-the-google-interview/" target="_blank" rel="noopener">重点：为在 Google 的面试选择一种语言</a></p><p>在大多数公司的面试当中，你可以在编程这一环节，使用一种自己用起来较为舒适的语言去完成编程。但在 Google，你只有三种固定的选择：</p><ul><li>C++</li><li>Java</li><li>Python</li></ul><p>有时你也可以使用下面两种，但需要事先查阅说明。因为，说明中会有警告：</p><ul><li>JavaScript</li><li>Ruby</li></ul><p>你需要对你所选择的语言感到非常舒适且足够了解。</p><p>更多关于语言选择的阅读：</p><ul><li><a href="http://www.byte-by-byte.com/choose-the-right-language-for-your-coding-interview/" target="_blank" rel="noopener">http://www.byte-by-byte.com/choose-the-right-language-for-your-coding-interview/</a></li><li><a href="http://blog.codingforinterviews.com/best-programming-language-jobs/" target="_blank" rel="noopener">http://blog.codingforinterviews.com/best-programming-language-jobs/</a></li><li><a href="https://www.quora.com/What-is-the-best-language-to-program-in-for-an-in-person-Google-interview" target="_blank" rel="noopener">https://www.quora.com/What-is-the-best-language-to-program-in-for-an-in-person-Google-interview</a></li></ul><p><a href="../programming-language-resources.md">在此查看相关语言的资源</a></p><p>由于，我正在学习C、C++ 和 Python。因此，在下面你会看到部分关于它们的学习资料。相关书籍请看文章的底部。</p><h2 id="在你开始之前"><a href="#在你开始之前" class="headerlink" title="在你开始之前"></a>在你开始之前</h2><p>该列表已经持续更新了很长的一段时间，所以，我们的确很容易会对其失去控制。</p><p>这里列出了一些我所犯过的错误，希望您不要重滔覆辙。</p><h3 id="1-你不可能把所有的东西都记住"><a href="#1-你不可能把所有的东西都记住" class="headerlink" title="1. 你不可能把所有的东西都记住"></a>1. 你不可能把所有的东西都记住</h3><p>就算我查看了数小时的视频，并记录了大量的笔记。几个月后的我，仍然会忘却其中大部分的东西。所以，我翻阅了我的笔记，并将可回顾的东西制作成抽认卡（flashcard）（请往下看）</p><h3 id="2-使用抽认卡"><a href="#2-使用抽认卡" class="headerlink" title="2. 使用抽认卡"></a>2. 使用抽认卡</h3><p>为了解决善忘的问题，我制作了一些关于抽认卡的页面，用于添加两种抽认卡：正常的及带有代码的。每种卡都会有不同的格式设计。</p><p>而且，我还以移动设备为先去设计这些网页，以使得在任何地方的我，都能通过我的手机及平板去回顾知识。</p><p>你也可以免费制作属于你自己的抽认卡网站：</p><ul><li><a href="https://github.com/jwasham/computer-science-flash-cards" target="_blank" rel="noopener">抽认卡页面的代码仓库</a></li><li><a href="https://github.com/jwasham/computer-science-flash-cards/blob/master/cards-jwasham.db" target="_blank" rel="noopener">我的抽认卡数据库</a>：有一点需要记住的是，我做事有点过头，以至于把卡片都覆盖到所有的东西上。从汇编语言和 Python 的细枝末节，乃至到机器学习和统计都被覆盖到卡片上。而这种做法，对于 Google 的要求来说，却是多余。</li></ul><p><strong>在抽认卡上做笔记：</strong> 若你第一次发现你知道问题的答案时，先不要急着把其标注成“已懂”。你需要做的，是去查看一下是否有同样的抽认卡，并在你真正懂得如何解决问题之前，多问自己几次。重复地问答可帮助您深刻记住该知识点。</p><h3 id="3-回顾，回顾，回顾"><a href="#3-回顾，回顾，回顾" class="headerlink" title="3. 回顾，回顾，回顾"></a>3. 回顾，回顾，回顾</h3><p>我留有一组 ASCII 码表、OSI 堆栈、Big-O 记号及更多的小抄纸，以便在空余的时候可以学习。</p><p>每编程半个小时就要休息一下，并去回顾你的抽认卡。</p><h3 id="4-专注"><a href="#4-专注" class="headerlink" title="4. 专注"></a>4. 专注</h3><p>在学习的过程中，往往会有许多令人分心的事占据着我们宝贵的时间。因此，专注和集中注意力是非常困难的。</p><h2 id="你所看不到的"><a href="#你所看不到的" class="headerlink" title="你所看不到的"></a>你所看不到的</h2><p>由于，这个巨大的列表一开始是作为我个人从 Google 面试指导笔记所形成的一个事件处理列表。因此，有一些我熟悉且普遍的技术在此都未被谈及到：</p><ul><li>SQL</li><li>Javascript</li><li>HTML、CSS 和其他前端技术</li></ul><h2 id="日常计划"><a href="#日常计划" class="headerlink" title="日常计划"></a>日常计划</h2><p>部分问题可能会花费一天的时间去学习，而部分则会花费多天。当然，有些学习并不需要我们懂得如何实现。</p><p>因此，每一天我都会在下面所列出的列表中选择一项，并查看相关的视频。然后，使用以下的一种语言去实现：</p><pre><code>C —— 使用结构体和函数，该函数会接受一个结构体指针 * 及其他数据作为参数。C++ —— 不使用内建的数据类型。C++ —— 使用内建的数据类型，如使用 STL 的 std::list 来作为链表。Python ——  使用内建的数据类型（为了持续练习 Python），并编写一些测试去保证自己代码的正确性。有时，只需要使用断言函数 assert() 即可。此外，你也可以使用 Java 或其他语言。以上只是我的个人偏好而已。</code></pre><p>为何要在这些语言上分别实现一次？</p><pre><code>因为可以练习，练习，练习，直至我厌倦它，并完美地实现出来。（若有部分边缘条件没想到时，我会用书写的形式记录下来并去记忆）因为可以在纯原生的条件下工作（不需垃圾回收机制的帮助下，分配/释放内存（除了 Python））因为可以利用上内建的数据类型，以使得我拥有在现实中使用内建工具的经验（在生产环境中，我不会去实现自己的链表）</code></pre><p>就算我没有时间去每一项都这么做，但我也会尽我所能的。</p><p>在这里，你可以查看到我的代码：</p><ul><li><a href="https://github.com/jwasham/practice-c" target="_blank" rel="noopener">C</a></li><li><a href="https://github.com/jwasham/practice-cpp" target="_blank" rel="noopener">C++</a></li><li><a href="https://github.com/jwasham/practice-python" target="_blank" rel="noopener">Python</a></li></ul><p>你不需要记住每一个算法的内部原理。</p><p>在一个白板上写代码，而不要直接在计算机上编写。在测试完部分简单的输入后，到计算机上再测试一遍。</p><h2 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h2><ul><li><p>[ ] <strong>计算机是如何处理一段程序：</strong></p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=42KTvGYQYnA" target="_blank" rel="noopener">CPU 是如何执行代码（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Mv2XQgpbTNE" target="_blank" rel="noopener">机器码指令（视频）</a></li></ul></li><li><p>[ ] <strong>编译器</strong></p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=IhC7sdYe-Jg" target="_blank" rel="noopener">编译器是如何在 ~1 分钟内工作（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=CSZLNYF4Klo" target="_blank" rel="noopener">Hardvard CS50 —— 编译器（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=twodd1KFfGk" target="_blank" rel="noopener">C++（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=FnGCDLhaxKU" target="_blank" rel="noopener">掌握编译器的优化（C++）（视频）</a></li></ul></li><li><p>[ ] <strong>浮点数是如何存储的：</strong></p><ul><li style="list-style: none"><input type="checkbox"> 简单的 8-bit：<a href="https://www.youtube.com/watch?v=ji3SfClm8TU" target="_blank" rel="noopener">浮点数的表达形式　—— 1（视频 —— 在计算上有一个错误 —— 详情请查看视频的介绍）</a></li><li style="list-style: none"><input type="checkbox"> 32 bit：<a href="https://www.youtube.com/watch?v=50ZYcZebIec" target="_blank" rel="noopener">IEEE754 32-bit 浮点二进制（视频）</a></li></ul></li></ul><h2 id="算法复杂度-Big-O-渐进分析法"><a href="#算法复杂度-Big-O-渐进分析法" class="headerlink" title="算法复杂度 / Big-O / 渐进分析法"></a>算法复杂度 / Big-O / 渐进分析法</h2><ul><li>并不需要实现</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=iOq5kSKqeR4" target="_blank" rel="noopener">Harvard CS50 —— 渐进表示（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=V6mKVRU1evU" target="_blank" rel="noopener">Big O 记号（通用快速教程）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ei-A_wy5Yxw&amp;index=2&amp;list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN" target="_blank" rel="noopener">Big O 记号（以及 Omega 和 Theta）——  最佳数学解释（视频）</a></li><li style="list-style: none"><input type="checkbox"> Skiena 算法：<ul><li><a href="https://www.youtube.com/watch?v=gSyDMtdPNpU&amp;index=2&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">视频</a></li><li><a href="http://www3.cs.stonybrook.edu/~algorith/video-lectures/2007/lecture2.pdf" target="_blank" rel="noopener">幻灯片</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://discrete.gr/complexity/" target="_blank" rel="noopener">对于算法复杂度分析的一次详细介绍</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://class.coursera.org/algorithmicthink1-004/lecture/59" target="_blank" rel="noopener">增长阶数（Orders of Growth）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://class.coursera.org/algorithmicthink1-004/lecture/61" target="_blank" rel="noopener">渐进性（Asymptotics）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/VIS4YDpuP98" target="_blank" rel="noopener">UC Berkeley Big O（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/ca3e7UVmeUc" target="_blank" rel="noopener">UC Berkeley Big Omega（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=B3SpQZaAZP4&amp;index=10&amp;list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN" target="_blank" rel="noopener">平摊分析法（Amortized Analysis）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://class.coursera.org/algorithmicthink1-004/lecture/63" target="_blank" rel="noopener">举证“Big O”（视频）</a></li><li style="list-style: none"><input type="checkbox"> 高级编程（包括递归关系和主定理）：<ul><li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-1/" target="_blank" rel="noopener">计算性复杂度：第一部</a></li><li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-2/" target="_blank" rel="noopener">计算性复杂度：第二部</a></li></ul></li><li><p>[ ] <a href="http://bigocheatsheet.com/" target="_blank" rel="noopener">速查表（Cheat sheet）</a></p><p>  如果部分课程过于学术性，你可直接跳到文章底部，去查看离散数学的视频以获取相关背景知识。</p></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li><h3 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h3><ul><li>实现一个可自动调整大小的动态数组。</li><li style="list-style: none"><input type="checkbox"> 介绍：<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/OsBSF/arrays" target="_blank" rel="noopener">数组（视频）</a></li><li><a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Basic-arrays/149042/177104-4.html" target="_blank" rel="noopener">数组的基础知识（视频）</a></li><li><a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Multidimensional-arrays/149042/177105-4.html" target="_blank" rel="noopener">多维数组（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/EwbnV/dynamic-arrays" target="_blank" rel="noopener">动态数组（视频）</a></li><li><a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Jagged-arrays/149042/177106-4.html" target="_blank" rel="noopener">不规则数组（视频）</a></li><li><a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Resizable-arrays/149042/177108-4.html" target="_blank" rel="noopener">调整数组的大小（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 实现一个动态数组（可自动调整大小的可变数组）：<ul><li style="list-style: none"><input type="checkbox"> 练习使用数组和指针去编码，并且指针是通过计算去跳转而不是使用索引</li><li style="list-style: none"><input type="checkbox"> 通过分配内存来新建一个原生数据型数组<ul><li>可以使用 int 类型的数组，但不能使用其语法特性</li><li>从大小为16或更大的数（使用2的倍数 —— 16、32、64、128）开始编写</li></ul></li><li style="list-style: none"><input type="checkbox"> size() —— 数组元素的个数</li><li style="list-style: none"><input type="checkbox"> capacity() —— 可容纳元素的个数</li><li style="list-style: none"><input type="checkbox"> is_empty()</li><li style="list-style: none"><input type="checkbox"> at(index) —— 返回对应索引的元素，且若索引越界则愤然报错</li><li style="list-style: none"><input type="checkbox"> push(item)</li><li style="list-style: none"><input type="checkbox"> insert(index, item) —— 在指定索引中插入元素，并把后面的元素依次后移</li><li style="list-style: none"><input type="checkbox"> prepend(item) —— 可以使用上面的 insert 函数，传参 index 为 0</li><li style="list-style: none"><input type="checkbox"> pop() —— 删除在数组末端的元素，并返回其值</li><li style="list-style: none"><input type="checkbox"> delete(index) —— 删除指定索引的元素，并把后面的元素依次前移</li><li style="list-style: none"><input type="checkbox"> remove(item) —— 删除指定值的元素，并返回其索引（即使有多个元素）</li><li style="list-style: none"><input type="checkbox"> find(item) —— 寻找指定值的元素并返回其中第一个出现的元素其索引，若未找到则返回 -1</li><li style="list-style: none"><input type="checkbox"> resize(new_capacity) // 私有函数<ul><li>若数组的大小到达其容积，则变大一倍</li><li>获取元素后，若数组大小为其容积的1/4，则缩小一半</li></ul></li></ul></li><li style="list-style: none"><input type="checkbox"> 时间复杂度<ul><li>在数组末端增加/删除、定位、更新元素，只允许占 O(1) 的时间复杂度（平摊（amortized）去分配内存以获取更多空间）</li><li>在数组任何地方插入/移除元素，只允许 O(n) 的时间复杂度</li></ul></li><li style="list-style: none"><input type="checkbox"> 空间复杂度<ul><li>因为在内存中分配的空间邻近，所以有助于提高性能</li><li>空间需求 = （大于或等于 n 的数组容积）* 元素的大小。即便空间需求为 2n，其空间复杂度仍然是 O(n)</li></ul></li></ul></li><li><h3 id="链表（Linked-Lists）"><a href="#链表（Linked-Lists）" class="headerlink" title="链表（Linked Lists）"></a>链表（Linked Lists）</h3><ul><li style="list-style: none"><input type="checkbox"> 介绍：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/kHhgK/singly-linked-lists" target="_blank" rel="noopener">单向链表（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=sJtJOtXCW_M&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=5" target="_blank" rel="noopener">CS 61B —— 链表（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=QN6FPiD0Gzo" target="_blank" rel="noopener">C 代码（视频）</a><ul><li>并非看完整个视频，只需要看关于节点结果和内存分配那一部分即可</li></ul></li><li style="list-style: none"><input type="checkbox"> 链表 vs 数组：<ul><li><a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/rjBs9/core-linked-lists-vs-arrays" target="_blank" rel="noopener">基本链表 Vs 数组（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/QUaUd/in-the-real-world-lists-vs-arrays" target="_blank" rel="noopener">在现实中，链表 Vs 数组（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=YQs6IC-vgmo" target="_blank" rel="noopener">为什么你需要避免使用链表（视频）</a></li><li style="list-style: none"><input type="checkbox"> 的确：你需要关于“指向指针的指针”的相关知识：（因为当你传递一个指针到一个函数时，该函数可能会改变指针所指向的地址）该页只是为了让你了解“指向指针的指针”这一概念。但我并不推荐这种链式遍历的风格。因为，这种风格的代码，其可读性和可维护性太低。<ul><li><a href="https://www.eskimo.com/~scs/cclass/int/sx8.html" target="_blank" rel="noopener">指向指针的指针</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 实现（我实现了使用尾指针以及没有使用尾指针这两种情况）：<ul><li style="list-style: none"><input type="checkbox"> size() —— 返回链表中数据元素的个数</li><li style="list-style: none"><input type="checkbox"> empty() —— 若链表为空则返回一个布尔值 true</li><li style="list-style: none"><input type="checkbox"> value_at(index) —— 返回第 n 个元素的值（从0开始计算）</li><li style="list-style: none"><input type="checkbox"> push_front(value) —— 添加元素到链表的首部</li><li style="list-style: none"><input type="checkbox"> pop_front() —— 删除首部元素并返回其值</li><li style="list-style: none"><input type="checkbox"> push_back(value) —— 添加元素到链表的尾部</li><li style="list-style: none"><input type="checkbox"> pop_back() —— 删除尾部元素并返回其值</li><li style="list-style: none"><input type="checkbox"> front() —— 返回首部元素的值</li><li style="list-style: none"><input type="checkbox"> back() —— 返回尾部元素的值</li><li style="list-style: none"><input type="checkbox"> insert(index, value) —— 插入值到指定的索引，并把当前索引的元素指向到新的元素</li><li style="list-style: none"><input type="checkbox"> erase(index) —— 删除指定索引的节点</li><li style="list-style: none"><input type="checkbox"> value_n_from_end(n) —— 返回倒数第 n 个节点的值</li><li style="list-style: none"><input type="checkbox"> reverse() —— 逆序链表</li><li style="list-style: none"><input type="checkbox"> remove_value(value) —— 删除链表中指定值的第一个元素</li></ul></li><li style="list-style: none"><input type="checkbox"> 双向链表<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/jpGKD/doubly-linked-lists" target="_blank" rel="noopener">介绍（视频）</a></li><li>并不需要实现</li></ul></li></ul></li><li><h3 id="堆栈（Stack）"><a href="#堆栈（Stack）" class="headerlink" title="堆栈（Stack）"></a>堆栈（Stack）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/UdKzQ/stacks" target="_blank" rel="noopener">堆栈（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Using-stacks-last-first-out/149042/177120-4.html" target="_blank" rel="noopener">使用堆栈 —— 后进先出（视频）</a></li><li style="list-style: none"><input type="checkbox"> 可以不实现，因为使用数组来实现并不重要</li></ul></li><li><h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Using-queues-first-first-out/149042/177122-4.html" target="_blank" rel="noopener">使用队列 —— 先进先出（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/EShpq/queue" target="_blank" rel="noopener">队列（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Circular_buffer" target="_blank" rel="noopener">原型队列/先进先出（FIFO）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Priority-queues-deques/149042/177123-4.html" target="_blank" rel="noopener">优先级队列（视频）</a></li><li style="list-style: none"><input type="checkbox"> 使用含有尾部指针的链表来实现:<ul><li>enqueue(value) —— 在尾部添加值</li><li>dequeue() —— 删除最早添加的元素并返回其值（首部元素）</li><li>empty()</li></ul></li><li style="list-style: none"><input type="checkbox"> 使用固定大小的数组实现：<ul><li>enqueue(value) —— 在可容的情况下添加元素到尾部</li><li>dequeue() —— 删除最早添加的元素并返回其值</li><li>empty()</li><li>full()</li></ul></li><li style="list-style: none"><input type="checkbox"> 花销：<ul><li>在糟糕的实现情况下，使用链表所实现的队列，其入列和出列的时间复杂度将会是 O(n)。因为，你需要找到下一个元素，以致循环整个队列</li><li>enqueue：O(1)（平摊（amortized）、链表和数组 [探测（probing）]）</li><li>dequeue：O(1)（链表和数组）</li><li>empty：O(1)（链表和数组）</li></ul></li></ul></li><li><h3 id="哈希表（Hash-table）"><a href="#哈希表（Hash-table）" class="headerlink" title="哈希表（Hash table）"></a>哈希表（Hash table）</h3><ul><li><p>[ ] 视频：</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=0M_kIqhwbFo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=8" target="_blank" rel="noopener">链式哈希表（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=BRO7mVIFt08&amp;index=9&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">Table Doubling 和 Karp-Rabin（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=rvdJDijO2Ro&amp;index=10&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">Open Addressing 和密码型哈希（Cryptographic Hashing）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=C4Kc8xzcA68" target="_blank" rel="noopener">PyCon 2010：The Mighty Dictionary（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=z0lJ2k0sl1g&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=11" target="_blank" rel="noopener">（进阶）随机取样（Randomization）：全域哈希（Universal Hashing）&amp; 完美哈希（Perfect Hashing）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=N0COwN14gt0&amp;list=PL2B4EEwhKD-NbwZ4ezj7gyc_3yNrojKM9&amp;index=4" target="_blank" rel="noopener">（进阶）完美哈希（Perfect hashing）（视频）</a></li></ul></li><li><p>[ ] 在线课程：</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Understanding-hash-functions/149042/177126-4.html" target="_blank" rel="noopener">哈希函数的掌握（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Using-hash-tables/149042/177127-4.html" target="_blank" rel="noopener">使用哈希表（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Supporting-hashing/149042/177128-4.html" target="_blank" rel="noopener">哈希表的支持（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Language-support-hash-tables/149042/177129-4.html" target="_blank" rel="noopener">哈希表的语言支持（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/m7UuP/core-hash-tables" target="_blank" rel="noopener">基本哈希表（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/home/week/3" target="_blank" rel="noopener">数据结构（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/NYZZP/phone-book-problem" target="_blank" rel="noopener">电话薄问题（Phone Book Problem）（视频）</a></li><li style="list-style: none"><input type="checkbox"> 分布式哈希表：<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/DvaIb/instant-uploads-and-storage-optimization-in-dropbox" target="_blank" rel="noopener">Dropbox 中的瞬时上传及存储优化（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/tvH8H/distributed-hash-tables" target="_blank" rel="noopener">分布式哈希表（视频）</a></li></ul></li></ul></li><li><p>[ ] 使用线性探测的数组去实现</p><ul><li>hash(k, m) —— m 是哈希表的大小</li><li>add(key, value) —— 如果 key 已存在则更新值</li><li>exists(key)</li><li>get(key)</li><li>remove(key)</li></ul></li></ul></li></ul><h2 id="更多的知识"><a href="#更多的知识" class="headerlink" title="更多的知识"></a>更多的知识</h2><ul><li><h3 id="二分查找（Binary-search）"><a href="#二分查找（Binary-search）" class="headerlink" title="二分查找（Binary search）"></a>二分查找（Binary search）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=D5SrAga1pno" target="_blank" rel="noopener">二分查找（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search" target="_blank" rel="noopener">二分查找（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/binary-search/" target="_blank" rel="noopener">详情</a></li><li style="list-style: none"><input type="checkbox"> 实现：<ul><li>二分查找（在一个已排序好的整型数组中查找）</li><li>迭代式二分查找</li></ul></li></ul></li><li><h3 id="按位运算（Bitwise-operations）"><a href="#按位运算（Bitwise-operations）" class="headerlink" title="按位运算（Bitwise operations）"></a>按位运算（Bitwise operations）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://github.com/jwasham/google-interview-university/blob/master/extras/cheat%20sheets/bits-cheat-cheet.pdf" target="_blank" rel="noopener">Bits 速查表</a><ul><li>你需要知道大量2的幂数值（从2^1 到 2^16 及 2^32）</li></ul></li><li style="list-style: none"><input type="checkbox"> 好好理解位操作符的含义：&amp;、|、^、~、&gt;&gt;、&lt;&lt;<ul><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Word_(computer_architecture" target="_blank" rel="noopener">字码（words）</a>)</li><li style="list-style: none"><input type="checkbox"> 好的介绍：<br>  <a href="https://www.youtube.com/watch?v=7jkIUgLC29I" target="_blank" rel="noopener">位操作（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=d0AwjSpNXR0" target="_blank" rel="noopener">C 语言编程教程 2-10：按位运算（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Bit_manipulation" target="_blank" rel="noopener">位操作</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Bitwise_operation" target="_blank" rel="noopener">按位运算</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://graphics.stanford.edu/~seander/bithacks.html" target="_blank" rel="noopener">Bithacks</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://bits.stephan-brumme.com/" target="_blank" rel="noopener">位元抚弄者（The Bit Twiddler）</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://bits.stephan-brumme.com/interactive.html" target="_blank" rel="noopener">交互式位元抚弄者（The Bit Twiddler Interactive）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 一补数和补码<ul><li><a href="https://www.youtube.com/watch?v=lKTsv6iVxV4" target="_blank" rel="noopener">二进制：利 &amp; 弊（为什么我们要使用补码）（视频）</a></li><li><a href="https://en.wikipedia.org/wiki/Ones%27_complement" target="_blank" rel="noopener">一补数（1s Complement）</a></li><li><a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank" rel="noopener">补码（2s Complement）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 计算置位（Set Bits）<ul><li><a href="https://youtu.be/Hzuzo9NJrlc" target="_blank" rel="noopener">计算一个字节中置位（Set Bits）的四种方式（视频）</a></li><li><a href="https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan" target="_blank" rel="noopener">计算比特位</a></li><li><a href="http://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer" target="_blank" rel="noopener">如何在一个 32 位的整型中计算置位（Set Bits）的数量</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 四舍五入2的幂数：<ul><li><a href="http://bits.stephan-brumme.com/roundUpToNextPowerOfTwo.html" target="_blank" rel="noopener">四舍五入到2的下一幂数</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 交换值：<ul><li><a href="http://bits.stephan-brumme.com/swap.html" target="_blank" rel="noopener">交换（Swap）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 绝对值：<ul><li><a href="http://bits.stephan-brumme.com/absInteger.html" target="_blank" rel="noopener">绝对整型（Absolute Integer）</a></li></ul></li></ul></li></ul><h2 id="树（Trees）"><a href="#树（Trees）" class="headerlink" title="树（Trees）"></a>树（Trees）</h2><ul><li><h3 id="树-——-笔记-amp-背景"><a href="#树-——-笔记-amp-背景" class="headerlink" title="树 —— 笔记 &amp; 背景"></a>树 —— 笔记 &amp; 背景</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/ovovP/core-trees" target="_blank" rel="noopener">系列：基本树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/95qda/trees" target="_blank" rel="noopener">系列：树（视频）</a></li><li>基本的树形结构</li><li>遍历</li><li>操作算法</li><li>BFS（广度优先检索，breadth-first search）<ul><li><a href="https://www.youtube.com/watch?v=s-CYnVz-uh4&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=13" target="_blank" rel="noopener">MIT（视频）</a></li><li>层序遍历（使用队列的 BFS 算法）<ul><li>时间复杂度： O(n)</li><li>空间复杂度：<ul><li>最好情况： O(1)</li><li>最坏情况：O(n/2)=O(n)</li></ul></li></ul></li></ul></li><li>DFS（深度优先检索，depth-first search）<ul><li><a href="https://www.youtube.com/watch?v=AfSk24UTFS8&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=14" target="_blank" rel="noopener">MIT（视频）</a></li><li>笔记：<ul><li>时间复杂度：O(n)</li><li>空间复杂度：<ul><li>最好情况：O(log n) - 树的平均高度</li><li>最坏情况：O(n)</li></ul></li></ul></li><li>中序遍历（DFS：左、节点本身、右）</li><li>后序遍历（DFS：左、右、节点本身）</li><li>先序遍历（DFS：节点本身、左、右）</li></ul></li></ul></li><li><h3 id="二叉查找树（Binary-search-trees）：BSTs"><a href="#二叉查找树（Binary-search-trees）：BSTs" class="headerlink" title="二叉查找树（Binary search trees）：BSTs"></a>二叉查找树（Binary search trees）：BSTs</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=x6At0nzX92o&amp;index=1&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="noopener">二叉查找树概览（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/p82sw/core-introduction-to-binary-search-trees" target="_blank" rel="noopener">系列（视频）</a><ul><li>从符号表开始到 BST 程序</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/E7cXP/introduction" target="_blank" rel="noopener">介绍（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=9Jry5-82I68" target="_blank" rel="noopener">MIT（视频）</a></li><li>C/C++:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=COZK7NATh4k&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=28" target="_blank" rel="noopener">二叉查找树 —— 在 C/C++ 中实现（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=hWokyBoo0aI&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=29" target="_blank" rel="noopener">BST 的实现 —— 在堆栈和堆中的内存分配（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Ut90klNN264&amp;index=30&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="noopener">在二叉查找树中找到最小和最大的元素（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=_pnqMz5nrRs&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=31" target="_blank" rel="noopener">寻找二叉树的高度（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=9RHO6jU--GU&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=32" target="_blank" rel="noopener">二叉树的遍历 —— 广度优先和深度优先策略（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=86g8jAQug04&amp;index=33&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="noopener">二叉树：层序遍历（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=gm8DUJJhmY4&amp;index=34&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="noopener">二叉树的遍历：先序、中序、后序（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=yEwSGhSsT0U&amp;index=35&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="noopener">判断一棵二叉树是否为二叉查找树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=gcULXE7ViZw&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=36" target="_blank" rel="noopener">从二叉查找树中删除一个节点（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=5cPbNCrdotA&amp;index=37&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="noopener">二叉查找树中序遍历的后继者（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 实现：<ul><li style="list-style: none"><input type="checkbox"> insert    // 往树上插值</li><li style="list-style: none"><input type="checkbox"> get_node_count // 查找树上的节点数</li><li style="list-style: none"><input type="checkbox"> print_values // 从小到大打印树中节点的值</li><li style="list-style: none"><input type="checkbox"> delete_tree</li><li style="list-style: none"><input type="checkbox"> is_in_tree // 如果值存在于树中则返回 true</li><li style="list-style: none"><input type="checkbox"> get_height // 返回节点所在的高度（如果只有一个节点，那么高度则为1）</li><li style="list-style: none"><input type="checkbox"> get_min   // 返回树上的最小值</li><li style="list-style: none"><input type="checkbox"> get_max   // 返回树上的最大值</li><li style="list-style: none"><input type="checkbox"> is_binary_search_tree</li><li style="list-style: none"><input type="checkbox"> delete_value</li><li style="list-style: none"><input type="checkbox"> get_successor // 返回给定值的后继者，若没有则返回-1</li></ul></li></ul></li><li><h3 id="堆（Heap）-优先级队列（Priority-Queue）-二叉堆（Binary-Heap）"><a href="#堆（Heap）-优先级队列（Priority-Queue）-二叉堆（Binary-Heap）" class="headerlink" title="堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）"></a>堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）</h3><ul><li>可视化是一棵树，但通常是以线性的形式存储（数组、链表）</li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Heap_(data_structure" target="_blank" rel="noopener">堆</a>)</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/2OpTs/introduction" target="_blank" rel="noopener">介绍（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/z3l9N/naive-implementations" target="_blank" rel="noopener">无知的实现（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/GRV2q/binary-trees" target="_blank" rel="noopener">二叉树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/supplement/S5xxz/tree-height-remark" target="_blank" rel="noopener">关于树高的讨论（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/0g1dl/basic-operations" target="_blank" rel="noopener">基本操作（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/gl5Ni/complete-binary-trees" target="_blank" rel="noopener">完全二叉树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/HxQo9/pseudocode" target="_blank" rel="noopener">伪代码（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/odNJmw5TOEE?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3291" target="_blank" rel="noopener">堆排序 —— 跳到起点（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/hSzMO/heap-sort" target="_blank" rel="noopener">堆排序（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/dwrOS/building-a-heap" target="_blank" rel="noopener">构建一个堆（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=B7hVxCmfPtM&amp;index=4&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">MIT：堆与堆排序（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=yIUFT6AKBGE&amp;index=24&amp;list=PL4BBB74C7D2A1049C" target="_blank" rel="noopener">CS 61B Lecture 24：优先级队列（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=MiyLo8adrWw" target="_blank" rel="noopener">构建线性时间复杂度的堆（大顶堆）</a></li><li style="list-style: none"><input type="checkbox"> 实现一个大顶堆：<ul><li style="list-style: none"><input type="checkbox"> insert</li><li style="list-style: none"><input type="checkbox"> sift_up —— 用于插入元素</li><li style="list-style: none"><input type="checkbox"> get_max —— 返回最大值但不移除元素</li><li style="list-style: none"><input type="checkbox"> get_size() —— 返回存储的元素数量</li><li style="list-style: none"><input type="checkbox"> is_empty() —— 若堆为空则返回 true</li><li style="list-style: none"><input type="checkbox"> extract_max —— 返回最大值并移除</li><li style="list-style: none"><input type="checkbox"> sift_down —— 用于获取最大值元素</li><li style="list-style: none"><input type="checkbox"> remove(i) —— 删除指定索引的元素</li><li style="list-style: none"><input type="checkbox"> heapify —— 构建堆，用于堆排序</li><li style="list-style: none"><input type="checkbox"> heap_sort() —— 拿到一个未排序的数组，然后使用大顶堆进行就地排序<ul><li>注意：若用小顶堆可节省操作，但导致空间复杂度加倍。（无法做到就地）</li></ul></li></ul></li></ul></li><li><h3 id="字典树（Tries）"><a href="#字典树（Tries）" class="headerlink" title="字典树（Tries）"></a>字典树（Tries）</h3><ul><li>需要注意的是，字典树各式各样。有些有前缀，而有些则没有。有些使用字符串而不使用比特位来追踪路径。</li><li>阅读代码，但不实现。</li><li style="list-style: none"><input type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Tries" target="_blank" rel="noopener">数据结构笔记及编程技术</a></li><li style="list-style: none"><input type="checkbox"> 短课程视频：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/08Xyf/core-introduction-to-tries" target="_blank" rel="noopener">对字典树的介绍（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/PvlZW/core-performance-of-tries" target="_blank" rel="noopener">字典树的性能（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/DFvd3/core-implementing-a-trie" target="_blank" rel="noopener">实现一棵字典树（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.toptal.com/java/the-trie-a-neglected-data-structure" target="_blank" rel="noopener">字典树：一个被忽略的数据结构</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/using-tries/" target="_blank" rel="noopener">高级编程 —— 使用字典树</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=TJ8SkcUSdbU" target="_blank" rel="noopener">标准教程（现实中的用例）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=NinWEPPrkDQ&amp;index=16&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf" target="_blank" rel="noopener">MIT，高阶数据结构，使用字符串追踪路径（可事半功倍）</a></li></ul></li><li><h3 id="平衡查找树（Balanced-search-trees）"><a href="#平衡查找树（Balanced-search-trees）" class="headerlink" title="平衡查找树（Balanced search trees）"></a>平衡查找树（Balanced search trees）</h3><ul><li>掌握至少一种平衡查找树（并懂得如何实现）：</li><li>“在各种平衡查找树当中，AVL 树和2-3树已经成为了过去，而红黑树（red-black trees）看似变得越来越受人青睐。这种令人特别感兴趣的数据结构，亦称伸展树（splay tree）。它可以自我管理，且会使用轮换来移除任何访问过根节点的 key。” —— Skiena</li><li>因此，在各种各样的平衡查找树当中，我选择了伸展树来实现。虽然，通过我的阅读，我发现在 Google 的面试中并不会被要求实现一棵平衡查找树。但是，为了胜人一筹，我们还是应该看看如何去实现。在阅读了大量关于红黑树的代码后，我才发现伸展树的实现确实会使得各方面更为高效。<ul><li>伸展树：插入、查找、删除函数的实现，而如果你最终实现了红黑树，那么请尝试一下：</li><li>跳过删除函数，直接实现搜索和插入功能</li></ul></li><li>我希望能阅读到更多关于 B 树的资料，因为它也被广泛地应用到大型的数据库当中。</li><li><p>[ ] <a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" target="_blank" rel="noopener">自平衡二叉查找树</a></p></li><li><p>[ ] <strong>AVL 树</strong></p><ul><li>实际中：我能告诉你的是，该种树并无太多的用途，但我能看到有用的地方在哪里：AVL 树是另一种平衡查找树结构。其可支持时间复杂度为 O(log n) 的查询、插入及删除。它比红黑树严格意义上更为平衡，从而导致插入和删除更慢，但遍历却更快。正因如此，才彰显其结构的魅力。只需要构建一次，就可以在不重新构造的情况下读取，适合于实现诸如语言字典（或程序字典，如一个汇编程序或解释程序的操作码）。</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=FNeL18KsWPc&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=6" target="_blank" rel="noopener">MIT AVL 树 / AVL 树的排序（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/Qq5E0/avl-trees" target="_blank" rel="noopener">AVL 树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/PKEBC/avl-tree-implementation" target="_blank" rel="noopener">AVL 树的实现（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/22BgE/split-and-merge" target="_blank" rel="noopener">分离与合并</a></li></ul></li><li><p>[ ] <strong>伸展树</strong></p><ul><li>实际中：伸展树一般用于缓存、内存分配者、路由器、垃圾回收者、数据压缩、ropes（字符串的一种替代品，用于存储长串的文本字符）、Windows NT（虚拟内存、网络及文件系统）等的实现。</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Najzh1rYQTo&amp;index=23&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd" target="_blank" rel="noopener">CS 61B：伸展树（Splay trees）（视频）</a></li><li style="list-style: none"><input type="checkbox"> MIT 教程：伸展树（Splay trees）：<ul><li>该教程会过于学术，但请观看到最后的10分钟以确保掌握。</li><li><a href="https://www.youtube.com/watch?v=QnPl_Y6EqMo" target="_blank" rel="noopener">视频</a></li></ul></li></ul></li><li><p>[ ] <strong>2-3查找树</strong></p><ul><li>实际中：2-3树的元素插入非常快速，但却有着查询慢的代价（因为相比较 AVL 树来说，其高度更高）。</li><li>你会很少用到2-3树。这是因为，其实现过程中涉及到不同类型的节点。因此，人们更多地会选择红黑树。</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=C3SsdUqasD4&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&amp;index=2" target="_blank" rel="noopener">2-3树的直感与定义（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=iYvBtGKsqSg&amp;index=3&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="noopener">2-3树的二元观点</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=TOb1tuEZ2X4&amp;index=5&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">2-3树（学生叙述）（视频）</a></li></ul></li><li><p>[ ] <strong>2-3-4树 (亦称2-4树)</strong></p><ul><li>实际中：对于每一棵2-4树，都有着对应的红黑树来存储同样顺序的数据元素。在2-4树上进行插入及删除操作等同于在红黑树上进行颜色翻转及轮换。这使得2-4树成为一种用于掌握红黑树背后逻辑的重要工具。这就是为什么许多算法引导文章都会在介绍红黑树之前，先介绍2-4树，尽管<strong>2-4树在实际中并不经常使用</strong>。</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=zqrqYXkth6Q&amp;index=26&amp;list=PL4BBB74C7D2A1049C" target="_blank" rel="noopener">CS 61B Lecture 26：平衡查找树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=DQdMYevEyE4&amp;index=4&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="noopener">自底向上的2-4树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2679VQ26Fp4&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&amp;index=5" target="_blank" rel="noopener">自顶向下的2-4树（视频）</a></li></ul></li><li><p>[ ] <strong>B 树</strong></p><ul><li>有趣的是：为啥叫 B 仍然是一个神秘。因为 B 可代表波音（Boeing）、平衡（Balanced）或 Bayer（联合创造者）</li><li>实际中：B 树会被广泛适用于数据库中，而现代大多数的文件系统都会使用到这种树（或变种)。除了运用在数据库中，B 树也会被用于文件系统以快速访问一个文件的任意块。但存在着一个基本的问题，那就是如何将文件块 i 转换成一个硬盘块（或一个柱面-磁头-扇区）上的地址。</li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener">B 树</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=I22wEC1tTGo&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&amp;index=6" target="_blank" rel="noopener">B 树的介绍（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=s3bCdZGrgpA&amp;index=7&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="noopener">B 树的定义及其插入操作（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=svfnVhJOfMc&amp;index=8&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="noopener">B 树的删除操作（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=V3omVLzI0WE&amp;index=7&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf" target="_blank" rel="noopener">MIT 6.851 —— 内存层次模块（Memory Hierarchy Models）（视频）</a><ul><li>覆盖有高速缓存参数无关型（cache-oblivious）B 树和非常有趣的数据结构</li><li>头37分钟讲述的很专业，或许可以跳过（B 指块的大小、即缓存行的大小）</li></ul></li></ul></li><li><p>[ ] <strong>红黑树</strong></p><ul><li>实际中：红黑树提供了在最坏情况下插入操作、删除操作和查找操作的时间保证。这些时间值的保障不仅对时间敏感型应用有用，例如实时应用，还对在其他数据结构中块的构建非常有用，而这些数据结构都提供了最坏情况下的保障；例如，许多用于计算几何学的数据结构都可以基于红黑树，而目前 Linux 系统所采用的完全公平调度器（the Completely Fair Scheduler）也使用到了该种树。在 Java 8中，红黑树也被用于存储哈希列表集合中相同的数据，而不是使用链表及哈希码。</li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/1W3x0f_RmUo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3871" target="_blank" rel="noopener">Aduni —— 算法 —— 课程4（该链接直接跳到开始部分）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=hm2GHwyKF1o&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=5" target="_blank" rel="noopener">Aduni —— 算法 —— 课程5（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree" target="_blank" rel="noopener">黑树（Black Tree）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/" target="_blank" rel="noopener">二分查找及红黑树的介绍</a></li></ul></li></ul></li><li><h3 id="N-叉树（K-叉树、M-叉树）"><a href="#N-叉树（K-叉树、M-叉树）" class="headerlink" title="N 叉树（K 叉树、M 叉树）"></a>N 叉树（K 叉树、M 叉树）</h3><ul><li>注意：N 或 K 指的是分支系数（即树的最大分支数）：<ul><li>二叉树是一种分支系数为2的树</li><li>2-3树是一种分支系数为3的树</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/K-ary_tree" target="_blank" rel="noopener">K 叉树</a></li></ul></li></ul><h2 id="排序（Sorting）"><a href="#排序（Sorting）" class="headerlink" title="排序（Sorting）"></a>排序（Sorting）</h2><ul><li><p>[ ] 笔记:</p><ul><li>实现各种排序 &amp; 知道每种排序的最坏、最好和平均的复杂度分别是什么场景:<ul><li>不要用冒泡排序 - 大多数情况下效率感人 - 时间复杂度 O(n^2), 除非 n &lt;= 16</li></ul></li><li style="list-style: none"><input type="checkbox"> 排序算法的稳定性 (“快排是稳定的么?”)<ul><li><a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability" target="_blank" rel="noopener">排序算法的稳定性</a></li><li><a href="http://stackoverflow.com/questions/1517793/stability-in-sorting-algorithms" target="_blank" rel="noopener">排序算法的稳定性</a></li><li><a href="http://stackoverflow.com/questions/1517793/stability-in-sorting-algorithms" target="_blank" rel="noopener">排序算法的稳定性</a></li><li><a href="http://www.geeksforgeeks.org/stability-in-sorting-algorithms/" target="_blank" rel="noopener">排序算法的稳定性</a></li><li><a href="http://homepages.math.uic.edu/~leon/cs-mcs401-s08/handouts/stability.pdf" target="_blank" rel="noopener">排序算法 - 稳定性</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 哪种排序算法可以用链表？哪种用数组？哪种两者都可？<ul><li>并不推荐对一个链表排序，但归并排序是可行的.</li><li><a href="http://www.geeksforgeeks.org/merge-sort-for-linked-list/" target="_blank" rel="noopener">链表的归并排序</a></li></ul></li></ul></li><li><p>关于堆排序，请查看前文堆的数据结构部分。堆排序很强大，不过是非稳定排序。</p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=P00xJgWzz2c&amp;index=1&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">冒泡排序 (video)</a></p></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ni_zk257Nqo&amp;index=7&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">冒泡排序分析 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Kg4bqzAqRBM&amp;index=3&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">插入排序 &amp; 归并排序 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=c4BRHC7kTaQ&amp;index=2&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">插入排序 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=GCae1WNvnZM&amp;index=3&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">归并排序 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=y_G9BkAm6B8&amp;index=4&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">快排 (video)</a></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=6nDMgr0-Yyo&amp;index=8&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">选择排序 (video)</a></p></li><li><p>[ ] 斯坦福大学关于排序算法的视频:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ENp00xylP7c&amp;index=15&amp;list=PLFE6E58F856038C69" target="_blank" rel="noopener">课程 15 | 编程抽象 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=y4M9IVgrVKo&amp;index=16&amp;list=PLFE6E58F856038C69" target="_blank" rel="noopener">课程 16 | 编程抽象 (video)</a></li></ul></li><li><p>[ ] Shai Simonson 视频, <a href="http://www.aduni.org/" target="_blank" rel="noopener">Aduni.org</a>:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=odNJmw5TOEE&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=2" target="_blank" rel="noopener">算法 - 排序 - 第二讲 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=hj8YKFTFKEE&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=3" target="_blank" rel="noopener">算法 - 排序2 - 第三讲 (video)</a></li></ul></li><li><p>[ ] Steven Skiena 关于排序的视频:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/ute-pmMkyuk?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=1600" target="_blank" rel="noopener">课程从 26:46 开始 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=yLvp-pB8mak&amp;index=8&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">课程从 27:40 开始 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=q7K9otnzlfE&amp;index=9&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">课程从 35:00 开始 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=TvqIGu9Iupw&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=10" target="_blank" rel="noopener">课程从 23:50 开始 (video)</a></li></ul></li><li><p>[ ] 加州大学伯克利分校（UC Berkeley） 大学课程:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=EiUvYS2DT6I&amp;list=PL4BBB74C7D2A1049C&amp;index=29" target="_blank" rel="noopener">CS 61B 课程 29: 排序 I (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2hTY3t80Qsk&amp;list=PL4BBB74C7D2A1049C&amp;index=30" target="_blank" rel="noopener">CS 61B 课程 30: 排序 II (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Y6LOLpxg6Dc&amp;index=32&amp;list=PL4BBB74C7D2A1049C" target="_blank" rel="noopener">CS 61B 课程 32: 排序 III (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=qNMQ4ly43p4&amp;index=33&amp;list=PL4BBB74C7D2A1049C" target="_blank" rel="noopener">CS 61B 课程 33: 排序 V (video)</a></li></ul></li><li><p>[ ] - 归并排序:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/examples/sorting/mergesort.c" target="_blank" rel="noopener">使用外部数组</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://github.com/jwasham/practice-cpp/blob/master/merge_sort/merge_sort.cc" target="_blank" rel="noopener">对原数组直接排序</a></li></ul></li><li><p>[ ] - 快速排序:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/examples/randomization/quick.c" target="_blank" rel="noopener">实现</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://github.com/jwasham/practice-c/blob/master/quick_sort/quick_sort.c" target="_blank" rel="noopener">实现</a></li></ul></li><li><p>[ ] 实现:</p><ul><li style="list-style: none"><input type="checkbox"> 归并：平均和最差情况的时间复杂度为 O(n log n)。</li><li style="list-style: none"><input type="checkbox"> 快排：平均时间复杂度为 O(n log n)。</li><li>选择排序和插入排序的最坏、平均时间复杂度都是 O(n^2)。</li><li>关于堆排序，请查看前文堆的数据结构部分。</li></ul></li><li><p>[ ] 有兴趣的话，还有一些补充 - 但并不是必须的:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#radixSort" target="_blank" rel="noopener">基数排序</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=xhr26ia4k38" target="_blank" rel="noopener">基数排序 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Nz1KZXbghj8&amp;index=7&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">基数排序, 计数排序 (线性时间内) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=cNB2lADK3_s&amp;index=8&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">随机算法: 矩阵相乘, 快排, Freivalds’ 算法 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=pOKy3RZbSws&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&amp;index=14" target="_blank" rel="noopener">线性时间内的排序 (video)</a></li></ul></li></ul><h2 id="图（Graphs）"><a href="#图（Graphs）" class="headerlink" title="图（Graphs）"></a>图（Graphs）</h2><p>图论能解决计算机科学里的很多问题，所以这一节会比较长，像树和排序的部分一样。</p><ul><li><p>Yegge 的笔记:</p><ul><li>有 3 种基本方式在内存里表示一个图:<ul><li>对象和指针</li><li>矩阵</li><li>邻接表</li></ul></li><li>熟悉以上每一种图的表示法，并了解各自的优缺点</li><li>宽度优先搜索和深度优先搜索 - 知道它们的计算复杂度和设计上的权衡以及如何用代码实现它们</li><li>遇到一个问题时，首先尝试基于图的解决方案，如果没有再去尝试其他的。</li></ul></li><li><p>[ ] Skiena 教授的课程 - 很不错的介绍:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=OiXxhDrFruw&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=11" target="_blank" rel="noopener">CSE373 2012 - 课程 11 - 图的数据结构 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=g5vF8jscteo&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=12" target="_blank" rel="noopener">CSE373 2012 - 课程 12 - 广度优先搜索 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=S23W6eTcqdY&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=13" target="_blank" rel="noopener">CSE373 2012 - 课程 13 - 图的算法 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=WitPBKGV0HY&amp;index=14&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">CSE373 2012 - 课程 14 - 图的算法 (1) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ia1L30l7OIg&amp;index=15&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">CSE373 2012 - 课程 15 - 图的算法 (2) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=jgDOQq6iWy8&amp;index=16&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">CSE373 2012 - 课程 16 - 图的算法 (3) (video)</a></li></ul></li><li><p>[ ] 图 (复习和其他):</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Aa2sqUhIn-E&amp;index=15&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">6.006 单源最短路径问题 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2E7MmKv0Y24&amp;index=16&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">6.006 Dijkstra 算法 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ozsuci5pIso&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=17" target="_blank" rel="noopener">6.006 Bellman-Ford 算法(video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=CHvQ3q_gJ7E&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=18" target="_blank" rel="noopener">6.006 Dijkstra 效率优化 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=i_AQT_XfvD8&amp;index=6&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="noopener">Aduni: 图的算法 I - 拓扑排序, 最小生成树, Prim 算法 -  第六课 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ufj5_bppBsA&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=7" target="_blank" rel="noopener">Aduni: 图的算法 II - 深度优先搜索, 广度优先搜索, Kruskal 算法, 并查集数据结构 - 第七课 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=DiedsPsMKXc&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=8" target="_blank" rel="noopener">Aduni: 图的算法 III: 最短路径 - 第八课 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=XIAQRlNkJAw&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=9" target="_blank" rel="noopener">Aduni: 图的算法. IV: 几何算法介绍 - 第九课 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/dgjX4HdMI-Q?list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;t=3489" target="_blank" rel="noopener">CS 61B 2014 (从 58:09 开始) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=aJjlQCFwylA&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=19" target="_blank" rel="noopener">CS 61B 2014: 加权图 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=tKwnms5iRBU&amp;index=16&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">贪心算法: 最小生成树 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=RpgcYiky7uw" target="_blank" rel="noopener">图的算法之强连通分量 Kosaraju 算法 (video)</a></li></ul></li><li><p>完整的 Coursera 课程:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-on-graphs/home/welcome" target="_blank" rel="noopener">图的算法 (video)</a></li></ul></li><li><p>Yegge: 如果有机会，可以试试研究更酷炫的算法:</p><ul><li style="list-style: none"><input type="checkbox"> Dijkstra 算法 - 上文 - 6.006</li><li style="list-style: none"><input type="checkbox"> A* 算法<ul><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/A*_search_algorithm" target="_blank" rel="noopener">A* 算法</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=KNXfSOx4eEE" target="_blank" rel="noopener">A* 寻路教程 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=-L-WgKMFuhE" target="_blank" rel="noopener">A* 寻路 (E01: 算法解释) (video)</a></li></ul></li></ul></li><li><p>我会实现:</p><ul><li style="list-style: none"><input type="checkbox"> DFS 邻接表 (递归)</li><li style="list-style: none"><input type="checkbox"> DFS 邻接表 (栈迭代)</li><li style="list-style: none"><input type="checkbox"> DFS 邻接矩阵 (递归)</li><li style="list-style: none"><input type="checkbox"> DFS 邻接矩阵 (栈迭代)</li><li style="list-style: none"><input type="checkbox"> BFS 邻接表</li><li style="list-style: none"><input type="checkbox"> BFS 邻接矩阵</li><li style="list-style: none"><input type="checkbox"> 单源最短路径问题 (Dijkstra)</li><li style="list-style: none"><input type="checkbox"> 最小生成树</li><li>基于 DFS 的算法 (根据上文 Aduni 的视频):<ul><li style="list-style: none"><input type="checkbox"> 检查环 (我们会先检查是否有环存在以便做拓扑排序)</li><li style="list-style: none"><input type="checkbox"> 拓扑排序</li><li style="list-style: none"><input type="checkbox"> 计算图中的连通分支</li><li style="list-style: none"><input type="checkbox"> 列出强连通分量</li><li style="list-style: none"><input type="checkbox"> 检查双向图</li></ul></li></ul></li></ul><p>可以从 Skiena 的书（参考下面的书推荐小节）和面试书籍中学习更多关于图的实践。</p><h2 id="更多知识"><a href="#更多知识" class="headerlink" title="更多知识"></a>更多知识</h2><ul><li><h3 id="递归（Recursion）"><a href="#递归（Recursion）" class="headerlink" title="递归（Recursion）"></a>递归（Recursion）</h3><ul><li style="list-style: none"><input type="checkbox"> Stanford 大学关于递归 &amp; 回溯的课程:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=gl3emqCuueQ&amp;list=PLFE6E58F856038C69&amp;index=8" target="_blank" rel="noopener">课程 8 | 抽象编程 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=uFJhEPrbycQ&amp;list=PLFE6E58F856038C69&amp;index=9" target="_blank" rel="noopener">课程 9 | 抽象编程 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=NdF1QDTRkck&amp;index=10&amp;list=PLFE6E58F856038C69" target="_blank" rel="noopener">课程 10 | 抽象编程 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=p-gpaIGRCQI&amp;list=PLFE6E58F856038C69&amp;index=11" target="_blank" rel="noopener">课程 11 | 抽象编程 (video)</a></li></ul></li><li>什么时候适合使用</li><li>尾递归会更好么?<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.quora.com/What-is-tail-recursion-Why-is-it-so-bad" target="_blank" rel="noopener">什么是尾递归以及为什么它如此糟糕?</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=L1jjXGfxozc" target="_blank" rel="noopener">尾递归 (video)</a></li></ul></li></ul></li><li><h3 id="动态规划（Dynamic-Programming）"><a href="#动态规划（Dynamic-Programming）" class="headerlink" title="动态规划（Dynamic Programming）"></a>动态规划（Dynamic Programming）</h3><ul><li><strong>注意</strong> ：动态规划是门极为重要的技术，尽管其并未被 Google 提供的准备手册提及，但你可能会对寻求最佳解的方式有点疑问，所以我将其列入这份表单。</li><li>这一部分会有点困难，每个可以用动态规划解决的问题都必须先定义出递推关系，要推导出来可能会有点棘手。</li><li><p>我建议先阅读和学习足够多的动态规划的例子，以便对解决 DP 问题的一般模式有个扎实的理解。</p></li><li><p>[ ] 视频:</p><ul><li>Skiena 的视频可能会有点难跟上，有时候他用白板写的字会比较小，难看清楚。</li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/Qc2ieXRgR0k?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=1718" target="_blank" rel="noopener">Skiena: CSE373 2012 - 课程 19 - 动态规划介绍 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/IsmMhMdyeGY?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=2749" target="_blank" rel="noopener">Skiena: CSE373 2012 - 课程 20 - 编辑距离 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/o0V9eYF4UI8?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=406" target="_blank" rel="noopener">Skiena: CSE373 2012 - 课程 21 - 动态规划举例 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=dRbMC1Ltl3A&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=22" target="_blank" rel="noopener">Skiena: CSE373 2012 - 课程 22 - 动态规划应用 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/J5aJEcOr6Eo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3558" target="_blank" rel="noopener">Simonson: 动态规划 0 (starts at 59:18) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=0EzHjQ_SOeU&amp;index=11&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="noopener">Simonson: 动态规划 I - 课程 11 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=v1qiRwuJU7g&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=12" target="_blank" rel="noopener">Simonson: 动态规划 II - 课程 12 (video)</a></li><li style="list-style: none"><input type="checkbox"> 单独的 DP 问题 (每一个视频都很短):<br>  <a href="https://www.youtube.com/playlist?list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr" target="_blank" rel="noopener">动态规划 (video)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> Yale 课程笔记:<ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#dynamicProgramming" target="_blank" rel="noopener">动态规划</a></li></ul></li><li style="list-style: none"><input type="checkbox"> Coursera 课程:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/80RrW/the-rna-secondary-structure-problem" target="_blank" rel="noopener">RNA 二级结构问题 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/PSonq/a-dynamic-programming-algorithm" target="_blank" rel="noopener">动态规划算法 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/oUEK2/illustrating-the-dp-algorithm" target="_blank" rel="noopener">DP 算法描述 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/nfK2r/running-time-of-the-dp-algorithm" target="_blank" rel="noopener">DP 算法的运行时间 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/M999a/dp-vs-recursive-implementation" target="_blank" rel="noopener">DP vs 递归实现 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/UZ7o6/global-pairwise-sequence-alignment" target="_blank" rel="noopener">全局成对序列排列 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/WnNau/local-pairwise-sequence-alignment" target="_blank" rel="noopener">本地成对序列排列 (video)</a></li></ul></li></ul></li><li><h3 id="组合（Combinatorics）-n-中选-k-个-amp-概率（Probability）"><a href="#组合（Combinatorics）-n-中选-k-个-amp-概率（Probability）" class="headerlink" title="组合（Combinatorics） (n 中选 k 个) &amp; 概率（Probability）"></a>组合（Combinatorics） (n 中选 k 个) &amp; 概率（Probability）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=8RRo6Ti9d0U" target="_blank" rel="noopener">数据技巧: 如何找出阶乘、排列和组合(选择) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=sZkAAk9Wwa4" target="_blank" rel="noopener">来点学校的东西: 概率 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=dNaJg-mLobQ" target="_blank" rel="noopener">来点学校的东西: 概率和马尔可夫链 (video)</a></li><li style="list-style: none"><input type="checkbox"> 可汗学院:<ul><li>课程设置:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.khanacademy.org/math/probability/probability-and-combinatorics-topic" target="_blank" rel="noopener">概率理论基础</a></li></ul></li><li>视频 - 41 (每一个都短小精悍):<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=uzkc-qNVoOk&amp;list=PLC58778F28211FA19" target="_blank" rel="noopener">概率解释 (video)</a></li></ul></li></ul></li></ul></li><li><h3 id="NP-NP-完全和近似算法"><a href="#NP-NP-完全和近似算法" class="headerlink" title="NP, NP-完全和近似算法"></a>NP, NP-完全和近似算法</h3><ul><li>知道最经典的一些 NP 完全问题，比如旅行商问题和背包问题,<br>  而且能在面试官试图忽悠你的时候识别出他们。</li><li>知道 NP 完全是什么意思.</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=moPtwq_cVH8&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=23" target="_blank" rel="noopener">计算复杂度 (video)</a></li><li style="list-style: none"><input type="checkbox"> Simonson:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/qcGnJ47Smlo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=2939" target="_blank" rel="noopener">贪心算法. II &amp; 介绍 NP-完全性 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=e0tGC6ZQdQE&amp;index=16&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="noopener">NP-完全性 II &amp; 归约 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=fCX1BGT3wjE&amp;index=17&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="noopener">NP-完全性 III (Video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=NKLDp3Rch3M&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=18" target="_blank" rel="noopener">NP-完全性 IV (video)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> Skiena:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/KiK5TVgXbFg?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=1508" target="_blank" rel="noopener">CSE373 2012 - 课程 23 - 介绍 NP-完全性 IV (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=27Al52X3hd4&amp;index=24&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">CSE373 2012 - 课程 24 - NP-完全性证明 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=xCPH4gwIIXM&amp;index=25&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">CSE373 2012 - 课程 25 - NP-完全性挑战 (video)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=eHZifpgyH_4&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=22" target="_blank" rel="noopener">复杂度: P, NP, NP-完全性, 规约 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=MEz1J9wY2iM&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=24" target="_blank" rel="noopener">复杂度: 近视算法 Algorithms (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=4q-jmGrmxKs&amp;index=25&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">复杂度: 固定参数算法 (video)</a></li><li>Peter Norvik 讨论旅行商问题的近似最优解:<ul><li><a href="http://nbviewer.jupyter.org/url/norvig.com/ipython/TSP.ipynb" target="_blank" rel="noopener">Jupyter 笔记本</a></li></ul></li><li>《算法导论》的第 1048 - 1140 页。</li></ul></li><li><h3 id="缓存（Cache）"><a href="#缓存（Cache）" class="headerlink" title="缓存（Cache）"></a>缓存（Cache）</h3><ul><li style="list-style: none"><input type="checkbox"> LRU 缓存:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=R5ON3iwx78M" target="_blank" rel="noopener">LRU 的魔力 (100 Days of Google Dev) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=bq6N7Ym81iI" target="_blank" rel="noopener">实现 LRU (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=8-FZRAjR7qU" target="_blank" rel="noopener">LeetCode - 146 LRU Cache (C++) (video)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> CPU 缓存:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=vjYF_fAZI5E&amp;list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-&amp;index=24" target="_blank" rel="noopener">MIT 6.004 L15: 存储体系 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ajgC3-pyGlk&amp;index=25&amp;list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-" target="_blank" rel="noopener">MIT 6.004 L16: 缓存的问题 (video)</a></li></ul></li></ul></li><li><h3 id="进程（Processe）和线程（Thread）"><a href="#进程（Processe）和线程（Thread）" class="headerlink" title="进程（Processe）和线程（Thread）"></a>进程（Processe）和线程（Thread）</h3><ul><li style="list-style: none"><input type="checkbox"> 计算机科学 162 - 操作系统 (25 个视频):<ul><li>视频 1-11 是关于进程和线程</li><li><a href="https://www.youtube.com/playlist?list=PL-XXv-cvA_iBDyz-ba4yDskqMDY6A1w_c" target="_blank" rel="noopener">操作系统和系统编程 (video)</a></li></ul></li><li><a href="https://www.quora.com/What-is-the-difference-between-a-process-and-a-thread" target="_blank" rel="noopener">进程和线程的区别是什么?</a></li><li>涵盖了:<ul><li>进程、线程、协程<ul><li>进程和线程的区别</li><li>进程</li><li>线程</li><li>锁</li><li>互斥</li><li>信号量</li><li>监控</li><li>他们是如何工作的</li><li>死锁</li><li>活锁</li></ul></li><li>CPU 活动, 中断, 上下文切换</li><li>现代多核处理器的并发式结构</li><li>进程资源需要（内存：代码、静态存储器、栈、堆、文件描述符、I/O）</li><li>线程资源需要（在同一个进程内和其他线程共享以上的资源，但是每个线程都有独立的程序计数器、栈计数器、寄存器和栈）</li><li>Fork 操作是真正的写时复制（只读），直到新的进程写到内存中，才会生成一份新的拷贝。</li><li>上下文切换<ul><li>操作系统和底层硬件是如何初始化上下文切换的。</li></ul></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M" target="_blank" rel="noopener">C++ 的线程 (系列 - 10 个视频)</a></li><li style="list-style: none"><input type="checkbox"> Python 的协程 (视频):<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PL1H1sBF1VAKVMONJWJkmUh6_p8g4F2oy1" target="_blank" rel="noopener">线程系列</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Bs7vPNbB9JM" target="_blank" rel="noopener">Python 线程</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Obt-vMVdM8s" target="_blank" rel="noopener">理解 Python 的 GIL (2010)</a><ul><li><a href="http://www.dabeaz.com/GIL" target="_blank" rel="noopener">参考</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=MCs5OvhV9S4" target="_blank" rel="noopener">David Beazley - Python 协程 - PyCon 2015</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ZzfHjytDceU" target="_blank" rel="noopener">Keynote David Beazley - 兴趣主题 (Python 异步 I/O)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=0zaPs8OtyKY" target="_blank" rel="noopener">Python 中的互斥</a></li></ul></li></ul></li></ul><pre><code>系统设计以及可伸缩性，要把软硬件的伸缩性设计的足够好有很多的东西要考虑，所以这是个包含非常多内容和资源的大主题。需要花费相当多的时间在这个主题上。</code></pre><ul><li><h3 id="系统设计、可伸缩性、数据处理"><a href="#系统设计、可伸缩性、数据处理" class="headerlink" title="系统设计、可伸缩性、数据处理"></a>系统设计、可伸缩性、数据处理</h3><ul><li>Yegge 的注意事项:<ul><li>伸缩性<ul><li>把大数据集提取为单一值</li><li>大数据集转换</li><li>处理大量的数据集</li></ul></li><li>系统<ul><li>特征集</li><li>接口</li><li>类层次结构</li><li>在特定的约束下设计系统</li><li>轻量和健壮性</li><li>权衡和折衷</li><li>性能分析和优化</li></ul></li></ul></li><li style="list-style: none"><input type="checkbox"> <strong>从这里开始</strong>: <a href="http://www.hiredintech.com/system-design/" target="_blank" rel="noopener">HiredInTech：系统设计</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.quora.com/How-do-I-prepare-to-answer-design-questions-in-a-technical-interview?redirected_qid=1500023" target="_blank" rel="noopener">该如何为技术面试里设计方面的问题做准备?</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://blog.gainlo.co/index.php/2015/10/22/8-things-you-need-to-know-before-system-design-interviews/" target="_blank" rel="noopener">在系统设计面试前必须知道的 8 件事</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.hiredintech.com/algorithm-design/" target="_blank" rel="noopener">算法设计</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=UrYLYV7WSHM" target="_blank" rel="noopener">数据库范式 - 1NF, 2NF, 3NF and 4NF (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://github.com/checkcheckzz/system-design-interview" target="_blank" rel="noopener">系统设计面试</a> - 这一部分有很多的资源，浏览一下我放在下面的文章和例子。</li><li style="list-style: none"><input type="checkbox"> <a href="http://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/" target="_blank" rel="noopener">如何在系统设计面试中脱颖而出</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://everythingisdata.wordpress.com/2009/10/17/numbers-everyone-should-know/" target="_blank" rel="noopener">每个人都该知道的一些数字</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html" target="_blank" rel="noopener">上下文切换操作会耗费多少时间?</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=srOgpXECblk" target="_blank" rel="noopener">跨数据中心的事务 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem/" target="_blank" rel="noopener">简明 CAP 理论介绍</a></li><li style="list-style: none"><input type="checkbox"> Paxos 一致性算法:<ul><li><a href="https://www.youtube.com/watch?v=s8JqcZtvnsM" target="_blank" rel="noopener">时间很短</a></li><li><a href="https://www.youtube.com/watch?v=JEpsBg0AO6o" target="_blank" rel="noopener">用例 和 multi-paxos</a></li><li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="noopener">论文</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.tom-e-white.com/2007/11/consistent-hashing.html" target="_blank" rel="noopener">一致性哈希</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://horicky.blogspot.com/2009/11/nosql-patterns.html" target="_blank" rel="noopener">NoSQL 模式</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=OkC7HKtiZC0&amp;list=PLGLfVvz_LVvQ5G-LdJ8RLqe-ndo7QITYc" target="_blank" rel="noopener">OOSE: UML 2.0 系列 (video)</a></li><li style="list-style: none"><input type="checkbox"> OOSE: 使用 UML 和 Java 开发软件 (21 videos):<ul><li>如果你对 OO 都深刻的理解和实践，可以跳过这部分。</li><li><a href="https://www.youtube.com/playlist?list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO" target="_blank" rel="noopener">OOSE: 使用 UML 和 Java 开发软件</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 面向对象编程的 SOLID 原则:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=TMuno5RZNeE" target="_blank" rel="noopener">Bob Martin 面向对象的 SOLID 原则和敏捷设计 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PL8m4NUhTQU48oiGCSgCP1FiJEcg_xJzyQ" target="_blank" rel="noopener">C# SOLID 设计模式 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PL4CE9F710017EA77A" target="_blank" rel="noopener">SOLID 原则 (video)</a></li><li style="list-style: none"><input type="checkbox"> S - <a href="http://www.oodesign.com/single-responsibility-principle.html" target="_blank" rel="noopener">单一职责原则</a> | <a href="http://www.javacodegeeks.com/2011/11/solid-single-responsibility-principle.html" target="_blank" rel="noopener">每个对象的单一职责</a><ul><li><a href="https://docs.google.com/open?id=0ByOwmqah_nuGNHEtcU5OekdDMkk" target="_blank" rel="noopener">更多</a></li></ul></li><li style="list-style: none"><input type="checkbox"> O - <a href="http://www.oodesign.com/open-close-principle.html" target="_blank" rel="noopener">开闭原则</a>  | <a href="https://en.wikipedia.org/wiki/Open/closed_principle" target="_blank" rel="noopener">生产环境里的对象应该为扩展做准备而不是为更改</a><ul><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgN2M5MTkwM2EtNWFkZC00ZTI3LWFjZTUtNTFhZGZiYmUzODc1&amp;hl=en" target="_blank" rel="noopener">更多</a></li></ul></li><li style="list-style: none"><input type="checkbox"> L - <a href="http://www.oodesign.com/liskov-s-substitution-principle.html" target="_blank" rel="noopener">里氏代换原则</a> | <a href="http://stackoverflow.com/questions/56860/what-is-the-liskov-substitution-principle" target="_blank" rel="noopener">基类和继承类遵循 ‘IS A’ 原则</a><ul><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgNzAzZjA5ZmItNjU3NS00MzQ5LTkwYjMtMDJhNDU5ZTM0MTlh&amp;hl=en" target="_blank" rel="noopener">更多</a></li></ul></li><li style="list-style: none"><input type="checkbox"> I - <a href="http://www.oodesign.com/interface-segregation-principle.html" target="_blank" rel="noopener">接口隔离原则</a> | 客户端被迫实现用不到的接口<ul><li><a href="https://www.youtube.com/watch?v=3CtAfl7aXAQ" target="_blank" rel="noopener">5 分钟讲解接口隔离原则 (video)</a></li><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgOTViYjJhYzMtMzYxMC00MzFjLWJjMzYtOGJiMDc5N2JkYmJi&amp;hl=en" target="_blank" rel="noopener">更多</a></li></ul></li><li style="list-style: none"><input type="checkbox"> D -<a href="http://www.oodesign.com/dependency-inversion-principle.html" target="_blank" rel="noopener">依赖反转原则</a> | 减少对象里的依赖。<ul><li><a href="http://stackoverflow.com/questions/62539/what-is-the-dependency-inversion-principle-and-why-is-it-important" target="_blank" rel="noopener">什么是依赖倒置以及它为什么重要</a></li><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgMjdlMWIzNGUtZTQ0NC00ZjQ5LTkwYzQtZjRhMDRlNTQ3ZGMz&amp;hl=en" target="_blank" rel="noopener">更多</a></li></ul></li></ul></li><li style="list-style: none"><input type="checkbox"> 可伸缩性:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=-W9F__D3oY4" target="_blank" rel="noopener">很棒的概述 (video)</a></li><li style="list-style: none"><input type="checkbox"> 简短系列:<ul><li><a href="http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones" target="_blank" rel="noopener">克隆</a></li><li><a href="http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database" target="_blank" rel="noopener">数据库</a></li><li><a href="http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache" target="_blank" rel="noopener">缓存</a></li><li><a href="http://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism" target="_blank" rel="noopener">异步</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.aosabook.org/en/distsys.html" target="_blank" rel="noopener">可伸缩的 Web 架构和分布式系统</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://pages.cs.wisc.edu/~zuyu/files/fallacies.pdf" target="_blank" rel="noopener">错误的分布式系统解释</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html" target="_blank" rel="noopener">实用编程技术</a><ul><li><a href="http://horicky.blogspot.com/2010/07/google-pregel-graph-processing.html" target="_blank" rel="noopener">extra: Google Pregel 图形处理</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=modXC5IWTJI" target="_blank" rel="noopener">Jeff Dean - 在 Goolge 构建软件系统 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://lethain.com/introduction-to-architecting-systems-for-scale/" target="_blank" rel="noopener">可伸缩系统架构设计介绍</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=9nWyWwY2Onc" target="_blank" rel="noopener">使用 App Engine 和云存储扩展面向全球用户的手机游戏架构实践(video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=H4vMcD7zKM0" target="_blank" rel="noopener">How Google Does Planet-Scale Engineering for Planet-Scale Infra (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/the-importance-of-algorithms/" target="_blank" rel="noopener">算法的重要性</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html" target="_blank" rel="noopener">分片</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.infoq.com/presentations/Scale-at-Facebook" target="_blank" rel="noopener">Facebook 系统规模扩展实践 (2009)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=oodS71YtkGU" target="_blank" rel="noopener">Facebook 系统规模扩展实践 (2012), “为 10 亿用户构建” (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=p0jGmgIrf_M&amp;list=PLRXxvay_m8gqVlExPC5DG3TGWJTaBgqSA&amp;index=4" target="_blank" rel="noopener">Long Game 工程实践 - Astrid Atkinson Keynote(video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2012/3/26/7-years-of-youtube-scalability-lessons-in-30-minutes.html" target="_blank" rel="noopener">30 分钟看完 YouTuBe 7 年系统扩展经验</a><ul><li><a href="https://www.youtube.com/watch?v=G-lGCC4KKok" target="_blank" rel="noopener">video</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/8/15/how-paypal-scaled-to-billions-of-transactions-daily-using-ju.html" target="_blank" rel="noopener">PayPal 如何用 8 台虚拟机扛住 10 亿日交易量系统</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://blog.clevertap.com/how-to-remove-duplicates-in-large-datasets/" target="_blank" rel="noopener">如何对大数据集去重</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=3vV4YiqKm1o" target="_blank" rel="noopener">Etsy 的扩展和工程文化探究 Jon Cowie (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://thenewstack.io/led-amazon-microservices-architecture/" target="_blank" rel="noopener">是什么造就了 Amazon 自己的微服务架构</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://eng.uber.com/trip-data-squeeze/" target="_blank" rel="noopener">压缩还是不压缩，是 Uber 面临的问题</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/3/3/asyncio-tarantool-queue-get-in-the-queue.html" target="_blank" rel="noopener">异步 I/O Tarantool 队列</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/2/25/when-should-approximate-query-processing-be-used.html" target="_blank" rel="noopener">什么时候应该用近视查询处理?</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/2/23/googles-transition-from-single-datacenter-to-failover-to-a-n.html" target="_blank" rel="noopener">Google 从单数据中心到故障转移, 到本地多宿主架构的演变</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2012/9/24/google-spanners-most-surprising-revelation-nosql-is-out-and.html" target="_blank" rel="noopener">Spanner</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/2/15/egnyte-architecture-lessons-learned-in-building-and-scaling.html" target="_blank" rel="noopener">Egnyte: 构建和扩展 PB 级分布式系统架构的经验教训</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/7/6/machine-learning-driven-programming-a-new-programming-for-a.html" target="_blank" rel="noopener">机器学习驱动的编程: 新世界的新编程方式</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/6/15/the-image-optimization-technology-that-serves-millions-of-re.html" target="_blank" rel="noopener">日服务数百万请求的图像优化技术</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/2/1/a-patreon-architecture-short.html" target="_blank" rel="noopener">Patreon 架构</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/1/27/tinder-how-does-one-of-the-largest-recommendation-engines-de.html" target="_blank" rel="noopener">Tinder: 推荐引擎是如何决定下一个你将会看到谁的?</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html" target="_blank" rel="noopener">现代缓存设计</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/1/13/live-video-streaming-at-facebook-scale.html" target="_blank" rel="noopener">Facebook 实时视频流扩展</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/1/11/a-beginners-guide-to-scaling-to-11-million-users-on-amazons.html" target="_blank" rel="noopener">在 Amazon AWS 上把服务扩展到 1100 万量级的新手教程</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2015/12/16/how-does-the-use-of-docker-effect-latency.html" target="_blank" rel="noopener">对延时敏感的应用是否应该使用 Docker?</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2015/12/14/does-amp-counter-an-existential-threat-to-google.html" target="_blank" rel="noopener">AMP（Accelerated Mobile Pages）的存在是对 Google 的威胁么?</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html" target="_blank" rel="noopener">360 度解读 Netflix 技术栈</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/latency-everywhere-and-it-costs-you-sales-how-crush-it" target="_blank" rel="noopener">延迟无处不在 - 如何搞定它？</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://martinfowler.com/articles/serverless.html" target="_blank" rel="noopener">无服务器架构</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances" target="_blank" rel="noopener">是什么驱动着 Instagram: 上百个实例、几十种技术</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html" target="_blank" rel="noopener">Cinchcast 架构 - 每天处理 1500 小时的音频</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html" target="_blank" rel="noopener">Justin.Tv 实时视频播放架构</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html" target="_blank" rel="noopener">Playfish’s 社交游戏架构 - 每月五千万用户增长</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html" target="_blank" rel="noopener">猫途鹰架构 - 40 万访客, 200 万动态页面访问, 30TB 数据</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/plentyoffish-architecture" target="_blank" rel="noopener">PlentyOfFish 架构</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html" target="_blank" rel="noopener">Salesforce 架构 - 如何扛住 13 亿日交易量</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html" target="_blank" rel="noopener">ESPN’s 架构扩展</a></li><li style="list-style: none"><input type="checkbox"> 下面 『消息、序列化和消息系统』部分的内容会提到什么样的技术能把各种服务整合到一起</li><li style="list-style: none"><input type="checkbox"> Twitter:<ul><li><a href="https://www.youtube.com/watch?v=5cKTP36HVgI" target="_blank" rel="noopener">O’Reilly MySQL CE 2011: Jeremy Cole, “Big and Small Data at @Twitter” (video)</a></li><li><a href="https://www.infoq.com/presentations/Twitter-Timeline-Scalability" target="_blank" rel="noopener">时间线的扩展</a></li></ul></li><li>更多内容可以查看视频部分的『大规模数据挖掘』视频系列。</li></ul></li><li style="list-style: none"><input type="checkbox"> 系统设计问题练习：下面有一些指导原则，每一个都有相关文档以及在现实中该如何处理。<ul><li>复习: <a href="http://www.hiredintech.com/system-design/" target="_blank" rel="noopener">HiredInTech 的系统设计</a></li><li><a href="https://github.com/jwasham/google-interview-university/blob/master/extras/cheat%20sheets/system-design.pdf" target="_blank" rel="noopener">cheat sheet</a></li><li>流程:<ol><li>理解问题和范围:<ul><li>在面试官的帮助下定义用例</li><li>提出附加功能的建议</li><li>去掉面试官认定范围以外的内容</li><li>假定高可用是必须的，而且要作为一个用例</li></ul></li><li>考虑约束:<ul><li>问一下每月请求量</li><li>问一下每秒请求量 (他们可能会主动提到或者让你算一下)</li><li>评估读写所占的百分比</li><li>评估的时候牢记 2/8 原则</li><li>每秒写多少数据</li><li>总的数据存储量要考虑超过 5 年的情况</li><li>每秒读多少数据</li></ul></li><li>抽象设计:<ul><li>分层 (服务, 数据, 缓存)</li><li>基础设施: 负载均衡, 消息</li><li>粗略的概括任何驱动整个服务的关键算法</li><li>考虑瓶颈并指出解决方案</li></ul></li></ol></li><li>练习:<ul><li><a href="http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&amp;context=compsci" target="_blank" rel="noopener">设计一个 CDN 网络</a></li><li><a href="https://blog.twitter.com/2010/announcing-snowflake" target="_blank" rel="noopener">设计一个随机唯一 ID 生成系统</a></li><li><a href="http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html" target="_blank" rel="noopener">设计一个在线多人卡牌游戏</a></li><li><a href="http://www.slideshare.net/dvirsky/introduction-to-redis" target="_blank" rel="noopener">设计一个 key-value 数据库</a></li><li><a href="https://icmi.cs.ucsb.edu/research/tech_reports/reports/2005-23.pdf" target="_blank" rel="noopener">设计一个函数获取过去某个时间段内前 K 个最高频访问的请求</a></li><li><a href="http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html" target="_blank" rel="noopener">设计一个图片分享系统</a></li><li><a href="http://ijcai13.org/files/tutorial_slides/td3.pdf" target="_blank" rel="noopener">设计一个推荐系统</a></li><li><a href="http://www.hiredintech.com/system-design/the-system-design-process/" target="_blank" rel="noopener">设计一个短域名生成系统</a></li><li><a href="https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/" target="_blank" rel="noopener">设计一个缓存系统</a></li></ul></li></ul></li></ul></li><li><h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><ul><li>有 Google 的论文和一些知名的论文.</li><li>你很可能实在没时间一篇篇完整的读完他们。我建议可以有选择的读其中一些论文里的核心部分。</li><li style="list-style: none"><input type="checkbox"> <a href="http://spinroot.com/courses/summer/Papers/hoare_1978.pdf" target="_blank" rel="noopener">1978: 通信顺序处理</a><ul><li><a href="https://godoc.org/github.com/thomas11/csp" target="_blank" rel="noopener">Go 实现</a></li><li><a href="https://www.cs.cmu.edu/~crary/819-f09/" target="_blank" rel="noopener">喜欢经典的论文?</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf" target="_blank" rel="noopener">2003: The Google 文件系统</a><ul><li>2012 年被 Colossus 取代了</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">2004: MapReduce: Simplified Data Processing on Large Clusters</a><ul><li>大多被云数据流取代了?</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.akkadia.org/drepper/cpumemory.pdf" target="_blank" rel="noopener">2007: 每个程序员都应该知道的内存知识 (非常长，作者建议跳过某些章节来阅读)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.wired.com/2012/07/google-colossus/" target="_blank" rel="noopener">2012: Google 的 Colossus</a><ul><li>没有论文</li></ul></li><li style="list-style: none"><input type="checkbox"> 2012: AddressSanitizer: 快速的内存访问检查器:<ul><li><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/37752.pdf" target="_blank" rel="noopener">论文</a></li><li><a href="https://www.usenix.org/conference/atc12/technical-sessions/presentation/serebryany" target="_blank" rel="noopener">视频</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 2013: Spanner: Google 的分布式数据库:<ul><li><a href="http://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf" target="_blank" rel="noopener">论文</a></li><li><a href="https://www.usenix.org/node/170855" target="_blank" rel="noopener">视频</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43146.pdf" target="_blank" rel="noopener">2014: Machine Learning: The High-Interest Credit Card of Technical Debt</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43790.pdf" target="_blank" rel="noopener">2015: Continuous Pipelines at Google</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44686.pdf" target="_blank" rel="noopener">2015: 大规模高可用: 构建 Google Ads 的数据基础设施</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://download.tensorflow.org/paper/whitepaper2015.pdf" target="_blank" rel="noopener">2015: TensorFlow: 异构分布式系统上的大规模机器学习</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43835.pdf" target="_blank" rel="noopener">2015: 开发者应该如何搜索代码：用例学习</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44843.pdf" target="_blank" rel="noopener">2016: Borg, Omega, and Kubernetes</a></li></ul></li><li><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>涵盖了:<ul><li>单元测试是如何工作的</li><li>什么是模拟对象</li><li>什么是集成测试</li><li>什么是依赖注入</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=SAhJf36_u5U" target="_blank" rel="noopener">James Bach 讲敏捷软件测试 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ILkT_HV9DVU" target="_blank" rel="noopener">James Bach 软件测试公开课 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://vimeo.com/83960706" target="_blank" rel="noopener">Steve Freeman - 测试驱动的开发 (video)</a><ul><li><a href="http://gotocon.com/dl/goto-berlin-2013/slides/SteveFreeman_TestDrivenDevelopmentThatsNotWhatWeMeant.pdf" target="_blank" rel="noopener">slides</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html" target="_blank" rel="noopener">测试驱动的开发已死。测试不朽。</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=z9quxZsLcfo" target="_blank" rel="noopener">测试驱动的开发已死? (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=nzJapzxH_rE&amp;list=PLAwxTw4SYaPkWVHeC_8aSIbSxE_NXI76g" target="_blank" rel="noopener">视频系列 (152 个) - 并不都是必须 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.obeythetestinggoat.com/pages/book.html#toc" target="_blank" rel="noopener">Python：测试驱动的 Web 开发</a></li><li style="list-style: none"><input type="checkbox"> 依赖注入:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=IKD2-MAkXyQ" target="_blank" rel="noopener">视频</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://jasonpolites.github.io/tao-of-testing/ch3-1.1.html" target="_blank" rel="noopener">测试之道</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://jasonpolites.github.io/tao-of-testing/ch4-1.1.html" target="_blank" rel="noopener">如何编写测试</a></li></ul></li><li><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><ul><li>在操作系统中是如何运作的</li><li>在操作系统部分的视频里有很多资料</li></ul></li><li><h3 id="实现系统例程"><a href="#实现系统例程" class="headerlink" title="实现系统例程"></a>实现系统例程</h3><ul><li>理解你使用的系统 API 底层有什么</li><li>你能自己实现它们么?</li></ul></li><li><h3 id="字符串搜索和操作"><a href="#字符串搜索和操作" class="headerlink" title="字符串搜索和操作"></a>字符串搜索和操作</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/tAfHI/search-pattern-in-text" target="_blank" rel="noopener">文本的搜索模式 (video)</a></li><li style="list-style: none"><input type="checkbox"> Rabin-Karp (videos):<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/c0Qkw/rabin-karps-algorithm" target="_blank" rel="noopener">Rabin Karps 算法</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/nYrc8/optimization-precomputation" target="_blank" rel="noopener">预先计算的优化</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/h4ZLc/optimization-implementation-and-analysis" target="_blank" rel="noopener">优化: 实现和分析</a></li><li><a href="https://www.youtube.com/watch?v=BRO7mVIFt08&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=9" target="_blank" rel="noopener">Table Doubling, Karp-Rabin</a></li><li><a href="https://www.youtube.com/watch?v=w6nuXg0BISo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=32" target="_blank" rel="noopener">滚动哈希</a></li></ul></li><li style="list-style: none"><input type="checkbox"> Knuth-Morris-Pratt (KMP) 算法:<ul><li><a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="noopener">Pratt 算法</a></li><li><a href="https://www.youtube.com/watch?v=2ogqPWJSftE" target="_blank" rel="noopener">教程: Knuth-Morris-Pratt (KMP) 字符串匹配算法</a></li></ul></li><li style="list-style: none"><input type="checkbox"> Boyer–Moore 字符串搜索算法<ul><li><a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm" target="_blank" rel="noopener">Boyer-Moore字符串搜索算法</a></li><li><a href="https://www.youtube.com/watch?v=QDZpzctPf10" target="_blank" rel="noopener">Boyer-Moore-Horspool 高级字符串搜索算法 (video)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-on-strings/home/week/1" target="_blank" rel="noopener">Coursera: 字符串的算法</a></li></ul></li></ul><hr><h2 id="终面"><a href="#终面" class="headerlink" title="终面"></a>终面</h2><pre><code>这一部分有一些短视频，你可以快速的观看和复习大多数重要概念。这对经常性的巩固很有帮助。</code></pre><h4 id="综述"><a href="#综述" class="headerlink" title="综述:"></a>综述:</h4><ul><li style="list-style: none"><input type="checkbox"> 2-3 分钟的短视频系列 (23 个)<ul><li><a href="https://www.youtube.com/watch?v=r4r1DZcx1cM&amp;list=PLmVb1OknmNJuC5POdcDv5oCS7_OUkDgpj&amp;index=22" target="_blank" rel="noopener">Videos</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 2-5 分钟的短视频系列 - Michael Sambol (18 个):<ul><li><a href="https://www.youtube.com/channel/UCzDJwLWoYCUQowF_nG3m5OQ" target="_blank" rel="noopener">Videos</a></li></ul></li></ul><h4 id="排序"><a href="#排序" class="headerlink" title="排序:"></a>排序:</h4><ul><li style="list-style: none"><input type="checkbox"> 归并排序: <a href="https://www.youtube.com/watch?v=GCae1WNvnZM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=GCae1WNvnZM</a></li></ul><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><h3 id="Google-Coaching-里提到的"><a href="#Google-Coaching-里提到的" class="headerlink" title="Google Coaching 里提到的"></a>Google Coaching 里提到的</h3><p><strong>阅读并做练习:</strong></p><ul><li><p>[ ] 算法设计手册 (Skiena)</p><ul><li>书 (Kindle 上可以租到):<ul><li><a href="http://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1849967202" target="_blank" rel="noopener">Algorithm Design Manual</a></li></ul></li><li>Half.com 是一个资源丰富且性价比很高的在线书店.</li><li>答案:<ul><li><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/The_Algorithms_Design_Manual_(Second_Edition" target="_blank" rel="noopener">解答</a>)</li><li><a href="http://blog.panictank.net/category/algorithmndesignmanualsolutions/page/2/" target="_blank" rel="noopener">解答</a></li></ul></li><li><p><a href="http://www3.cs.stonybrook.edu/~skiena/algorist/book/errata" target="_blank" rel="noopener">勘误表</a></p><p>read and do exercises from the books below. Then move to coding challenges (further down below)<br>一旦你理解了每日计划里的所有内容，就去读上面所列的书并完成练习，然后开始读下面所列的书并做练习，之后就可以开始实战写代码了（本文再往后的部分）</p></li></ul></li></ul><p><strong>首先阅读:</strong></p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-047012167X.html" target="_blank" rel="noopener">Programming Interviews Exposed: Secrets to Landing Your Next Job, 2nd Edition</a></li></ul><p><strong>然后阅读 (这本获得了很多推荐， 但是不在 Google coaching 的文档里):</strong></p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.amazon.com/Cracking-Coding-Interview-6th-Programming/dp/0984782850/" target="_blank" rel="noopener">Cracking the Coding Interview, 6th Edition</a><ul><li>如果你看到有人在看 “The Google Resume”, 实际上它和 “Cracking the Coding Interview” 是同一个作者写的，而且后者是升级版。</li></ul></li></ul><h3 id="附加书单"><a href="#附加书单" class="headerlink" title="附加书单"></a>附加书单</h3><p>这些没有被 Google 推荐阅读，不过我因为需要这些背景知识所以也把它们列在了这里。</p><ul><li><p>[ ] C Programming Language, Vol 2</p><ul><li><a href="https://github.com/lekkas/c-algorithms" target="_blank" rel="noopener">练习的答案</a></li></ul></li><li><p>[ ] C++ Primer Plus, 6th Edition</p></li><li><p>[ ] <a href="http://product.half.ebay.com/The-UNIX-Programming-Environment-by-Brian-W-Kernighan-and-Rob-Pike-1983-Other/54385&amp;tg=info" target="_blank" rel="noopener">《Unix 环境高级编程》 The Unix Programming Environment</a></p></li><li><p>[ ] <a href="http://www.amazon.com/Programming-Pearls-2nd-Jon-Bentley/dp/0201657880" target="_blank" rel="noopener">《编程珠玑》 Programming Pearls</a></p></li><li><p>[ ] <a href="http://www.amazon.com/Algorithms-Programming-Solutions-Alexander-Shen/dp/0817638474" target="_blank" rel="noopener">Algorithms and Programming: Problems and Solutions</a></p></li></ul><h3 id="如果你有时间"><a href="#如果你有时间" class="headerlink" title="如果你有时间"></a>如果你有时间</h3><ul><li><p>[ ] <a href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844" target="_blank" rel="noopener">Introduction to Algorithms</a></p></li><li><p>[ ] <a href="https://www.amazon.com/Elements-Programming-Interviews-Insiders-Guide/dp/1479274836" target="_blank" rel="noopener">Elements of Programming Interviews</a></p><ul><li>如果你希望在面试里用 C++ 写代码，这本书的代码全都是 C++ 写的</li><li>通常情况下能找到解决方案的好书.</li></ul></li></ul><h2 id="编码练习和挑战"><a href="#编码练习和挑战" class="headerlink" title="编码练习和挑战"></a>编码练习和挑战</h2><p>一旦你学会了理论基础，就应该把它们拿出来练练。<br>尽量坚持每天做编码练习，越多越好。</p><p>编程问题预备:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.hiredintech.com/algorithm-design/" target="_blank" rel="noopener">不错的介绍 (摘自 System Design 章节): 算法设计:</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/how-to-find-a-solution/" target="_blank" rel="noopener">如何找到解决方案</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/how-to-dissect-a-topcoder-problem-statement/" target="_blank" rel="noopener">如何剖析 Topcoder 题目描述</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/mathematics-for-topcoders/" target="_blank" rel="noopener">Topcoders 里用到的数学</a></li><li><p>[ ] <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/dynamic-programming-from-novice-to-advanced/" target="_blank" rel="noopener">动态规划 – 从入门到精通</a></p></li><li><p><a href="https://courses.csail.mit.edu/iap/interview/materials.php" target="_blank" rel="noopener">MIT 面试材料</a></p></li><li><p><a href="http://exercism.io/languages" target="_blank" rel="noopener">针对编程语言本身的练习</a></p></li></ul><p>编码练习平台:</p><ul><li><a href="https://leetcode.com/" target="_blank" rel="noopener">LeetCode</a></li><li><a href="https://www.topcoder.com/" target="_blank" rel="noopener">TopCoder</a></li><li><a href="https://projecteuler.net/index.php?section=problems" target="_blank" rel="noopener">Project Euler (数学方向为主)</a></li><li><a href="http://www.codewars.com" target="_blank" rel="noopener">Codewars</a></li><li><a href="https://www.hackerrank.com/" target="_blank" rel="noopener">HackerRank</a></li><li><a href="https://codility.com/programmers/" target="_blank" rel="noopener">Codility</a></li><li><a href="https://www.interviewcake.com/" target="_blank" rel="noopener">InterviewCake</a></li><li><p><a href="https://www.interviewbit.com/invite/icjf" target="_blank" rel="noopener">InterviewBit</a></p></li><li><p><a href="http://www.gainlo.co/" target="_blank" rel="noopener">模拟大公司的面试</a></p></li></ul><h2 id="当你临近面试时"><a href="#当你临近面试时" class="headerlink" title="当你临近面试时"></a>当你临近面试时</h2><ul><li style="list-style: none"><input type="checkbox"> 搞定代码面试 (videos):<ul><li><a href="https://www.youtube.com/watch?v=4NIb9l3imAo" target="_blank" rel="noopener">Cracking The Code Interview</a></li><li><a href="https://www.youtube.com/watch?v=Eg5-tdAwclo" target="_blank" rel="noopener">Cracking the Coding Interview - 全栈系列</a></li><li><a href="https://www.youtube.com/watch?v=1fqxMuPmGak" target="_blank" rel="noopener">Ask Me Anything: Gayle Laakmann McDowell (Cracking the Coding Interview 的作者)</a></li></ul></li></ul><h2 id="你的简历"><a href="#你的简历" class="headerlink" title="你的简历"></a>你的简历</h2><ul><li><a href="http://steve-yegge.blogspot.co.uk/2007_09_01_archive.html" target="_blank" rel="noopener">10 条小贴士让你写出一份还算不错的简历</a></li><li>这是搞定面试的第一个关键步骤</li></ul><h2 id="当面试来临的时候"><a href="#当面试来临的时候" class="headerlink" title="当面试来临的时候"></a>当面试来临的时候</h2><pre><code>随着下面列举的问题思考下你可能会遇到的 20 个面试问题每个问题准备 2-3 种回答准备点故事，不要只是摆一些你完成的事情的数据，相信我，人人都喜欢听故事</code></pre><ul><li>你为什么想得到这份工作？</li><li>你解决过的最有难度的问题是什么？</li><li>面对过的最大挑战是什么?</li><li>见过的最好或者最坏的设计是怎么样的?</li><li>对某项 Google 产品提出改进建议。</li><li>你作为一个个体同时也是团队的一员，如何达到最好的工作状态?</li><li>你的什么技能或者经验是你的角色中不可或缺的?为什么？</li><li>你在某份工作或某个项目中最享受的是什么?</li><li>你在某份工作或某个项目中面临过的最大挑战是什么?</li><li>你在某份工作或某个项目中遇到过的最蛋疼的 Bug 是什么样的？</li><li>你在某份工作或某个项目中学到了什么？</li><li>你在某份工作或某个项目中哪些地方还可以做的更好？</li></ul><h2 id="问面试官的问题"><a href="#问面试官的问题" class="headerlink" title="问面试官的问题"></a>问面试官的问题</h2><pre><code>我会问的一些：(可能我已经知道了答案但我想听听面试官的看法或者了解团队的前景):</code></pre><ul><li>团队多大规模?</li><li>开发周期是怎样的? 会使用瀑布流/极限编程/敏捷开发么?</li><li>经常会为 deadline 加班么? 或者是有弹性的?</li><li>团队里怎么做技术选型?</li><li>每周平均开多少次会?</li><li>你觉得工作环境有助于员工集中精力吗?</li><li>目前正在做什么工作?</li><li>喜欢这些事情吗?</li><li>工作期限是怎么样的?</li></ul><h2 id="当你获得了梦想的职位"><a href="#当你获得了梦想的职位" class="headerlink" title="当你获得了梦想的职位"></a>当你获得了梦想的职位</h2><p>我还能说些什么呢，恭喜你！</p><ul><li><a href="https://medium.com/@moonstorming/10-things-i-wish-i-knew-on-my-first-day-at-google-107581d87286#.livxn7clw" target="_blank" rel="noopener">我希望在 Google 的第一天就知道的 10 件事</a></li></ul><p>坚持继续学习。</p><p>得到这份工作只是一个开始。</p><hr><pre><code>**********************************************************************************************************************************************************************************************************下面的内容都是可选的。这些是我的推荐，不是 Google 的。通过学习这些内容，你将会得到更多的有关 CS 的概念，并将为所有的软件工程工作做更好的准备。**********************************************************************************************************************************************************************************************************</code></pre><hr><h2 id="附加的学习"><a href="#附加的学习" class="headerlink" title="附加的学习"></a>附加的学习</h2><ul><li><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.joelonsoftware.com/articles/Unicode.html" target="_blank" rel="noopener">每一个软件开发者的绝对最低限度，必须要知道的关于 Unicode 和字符集知识</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://kunststube.net/encoding/" target="_blank" rel="noopener">关于处理文本需要的编码和字符集, 每个程序员绝对需要知道的知识</a></li></ul></li><li><h3 id="字节顺序"><a href="#字节顺序" class="headerlink" title="字节顺序"></a>字节顺序</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html" target="_blank" rel="noopener">大、小端字节序</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=JrNF0KRAlyo" target="_blank" rel="noopener">大端字节 Vs 小端字节(视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=oBSuXP-1Tc0" target="_blank" rel="noopener">大、小端字节序的里里外外(Big And Little Endian Inside/Out) (视频)</a><ul><li>内核开发者的讨论非常技术性，如果大多数都超出了你的理解范围，不要太担心。</li><li>前半段已经足够了。</li></ul></li></ul></li><li><h3 id="Emacs-and-vi-m"><a href="#Emacs-and-vi-m" class="headerlink" title="Emacs and vi(m)"></a>Emacs and vi(m)</h3><ul><li>Yegge 的建议，从一个很早以前的亚马逊招聘信息中而来：熟悉基于 unix 的代码编辑器</li><li>vi(m):<ul><li><a href="https://www.youtube.com/watch?v=5givLEMcINQ&amp;index=1&amp;list=PL13bz4SHGmRxlZVmWQ9DvXo1fEg4UdGkr" target="_blank" rel="noopener">使用 vim 进行编辑 01 - 安装, 设置和模式 (视频)</a></li><li><a href="http://vim-adventures.com/" target="_blank" rel="noopener">VIM 的冒险之旅</a></li><li>4 个视频集:<ul><li><a href="https://www.youtube.com/watch?v=SI8TeVMX8pk" target="_blank" rel="noopener">vi/vim 编辑器 - 课程 1</a></li><li><a href="https://www.youtube.com/watch?v=F3OO7ZIOaJE" target="_blank" rel="noopener">vi/vim 编辑器 - 课程 2</a></li><li><a href="https://www.youtube.com/watch?v=1lYD5gwgZIA" target="_blank" rel="noopener">vi/vim 编辑器 - 课程 4</a></li><li><a href="https://www.youtube.com/watch?v=ZYEccA_nMaI" target="_blank" rel="noopener">vi/vim 编辑器 - 课程 3</a></li></ul></li><li><a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Using_Vi_instead_of_Emacs" target="_blank" rel="noopener">使用 Vi 而不是 Emacs</a></li></ul></li><li>emacs:<ul><li><a href="https://www.youtube.com/watch?v=hbmV1bnQ-i0" target="_blank" rel="noopener">基础 Emacs 教程 (视频)</a></li><li>3 个视频集:<ul><li><a href="https://www.youtube.com/watch?v=ujODL7MD04Q" target="_blank" rel="noopener">Emacs 教程 (初学者) -第 1 部分- 文件命令, 剪切/复制/粘贴,  自定义命令</a></li><li><a href="https://www.youtube.com/watch?v=XWpsRupJ4II" target="_blank" rel="noopener">Emacs 教程 (初学者 -第 2 部分- Buffer 管理, 搜索, M-x grep 和 rgrep 模式</a></li><li><a href="https://www.youtube.com/watch?v=paSgzPso-yc" target="_blank" rel="noopener">Emacs 教程 (初学者 -第 3 部分- 表达式, 声明, ~/.emacs 文件和包机制</a></li></ul></li><li><a href="https://www.youtube.com/watch?v=JWD1Fpdd4Pc" target="_blank" rel="noopener">Evil 模式: 或许, 我是怎样对 Emacs 路人转粉的 (视频)</a></li><li><a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Writing_C_programs_with_Emacs" target="_blank" rel="noopener">使用 Emacs 开发 C 程序</a></li><li><a href="https://www.youtube.com/watch?v=nsGYet02bEk" target="_blank" rel="noopener">(或许) 深度组织模式:管理结构 (视频)</a></li></ul></li></ul></li><li><h3 id="Unix-命令行工具"><a href="#Unix-命令行工具" class="headerlink" title="Unix 命令行工具"></a>Unix 命令行工具</h3><ul><li>下列内容中的优秀工具由的 Yegge 推荐，Yegge 目前致力于 Amazon 人事招聘处。</li><li style="list-style: none"><input type="checkbox"> bash</li><li style="list-style: none"><input type="checkbox"> cat</li><li style="list-style: none"><input type="checkbox"> grep</li><li style="list-style: none"><input type="checkbox"> sed</li><li style="list-style: none"><input type="checkbox"> awk</li><li style="list-style: none"><input type="checkbox"> curl or wget</li><li style="list-style: none"><input type="checkbox"> sort</li><li style="list-style: none"><input type="checkbox"> tr</li><li style="list-style: none"><input type="checkbox"> uniq</li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Strace" target="_blank" rel="noopener">strace</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://danielmiessler.com/study/tcpdump/" target="_blank" rel="noopener">tcpdump</a></li></ul></li><li><h3 id="信息资源-视频"><a href="#信息资源-视频" class="headerlink" title="信息资源 (视频)"></a>信息资源 (视频)</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.khanacademy.org/computing/computer-science/informationtheory" target="_blank" rel="noopener">Khan Academy 可汗学院</a></li><li style="list-style: none"><input type="checkbox"> 更多有关马尔可夫的内容:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/waxgx/core-markov-text-generation" target="_blank" rel="noopener">Core Markov Text Generation马尔可夫内容生成</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/gZhiC/core-implementing-markov-text-generation" target="_blank" rel="noopener">Core Implementing Markov Text Generation马尔可夫内容生成补充</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/EUjrq/project-markov-text-generation-walk-through" target="_blank" rel="noopener">Project = Markov Text Generation Walk Through一个马尔可夫内容生成器的项目</a></li></ul></li><li>关于更多信息，请参照下方 MIT 6.050J 信息和系统复杂度的内容.</li></ul></li><li><h3 id="奇偶校验位-amp-汉明码-视频"><a href="#奇偶校验位-amp-汉明码-视频" class="headerlink" title="奇偶校验位 &amp; 汉明码 (视频)"></a>奇偶校验位 &amp; 汉明码 (视频)</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=q-3BctoUpHE" target="_blank" rel="noopener">入门</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=DdMcAUlxh1M" target="_blank" rel="noopener">奇偶校验位</a></li><li style="list-style: none"><input type="checkbox"> 汉明码(Hamming Code):<ul><li><a href="https://www.youtube.com/watch?v=1A_NcXxdoCc" target="_blank" rel="noopener">发现错误</a></li><li><a href="https://www.youtube.com/watch?v=JAMLuxdHH8o" target="_blank" rel="noopener">修正错误</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=wbH2VxzmoZk" target="_blank" rel="noopener">检查错误</a></li></ul></li><li><h3 id="系统熵值（系统复杂度）"><a href="#系统熵值（系统复杂度）" class="headerlink" title="系统熵值（系统复杂度）"></a>系统熵值（系统复杂度）</h3><ul><li>请参考下方视频</li><li>观看之前，请先确定观看了信息论的视频</li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/JnJq3Py0dyM?t=176" target="_blank" rel="noopener">信息理论, 克劳德·香农, 熵值, 系统冗余, 数据比特压缩 (视频)</a></li></ul></li><li><h3 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h3><ul><li>请参考下方视频</li><li>观看之前，请先确定观看了信息论的视频</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.khanacademy.org/computing/computer-science/密码学" target="_blank" rel="noopener">可汗学院</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=KqqOXndnvic&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=30" target="_blank" rel="noopener">密码学: 哈希函数</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=9TNI2wHmaeI&amp;index=31&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">密码学: 加密</a></li></ul></li><li><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul><li>观看之前，请先确定观看了信息论的视频</li><li style="list-style: none"><input type="checkbox"> 压缩 (视频):<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Lto-ajuqW3w" target="_blank" rel="noopener">压缩</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=M5c_RFKVkko" target="_blank" rel="noopener">压缩熵值</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=umTbivyJoiI" target="_blank" rel="noopener">由上而下的树 (霍夫曼编码树)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=DV8efuB3h2g" target="_blank" rel="noopener">额外比特 - 霍夫曼编码树</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=goOa3DGezUA" target="_blank" rel="noopener">优雅的压缩数据 (无损数据压缩方法)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=cCDCfoHTsaU" target="_blank" rel="noopener">Text Compression Meets Probabilities</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIJGErt5rrCqaSGTMyyqNt2H" target="_blank" rel="noopener">数据压缩的艺术</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=whGwm0Lky2s" target="_blank" rel="noopener">(可选) 谷歌开发者: GZIP 还差远了呢!</a></li></ul></li><li><h3 id="网络-视频"><a href="#网络-视频" class="headerlink" title="网络 (视频)"></a>网络 (视频)</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.khanacademy.org/computing/computer-science/internet-intro" target="_blank" rel="noopener">可汗学院</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Vdc8TCESIg8" target="_blank" rel="noopener">网络传输协议中的数据压缩</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=e5DEVa9eSN0" target="_blank" rel="noopener">TCP/IP 和 OSI 模型解析!</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=nomyRJehhnM" target="_blank" rel="noopener">TCP/IP 教程：传输数据包.</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=WGJrLqtX7As" target="_blank" rel="noopener">HTTP</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=S2iBR2ZlZf0" target="_blank" rel="noopener">SSL 和 HTTPS</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Rp3iZUvXWlM" target="_blank" rel="noopener">SSL/TLS</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=E9FxNzv1Tr8" target="_blank" rel="noopener">HTTP 2.0</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLEbnTDJUr_IegfoqO4iPnPYQui46QqT0j" target="_blank" rel="noopener">视频</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=t5xYI0jzOf4" target="_blank" rel="noopener">子网络解密 - 第五部分 经典内部域名指向 CIDR 标记</a></li></ul></li><li><h3 id="计算机安全"><a href="#计算机安全" class="headerlink" title="计算机安全"></a>计算机安全</h3><ul><li><a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">MIT</a><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=GqmQg-cszw4&amp;index=1&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">威胁模型：入门</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=6bwzNg5qQ0o&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&amp;index=2" target="_blank" rel="noopener">控制攻击</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=drQyrzRoRiA&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&amp;index=3" target="_blank" rel="noopener">缓冲数据注入和防御</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=6SIJmoE9L9g&amp;index=4&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">优先权区分</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=8VqTSY-11F4&amp;index=5&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">能力</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=VEV74hwASeU&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&amp;index=6" target="_blank" rel="noopener">在沙盒中运行原生代码</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=chkFBigodIw&amp;index=7&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">网络安全模型</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=EBQIGy1ROLY&amp;index=8&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">网络安全应用</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=yRVZPvHYHzw&amp;index=9&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">标志化执行</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=SIEVvk3NVuk&amp;index=11&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">网络安全</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=QOtA76ga_fY&amp;index=12&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">网络协议</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=PuVMkSEcPiI&amp;index=15&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">旁路攻击</a></li></ul></li></ul></li><li><h3 id="释放缓存"><a href="#释放缓存" class="headerlink" title="释放缓存"></a>释放缓存</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=StdfeXaKGEc&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=25" target="_blank" rel="noopener">Java 释放缓存; 片段化数据 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLO9y7hOkmmSGTy5z6HZ-W4k2y8WXF7Bff" target="_blank" rel="noopener">编译器 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=iHVs_HkjdmI" target="_blank" rel="noopener">Python 释放缓存 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.infoq.com/presentations/garbage-collection-benefits" target="_blank" rel="noopener">深度解析：论释放缓存在 JAVA 中的重要性</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=P-8Z0-MhdQs&amp;list=PLdzf4Clw0VbOEWOS_sLhT_9zaiQDrS5AR&amp;index=3" target="_blank" rel="noopener">深度解析：论释放缓存在 Python 中的重要性(视频)</a></li></ul></li><li><h3 id="并行-并发编程"><a href="#并行-并发编程" class="headerlink" title="并行/并发编程"></a>并行/并发编程</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/parprog1/home/week/1" target="_blank" rel="noopener">Coursera (Scala)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=uY85GkaYzBk" target="_blank" rel="noopener">论并行/并发编程如何提高 Python 执行效率 (视频)</a></li></ul></li><li><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=3cmzqZzwNDM&amp;list=PLGLfVvz_LVvQ5G-LdJ8RLqe-ndo7QITYc&amp;index=3" target="_blank" rel="noopener">UML统一建模语言概览 (视频)</a></li><li style="list-style: none"><input type="checkbox"> 主要有如下的设计模式:<ul><li style="list-style: none"><input type="checkbox"> s(strategy)</li><li style="list-style: none"><input type="checkbox"> singleton</li><li style="list-style: none"><input type="checkbox"> adapter</li><li style="list-style: none"><input type="checkbox"> prototype</li><li style="list-style: none"><input type="checkbox"> decorator</li><li style="list-style: none"><input type="checkbox"> visitor</li><li style="list-style: none"><input type="checkbox"> factory, abstract factory</li><li style="list-style: none"><input type="checkbox"> facade</li><li style="list-style: none"><input type="checkbox"> observer</li><li style="list-style: none"><input type="checkbox"> proxy</li><li style="list-style: none"><input type="checkbox"> delegate</li><li style="list-style: none"><input type="checkbox"> command</li><li style="list-style: none"><input type="checkbox"> state</li><li style="list-style: none"><input type="checkbox"> memento</li><li style="list-style: none"><input type="checkbox"> iterator</li><li style="list-style: none"><input type="checkbox"> composite</li><li style="list-style: none"><input type="checkbox"> flyweight</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/LAP2A80Ajrg?list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO&amp;t=3344" target="_blank" rel="noopener">第六章 (第 1 部分 ) - 设计模式 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=U8-PGsjvZc4&amp;index=12&amp;list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO" target="_blank" rel="noopener">第六章 (第 2 部分 ) - Abstraction-Occurrence, General Hierarchy, Player-Role, Singleton, Observer, Delegation (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=7sduBHuex4c&amp;index=13&amp;list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO" target="_blank" rel="noopener">第六章 (第 3 部分 ) - Adapter, Facade, Immutable, Read-Only Interface, Proxy (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLF206E906175C7E07" target="_blank" rel="noopener">视频</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.amazon.com/Head-First-Design-Patterns-Freeman/dp/0596007124" target="_blank" rel="noopener">Head First 设计模型</a><ul><li>尽管这本书叫做设计模式：重复使用模块，但是我还是认为Head First是对于新手来说很不错的书。</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://sourcemaking.com/design-patterns-and-tips" target="_blank" rel="noopener">基于实际操作对于入门开发者的建议</a></li></ul></li><li><h3 id="信息传输-序列化-和队列化的系统"><a href="#信息传输-序列化-和队列化的系统" class="headerlink" title="信息传输, 序列化,和队列化的系统"></a>信息传输, 序列化,和队列化的系统</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://thrift.apache.org/" target="_blank" rel="noopener">Thrift</a><ul><li><a href="http://thrift-tutorial.readthedocs.io/en/latest/intro.html" target="_blank" rel="noopener">教程</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">协议缓冲</a><ul><li><a href="https://developers.google.com/protocol-buffers/docs/tutorials" target="_blank" rel="noopener">教程</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.grpc.io/" target="_blank" rel="noopener">gRPC</a><ul><li><a href="https://www.youtube.com/watch?v=5tmPvSe7xXQ&amp;list=PLcTqM9n_dieN0k1nSeN36Z_ppKnvMJoly&amp;index=1" target="_blank" rel="noopener">gRPC 对于JAVA开发者的入门教程（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://redis.io/" target="_blank" rel="noopener">Redis</a><ul><li><a href="http://try.redis.io/" target="_blank" rel="noopener">教程</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://aws.amazon.com/sqs/" target="_blank" rel="noopener">Amazon的 SQS 系统 (队列)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://aws.amazon.com/sns/" target="_blank" rel="noopener">Amazon的 SNS 系统 (pub-sub)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a><ul><li><a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">入门教程</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.celeryproject.org/" target="_blank" rel="noopener">Celery</a><ul><li><a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html" target="_blank" rel="noopener">Celery入门</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://zeromq.org/" target="_blank" rel="noopener">ZeroMQ</a><ul><li><a href="http://zeromq.org/intro:read-the-manual" target="_blank" rel="noopener">入门教程</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://activemq.apache.org/" target="_blank" rel="noopener">ActiveMQ</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://kafka.apache.org/documentation.html#introduction" target="_blank" rel="noopener">Kafka</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://msgpack.org/index.html" target="_blank" rel="noopener">MessagePack</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://avro.apache.org/" target="_blank" rel="noopener">Avro</a></li></ul></li><li><h3 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.askamathematician.com/2012/09/q-what-is-a-fourier-transform-what-is-it-used-for/" target="_blank" rel="noopener">什么是傅立叶变换？论傅立叶变换的用途</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Xxut2PN-V8Q" target="_blank" rel="noopener">什么是傅立叶变换？ (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=iTMn0Kt18tg&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=4" target="_blank" rel="noopener">关于 FFT 的不同观点 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://jakevdp.github.io/blog/2013/08/28/understanding-the-fft/" target="_blank" rel="noopener">FTT 是什么</a></li></ul></li><li><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><ul><li>给一个布隆过滤器m比特和k个哈希函数，所有的注入和相关测试都会是通过。</li><li><a href="https://www.youtube.com/watch?v=-SuTGoFYjZs" target="_blank" rel="noopener">布隆过滤器</a></li><li><a href="https://www.youtube.com/watch?v=qBTdukbzc78" target="_blank" rel="noopener">布隆过滤器 | 数据挖掘 | Stanford University</a></li><li><a href="http://billmill.org/bloomfilter-tutorial/" target="_blank" rel="noopener">教程</a></li><li><a href="http://blog.michaelschmatz.com/2016/04/11/how-to-write-a-bloom-filter-cpp/" target="_blank" rel="noopener">如何写一个布隆过滤器应用</a></li></ul></li><li><h3 id="van-Emde-Boas-树"><a href="#van-Emde-Boas-树" class="headerlink" title="van Emde Boas 树"></a>van Emde Boas 树</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=hmReJCupbNU&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=6" target="_blank" rel="noopener">争论: van Emde Boas 树 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2012/lecture-notes/MIT6_046JS12_lec15.pdf" target="_blank" rel="noopener">MIT课堂笔记</a></li></ul></li><li><h3 id="更深入的数据结构"><a href="#更深入的数据结构" class="headerlink" title="更深入的数据结构"></a>更深入的数据结构</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/zksIj9O8_jc?list=PL4BBB74C7D2A1049C&amp;t=950" target="_blank" rel="noopener">CS 61B 第 39 课: 更深入的数据结构</a></li></ul></li><li><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><ul><li>“有一种非常迷幻的数据类型” - Skiena</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2g9OSRKJuzM&amp;index=10&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">随机化: 跳表 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Skip_list" target="_blank" rel="noopener">更生动详细的解释</a></li></ul></li><li><h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=v1VgJmkEJW0" target="_blank" rel="noopener">5分钟简析Ford-Fulkerson (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=v1VgJmkEJW0" target="_blank" rel="noopener">Ford-Fulkerson 算法 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2vhN4Ice5jI" target="_blank" rel="noopener">网络流 (视频)</a></li></ul></li><li><h3 id="不相交集-amp-联合查找"><a href="#不相交集-amp-联合查找" class="headerlink" title="不相交集 &amp; 联合查找"></a>不相交集 &amp; 联合查找</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank" rel="noopener">不相交集</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=MAEGXTwmUsI&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=21" target="_blank" rel="noopener">UCB 61B - 不相交集; 排序 &amp; 选择(视频)</a></li><li style="list-style: none"><input type="checkbox"> Coursera (not needed since the above video explains it great):<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/JssSY/overview" target="_blank" rel="noopener">概览</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/EM5D0/naive-implementations" target="_blank" rel="noopener">初级实践</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/Mxu0w/trees" target="_blank" rel="noopener">树状结构</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/qb4c2/union-by-rank" target="_blank" rel="noopener">合并树状结构</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/Q9CVI/path-compression" target="_blank" rel="noopener">路径压缩</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/GQQLN/analysis-optional" target="_blank" rel="noopener">分析选项</a></li></ul></li></ul></li><li><h3 id="快速处理数学"><a href="#快速处理数学" class="headerlink" title="快速处理数学"></a>快速处理数学</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=eCaXlAaN2uE&amp;index=11&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">整数运算, Karatsuba 乘法 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ru7mWZJlRQg" target="_blank" rel="noopener">中国剩余定理 (在密码学中的使用) (视频)</a></li></ul></li><li><h3 id="树堆-Treap"><a href="#树堆-Treap" class="headerlink" title="树堆 (Treap)"></a>树堆 (Treap)</h3><ul><li>一个二叉搜索树和一个堆的组合</li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Treap" target="_blank" rel="noopener">树堆</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=6podLUYinH8" target="_blank" rel="noopener">数据结构：树堆的讲解(video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.cs.cmu.edu/~scandal/papers/treaps-spaa98.pdf" target="_blank" rel="noopener">集合操作的应用(Applications in set operations)</a></li></ul></li><li><h3 id="线性规划（Linear-Programming）（视频）"><a href="#线性规划（Linear-Programming）（视频）" class="headerlink" title="线性规划（Linear Programming）（视频）"></a>线性规划（Linear Programming）（视频）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=M4K6HYLHREQ" target="_blank" rel="noopener">线性规划</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2ACJ9ewUC6U" target="_blank" rel="noopener">寻找最小成本</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=8AA_81xI3ik" target="_blank" rel="noopener">寻找最大值</a></li></ul></li><li><h3 id="几何：凸包（Geometry-Convex-hull）（视频）"><a href="#几何：凸包（Geometry-Convex-hull）（视频）" class="headerlink" title="几何：凸包（Geometry, Convex hull）（视频）"></a>几何：凸包（Geometry, Convex hull）（视频）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/XIAQRlNkJAw?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3164" target="_blank" rel="noopener">Graph Alg. IV: 几何算法介绍 - 第 9 课</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=J5aJEcOr6Eo&amp;index=10&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="noopener">Graham &amp; Jarvis: 几何算法 - 第 10 课</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=EzeYI7p9MjU&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=2" target="_blank" rel="noopener">Divide &amp; Conquer: 凸包, 中值查找</a></li></ul></li><li><h3 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h3><ul><li>查看下面的视频：(这里没看到视频= =）</li></ul></li><li><h3 id="机器学习（Machine-Learning）"><a href="#机器学习（Machine-Learning）" class="headerlink" title="机器学习（Machine Learning）"></a>机器学习（Machine Learning）</h3><ul><li style="list-style: none"><input type="checkbox"> 为什么学习机器学习？<ul><li style="list-style: none"><input type="checkbox"> <a href="https://backchannel.com/how-google-is-remaking-itself-as-a-machine-learning-first-company-ada63defcb70" target="_blank" rel="noopener">谷歌如何将自己改造成一家「机器学习优先」公司？</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=QSaZGT4-6EY" target="_blank" rel="noopener">智能计算机系统的大规模深度学习 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=X769cyzBNVw" target="_blank" rel="noopener">Peter Norvig：深度学习和理解与软件工程和验证的对比</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Ja2hxBAwG_0" target="_blank" rel="noopener">谷歌云机器学习工具（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIIuiBfYad6rFYQU_jL2ryal" target="_blank" rel="noopener">谷歌开发者机器学习清单 (Scikit Learn 和 Tensorflow) (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=oZikw5k_2FM" target="_blank" rel="noopener">Tensorflow (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.tensorflow.org/versions/r0.11/tutorials/index.html" target="_blank" rel="noopener">Tensorflow 教程</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.analyticsvidhya.com/blog/2016/04/neural-networks-python-theano/" target="_blank" rel="noopener">Python 实现神经网络实例教程（使用 Theano）</a></li><li>课程:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">很棒的初级课程：机器学习</a><pre><code>- [视频教程](https://www.youtube.com/playlist?list=PLZ9qNFMHZ-A4rycgrgOYma6zxF4BZGGPW)- 看第 12-18 集复习线性代数（第 14 集和第 15 集是重复的）</code></pre></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/neural-networks" target="_blank" rel="noopener">机器学习中的神经网络</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.udacity.com/course/deep-learning--ud730" target="_blank" rel="noopener">Google 深度学习微学位</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.udacity.com/course/machine-learning-engineer-nanodegree-by-google--nd009" target="_blank" rel="noopener">Google/Kaggle 机器学习工程师微学位</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.udacity.com/drive" target="_blank" rel="noopener">无人驾驶工程师微学位</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.thisismetis.com/explore-data-science" target="_blank" rel="noopener">Metis 在线课程 (两个月 99 美元)</a></li></ul></li><li>资源:<ul><li>书籍: Data Science from Scratch: First Principles with Python: <a href="https://www.amazon.com/Data-Science-Scratch-Principles-Python/dp/149190142X" target="_blank" rel="noopener">https://www.amazon.com/Data-Science-Scratch-Principles-Python/dp/149190142X</a></li><li>网站: Data School: <a href="http://www.dataschool.io/" target="_blank" rel="noopener">http://www.dataschool.io/</a></li></ul></li></ul></li><li><h3 id="Go-语言"><a href="#Go-语言" class="headerlink" title="Go 语言"></a>Go 语言</h3><ul><li style="list-style: none"><input type="checkbox"> 视频:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=FTl0tl9BGdc" target="_blank" rel="noopener">为什么学习 Go 语言？</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=CF9S4QZuV30" target="_blank" rel="noopener">Go 语言编程</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ytEkHepK08c" target="_blank" rel="noopener">Go 语言之旅</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 书籍:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.golang-book.com/books/intro" target="_blank" rel="noopener">Go 语言编程入门 (免费在线阅读)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440" target="_blank" rel="noopener">Go 语言圣经 (Donovan &amp; Kernighan)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.golang-book.com/guides/bootcamp" target="_blank" rel="noopener">Go 语言新手训练营</a></li></ul></li></ul><p>–</p><h2 id="一些主题的额外内容"><a href="#一些主题的额外内容" class="headerlink" title="一些主题的额外内容"></a>一些主题的额外内容</h2><pre><code>我为前面提到的某些主题增加了一些额外的内容，之所以没有直接添加到前面，是因为这样很容易导致某个主题内容过多。毕竟你想在本世纪找到一份工作，对吧？</code></pre><ul><li><p>[ ] <strong>动态规划的更多内容</strong> (视频)</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=OQ5jsbhAv_M&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=19" target="_blank" rel="noopener">6.006: 动态规划 I: 斐波那契数列, 最短路径</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ENyox7kNKeY&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=20" target="_blank" rel="noopener">6.006: 动态规划 II: 文本匹配, 二十一点/黑杰克</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ocZMDMZwhCY&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=21" target="_blank" rel="noopener">6.006: 动态规划 III: 最优加括号方式, 最小编辑距离, 背包问题</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=tp4_UXaVyx8&amp;index=22&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">6.006: 动态规划 IV: 吉他指法，拓扑，超级马里奥.</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Tw1k46ywN6E&amp;index=14&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">6.046: 动态规划: 动态规划进阶</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=NzgFUwOaoIw&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=15" target="_blank" rel="noopener">6.046: 动态规划: 所有点对最短路径</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=krZI60lKPek&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=12" target="_blank" rel="noopener">6.046: 动态规划: 更多示例</a></li></ul></li><li><p>[ ] <strong>图形处理进阶</strong> (视频)</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=mUBmcbbJNf4&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=27" target="_blank" rel="noopener">异步分布式算法: 对称性破缺，最小生成树</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=kQ-UQAzcnzA&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=28" target="_blank" rel="noopener">异步分布式算法: 最小生成树</a></li></ul></li><li><p>[ ] MIT <strong>概率论</strong> (mathy, and go slowly, which is good for mathy things) (视频):</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=SmFwFdESMHI&amp;index=18&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 概率论概述</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=E6FbvM-FGZ8&amp;index=19&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 条件概率 Probability</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=l1BCv3qqW4A&amp;index=20&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 独立</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=MOfhhFaQdjw&amp;list=PLB7540DEDD482705B&amp;index=21" target="_blank" rel="noopener">MIT 6.042J - 随机变量</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=gGlMSe7uEkA&amp;index=22&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 期望 I</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=oI9fMUqgfxY&amp;index=23&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 期望 II</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=q4mwO2qS2z4&amp;index=24&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 大偏差</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=56iFMY8QW2k&amp;list=PLB7540DEDD482705B&amp;index=25" target="_blank" rel="noopener">MIT 6.042J - 随机游走</a></li></ul></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=oDniZCmNmNw&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=19" target="_blank" rel="noopener">Simonson: 近似算法 (视频)</a></p></li></ul><h2 id="视频系列"><a href="#视频系列" class="headerlink" title="视频系列"></a>视频系列</h2><p> 坐下来享受一下吧。”netflix and skill” :P</p><ul><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr" target="_blank" rel="noopener">个人的动态规划问题列表 (都是短视频哟)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL038BE01D3BAEFDB0" target="_blank" rel="noopener">x86 架构，汇编，应用程序 (11 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLE7DDD91010BC51F8" target="_blank" rel="noopener">MIT 18.06 线性代数，2005 年春季 (35 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL3B08AE665AB9002A" target="_blank" rel="noopener">绝妙的 MIT 微积分：单变量微积分</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL-XXv-cvA_iD8wQm8U0gG_Z1uHjImKXFy" target="_blank" rel="noopener">计算机科学 70, 001 - 2015 年春季 - 离散数学和概率理论</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL3o9D4Dl2FJ9q0_gtFXPh_H4POI5dK0yG" target="_blank" rel="noopener">离散数学 (19 个视频)</a></p></li><li><p>[ ] CSE373 - 算法分析 (25 个视频)</p><ul><li><a href="https://www.youtube.com/watch?v=ZFjhkohHdAA&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=1" target="_blank" rel="noopener">Skiena 的算法设计手册讲座</a></li></ul></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=mFPmKGIrQs4&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd" target="_blank" rel="noopener">UC Berkeley 61B (2014 年春季): 数据结构 (25 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL4BBB74C7D2A1049C" target="_blank" rel="noopener">UC Berkeley 61B (2006 年秋季): 数据结构 (39 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=gJJeUFyuvvg&amp;list=PL-XXv-cvA_iCl2-D-FS5mk0jFF6cYSJs_" target="_blank" rel="noopener">UC Berkeley 61C: 计算机结构 (26 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO" target="_blank" rel="noopener">OOSE: 使用 UML 和 Java 进行软件开发 (21 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=UH0QYvtP7Rk&amp;index=20&amp;list=PLkFD6_40KJIwEiwQx1dACXwh-2Fuo32qr" target="_blank" rel="noopener">UC Berkeley CS 152: 计算机结构和工程 (20 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-" target="_blank" rel="noopener">MIT 6.004: 计算结构 (49 视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL5PHm2jkkXmi5CxxI7b3JCL1TWybTDtKq" target="_blank" rel="noopener">卡內基梅隆大学 - 计算机架构讲座 (39 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=HtSuA80QTyo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;nohtml5=False" target="_blank" rel="noopener">MIT 6.006: 算法介绍 (47 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=zm2VP0kHl1M&amp;list=PL6535748F59DCA484" target="_blank" rel="noopener">MIT 6.033: 计算机系统工程 (22 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP63gFHB6xb-kVBiQHYe_4hSi" target="_blank" rel="noopener">MIT 6.034 人工智能, 2010 年秋季 (30 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=L3LMbpZIKhQ&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J: 计算机科学数学, 2010 年秋季 (25 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=2P-yW7LQr08&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">MIT 6.046: 算法设计与分析 (34 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=phxsQrZQupo&amp;list=PL_2Bwul6T-A7OldmhGODImZL8KEVE38X7" target="_blank" rel="noopener">MIT 6.050J: 信息和熵, 2008 年春季 (19 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=T0yzrZL1py0&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&amp;index=1" target="_blank" rel="noopener">MIT 6.851: 高等数据结构 (22 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL6ogFv-ieghdoGKGg2Bik3Gl1glBTEu8c" target="_blank" rel="noopener">MIT 6.854: 高等算法, 2016 年春季 (24 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=GqmQg-cszw4&amp;index=1&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">MIT 6.858计算机系统安全, 2014 年秋季</a></p></li><li><p>[ ] 斯坦福: 编程范例 (17 个视频)</p><ul><li><a href="https://www.youtube.com/watch?v=jTSvthW34GU&amp;list=PLC0B8B318B7394B6F&amp;nohtml5=False" target="_blank" rel="noopener">C 和 C++ 课程</a></li></ul></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=2aHkqB2-46k&amp;feature=youtu.be" target="_blank" rel="noopener">密码学导论</a></p><ul><li><a href="https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg" target="_blank" rel="noopener">本系列更多内容 (不分先后顺序)</a></li></ul></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLLssT5z_DsK9JDLcT8T62VtzwyW9LNepV" target="_blank" rel="noopener">大数据 - 斯坦福大学 (94 个视频)</a></p></li></ul><h2 id="计算机科学课程"><a href="#计算机科学课程" class="headerlink" title="计算机科学课程"></a>计算机科学课程</h2><ul><li><a href="https://github.com/open-source-society/computer-science" target="_blank" rel="noopener"> 在线 CS 课程目录 </a></li><li><a href="https://github.com/prakhar1989/awesome-courses" target="_blank" rel="noopener">CS 课程目录 (一些是在线讲座)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在GitHub上无意中发现一位为了入职Google而准备的学习手册，粗略一看，深感佩服，获益颇多，故转发一波，希望与大家共勉。&lt;/p&gt;
&lt;h1 id=&quot;译-Google-Interview-University-一套完整的学习手册帮助自己准备-Google-的面试&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="译文集" scheme="http://huangyiblog.com/categories/%E8%AF%91%E6%96%87%E9%9B%86/"/>
    
    
      <category term="Github" scheme="http://huangyiblog.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>技术书单系列1</title>
    <link href="http://huangyiblog.com/%E9%9A%8F%E7%AC%94/%E6%8A%80%E6%9C%AF%E4%B9%A6%E5%8D%95%E7%B3%BB%E5%88%971/"/>
    <id>http://huangyiblog.com/随笔/技术书单系列1/</id>
    <published>2018-05-16T12:22:08.000Z</published>
    <updated>2018-05-16T12:24:06.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我眼中的阅读"><a href="#我眼中的阅读" class="headerlink" title="我眼中的阅读"></a>我眼中的阅读</h1><p>有这么一句话：看一个人，只需看他读什么书，与什么交往。</p><p>但不知为什么，估计是我的社交圈太小的原因吧，大学里面认识的同学，目前没有几个是真正热爱阅读的，不论是带有功利性质的技能书还是休闲性质的杂书。注意，我没有过分强调读书的功利作用，我从不认为不读书的人就怎么怎么没素养，不读书就不能有大的作为。很多时候这也不过是一种爱好，一种消磨时间的途径而已。所以爱读书的也不必故作清高，但不爱读书的，也请将你的读书无用论收一收，不读书的一个巨大遗憾就是让你们产生了这样的眼界。</p><p>对我来说，书的魅力是巨大的，起初和很多人一样，一看到书就头疼，会有种读不下去的感觉，尤其是面对一些字典般大小的恐龙书。因此很多时候，读书也得讲策略，不是任何一本书都得一字一句的啃下去，有选择有针对性的扩展广度，当发现一本内容精致的好书在一遍遍精读也不迟。这里又提到了选书的问题，其实人这一生，你再怎么努力，能读的书终究是有限的，因此选择成了至关重要的一环，门外汉建议还是根据口碑选择较为靠谱，数年积累的业内口碑一般都不是没有理由的，经典之所以能成为经典，必然是经过一代代人的筛选与淘汰留下的宝藏。</p><p>说起自己，倒也误区多多，一方面，关于买书，我明显对技术书籍有了歧视，至今我买的纸质书里面，大多以古今中外文学名著小说诗歌居多，然而技术书却是能用指头就点的过来的寥寥几本。其中，我可能嫌一些技术书价格过高，网上的pdf版本一搜一大把，何苦花这冤枉钱。但后面意识到，很多技术书却是值这个价，内容对一些原理和思维剖析深刻到位，总之纸质书的阅读感很多时候还是电子书无法取代的。我目前两种媒介都不拒绝，大多时候不方便的话，kindle带在身边就是了，方便的话，翻开纸质书就是撸。另外，在读书笔记方面我做的也是有很大欠缺的，一本书读完，或者一部电影看完，只要不是内容空洞话作品，多多少少也该有点自己的理解与总结吧。转眼已到大二下半年，紧迫感似乎越来越强，面对学业上的考核，大三的实习校招，貌似留给我的阅读时间越来越少，且行且珍惜把。</p><p>中学，在高考中考的指挥棒下，自主时间实在有限，以后工作想必时间上的安排也必然紧张。粗想一下，大学貌似是我人生中为数不多的可以有大把时间读书，大把时间旅游，大把时间培养自主习惯的时候了，生活已经不易，希望有更多的人愿意与我一同追逐心中的书和远方。</p><h1 id="刘大佬认为的面试微软10本必读书"><a href="#刘大佬认为的面试微软10本必读书" class="headerlink" title="刘大佬认为的面试微软10本必读书"></a>刘大佬认为的面试微软10本必读书</h1><ol><li>Code: The Hidden Language of Computer Hardware and Software （《编码的奥秘》）</li><li>Computer System: A Programmer’s Perspective （《深入理解计算机系统》） / Windows via C/C++ （《Windows核心编程》 / 《程序员的自我修养》</li><li>Code Complete 2（《代码大全》）/ The Pragmatic Programmer （《程序员修炼之道》，我也把这本书称为《代码小全》）</li><li>Programming Pearls （《编程珠玑》） / Algorithms / Algorithm Design / 《编程之美》</li><li>The C Programming Language</li><li>The C++ Programming Language / Programming: Principles and Practice Using C++ / Accelerated C++</li><li>The Structure and Interpretation of Computer Programs （《计算机程序的构造和解释》）</li><li>Clean Code / Implementation Patterns</li><li>Design Patterns （《设计模式》） / Agile Software Development, Principles, Patterns, and Practices</li><li>Refactoring （《重构》）</li></ol><h1 id="云风的书单（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）"><a href="#云风的书单（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）" class="headerlink" title="云风的书单（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）"></a>云风的书单（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）</h1><ol><li>C++编程思想</li><li>Effective C++</li><li>深度探索C++对象模型</li><li>C++语言的设计和演化</li><li>C专家编程</li><li>C陷阱与缺陷</li><li>C语言接口与实现</li><li>Lua程序设计</li><li>Linkers and Loaders</li><li>COM本质论</li><li>Windows核心编程</li><li>深入解析Windows操作系统</li><li>程序员修炼之道</li><li>代码大全</li><li>UNIX编程艺术</li><li>设计模式</li><li>代码优化：有效使用内存</li><li>深入理解计算机系统</li><li>深入理解LINUX内核</li><li>TCP/IP 详解</li></ol><h1 id="来自stackoverflow的一个帖子"><a href="#来自stackoverflow的一个帖子" class="headerlink" title="来自stackoverflow的一个帖子"></a>来自stackoverflow的一个帖子</h1><ul><li><a href="https://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read" target="_blank" rel="noopener">原网址</a></li></ul><ol><li>Code Complete (2nd edition) by Steve McConnell</li><li>The Pragmatic Programmer</li><li>Structure and Interpretation of Computer Programs</li><li>The C Programming Language by Kernighan and Ritchie</li><li>Introduction to Algorithms by Cormen, Leiserson, Rivest &amp; Stein</li><li>Design Patterns by the Gang of Four</li><li>Refactoring: Improving the Design of Existing Code</li><li>The Mythical Man Month</li><li>The Art of Computer Programming by Donald Knuth</li><li>Compilers: Principles, Techniques and Tools by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman</li><li>Gödel, Escher, Bach by Douglas Hofstadter</li><li>Clean Code: A Handbook of Agile Software Craftsmanship by Robert C. Martin</li><li>Effective C++</li><li>More Effective C++</li><li>CODE by Charles Petzold</li><li>Programming Pearls by Jon Bentley</li><li>Working Effectively with Legacy Code by Michael C. Feathers</li><li>Peopleware by Demarco and Lister</li><li>Coders at Work by Peter Seibel</li><li>Surely You’re Joking, Mr. Feynman!</li><li>Effective Java 2nd edition</li><li>Patterns of Enterprise Application Architecture by Martin Fowler</li><li>The Little Schemer</li><li>The Seasoned Schemer</li><li>Why’s (Poignant) Guide to Ruby</li><li>The Inmates Are Running The Asylum: Why High Tech Products Drive Us Crazy and How to Restore the Sanity</li><li>The Art of Unix Programming</li><li>Test-Driven Development: By Example by Kent Beck</li><li>Practices of an Agile Developer</li><li>Don’t Make Me Think</li><li>Agile Software Development, Principles, Patterns, and Practices by Robert C. Martin</li><li>Domain Driven Designs by Eric Evans</li><li>The Design of Everyday Things by Donald Norman</li><li>Modern C++ Design by Andrei Alexandrescu</li><li>Best Software Writing I by Joel Spolsky</li><li>The Practice of Programming by Kernighan and Pike</li><li>Pragmatic Thinking and Learning: Refactor Your Wetware by Andy Hunt</li><li>Software Estimation: Demystifying the Black Art by Steve McConnel</li><li>The Passionate Programmer (My Job Went To India) by Chad Fowler</li><li>Hackers: Heroes of the Computer Revolution</li><li>Algorithms + Data Structures = Programs</li><li>Writing Solid Code</li><li>JavaScript - The Good Parts</li><li>Getting Real by 37 Signals</li><li>Foundations of Programming by Karl Seguin</li><li>Computer Graphics: Principles and Practice in C (2nd Edition)</li><li>Thinking in Java by Bruce Eckel</li><li>The Elements of Computing Systems</li><li>Refactoring to Patterns by Joshua Kerievsky</li><li>Modern Operating Systems by Andrew S. Tanenbaum</li><li>The Annotated Turing</li><li>Things That Make Us Smart by Donald Norman</li><li>The Timeless Way of Building by Christopher Alexander</li><li>The Deadline: A Novel About Project Management by Tom DeMarco</li><li>The C++ Programming Language (3rd edition) by Stroustrup</li><li>Patterns of Enterprise Application Architecture</li><li>Computer Systems - A Programmer’s Perspective</li><li>Agile Principles, Patterns, and Practices in C# by Robert C. Martin</li><li>Growing Object-Oriented Software, Guided by Tests</li><li>Framework Design Guidelines by Brad Abrams</li><li>Object Thinking by Dr. David West</li><li>Advanced Programming in the UNIX Environment by W. Richard Stevens</li><li>Hackers and Painters: Big Ideas from the Computer Age</li><li>The Soul of a New Machine by Tracy Kidder</li><li>CLR via C# by Jeffrey Richter</li><li>The Timeless Way of Building by Christopher Alexander</li><li>Design Patterns in C# by Steve Metsker</li><li>Alice in Wonderland by Lewis Carol</li><li>Zen and the Art of Motorcycle Maintenance by Robert M. Pirsig</li><li>About Face - The Essentials of Interaction Design</li><li>Here Comes Everybody: The Power of Organizing Without Organizations by Clay Shirky</li><li>The Tao of Programming</li><li>Computational Beauty of Nature</li><li>Writing Solid Code by Steve Maguire</li><li>Philip and Alex’s Guide to Web Publishing</li><li>Object-Oriented Analysis and Design with Applications by Grady Booch</li><li>Effective Java by Joshua Bloch</li><li>Computability by N. J. Cutland</li><li>Masterminds of Programming</li><li>The Tao Te Ching</li><li>The Productive Programmer</li><li>The Art of Deception by Kevin Mitnick</li><li>The Career Programmer: Guerilla Tactics for an Imperfect World by Christopher Duncan</li><li>Paradigms of Artificial Intelligence Programming: Case studies in Common Lisp</li><li>Masters of Doom</li><li>Pragmatic Unit Testing in C# with NUnit by Andy Hunt and Dave Thomas with Matt Hargett</li><li>How To Solve It by George Polya</li><li>The Alchemist by Paulo Coelho</li><li>Smalltalk-80: The Language and its Implementation</li><li>Writing Secure Code (2nd Edition) by Michael Howard</li><li>Introduction to Functional Programming by Philip Wadler and Richard Bird</li><li>No Bugs! by David Thielen</li><li>Rework by Jason Freid and DHH</li><li>JUnit in Action</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;我眼中的阅读&quot;&gt;&lt;a href=&quot;#我眼中的阅读&quot; class=&quot;headerlink&quot; title=&quot;我眼中的阅读&quot;&gt;&lt;/a&gt;我眼中的阅读&lt;/h1&gt;&lt;p&gt;有这么一句话：看一个人，只需看他读什么书，与什么交往。&lt;/p&gt;
&lt;p&gt;但不知为什么，估计是我的社交圈太小的原
      
    
    </summary>
    
      <category term="随笔" scheme="http://huangyiblog.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="阅读" scheme="http://huangyiblog.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>完全背包</title>
    <link href="http://huangyiblog.com/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    <id>http://huangyiblog.com/算法和数据结构/完全背包/</id>
    <published>2018-05-16T11:45:25.000Z</published>
    <updated>2018-05-16T11:47:06.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><p>有n种物品，每种物品的单件重量为w[i],价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，<br>使得背包内物品的总价值最大。其中每种物品都有无穷件。</p><p>完全背包与01背包的唯一区别：完全背包的物品数量每种有无穷件，而01背包的物品数量每种只有1件。</p><p>令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值</p><p>对每种物品有两种策略：</p><ol><li>不放第i件物品，那么dp[i][v] = dp[i-1][v]</li><li>放第i件物品。dp[i][v] = dp[i][v-w[i]]+c[i]<br>由此得出状态转移方程：<pre><code>**dp[i][v] = max(dp[i-1][v],dp[i][v-w[i]]+c[i]) (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V)**边界：dp[0][v] = 0(0&lt;=v&lt;=V)</code></pre>改写成一维形式：<pre><code>**dp[v] = max(dp[v],dp[v-w[i]]+c[i]) (1&lt;=i&lt;=n,w[i]&lt;=v&lt;=V)**边界：dp[v] = 0(0&lt;=v&lt;=V)</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=w[i];v&lt;=V;v++)&#123;</span><br><span class="line">    dp[v] = max(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="常见dp问题的模型总结"><a href="#常见dp问题的模型总结" class="headerlink" title="常见dp问题的模型总结"></a>常见dp问题的模型总结</h1><ol><li><p>最大连续子列和<br>令dp[i]表示以A[i]作为末尾的连续序列的最大和。</p></li><li><p>最长不下降子序列（LIS）<br>令dp[i]表示以A[i]结尾的最长不下降子序列长度</p></li><li><p>最长公共子序列（LCS）<br>令dp[i][j]表示字符串A的i号位和字符串B的j号位之前的LCS长度</p></li><li><p>最长回文子串<br>令dp[i][j]表示S[i]至S[j]所表示的子串是否是回文子串</p></li><li><p>数塔dp<br>令dp[i][j]表示从第i行第j个数字出发的到达最底层的所有路径上所能得到的最大和</p></li><li><p>DAG最长路<br>令dp[i]表示从i号顶点出发能获得的最长路径长度</p></li><li><p>01背包<br>令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值</p></li><li><p>完全背包<br>令dp[i][v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;完全背包问题&quot;&gt;&lt;a href=&quot;#完全背包问题&quot; class=&quot;headerlink&quot; title=&quot;完全背包问题&quot;&gt;&lt;/a&gt;完全背包问题&lt;/h1&gt;&lt;p&gt;有n种物品，每种物品的单件重量为w[i],价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，&lt;
      
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://huangyiblog.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
</feed>
